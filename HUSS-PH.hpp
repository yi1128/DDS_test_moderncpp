

/*
WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.

This file was generated from HUSS-PH.idl
using RTI Code Generator (rtiddsgen) version 4.0.0.
The rtiddsgen tool is part of the RTI Connext DDS distribution.
For more information, type 'rtiddsgen -help' at a command shell
or consult the Code Generator User's Manual.
*/

#ifndef HUSS_PH_1779633256_hpp
#define HUSS_PH_1779633256_hpp

#include <iosfwd>

#if (defined(RTI_WIN32) || defined (RTI_WINCE) || defined(RTI_INTIME)) && defined(NDDS_USER_DLL_EXPORT)
/* If the code is building on Windows, start exporting symbols.
*/
#undef RTIUSERDllExport
#define RTIUSERDllExport __declspec(dllexport)
#endif

#include "dds/domain/DomainParticipant.hpp"
#include "dds/topic/TopicTraits.hpp"
#include "dds/core/SafeEnumeration.hpp"
#include "dds/core/String.hpp"
#include "dds/core/array.hpp"
#include "dds/core/vector.hpp"
#include "dds/core/Optional.hpp"
#include "dds/core/xtypes/DynamicType.hpp"
#include "dds/core/xtypes/StructType.hpp"
#include "dds/core/xtypes/UnionType.hpp"
#include "dds/core/xtypes/EnumType.hpp"
#include "dds/core/xtypes/AliasType.hpp"
#include "rti/core/array.hpp"
#include "rti/core/BoundedSequence.hpp"
#include "rti/util/StreamFlagSaver.hpp"
#include "rti/domain/PluginSupport.hpp"
#include "rti/core/LongDouble.hpp"
#include "dds/core/External.hpp"
#include "rti/core/Pointer.hpp"
#include "rti/topic/TopicTraits.hpp"

#if (defined(RTI_WIN32) || defined (RTI_WINCE) || defined(RTI_INTIME)) && defined(NDDS_USER_DLL_EXPORT)
/* If the code is building on Windows, stop exporting symbols.
*/
#undef RTIUSERDllExport
#define RTIUSERDllExport
#endif

#if (defined(RTI_WIN32) || defined (RTI_WINCE) || defined(RTI_INTIME)) && defined(NDDS_USER_DLL_EXPORT)
/* If the code is building on Windows, start exporting symbols.
*/
#undef NDDSUSERDllExport
#define NDDSUSERDllExport __declspec(dllexport)
#endif

enum class E_CSCI_CSC_TYPE {
    E_SW_ID_NONE = 0, 
    E_SW_ID_SPE_LASDSP_1_LASDSP_LTA = 1, 
    E_SW_ID_SPE_LASDSP_1_SYSMGR_SMA = 2, 
    E_SW_ID_SPE_LASDSP_2_LASDSP_LTB = 3, 
    E_SW_ID_SPE_LASDSP_2_SYSMGR_SMA = 4, 
    E_SW_ID_SPE_LASDSP_3_LASDSP_LTC = 5, 
    E_SW_ID_SPE_LASDSP_3_SYSMGR_SMA = 6, 
    E_SW_ID_SPE_LASDSP_4_LASDSP_LFA = 7, 
    E_SW_ID_SPE_LASDSP_4_SYSMGR_SMA = 8, 
    E_SW_ID_SPE_LASDSP_5_LASDSP_LFB = 9, 
    E_SW_ID_SPE_LASDSP_5_SYSMGR_SMA = 10, 
    E_SW_ID_SPE_LASDSP_6_LASDSP_LFC = 11, 
    E_SW_ID_SPE_LASDSP_6_SYSMGR_SMA = 12, 
    E_SW_ID_SPE_SIGGEN_1_LASSIGGEN = 13, 
    E_SW_ID_SPE_SIGGEN_1_SYSMGR_SMA = 14, 
    E_SW_ID_SPE_SIGGEN_2_MASSIGGEN = 15, 
    E_SW_ID_SPE_SIGGEN_2_SYSMGR_SMA = 16, 
    E_SW_ID_SPE_SIGGEN_3_BISSIGGEN = 17, 
    E_SW_ID_SPE_SIGGEN_3_SYSMGR_SMA = 18, 
    E_SW_ID_SPE_CTRMGR_1_CTRMGR_LAS = 19, 
    E_SW_ID_SPE_CTRMGR_1_CTRMGR_MAS = 20, 
    E_SW_ID_SPE_CTRMGR_1_CTRMGR_BIS = 21, 
    E_SW_ID_SPE_CTRMGR_1_SYSMGR_SMA = 22, 
    E_SW_ID_SPE_BISDSP_1_BISDSP_APA = 23, 
    E_SW_ID_SPE_BISDSP_1_SYSMGR_SMA = 24, 
    E_SW_ID_SPE_BISDSP_2_BISDSP_APB = 25, 
    E_SW_ID_SPE_BISDSP_2_SYSMGR_SMA = 26, 
    E_SW_ID_SPE_BISDSP_3_BISDSP_APC = 27, 
    E_SW_ID_SPE_BISDSP_3_SYSMGR_SMA = 28, 
    E_SW_ID_SPE_BISDSP_4_BISDSP_TDA = 29, 
    E_SW_ID_SPE_BISDSP_4_SYSMGR_SMA = 30, 
    E_SW_ID_SPE_BISDSP_5_BISDSP_TDB = 31, 
    E_SW_ID_SPE_BISDSP_5_SYSMGR_SMA = 32, 
    E_SW_ID_SPE_BISDSP_6_BISDSP_TDC = 33, 
    E_SW_ID_SPE_BISDSP_6_SYSMGR_SMA = 34, 
    E_SW_ID_SPE_BISDSP_7_BISDSP_SPA = 35, 
    E_SW_ID_SPE_BISDSP_7_SYSMGR_SMA = 36, 
    E_SW_ID_SPE_BISDSP_8_BISDSP_SPB = 37, 
    E_SW_ID_SPE_BISDSP_8_SYSMGR_SMA = 38, 
    E_SW_ID_SPE_BISDSP_9_BISDSP_SPC = 39, 
    E_SW_ID_SPE_BISDSP_9_SYSMGR_SMA = 40, 
    E_SW_ID_SPE_MASDSP_1_MASDSP = 41, 
    E_SW_ID_SPE_MASDSP_1_SYSMGR_SMA = 42, 
    E_SW_ID_SPE_CTRMGR_1_R_CTRMGR_LAS = 43, 
    E_SW_ID_SPE_CTRMGR_1_R_CTRMGR_MAS = 44, 
    E_SW_ID_SPE_CTRMGR_1_R_CTRMGR_BIS = 45, 
    E_SW_ID_SPE_CTRMGR_1_R_SYSMGR_SMA = 46, 
    E_SW_ID_IPE_TGTMGR_1_TGTMGR_MGR = 47, 
    E_SW_ID_IPE_TGTMGR_1_TGTMGR_FUS = 48, 
    E_SW_ID_IPE_TGTMGR_1_SYSMGR_SMA = 49, 
    E_SW_ID_IPE_TGTTRK_1_TGTTRK_LAS = 50, 
    E_SW_ID_IPE_TGTTRK_1_SYSMGR_SMA = 51, 
    E_SW_ID_IPE_TGTTRK_2_TGTTRK_MAS = 52, 
    E_SW_ID_IPE_TGTTRK_2_TGTTRK_BIS = 53, 
    E_SW_ID_IPE_TGTTRK_2_SYSMGR_SMA = 54, 
    E_SW_ID_IPE_DATMGR_1_DATMGR_REC = 55, 
    E_SW_ID_IPE_DATMGR_1_SYSMGR_SMA = 56, 
    E_SW_ID_IPE_DATMGR_2_DATMGR_EX = 57, 
    E_SW_ID_IPE_DATMGR_2_SYSMGR_SMA = 58, 
    E_SW_ID_IPE_SYSMGR_1_SYSMGR_SOM = 59, 
    E_SW_ID_IPE_SYSMGR_1_SYSMGR_SMA = 60, 
    E_SW_ID_IPE_IFCCTR_1_IFCCTR_KNT = 61, 
    E_SW_ID_IPE_IFCCTR_1_IFCCTR_ASE = 62, 
    E_SW_ID_IPE_IFCCTR_1_IFCCTR_RDR = 63, 
    E_SW_ID_IPE_IFCCTR_1_IFCCTR_EOT = 64, 
    E_SW_ID_IPE_IFCCTR_1_IFCCTR_RMD = 65, 
    E_SW_ID_IPE_IFCCTR_1_SYSMGR_SMA = 66, 
    E_SW_ID_IPE_SPPANA_1_SPPANA_PAM = 67, 
    E_SW_ID_IPE_SPPANA_1_SPPANA_OCN = 68, 
    E_SW_ID_IPE_SPPANA_1_SYSMGR_SMA = 69, 
    E_SW_ID_IPE_SPPANA_2_SPPANA_BIS = 70, 
    E_SW_ID_IPE_SPPANA_2_SPPANA_PAM = 71, 
    E_SW_ID_IPE_SPPANA_2_SYSMGR_SMA = 72, 
    E_SW_ID_IPE_TGTCLA_1_TGTCLA_VMG = 73, 
    E_SW_ID_IPE_TGTCLA_1_TGTCLA_CLA = 74, 
    E_SW_ID_IPE_TGTCLA_1_SYSMGR_SMA = 75, 
    E_SW_ID_IPE_TGTMGR_1_R_TGTMGR_MGR = 76, 
    E_SW_ID_IPE_TGTMGR_1_R_TGTMGR_FUS = 77, 
    E_SW_ID_IPE_TGTMGR_1_R_SYSMGR_SMA = 78, 
    E_SW_ID_IPE_TGTTRK_1_R_TGTTRK_LAS = 79, 
    E_SW_ID_IPE_TGTTRK_1_R_SYSMGR_SMA = 80, 
    E_SW_ID_IPE_TGTTRK_2_R_TGTTRK_MAS = 81, 
    E_SW_ID_IPE_TGTTRK_2_R_TGTTRK_BIS = 82, 
    E_SW_ID_IPE_TGTTRK_2_R_SYSMGR_SMA = 83, 
    E_SW_ID_IPE_DATMGR_1_R_DATMGR_REC = 84, 
    E_SW_ID_IPE_DATMGR_1_R_SYSMGR_SMA = 85, 
    E_SW_ID_IPE_SYSMGR_1_R_SYSMGR_SOM = 86, 
    E_SW_ID_IPE_SYSMGR_1_R_SYSMGR_SMA = 87, 
    E_SW_ID_IPE_IFCCTR_1_R_IFCCTR_KNT = 88, 
    E_SW_ID_IPE_IFCCTR_1_R_IFCCTR_ASE = 89, 
    E_SW_ID_IPE_IFCCTR_1_R_IFCCTR_RDR = 90, 
    E_SW_ID_IPE_IFCCTR_1_R_IFCCTR_EOT = 91, 
    E_SW_ID_IPE_IFCCTR_1_R_IFCCTR_RMD = 92, 
    E_SW_ID_IPE_IFCCTR_1_R_SYSMGR_SMA = 93, 
    E_SW_ID_IDE_USERIF_1_USERIF_IFC = 94, 
    E_SW_ID_IDE_USERIF_1_TRAEDT = 95, 
    E_SW_ID_IDE_USERIF_1_MSSSUP = 96, 
    E_SW_ID_IDE_USERIF_1_SYSMGR_SMA = 97, 
    E_SW_ID_IDE_USERIF_2_USERIF_IFC = 98, 
    E_SW_ID_IDE_USERIF_2_TRAEDT = 99, 
    E_SW_ID_IDE_USERIF_2_MSSSUP = 100, 
    E_SW_ID_IDE_USERIF_2_SYSMGR_SMA = 101, 
    E_SW_ID_IDE_USERIF_3_USERIF_IFC = 102, 
    E_SW_ID_IDE_USERIF_3_TRAEDT = 103, 
    E_SW_ID_IDE_USERIF_3_MSSSUP = 104, 
    E_SW_ID_IDE_USERIF_3_SYSMGR_SMA = 105, 
    E_SW_ID_IDE_USERIF_4_USERIF_IFC = 106, 
    E_SW_ID_IDE_USERIF_4_TRAEDT = 107, 
    E_SW_ID_IDE_USERIF_4_MSSSUP = 108, 
    E_SW_ID_IDE_USERIF_4_SYSMGR_SMA = 109, 
    E_SW_ID_RMT_RMTDIS_1_USERIF_RMT = 110, 
    E_SW_ID_RMT_RMTDIS_1_SYSMGR_SMA = 111, 
    E_SW_ID_RMT_RMTDIS_2_USERIF_RMT = 112, 
    E_SW_ID_RMT_RMTDIS_2_SYSMGR_SMA = 113, 
    E_SW_ID_RMT_RMTDIS_3_USERIF_RMT = 114, 
    E_SW_ID_RMT_RMTDIS_3_SYSMGR_SMA = 115, 
    E_SW_ID_LASIE_LASIE_1_LASIE = 116, 
    E_SW_ID_LASIE_LASIE_2_LASIE = 117, 
    E_SW_ID_BISIE_BISIE_1_BISIE = 118, 
    E_SW_ID_BISIE_BISIE_2_BISIE = 119, 
    E_SW_ID_MASIE_MASIE_1_MASIE = 120, 
    E_SW_ID_MASIE_MASIE_2_MASIE = 121, 
    E_SW_ID_EIE_RADARIF_1_RADARIF = 122, 
    E_SW_ID_EIE_RADARIF_2_RADARIF = 123, 
    E_SW_ID_EIE_KNTDSIF_1_KNTDSIF = 124, 
    E_SW_ID_EOE_ELEOPT_1_ELEOPT1 = 125, 
    E_SW_ID_EOE_ELEOPT_2_ELEOPT2 = 126, 
    E_SW_ID_ASE_ACTDSP_1_ACTDSP1 = 127, 
    E_SW_ID_ASE_ACTDSP_2_ACTDSP2 = 128, 
    E_SW_ID_ASE_ACTDSP_3_ACTDSP3 = 129
};

NDDSUSERDllExport std::ostream& operator << (std::ostream& o,const E_CSCI_CSC_TYPE& sample);
enum class E_EQUIPMENT_ID {
    E_EQUIPMENT_ID_NONE = 0, 
    E_EQUIPMENT_ID_IPE1 = 1, 
    E_EQUIPMENT_ID_IPE2 = 2, 
    E_EQUIPMENT_ID_SPE1 = 3, 
    E_EQUIPMENT_ID_SPE2 = 4, 
    E_EQUIPMENT_ID_EOEAS = 5, 
    E_EQUIPMENT_ID_IDE = 6, 
    E_EQUIPMENT_ID_RDE = 7, 
    E_EQUIPMENT_ID_EIE = 8, 
    E_EQUIPMENT_ID_LASIE = 9, 
    E_EQUIPMENT_ID_BISIE = 10, 
    E_EQUIPMENT_ID_MASIE = 11, 
    E_EQUIPMENT_ID_RDIE1 = 12, 
    E_EQUIPMENT_ID_RDIE2 = 13
};

NDDSUSERDllExport std::ostream& operator << (std::ostream& o,const E_EQUIPMENT_ID& sample);
enum class E_HW_ID {
    E_HW_ID_NONE = 0, 
    E_HW_ID_IPE1_TGTMGR = 1, 
    E_HW_ID_IPE1_TGTTRK1 = 2, 
    E_HW_ID_IPE1_TGTTRK2 = 3, 
    E_HW_ID_IPE1_DATMGR1 = 4, 
    E_HW_ID_IPE1_DATMGR2 = 5, 
    E_HW_ID_IPE1_SYSMGR = 6, 
    E_HW_ID_IPE1_IFCCTR = 7, 
    E_HW_ID_IPE1_SPPANA1 = 8, 
    E_HW_ID_IPE1_SPPANA2 = 9, 
    E_HW_ID_IPE1_TGTCLA = 10, 
    E_HW_ID_IPE2_TGTMGR = 11, 
    E_HW_ID_IPE2_TGTTRK1 = 12, 
    E_HW_ID_IPE2_TGTTRK2 = 13, 
    E_HW_ID_IPE2_DATMGR1 = 14, 
    E_HW_ID_IPE2_SYSMGR = 15, 
    E_HW_ID_IPE2_IFCCTR = 16, 
    E_HW_ID_IPE1_HDDR = 17, 
    E_HW_ID_SPE1_LASDSP1 = 18, 
    E_HW_ID_SPE1_LASDSP2 = 19, 
    E_HW_ID_SPE1_LASDSP3 = 20, 
    E_HW_ID_SPE1_LASDSP4 = 21, 
    E_HW_ID_SPE1_LASDSP5 = 22, 
    E_HW_ID_SPE1_LASDSP6 = 23, 
    E_HW_ID_SPE1_SIGGEN1 = 24, 
    E_HW_ID_SPE1_SIGGEN2 = 25, 
    E_HW_ID_SPE1_SIGGEN3 = 26, 
    E_HW_ID_SPE1_IFCCTR = 27, 
    E_HW_ID_SPE2_BISDSP1 = 28, 
    E_HW_ID_SPE2_BISDSP2 = 29, 
    E_HW_ID_SPE2_BISDSP3 = 30, 
    E_HW_ID_SPE2_BISDSP4 = 31, 
    E_HW_ID_SPE2_BISDSP5 = 32, 
    E_HW_ID_SPE2_BISDSP6 = 33, 
    E_HW_ID_SPE2_BISDSP7 = 34, 
    E_HW_ID_SPE2_BISDSP8 = 35, 
    E_HW_ID_SPE2_BISDSP9 = 36, 
    E_HW_ID_SPE2_MASDSP = 37, 
    E_HW_ID_SPE2_IFCCTR_SUB = 38, 
    E_HW_ID_EOASE_ELEOPT1 = 39, 
    E_HW_ID_EOASE_ELEOPT2 = 40, 
    E_HW_ID_EOASE_ACTDSP1 = 41, 
    E_HW_ID_EOASE_ACTDSP2 = 42, 
    E_HW_ID_EOASE_ACTDSP3 = 43, 
    E_HW_ID_EOASE_HDDR = 44, 
    E_HW_ID_IDE_WS1 = 45, 
    E_HW_ID_IDE_WS2 = 46, 
    E_HW_ID_IDE_WS3 = 47, 
    E_HW_ID_IDE_WS4 = 48, 
    E_HW_ID_RDE_WS1 = 49, 
    E_HW_ID_RDE_WS2 = 50, 
    E_HW_ID_RDE_WS3 = 51, 
    E_HW_ID_ELE_NAIMIF = 52, 
    E_HW_ID_LASIE_TBD = 53, 
    E_HW_ID_BISIE_TBD = 54, 
    E_HW_ID_MASIE_TBD = 55
};

NDDSUSERDllExport std::ostream& operator << (std::ostream& o,const E_HW_ID& sample);
enum class E_SW_GID {
    E_SW_GID_NONE = 0, 
    E_SW_GID_SPE_LASDSP1 = 1, 
    E_SW_GID_SPE_LASDSP2 = 2, 
    E_SW_GID_SPE_LASDSP3 = 3, 
    E_SW_GID_SPE_LASDSP4 = 4, 
    E_SW_GID_SPE_LASDSP5 = 5, 
    E_SW_GID_SPE_LASDSP6 = 6, 
    E_SW_GID_SPE_SIGGEN1 = 7, 
    E_SW_GID_SPE_SIGGEN2 = 8, 
    E_SW_GID_SPE_SIGGEN3 = 9, 
    E_SW_GID_SPE_CTRMGR1 = 10, 
    E_SW_GID_SPE_BISDSP1 = 11, 
    E_SW_GID_SPE_BISDSP2 = 12, 
    E_SW_GID_SPE_BISDSP3 = 13, 
    E_SW_GID_SPE_BISDSP4 = 14, 
    E_SW_GID_SPE_BISDSP5 = 15, 
    E_SW_GID_SPE_BISDSP6 = 16, 
    E_SW_GID_SPE_BISDSP7 = 17, 
    E_SW_GID_SPE_BISDSP8 = 18, 
    E_SW_GID_SPE_BISDSP9 = 19, 
    E_SW_GID_SPE_MASDSP1 = 20, 
    E_SW_GID_IPE_TGTMGR1 = 21, 
    E_SW_GID_IPE_TGTTRK1 = 22, 
    E_SW_GID_IPE_TGTTRK2 = 23, 
    E_SW_GID_IPE_DATMGR1 = 24, 
    E_SW_GID_IPE_DATMGR2 = 25, 
    E_SW_GID_IPE_SYSMGR1 = 26, 
    E_SW_GID_IPE_IFCCTR1 = 27, 
    E_SW_GID_IPE_SPPANA1 = 28, 
    E_SW_GID_IPE_SPPANA2 = 29, 
    E_SW_GID_IPE_TGTCLA1 = 30, 
    E_SW_GID_IDE_USERIF1 = 31, 
    E_SW_GID_IDE_USERIF2 = 32, 
    E_SW_GID_IDE_USERIF3 = 33, 
    E_SW_GID_IDE_USERIF4 = 34, 
    E_SW_GID_IDE_RMTDIS1 = 35, 
    E_SW_GID_IDE_RMTDIS2 = 36, 
    E_SW_GID_IDE_RMTDIS3 = 37, 
    E_SW_GID_LASIE_LASIE1 = 38, 
    E_SW_GID_LASIE_LASIE2 = 39, 
    E_SW_GID_BISIE_BISIE1 = 40, 
    E_SW_GID_BISIE_BISIE2 = 41, 
    E_SW_GID_MASIE_MASIE1 = 42, 
    E_SW_GID_MASIE_MASIE2 = 43, 
    E_SW_GID_EIE_RADARIF1 = 44, 
    E_SW_GID_EIE_RADARIF2 = 45, 
    E_SW_GID_EIE_KNTDSIF1 = 46, 
    E_SW_GID_EOE_ELEOPT1 = 47, 
    E_SW_GID_EOE_ELEOPT2 = 48, 
    E_SW_GID_ASE_ACTDSP1 = 49, 
    E_SW_GID_ASE_ACTDSP2 = 50, 
    E_SW_GID_ASE_ACTDSP3 = 51
};

NDDSUSERDllExport std::ostream& operator << (std::ostream& o,const E_SW_GID& sample);

class NDDSUSERDllExport ST_DATE_TIME {
  public:
    ST_DATE_TIME();

    ST_DATE_TIME(uint16_t unYear,uint16_t unMonth,uint16_t unDay,uint16_t unHour,uint16_t unMin,uint16_t unSec,uint16_t unMilSec,uint16_t unReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_DATE_TIME (ST_DATE_TIME&&) = default;
    ST_DATE_TIME& operator=(ST_DATE_TIME&&) = default;
    ST_DATE_TIME& operator=(const ST_DATE_TIME&) = default;
    ST_DATE_TIME(const ST_DATE_TIME&) = default;
    #else
    ST_DATE_TIME(ST_DATE_TIME&& other_) OMG_NOEXCEPT;  
    ST_DATE_TIME& operator=(ST_DATE_TIME&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& unYear() OMG_NOEXCEPT {
        return m_unYear_;
    }

    const uint16_t& unYear() const OMG_NOEXCEPT {
        return m_unYear_;
    }

    void unYear(uint16_t value) {
        m_unYear_ = value;
    }

    uint16_t& unMonth() OMG_NOEXCEPT {
        return m_unMonth_;
    }

    const uint16_t& unMonth() const OMG_NOEXCEPT {
        return m_unMonth_;
    }

    void unMonth(uint16_t value) {
        m_unMonth_ = value;
    }

    uint16_t& unDay() OMG_NOEXCEPT {
        return m_unDay_;
    }

    const uint16_t& unDay() const OMG_NOEXCEPT {
        return m_unDay_;
    }

    void unDay(uint16_t value) {
        m_unDay_ = value;
    }

    uint16_t& unHour() OMG_NOEXCEPT {
        return m_unHour_;
    }

    const uint16_t& unHour() const OMG_NOEXCEPT {
        return m_unHour_;
    }

    void unHour(uint16_t value) {
        m_unHour_ = value;
    }

    uint16_t& unMin() OMG_NOEXCEPT {
        return m_unMin_;
    }

    const uint16_t& unMin() const OMG_NOEXCEPT {
        return m_unMin_;
    }

    void unMin(uint16_t value) {
        m_unMin_ = value;
    }

    uint16_t& unSec() OMG_NOEXCEPT {
        return m_unSec_;
    }

    const uint16_t& unSec() const OMG_NOEXCEPT {
        return m_unSec_;
    }

    void unSec(uint16_t value) {
        m_unSec_ = value;
    }

    uint16_t& unMilSec() OMG_NOEXCEPT {
        return m_unMilSec_;
    }

    const uint16_t& unMilSec() const OMG_NOEXCEPT {
        return m_unMilSec_;
    }

    void unMilSec(uint16_t value) {
        m_unMilSec_ = value;
    }

    uint16_t& unReserved() OMG_NOEXCEPT {
        return m_unReserved_;
    }

    const uint16_t& unReserved() const OMG_NOEXCEPT {
        return m_unReserved_;
    }

    void unReserved(uint16_t value) {
        m_unReserved_ = value;
    }

    bool operator == (const ST_DATE_TIME& other_) const;
    bool operator != (const ST_DATE_TIME& other_) const;

    void swap(ST_DATE_TIME& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_unYear_;
    uint16_t m_unMonth_;
    uint16_t m_unDay_;
    uint16_t m_unHour_;
    uint16_t m_unMin_;
    uint16_t m_unSec_;
    uint16_t m_unMilSec_;
    uint16_t m_unReserved_;

};

inline void swap(ST_DATE_TIME& a, ST_DATE_TIME& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_DATE_TIME& sample);

class NDDSUSERDllExport ST_MSG_HEADER {
  public:
    ST_MSG_HEADER();

    ST_MSG_HEADER(int32_t lTopicID,const E_CSCI_CSC_TYPE& eSendSW,int32_t lSequenceNo,const ST_DATE_TIME& stSendTime,const ::dds::core::array< uint8_t, 20L>& oSenderIP,uint32_t ulTopicSize,uint16_t usDomainID,uint8_t oConsoleID,uint8_t reserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSG_HEADER (ST_MSG_HEADER&&) = default;
    ST_MSG_HEADER& operator=(ST_MSG_HEADER&&) = default;
    ST_MSG_HEADER& operator=(const ST_MSG_HEADER&) = default;
    ST_MSG_HEADER(const ST_MSG_HEADER&) = default;
    #else
    ST_MSG_HEADER(ST_MSG_HEADER&& other_) OMG_NOEXCEPT;  
    ST_MSG_HEADER& operator=(ST_MSG_HEADER&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int32_t& lTopicID() OMG_NOEXCEPT {
        return m_lTopicID_;
    }

    const int32_t& lTopicID() const OMG_NOEXCEPT {
        return m_lTopicID_;
    }

    void lTopicID(int32_t value) {
        m_lTopicID_ = value;
    }

    E_CSCI_CSC_TYPE& eSendSW() OMG_NOEXCEPT {
        return m_eSendSW_;
    }

    const E_CSCI_CSC_TYPE& eSendSW() const OMG_NOEXCEPT {
        return m_eSendSW_;
    }

    void eSendSW(const E_CSCI_CSC_TYPE& value) {
        m_eSendSW_ = value;
    }

    void eSendSW(E_CSCI_CSC_TYPE&& value) {
        m_eSendSW_ = std::move(value);
    }
    int32_t& lSequenceNo() OMG_NOEXCEPT {
        return m_lSequenceNo_;
    }

    const int32_t& lSequenceNo() const OMG_NOEXCEPT {
        return m_lSequenceNo_;
    }

    void lSequenceNo(int32_t value) {
        m_lSequenceNo_ = value;
    }

    ST_DATE_TIME& stSendTime() OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    const ST_DATE_TIME& stSendTime() const OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    void stSendTime(const ST_DATE_TIME& value) {
        m_stSendTime_ = value;
    }

    void stSendTime(ST_DATE_TIME&& value) {
        m_stSendTime_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oSenderIP() OMG_NOEXCEPT {
        return m_oSenderIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oSenderIP() const OMG_NOEXCEPT {
        return m_oSenderIP_;
    }

    void oSenderIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oSenderIP_ = value;
    }

    void oSenderIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oSenderIP_ = std::move(value);
    }
    uint32_t& ulTopicSize() OMG_NOEXCEPT {
        return m_ulTopicSize_;
    }

    const uint32_t& ulTopicSize() const OMG_NOEXCEPT {
        return m_ulTopicSize_;
    }

    void ulTopicSize(uint32_t value) {
        m_ulTopicSize_ = value;
    }

    uint16_t& usDomainID() OMG_NOEXCEPT {
        return m_usDomainID_;
    }

    const uint16_t& usDomainID() const OMG_NOEXCEPT {
        return m_usDomainID_;
    }

    void usDomainID(uint16_t value) {
        m_usDomainID_ = value;
    }

    uint8_t& oConsoleID() OMG_NOEXCEPT {
        return m_oConsoleID_;
    }

    const uint8_t& oConsoleID() const OMG_NOEXCEPT {
        return m_oConsoleID_;
    }

    void oConsoleID(uint8_t value) {
        m_oConsoleID_ = value;
    }

    uint8_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint8_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint8_t value) {
        m_reserved_ = value;
    }

    bool operator == (const ST_MSG_HEADER& other_) const;
    bool operator != (const ST_MSG_HEADER& other_) const;

    void swap(ST_MSG_HEADER& other_) OMG_NOEXCEPT ;

  private:

    int32_t m_lTopicID_;
    E_CSCI_CSC_TYPE m_eSendSW_;
    int32_t m_lSequenceNo_;
    ST_DATE_TIME m_stSendTime_;
    ::dds::core::array< uint8_t, 20L> m_oSenderIP_;
    uint32_t m_ulTopicSize_;
    uint16_t m_usDomainID_;
    uint8_t m_oConsoleID_;
    uint8_t m_reserved_;

};

inline void swap(ST_MSG_HEADER& a, ST_MSG_HEADER& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSG_HEADER& sample);

class NDDSUSERDllExport BISDSP_BIS_ACTIVE_PULSE_DB_REQ {
  public:
    BISDSP_BIS_ACTIVE_PULSE_DB_REQ();

    BISDSP_BIS_ACTIVE_PULSE_DB_REQ(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< int32_t, 3L>& aDBReqDeviceID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_ACTIVE_PULSE_DB_REQ (BISDSP_BIS_ACTIVE_PULSE_DB_REQ&&) = default;
    BISDSP_BIS_ACTIVE_PULSE_DB_REQ& operator=(BISDSP_BIS_ACTIVE_PULSE_DB_REQ&&) = default;
    BISDSP_BIS_ACTIVE_PULSE_DB_REQ& operator=(const BISDSP_BIS_ACTIVE_PULSE_DB_REQ&) = default;
    BISDSP_BIS_ACTIVE_PULSE_DB_REQ(const BISDSP_BIS_ACTIVE_PULSE_DB_REQ&) = default;
    #else
    BISDSP_BIS_ACTIVE_PULSE_DB_REQ(BISDSP_BIS_ACTIVE_PULSE_DB_REQ&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_ACTIVE_PULSE_DB_REQ& operator=(BISDSP_BIS_ACTIVE_PULSE_DB_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< int32_t, 3L>& aDBReqDeviceID() OMG_NOEXCEPT {
        return m_aDBReqDeviceID_;
    }

    const ::dds::core::array< int32_t, 3L>& aDBReqDeviceID() const OMG_NOEXCEPT {
        return m_aDBReqDeviceID_;
    }

    void aDBReqDeviceID(const ::dds::core::array< int32_t, 3L>& value) {
        m_aDBReqDeviceID_ = value;
    }

    void aDBReqDeviceID(::dds::core::array< int32_t, 3L>&& value) {
        m_aDBReqDeviceID_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_ACTIVE_PULSE_DB_REQ& other_) const;
    bool operator != (const BISDSP_BIS_ACTIVE_PULSE_DB_REQ& other_) const;

    void swap(BISDSP_BIS_ACTIVE_PULSE_DB_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< int32_t, 3L> m_aDBReqDeviceID_;

};

inline void swap(BISDSP_BIS_ACTIVE_PULSE_DB_REQ& a, BISDSP_BIS_ACTIVE_PULSE_DB_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_ACTIVE_PULSE_DB_REQ& sample);

class NDDSUSERDllExport BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO {
  public:
    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO();

    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,const ::dds::core::array< uint16_t, 2L>& unDetBeamNo,const ST_DATE_TIME& stDetectionStartTime,const ST_DATE_TIME& stDetectionEndTime,uint16_t Reserved,uint16_t usStftResType,const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut,const ::dds::core::array< float, 2L>& fFC,const ::dds::core::array< float, 2L>& fBW,const ::dds::core::array< float, 2L>& fPL,uint16_t unPulseType,uint16_t usAPDInfoChgFlag,const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID,const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore,const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision,const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO (BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO&&) = default;
    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& operator=(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO&&) = default;
    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& operator=(const BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO&) = default;
    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO(const BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO&) = default;
    #else
    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& operator=(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& unDetBeamNo() OMG_NOEXCEPT {
        return m_unDetBeamNo_;
    }

    const ::dds::core::array< uint16_t, 2L>& unDetBeamNo() const OMG_NOEXCEPT {
        return m_unDetBeamNo_;
    }

    void unDetBeamNo(const ::dds::core::array< uint16_t, 2L>& value) {
        m_unDetBeamNo_ = value;
    }

    void unDetBeamNo(::dds::core::array< uint16_t, 2L>&& value) {
        m_unDetBeamNo_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionStartTime() OMG_NOEXCEPT {
        return m_stDetectionStartTime_;
    }

    const ST_DATE_TIME& stDetectionStartTime() const OMG_NOEXCEPT {
        return m_stDetectionStartTime_;
    }

    void stDetectionStartTime(const ST_DATE_TIME& value) {
        m_stDetectionStartTime_ = value;
    }

    void stDetectionStartTime(ST_DATE_TIME&& value) {
        m_stDetectionStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionEndTime() OMG_NOEXCEPT {
        return m_stDetectionEndTime_;
    }

    const ST_DATE_TIME& stDetectionEndTime() const OMG_NOEXCEPT {
        return m_stDetectionEndTime_;
    }

    void stDetectionEndTime(const ST_DATE_TIME& value) {
        m_stDetectionEndTime_ = value;
    }

    void stDetectionEndTime(ST_DATE_TIME&& value) {
        m_stDetectionEndTime_ = std::move(value);
    }
    uint16_t& Reserved() OMG_NOEXCEPT {
        return m_Reserved_;
    }

    const uint16_t& Reserved() const OMG_NOEXCEPT {
        return m_Reserved_;
    }

    void Reserved(uint16_t value) {
        m_Reserved_ = value;
    }

    uint16_t& usStftResType() OMG_NOEXCEPT {
        return m_usStftResType_;
    }

    const uint16_t& usStftResType() const OMG_NOEXCEPT {
        return m_usStftResType_;
    }

    void usStftResType(uint16_t value) {
        m_usStftResType_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut() OMG_NOEXCEPT {
        return m_aStftOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut() const OMG_NOEXCEPT {
        return m_aStftOut_;
    }

    void aStftOut(const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& value) {
        m_aStftOut_ = value;
    }

    void aStftOut(::dds::core::array< ::dds::core::array< float, 753L>, 640L>&& value) {
        m_aStftOut_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fFC() OMG_NOEXCEPT {
        return m_fFC_;
    }

    const ::dds::core::array< float, 2L>& fFC() const OMG_NOEXCEPT {
        return m_fFC_;
    }

    void fFC(const ::dds::core::array< float, 2L>& value) {
        m_fFC_ = value;
    }

    void fFC(::dds::core::array< float, 2L>&& value) {
        m_fFC_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fBW() OMG_NOEXCEPT {
        return m_fBW_;
    }

    const ::dds::core::array< float, 2L>& fBW() const OMG_NOEXCEPT {
        return m_fBW_;
    }

    void fBW(const ::dds::core::array< float, 2L>& value) {
        m_fBW_ = value;
    }

    void fBW(::dds::core::array< float, 2L>&& value) {
        m_fBW_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fPL() OMG_NOEXCEPT {
        return m_fPL_;
    }

    const ::dds::core::array< float, 2L>& fPL() const OMG_NOEXCEPT {
        return m_fPL_;
    }

    void fPL(const ::dds::core::array< float, 2L>& value) {
        m_fPL_ = value;
    }

    void fPL(::dds::core::array< float, 2L>&& value) {
        m_fPL_ = std::move(value);
    }
    uint16_t& unPulseType() OMG_NOEXCEPT {
        return m_unPulseType_;
    }

    const uint16_t& unPulseType() const OMG_NOEXCEPT {
        return m_unPulseType_;
    }

    void unPulseType(uint16_t value) {
        m_unPulseType_ = value;
    }

    uint16_t& usAPDInfoChgFlag() OMG_NOEXCEPT {
        return m_usAPDInfoChgFlag_;
    }

    const uint16_t& usAPDInfoChgFlag() const OMG_NOEXCEPT {
        return m_usAPDInfoChgFlag_;
    }

    void usAPDInfoChgFlag(uint16_t value) {
        m_usAPDInfoChgFlag_ = value;
    }

    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID() OMG_NOEXCEPT {
        return m_aDBMatchingID_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID() const OMG_NOEXCEPT {
        return m_aDBMatchingID_;
    }

    void aDBMatchingID(const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& value) {
        m_aDBMatchingID_ = value;
    }

    void aDBMatchingID(::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>&& value) {
        m_aDBMatchingID_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore() OMG_NOEXCEPT {
        return m_aDBMatchingScore_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore() const OMG_NOEXCEPT {
        return m_aDBMatchingScore_;
    }

    void aDBMatchingScore(const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& value) {
        m_aDBMatchingScore_ = value;
    }

    void aDBMatchingScore(::dds::core::array< ::dds::core::array< float, 2L>, 10L>&& value) {
        m_aDBMatchingScore_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision() OMG_NOEXCEPT {
        return m_aActivePulseDecision_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision() const OMG_NOEXCEPT {
        return m_aActivePulseDecision_;
    }

    void aActivePulseDecision(const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& value) {
        m_aActivePulseDecision_ = value;
    }

    void aActivePulseDecision(::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>&& value) {
        m_aActivePulseDecision_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore() OMG_NOEXCEPT {
        return m_aTableResultsScore_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore() const OMG_NOEXCEPT {
        return m_aTableResultsScore_;
    }

    void aTableResultsScore(const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& value) {
        m_aTableResultsScore_ = value;
    }

    void aTableResultsScore(::dds::core::array< ::dds::core::array< float, 2L>, 10L>&& value) {
        m_aTableResultsScore_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable() OMG_NOEXCEPT {
        return m_aDBtable_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable() const OMG_NOEXCEPT {
        return m_aDBtable_;
    }

    void aDBtable(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& value) {
        m_aDBtable_ = value;
    }

    void aDBtable(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>&& value) {
        m_aDBtable_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& other_) const;
    bool operator != (const BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& other_) const;

    void swap(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    ::dds::core::array< uint16_t, 2L> m_unDetBeamNo_;
    ST_DATE_TIME m_stDetectionStartTime_;
    ST_DATE_TIME m_stDetectionEndTime_;
    uint16_t m_Reserved_;
    uint16_t m_usStftResType_;
    ::dds::core::array< ::dds::core::array< float, 753L>, 640L> m_aStftOut_;
    ::dds::core::array< float, 2L> m_fFC_;
    ::dds::core::array< float, 2L> m_fBW_;
    ::dds::core::array< float, 2L> m_fPL_;
    uint16_t m_unPulseType_;
    uint16_t m_usAPDInfoChgFlag_;
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L> m_aDBMatchingID_;
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L> m_aDBMatchingScore_;
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L> m_aActivePulseDecision_;
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L> m_aTableResultsScore_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L> m_aDBtable_;

};

inline void swap(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& a, BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& sample);

class NDDSUSERDllExport BISDSP_BIS_A_AGC_CTRL_INFO {
  public:
    BISDSP_BIS_A_AGC_CTRL_INFO();

    BISDSP_BIS_A_AGC_CTRL_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t unAutoGainCntrlVal,const ::dds::core::array< float, 148L>& aSensorEnergy,float fTotalEnergy);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_A_AGC_CTRL_INFO (BISDSP_BIS_A_AGC_CTRL_INFO&&) = default;
    BISDSP_BIS_A_AGC_CTRL_INFO& operator=(BISDSP_BIS_A_AGC_CTRL_INFO&&) = default;
    BISDSP_BIS_A_AGC_CTRL_INFO& operator=(const BISDSP_BIS_A_AGC_CTRL_INFO&) = default;
    BISDSP_BIS_A_AGC_CTRL_INFO(const BISDSP_BIS_A_AGC_CTRL_INFO&) = default;
    #else
    BISDSP_BIS_A_AGC_CTRL_INFO(BISDSP_BIS_A_AGC_CTRL_INFO&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_A_AGC_CTRL_INFO& operator=(BISDSP_BIS_A_AGC_CTRL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& unAutoGainCntrlVal() OMG_NOEXCEPT {
        return m_unAutoGainCntrlVal_;
    }

    const uint16_t& unAutoGainCntrlVal() const OMG_NOEXCEPT {
        return m_unAutoGainCntrlVal_;
    }

    void unAutoGainCntrlVal(uint16_t value) {
        m_unAutoGainCntrlVal_ = value;
    }

    ::dds::core::array< float, 148L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 148L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 148L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 148L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    bool operator == (const BISDSP_BIS_A_AGC_CTRL_INFO& other_) const;
    bool operator != (const BISDSP_BIS_A_AGC_CTRL_INFO& other_) const;

    void swap(BISDSP_BIS_A_AGC_CTRL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_unAutoGainCntrlVal_;
    ::dds::core::array< float, 148L> m_aSensorEnergy_;
    float m_fTotalEnergy_;

};

inline void swap(BISDSP_BIS_A_AGC_CTRL_INFO& a, BISDSP_BIS_A_AGC_CTRL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_A_AGC_CTRL_INFO& sample);

class NDDSUSERDllExport BISDSP_BIS_A_BEAM_DATA {
  public:
    BISDSP_BIS_A_BEAM_DATA();

    BISDSP_BIS_A_BEAM_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint32_t unSubFrameNo,uint16_t usAxisId,const ST_DATE_TIME& stAcqusitionTime,uint16_t oReserved,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_A_BEAM_DATA (BISDSP_BIS_A_BEAM_DATA&&) = default;
    BISDSP_BIS_A_BEAM_DATA& operator=(BISDSP_BIS_A_BEAM_DATA&&) = default;
    BISDSP_BIS_A_BEAM_DATA& operator=(const BISDSP_BIS_A_BEAM_DATA&) = default;
    BISDSP_BIS_A_BEAM_DATA(const BISDSP_BIS_A_BEAM_DATA&) = default;
    #else
    BISDSP_BIS_A_BEAM_DATA(BISDSP_BIS_A_BEAM_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_A_BEAM_DATA& operator=(BISDSP_BIS_A_BEAM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint32_t& unSubFrameNo() OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    const uint32_t& unSubFrameNo() const OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    void unSubFrameNo(uint32_t value) {
        m_unSubFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& oReserved() OMG_NOEXCEPT {
        return m_oReserved_;
    }

    const uint16_t& oReserved() const OMG_NOEXCEPT {
        return m_oReserved_;
    }

    void oReserved(uint16_t value) {
        m_oReserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData() OMG_NOEXCEPT {
        return m_aBISBeamData_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData() const OMG_NOEXCEPT {
        return m_aBISBeamData_;
    }

    void aBISBeamData(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& value) {
        m_aBISBeamData_ = value;
    }

    void aBISBeamData(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>&& value) {
        m_aBISBeamData_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_A_BEAM_DATA& other_) const;
    bool operator != (const BISDSP_BIS_A_BEAM_DATA& other_) const;

    void swap(BISDSP_BIS_A_BEAM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint32_t m_unSubFrameNo_;
    uint16_t m_usAxisId_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_oReserved_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L> m_aBISBeamData_;

};

inline void swap(BISDSP_BIS_A_BEAM_DATA& a, BISDSP_BIS_A_BEAM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_A_BEAM_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_A_DETECTION_CW_DATA {
  public:
    BISDSP_BIS_A_DETECTION_CW_DATA();

    BISDSP_BIS_A_DETECTION_CW_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint32_t ulFramNo,uint32_t unSubFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usReserved,uint16_t unSensorGain,uint16_t unBFWindowType,uint16_t unTxSourceTargetNo,uint16_t unPulseID,uint32_t ulRemoveClutter,float fMinDopplerSpeed,uint32_t reserved3,uint32_t reserved4,const ST_DATE_TIME& stDetectionTime,uint16_t reserved1,const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw,const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize,const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo,const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo,bool bCWDrcPulseOnOff,float fPRICW,uint16_t usUsing3AxisDPDInfoFlag,uint16_t unPRISubFrameNoCW,uint16_t unPingNoCW,uint16_t usDirectPulseFlagCW,uint16_t usDirectPulseIndexCW,float fSoundVel,float fSourceToSensorDist,float fSourceToSensorBear,uint16_t usDirExistTDFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx,uint16_t usDirExistAudioFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx,uint16_t reserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_A_DETECTION_CW_DATA (BISDSP_BIS_A_DETECTION_CW_DATA&&) = default;
    BISDSP_BIS_A_DETECTION_CW_DATA& operator=(BISDSP_BIS_A_DETECTION_CW_DATA&&) = default;
    BISDSP_BIS_A_DETECTION_CW_DATA& operator=(const BISDSP_BIS_A_DETECTION_CW_DATA&) = default;
    BISDSP_BIS_A_DETECTION_CW_DATA(const BISDSP_BIS_A_DETECTION_CW_DATA&) = default;
    #else
    BISDSP_BIS_A_DETECTION_CW_DATA(BISDSP_BIS_A_DETECTION_CW_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_A_DETECTION_CW_DATA& operator=(BISDSP_BIS_A_DETECTION_CW_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint32_t& ulFramNo() OMG_NOEXCEPT {
        return m_ulFramNo_;
    }

    const uint32_t& ulFramNo() const OMG_NOEXCEPT {
        return m_ulFramNo_;
    }

    void ulFramNo(uint32_t value) {
        m_ulFramNo_ = value;
    }

    uint32_t& unSubFrameNo() OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    const uint32_t& unSubFrameNo() const OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    void unSubFrameNo(uint32_t value) {
        m_unSubFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& unSensorGain() OMG_NOEXCEPT {
        return m_unSensorGain_;
    }

    const uint16_t& unSensorGain() const OMG_NOEXCEPT {
        return m_unSensorGain_;
    }

    void unSensorGain(uint16_t value) {
        m_unSensorGain_ = value;
    }

    uint16_t& unBFWindowType() OMG_NOEXCEPT {
        return m_unBFWindowType_;
    }

    const uint16_t& unBFWindowType() const OMG_NOEXCEPT {
        return m_unBFWindowType_;
    }

    void unBFWindowType(uint16_t value) {
        m_unBFWindowType_ = value;
    }

    uint16_t& unTxSourceTargetNo() OMG_NOEXCEPT {
        return m_unTxSourceTargetNo_;
    }

    const uint16_t& unTxSourceTargetNo() const OMG_NOEXCEPT {
        return m_unTxSourceTargetNo_;
    }

    void unTxSourceTargetNo(uint16_t value) {
        m_unTxSourceTargetNo_ = value;
    }

    uint16_t& unPulseID() OMG_NOEXCEPT {
        return m_unPulseID_;
    }

    const uint16_t& unPulseID() const OMG_NOEXCEPT {
        return m_unPulseID_;
    }

    void unPulseID(uint16_t value) {
        m_unPulseID_ = value;
    }

    uint32_t& ulRemoveClutter() OMG_NOEXCEPT {
        return m_ulRemoveClutter_;
    }

    const uint32_t& ulRemoveClutter() const OMG_NOEXCEPT {
        return m_ulRemoveClutter_;
    }

    void ulRemoveClutter(uint32_t value) {
        m_ulRemoveClutter_ = value;
    }

    float& fMinDopplerSpeed() OMG_NOEXCEPT {
        return m_fMinDopplerSpeed_;
    }

    const float& fMinDopplerSpeed() const OMG_NOEXCEPT {
        return m_fMinDopplerSpeed_;
    }

    void fMinDopplerSpeed(float value) {
        m_fMinDopplerSpeed_ = value;
    }

    uint32_t& reserved3() OMG_NOEXCEPT {
        return m_reserved3_;
    }

    const uint32_t& reserved3() const OMG_NOEXCEPT {
        return m_reserved3_;
    }

    void reserved3(uint32_t value) {
        m_reserved3_ = value;
    }

    uint32_t& reserved4() OMG_NOEXCEPT {
        return m_reserved4_;
    }

    const uint32_t& reserved4() const OMG_NOEXCEPT {
        return m_reserved4_;
    }

    void reserved4(uint32_t value) {
        m_reserved4_ = value;
    }

    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& reserved1() OMG_NOEXCEPT {
        return m_reserved1_;
    }

    const uint16_t& reserved1() const OMG_NOEXCEPT {
        return m_reserved1_;
    }

    void reserved1(uint16_t value) {
        m_reserved1_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw() OMG_NOEXCEPT {
        return m_aCWDetInfoRaw_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw() const OMG_NOEXCEPT {
        return m_aCWDetInfoRaw_;
    }

    void aCWDetInfoRaw(const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& value) {
        m_aCWDetInfoRaw_ = value;
    }

    void aCWDetInfoRaw(::dds::core::array< ::dds::core::array< float, 64L>, 129L>&& value) {
        m_aCWDetInfoRaw_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize() OMG_NOEXCEPT {
        return m_aCWDetInfoNormalize_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize() const OMG_NOEXCEPT {
        return m_aCWDetInfoNormalize_;
    }

    void aCWDetInfoNormalize(const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& value) {
        m_aCWDetInfoNormalize_ = value;
    }

    void aCWDetInfoNormalize(::dds::core::array< ::dds::core::array< float, 64L>, 129L>&& value) {
        m_aCWDetInfoNormalize_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo() OMG_NOEXCEPT {
        return m_aCWDetInfoRangeInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo() const OMG_NOEXCEPT {
        return m_aCWDetInfoRangeInfo_;
    }

    void aCWDetInfoRangeInfo(const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& value) {
        m_aCWDetInfoRangeInfo_ = value;
    }

    void aCWDetInfoRangeInfo(::dds::core::array< ::dds::core::array< float, 64L>, 256L>&& value) {
        m_aCWDetInfoRangeInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo() OMG_NOEXCEPT {
        return m_aCWDetInfoDopplerInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo() const OMG_NOEXCEPT {
        return m_aCWDetInfoDopplerInfo_;
    }

    void aCWDetInfoDopplerInfo(const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& value) {
        m_aCWDetInfoDopplerInfo_ = value;
    }

    void aCWDetInfoDopplerInfo(::dds::core::array< ::dds::core::array< float, 64L>, 256L>&& value) {
        m_aCWDetInfoDopplerInfo_ = std::move(value);
    }
    bool& bCWDrcPulseOnOff() OMG_NOEXCEPT {
        return m_bCWDrcPulseOnOff_;
    }

    const bool& bCWDrcPulseOnOff() const OMG_NOEXCEPT {
        return m_bCWDrcPulseOnOff_;
    }

    void bCWDrcPulseOnOff(bool value) {
        m_bCWDrcPulseOnOff_ = value;
    }

    float& fPRICW() OMG_NOEXCEPT {
        return m_fPRICW_;
    }

    const float& fPRICW() const OMG_NOEXCEPT {
        return m_fPRICW_;
    }

    void fPRICW(float value) {
        m_fPRICW_ = value;
    }

    uint16_t& usUsing3AxisDPDInfoFlag() OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    const uint16_t& usUsing3AxisDPDInfoFlag() const OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    void usUsing3AxisDPDInfoFlag(uint16_t value) {
        m_usUsing3AxisDPDInfoFlag_ = value;
    }

    uint16_t& unPRISubFrameNoCW() OMG_NOEXCEPT {
        return m_unPRISubFrameNoCW_;
    }

    const uint16_t& unPRISubFrameNoCW() const OMG_NOEXCEPT {
        return m_unPRISubFrameNoCW_;
    }

    void unPRISubFrameNoCW(uint16_t value) {
        m_unPRISubFrameNoCW_ = value;
    }

    uint16_t& unPingNoCW() OMG_NOEXCEPT {
        return m_unPingNoCW_;
    }

    const uint16_t& unPingNoCW() const OMG_NOEXCEPT {
        return m_unPingNoCW_;
    }

    void unPingNoCW(uint16_t value) {
        m_unPingNoCW_ = value;
    }

    uint16_t& usDirectPulseFlagCW() OMG_NOEXCEPT {
        return m_usDirectPulseFlagCW_;
    }

    const uint16_t& usDirectPulseFlagCW() const OMG_NOEXCEPT {
        return m_usDirectPulseFlagCW_;
    }

    void usDirectPulseFlagCW(uint16_t value) {
        m_usDirectPulseFlagCW_ = value;
    }

    uint16_t& usDirectPulseIndexCW() OMG_NOEXCEPT {
        return m_usDirectPulseIndexCW_;
    }

    const uint16_t& usDirectPulseIndexCW() const OMG_NOEXCEPT {
        return m_usDirectPulseIndexCW_;
    }

    void usDirectPulseIndexCW(uint16_t value) {
        m_usDirectPulseIndexCW_ = value;
    }

    float& fSoundVel() OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    const float& fSoundVel() const OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    void fSoundVel(float value) {
        m_fSoundVel_ = value;
    }

    float& fSourceToSensorDist() OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    const float& fSourceToSensorDist() const OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    void fSourceToSensorDist(float value) {
        m_fSourceToSensorDist_ = value;
    }

    float& fSourceToSensorBear() OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    const float& fSourceToSensorBear() const OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    void fSourceToSensorBear(float value) {
        m_fSourceToSensorBear_ = value;
    }

    uint16_t& usDirExistTDFlag() OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    const uint16_t& usDirExistTDFlag() const OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    void usDirExistTDFlag(uint16_t value) {
        m_usDirExistTDFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    void usDirExistTDSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistTDSamIdx_ = value;
    }

    void usDirExistTDSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistTDSamIdx_ = std::move(value);
    }
    uint16_t& usDirExistAudioFlag() OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    const uint16_t& usDirExistAudioFlag() const OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    void usDirExistAudioFlag(uint16_t value) {
        m_usDirExistAudioFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    void usDirExistAudioSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistAudioSamIdx_ = value;
    }

    void usDirExistAudioSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistAudioSamIdx_ = std::move(value);
    }
    uint16_t& reserved2() OMG_NOEXCEPT {
        return m_reserved2_;
    }

    const uint16_t& reserved2() const OMG_NOEXCEPT {
        return m_reserved2_;
    }

    void reserved2(uint16_t value) {
        m_reserved2_ = value;
    }

    bool operator == (const BISDSP_BIS_A_DETECTION_CW_DATA& other_) const;
    bool operator != (const BISDSP_BIS_A_DETECTION_CW_DATA& other_) const;

    void swap(BISDSP_BIS_A_DETECTION_CW_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint32_t m_ulFramNo_;
    uint32_t m_unSubFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usReserved_;
    uint16_t m_unSensorGain_;
    uint16_t m_unBFWindowType_;
    uint16_t m_unTxSourceTargetNo_;
    uint16_t m_unPulseID_;
    uint32_t m_ulRemoveClutter_;
    float m_fMinDopplerSpeed_;
    uint32_t m_reserved3_;
    uint32_t m_reserved4_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_reserved1_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L> m_aCWDetInfoRaw_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L> m_aCWDetInfoNormalize_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L> m_aCWDetInfoRangeInfo_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L> m_aCWDetInfoDopplerInfo_;
    bool m_bCWDrcPulseOnOff_;
    float m_fPRICW_;
    uint16_t m_usUsing3AxisDPDInfoFlag_;
    uint16_t m_unPRISubFrameNoCW_;
    uint16_t m_unPingNoCW_;
    uint16_t m_usDirectPulseFlagCW_;
    uint16_t m_usDirectPulseIndexCW_;
    float m_fSoundVel_;
    float m_fSourceToSensorDist_;
    float m_fSourceToSensorBear_;
    uint16_t m_usDirExistTDFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistTDSamIdx_;
    uint16_t m_usDirExistAudioFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistAudioSamIdx_;
    uint16_t m_reserved2_;

};

inline void swap(BISDSP_BIS_A_DETECTION_CW_DATA& a, BISDSP_BIS_A_DETECTION_CW_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_A_DETECTION_CW_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_A_DETECTION_FM_DATA {
  public:
    BISDSP_BIS_A_DETECTION_FM_DATA();

    BISDSP_BIS_A_DETECTION_FM_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint32_t ulFrameNo,uint32_t usSubFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBFWindowType,uint16_t usTxSourceTargetNo,uint16_t usPulseID,const ST_DATE_TIME& stCommTime,const ST_DATE_TIME& stDetectionTime,uint16_t reserved1,const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw,const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize,const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo,bool bFMDrcPulseOnOff,float fPRIFM,uint16_t usUsing3AxisDPDInfoFlag,uint16_t unPRISubFrameNoFM,uint16_t unPingNoFM,uint16_t usDirectPulseFlagFM,uint16_t usDirectPulseIndexFM,float fSoundVel,float fSourceToSensorDist,float fSourceToSensorBear,uint16_t usDirExistTDFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx,uint16_t usDirExistAudioFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx,uint16_t reserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_A_DETECTION_FM_DATA (BISDSP_BIS_A_DETECTION_FM_DATA&&) = default;
    BISDSP_BIS_A_DETECTION_FM_DATA& operator=(BISDSP_BIS_A_DETECTION_FM_DATA&&) = default;
    BISDSP_BIS_A_DETECTION_FM_DATA& operator=(const BISDSP_BIS_A_DETECTION_FM_DATA&) = default;
    BISDSP_BIS_A_DETECTION_FM_DATA(const BISDSP_BIS_A_DETECTION_FM_DATA&) = default;
    #else
    BISDSP_BIS_A_DETECTION_FM_DATA(BISDSP_BIS_A_DETECTION_FM_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_A_DETECTION_FM_DATA& operator=(BISDSP_BIS_A_DETECTION_FM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint32_t& usSubFrameNo() OMG_NOEXCEPT {
        return m_usSubFrameNo_;
    }

    const uint32_t& usSubFrameNo() const OMG_NOEXCEPT {
        return m_usSubFrameNo_;
    }

    void usSubFrameNo(uint32_t value) {
        m_usSubFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBFWindowType() OMG_NOEXCEPT {
        return m_usBFWindowType_;
    }

    const uint16_t& usBFWindowType() const OMG_NOEXCEPT {
        return m_usBFWindowType_;
    }

    void usBFWindowType(uint16_t value) {
        m_usBFWindowType_ = value;
    }

    uint16_t& usTxSourceTargetNo() OMG_NOEXCEPT {
        return m_usTxSourceTargetNo_;
    }

    const uint16_t& usTxSourceTargetNo() const OMG_NOEXCEPT {
        return m_usTxSourceTargetNo_;
    }

    void usTxSourceTargetNo(uint16_t value) {
        m_usTxSourceTargetNo_ = value;
    }

    uint16_t& usPulseID() OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    const uint16_t& usPulseID() const OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    void usPulseID(uint16_t value) {
        m_usPulseID_ = value;
    }

    ST_DATE_TIME& stCommTime() OMG_NOEXCEPT {
        return m_stCommTime_;
    }

    const ST_DATE_TIME& stCommTime() const OMG_NOEXCEPT {
        return m_stCommTime_;
    }

    void stCommTime(const ST_DATE_TIME& value) {
        m_stCommTime_ = value;
    }

    void stCommTime(ST_DATE_TIME&& value) {
        m_stCommTime_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& reserved1() OMG_NOEXCEPT {
        return m_reserved1_;
    }

    const uint16_t& reserved1() const OMG_NOEXCEPT {
        return m_reserved1_;
    }

    void reserved1(uint16_t value) {
        m_reserved1_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw() OMG_NOEXCEPT {
        return m_aFMDetInfoRaw_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw() const OMG_NOEXCEPT {
        return m_aFMDetInfoRaw_;
    }

    void aFMDetInfoRaw(const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& value) {
        m_aFMDetInfoRaw_ = value;
    }

    void aFMDetInfoRaw(::dds::core::array< ::dds::core::array< float, 256L>, 129L>&& value) {
        m_aFMDetInfoRaw_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize() OMG_NOEXCEPT {
        return m_aFMDetInfoNormalize_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize() const OMG_NOEXCEPT {
        return m_aFMDetInfoNormalize_;
    }

    void aFMDetInfoNormalize(const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& value) {
        m_aFMDetInfoNormalize_ = value;
    }

    void aFMDetInfoNormalize(::dds::core::array< ::dds::core::array< float, 256L>, 129L>&& value) {
        m_aFMDetInfoNormalize_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo() OMG_NOEXCEPT {
        return m_aFMDetInfoRangeInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo() const OMG_NOEXCEPT {
        return m_aFMDetInfoRangeInfo_;
    }

    void aFMDetInfoRangeInfo(const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& value) {
        m_aFMDetInfoRangeInfo_ = value;
    }

    void aFMDetInfoRangeInfo(::dds::core::array< ::dds::core::array< float, 256L>, 256L>&& value) {
        m_aFMDetInfoRangeInfo_ = std::move(value);
    }
    bool& bFMDrcPulseOnOff() OMG_NOEXCEPT {
        return m_bFMDrcPulseOnOff_;
    }

    const bool& bFMDrcPulseOnOff() const OMG_NOEXCEPT {
        return m_bFMDrcPulseOnOff_;
    }

    void bFMDrcPulseOnOff(bool value) {
        m_bFMDrcPulseOnOff_ = value;
    }

    float& fPRIFM() OMG_NOEXCEPT {
        return m_fPRIFM_;
    }

    const float& fPRIFM() const OMG_NOEXCEPT {
        return m_fPRIFM_;
    }

    void fPRIFM(float value) {
        m_fPRIFM_ = value;
    }

    uint16_t& usUsing3AxisDPDInfoFlag() OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    const uint16_t& usUsing3AxisDPDInfoFlag() const OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    void usUsing3AxisDPDInfoFlag(uint16_t value) {
        m_usUsing3AxisDPDInfoFlag_ = value;
    }

    uint16_t& unPRISubFrameNoFM() OMG_NOEXCEPT {
        return m_unPRISubFrameNoFM_;
    }

    const uint16_t& unPRISubFrameNoFM() const OMG_NOEXCEPT {
        return m_unPRISubFrameNoFM_;
    }

    void unPRISubFrameNoFM(uint16_t value) {
        m_unPRISubFrameNoFM_ = value;
    }

    uint16_t& unPingNoFM() OMG_NOEXCEPT {
        return m_unPingNoFM_;
    }

    const uint16_t& unPingNoFM() const OMG_NOEXCEPT {
        return m_unPingNoFM_;
    }

    void unPingNoFM(uint16_t value) {
        m_unPingNoFM_ = value;
    }

    uint16_t& usDirectPulseFlagFM() OMG_NOEXCEPT {
        return m_usDirectPulseFlagFM_;
    }

    const uint16_t& usDirectPulseFlagFM() const OMG_NOEXCEPT {
        return m_usDirectPulseFlagFM_;
    }

    void usDirectPulseFlagFM(uint16_t value) {
        m_usDirectPulseFlagFM_ = value;
    }

    uint16_t& usDirectPulseIndexFM() OMG_NOEXCEPT {
        return m_usDirectPulseIndexFM_;
    }

    const uint16_t& usDirectPulseIndexFM() const OMG_NOEXCEPT {
        return m_usDirectPulseIndexFM_;
    }

    void usDirectPulseIndexFM(uint16_t value) {
        m_usDirectPulseIndexFM_ = value;
    }

    float& fSoundVel() OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    const float& fSoundVel() const OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    void fSoundVel(float value) {
        m_fSoundVel_ = value;
    }

    float& fSourceToSensorDist() OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    const float& fSourceToSensorDist() const OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    void fSourceToSensorDist(float value) {
        m_fSourceToSensorDist_ = value;
    }

    float& fSourceToSensorBear() OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    const float& fSourceToSensorBear() const OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    void fSourceToSensorBear(float value) {
        m_fSourceToSensorBear_ = value;
    }

    uint16_t& usDirExistTDFlag() OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    const uint16_t& usDirExistTDFlag() const OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    void usDirExistTDFlag(uint16_t value) {
        m_usDirExistTDFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    void usDirExistTDSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistTDSamIdx_ = value;
    }

    void usDirExistTDSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistTDSamIdx_ = std::move(value);
    }
    uint16_t& usDirExistAudioFlag() OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    const uint16_t& usDirExistAudioFlag() const OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    void usDirExistAudioFlag(uint16_t value) {
        m_usDirExistAudioFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    void usDirExistAudioSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistAudioSamIdx_ = value;
    }

    void usDirExistAudioSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistAudioSamIdx_ = std::move(value);
    }
    uint16_t& reserved2() OMG_NOEXCEPT {
        return m_reserved2_;
    }

    const uint16_t& reserved2() const OMG_NOEXCEPT {
        return m_reserved2_;
    }

    void reserved2(uint16_t value) {
        m_reserved2_ = value;
    }

    bool operator == (const BISDSP_BIS_A_DETECTION_FM_DATA& other_) const;
    bool operator != (const BISDSP_BIS_A_DETECTION_FM_DATA& other_) const;

    void swap(BISDSP_BIS_A_DETECTION_FM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint32_t m_ulFrameNo_;
    uint32_t m_usSubFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBFWindowType_;
    uint16_t m_usTxSourceTargetNo_;
    uint16_t m_usPulseID_;
    ST_DATE_TIME m_stCommTime_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_reserved1_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L> m_aFMDetInfoRaw_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L> m_aFMDetInfoNormalize_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 256L> m_aFMDetInfoRangeInfo_;
    bool m_bFMDrcPulseOnOff_;
    float m_fPRIFM_;
    uint16_t m_usUsing3AxisDPDInfoFlag_;
    uint16_t m_unPRISubFrameNoFM_;
    uint16_t m_unPingNoFM_;
    uint16_t m_usDirectPulseFlagFM_;
    uint16_t m_usDirectPulseIndexFM_;
    float m_fSoundVel_;
    float m_fSourceToSensorDist_;
    float m_fSourceToSensorBear_;
    uint16_t m_usDirExistTDFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistTDSamIdx_;
    uint16_t m_usDirExistAudioFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistAudioSamIdx_;
    uint16_t m_reserved2_;

};

inline void swap(BISDSP_BIS_A_DETECTION_FM_DATA& a, BISDSP_BIS_A_DETECTION_FM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_A_DETECTION_FM_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_A_ENE_DATA {
  public:
    BISDSP_BIS_A_ENE_DATA();

    BISDSP_BIS_A_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint32_t ulFrameNo,const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_A_ENE_DATA (BISDSP_BIS_A_ENE_DATA&&) = default;
    BISDSP_BIS_A_ENE_DATA& operator=(BISDSP_BIS_A_ENE_DATA&&) = default;
    BISDSP_BIS_A_ENE_DATA& operator=(const BISDSP_BIS_A_ENE_DATA&) = default;
    BISDSP_BIS_A_ENE_DATA(const BISDSP_BIS_A_ENE_DATA&) = default;
    #else
    BISDSP_BIS_A_ENE_DATA(BISDSP_BIS_A_ENE_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_A_ENE_DATA& operator=(BISDSP_BIS_A_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo() OMG_NOEXCEPT {
        return m_aENEInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo() const OMG_NOEXCEPT {
        return m_aENEInfo_;
    }

    void aENEInfo(const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& value) {
        m_aENEInfo_ = value;
    }

    void aENEInfo(::dds::core::array< ::dds::core::array< float, 7L>, 256L>&& value) {
        m_aENEInfo_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_A_ENE_DATA& other_) const;
    bool operator != (const BISDSP_BIS_A_ENE_DATA& other_) const;

    void swap(BISDSP_BIS_A_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint32_t m_ulFrameNo_;
    ::dds::core::array< ::dds::core::array< float, 7L>, 256L> m_aENEInfo_;

};

inline void swap(BISDSP_BIS_A_ENE_DATA& a, BISDSP_BIS_A_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_A_ENE_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO {
  public:
    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO();

    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,const ::dds::core::array< uint16_t, 2L>& unDetBeamNo,const ST_DATE_TIME& stDetectionStartTime,const ST_DATE_TIME& stDetectionEndTime,uint16_t Reserved,uint16_t usStftResType,const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut,const ::dds::core::array< float, 2L>& fFC,const ::dds::core::array< float, 2L>& fBW,const ::dds::core::array< float, 2L>& fPL,uint16_t unPulseType,uint16_t usAPDInfoChgFlag,const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID,const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore,const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision,const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO (BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO&&) = default;
    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& operator=(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO&&) = default;
    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& operator=(const BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO&) = default;
    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO(const BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO&) = default;
    #else
    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& operator=(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& unDetBeamNo() OMG_NOEXCEPT {
        return m_unDetBeamNo_;
    }

    const ::dds::core::array< uint16_t, 2L>& unDetBeamNo() const OMG_NOEXCEPT {
        return m_unDetBeamNo_;
    }

    void unDetBeamNo(const ::dds::core::array< uint16_t, 2L>& value) {
        m_unDetBeamNo_ = value;
    }

    void unDetBeamNo(::dds::core::array< uint16_t, 2L>&& value) {
        m_unDetBeamNo_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionStartTime() OMG_NOEXCEPT {
        return m_stDetectionStartTime_;
    }

    const ST_DATE_TIME& stDetectionStartTime() const OMG_NOEXCEPT {
        return m_stDetectionStartTime_;
    }

    void stDetectionStartTime(const ST_DATE_TIME& value) {
        m_stDetectionStartTime_ = value;
    }

    void stDetectionStartTime(ST_DATE_TIME&& value) {
        m_stDetectionStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionEndTime() OMG_NOEXCEPT {
        return m_stDetectionEndTime_;
    }

    const ST_DATE_TIME& stDetectionEndTime() const OMG_NOEXCEPT {
        return m_stDetectionEndTime_;
    }

    void stDetectionEndTime(const ST_DATE_TIME& value) {
        m_stDetectionEndTime_ = value;
    }

    void stDetectionEndTime(ST_DATE_TIME&& value) {
        m_stDetectionEndTime_ = std::move(value);
    }
    uint16_t& Reserved() OMG_NOEXCEPT {
        return m_Reserved_;
    }

    const uint16_t& Reserved() const OMG_NOEXCEPT {
        return m_Reserved_;
    }

    void Reserved(uint16_t value) {
        m_Reserved_ = value;
    }

    uint16_t& usStftResType() OMG_NOEXCEPT {
        return m_usStftResType_;
    }

    const uint16_t& usStftResType() const OMG_NOEXCEPT {
        return m_usStftResType_;
    }

    void usStftResType(uint16_t value) {
        m_usStftResType_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut() OMG_NOEXCEPT {
        return m_aStftOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut() const OMG_NOEXCEPT {
        return m_aStftOut_;
    }

    void aStftOut(const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& value) {
        m_aStftOut_ = value;
    }

    void aStftOut(::dds::core::array< ::dds::core::array< float, 753L>, 640L>&& value) {
        m_aStftOut_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fFC() OMG_NOEXCEPT {
        return m_fFC_;
    }

    const ::dds::core::array< float, 2L>& fFC() const OMG_NOEXCEPT {
        return m_fFC_;
    }

    void fFC(const ::dds::core::array< float, 2L>& value) {
        m_fFC_ = value;
    }

    void fFC(::dds::core::array< float, 2L>&& value) {
        m_fFC_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fBW() OMG_NOEXCEPT {
        return m_fBW_;
    }

    const ::dds::core::array< float, 2L>& fBW() const OMG_NOEXCEPT {
        return m_fBW_;
    }

    void fBW(const ::dds::core::array< float, 2L>& value) {
        m_fBW_ = value;
    }

    void fBW(::dds::core::array< float, 2L>&& value) {
        m_fBW_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fPL() OMG_NOEXCEPT {
        return m_fPL_;
    }

    const ::dds::core::array< float, 2L>& fPL() const OMG_NOEXCEPT {
        return m_fPL_;
    }

    void fPL(const ::dds::core::array< float, 2L>& value) {
        m_fPL_ = value;
    }

    void fPL(::dds::core::array< float, 2L>&& value) {
        m_fPL_ = std::move(value);
    }
    uint16_t& unPulseType() OMG_NOEXCEPT {
        return m_unPulseType_;
    }

    const uint16_t& unPulseType() const OMG_NOEXCEPT {
        return m_unPulseType_;
    }

    void unPulseType(uint16_t value) {
        m_unPulseType_ = value;
    }

    uint16_t& usAPDInfoChgFlag() OMG_NOEXCEPT {
        return m_usAPDInfoChgFlag_;
    }

    const uint16_t& usAPDInfoChgFlag() const OMG_NOEXCEPT {
        return m_usAPDInfoChgFlag_;
    }

    void usAPDInfoChgFlag(uint16_t value) {
        m_usAPDInfoChgFlag_ = value;
    }

    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID() OMG_NOEXCEPT {
        return m_aDBMatchingID_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID() const OMG_NOEXCEPT {
        return m_aDBMatchingID_;
    }

    void aDBMatchingID(const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& value) {
        m_aDBMatchingID_ = value;
    }

    void aDBMatchingID(::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>&& value) {
        m_aDBMatchingID_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore() OMG_NOEXCEPT {
        return m_aDBMatchingScore_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore() const OMG_NOEXCEPT {
        return m_aDBMatchingScore_;
    }

    void aDBMatchingScore(const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& value) {
        m_aDBMatchingScore_ = value;
    }

    void aDBMatchingScore(::dds::core::array< ::dds::core::array< float, 2L>, 10L>&& value) {
        m_aDBMatchingScore_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision() OMG_NOEXCEPT {
        return m_aActivePulseDecision_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision() const OMG_NOEXCEPT {
        return m_aActivePulseDecision_;
    }

    void aActivePulseDecision(const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& value) {
        m_aActivePulseDecision_ = value;
    }

    void aActivePulseDecision(::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>&& value) {
        m_aActivePulseDecision_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore() OMG_NOEXCEPT {
        return m_aTableResultsScore_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore() const OMG_NOEXCEPT {
        return m_aTableResultsScore_;
    }

    void aTableResultsScore(const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& value) {
        m_aTableResultsScore_ = value;
    }

    void aTableResultsScore(::dds::core::array< ::dds::core::array< float, 2L>, 10L>&& value) {
        m_aTableResultsScore_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable() OMG_NOEXCEPT {
        return m_aDBtable_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable() const OMG_NOEXCEPT {
        return m_aDBtable_;
    }

    void aDBtable(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& value) {
        m_aDBtable_ = value;
    }

    void aDBtable(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>&& value) {
        m_aDBtable_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& other_) const;
    bool operator != (const BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& other_) const;

    void swap(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    ::dds::core::array< uint16_t, 2L> m_unDetBeamNo_;
    ST_DATE_TIME m_stDetectionStartTime_;
    ST_DATE_TIME m_stDetectionEndTime_;
    uint16_t m_Reserved_;
    uint16_t m_usStftResType_;
    ::dds::core::array< ::dds::core::array< float, 753L>, 640L> m_aStftOut_;
    ::dds::core::array< float, 2L> m_fFC_;
    ::dds::core::array< float, 2L> m_fBW_;
    ::dds::core::array< float, 2L> m_fPL_;
    uint16_t m_unPulseType_;
    uint16_t m_usAPDInfoChgFlag_;
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L> m_aDBMatchingID_;
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L> m_aDBMatchingScore_;
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L> m_aActivePulseDecision_;
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L> m_aTableResultsScore_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L> m_aDBtable_;

};

inline void swap(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& a, BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& sample);

class NDDSUSERDllExport BISDSP_BIS_B_AGC_CTRL_INFO {
  public:
    BISDSP_BIS_B_AGC_CTRL_INFO();

    BISDSP_BIS_B_AGC_CTRL_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t unAutoGainCntrlVal,const ::dds::core::array< float, 148L>& aSensorEnergy,float fTotalEnergy);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_B_AGC_CTRL_INFO (BISDSP_BIS_B_AGC_CTRL_INFO&&) = default;
    BISDSP_BIS_B_AGC_CTRL_INFO& operator=(BISDSP_BIS_B_AGC_CTRL_INFO&&) = default;
    BISDSP_BIS_B_AGC_CTRL_INFO& operator=(const BISDSP_BIS_B_AGC_CTRL_INFO&) = default;
    BISDSP_BIS_B_AGC_CTRL_INFO(const BISDSP_BIS_B_AGC_CTRL_INFO&) = default;
    #else
    BISDSP_BIS_B_AGC_CTRL_INFO(BISDSP_BIS_B_AGC_CTRL_INFO&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_B_AGC_CTRL_INFO& operator=(BISDSP_BIS_B_AGC_CTRL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& unAutoGainCntrlVal() OMG_NOEXCEPT {
        return m_unAutoGainCntrlVal_;
    }

    const uint16_t& unAutoGainCntrlVal() const OMG_NOEXCEPT {
        return m_unAutoGainCntrlVal_;
    }

    void unAutoGainCntrlVal(uint16_t value) {
        m_unAutoGainCntrlVal_ = value;
    }

    ::dds::core::array< float, 148L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 148L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 148L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 148L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    bool operator == (const BISDSP_BIS_B_AGC_CTRL_INFO& other_) const;
    bool operator != (const BISDSP_BIS_B_AGC_CTRL_INFO& other_) const;

    void swap(BISDSP_BIS_B_AGC_CTRL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_unAutoGainCntrlVal_;
    ::dds::core::array< float, 148L> m_aSensorEnergy_;
    float m_fTotalEnergy_;

};

inline void swap(BISDSP_BIS_B_AGC_CTRL_INFO& a, BISDSP_BIS_B_AGC_CTRL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_B_AGC_CTRL_INFO& sample);

class NDDSUSERDllExport BISDSP_BIS_B_BEAM_DATA {
  public:
    BISDSP_BIS_B_BEAM_DATA();

    BISDSP_BIS_B_BEAM_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint32_t unSubFrameNo,uint16_t usAxisId,const ST_DATE_TIME& stAcqusitionTime,uint16_t oReserved,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_B_BEAM_DATA (BISDSP_BIS_B_BEAM_DATA&&) = default;
    BISDSP_BIS_B_BEAM_DATA& operator=(BISDSP_BIS_B_BEAM_DATA&&) = default;
    BISDSP_BIS_B_BEAM_DATA& operator=(const BISDSP_BIS_B_BEAM_DATA&) = default;
    BISDSP_BIS_B_BEAM_DATA(const BISDSP_BIS_B_BEAM_DATA&) = default;
    #else
    BISDSP_BIS_B_BEAM_DATA(BISDSP_BIS_B_BEAM_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_B_BEAM_DATA& operator=(BISDSP_BIS_B_BEAM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint32_t& unSubFrameNo() OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    const uint32_t& unSubFrameNo() const OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    void unSubFrameNo(uint32_t value) {
        m_unSubFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& oReserved() OMG_NOEXCEPT {
        return m_oReserved_;
    }

    const uint16_t& oReserved() const OMG_NOEXCEPT {
        return m_oReserved_;
    }

    void oReserved(uint16_t value) {
        m_oReserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData() OMG_NOEXCEPT {
        return m_aBISBeamData_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData() const OMG_NOEXCEPT {
        return m_aBISBeamData_;
    }

    void aBISBeamData(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& value) {
        m_aBISBeamData_ = value;
    }

    void aBISBeamData(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>&& value) {
        m_aBISBeamData_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_B_BEAM_DATA& other_) const;
    bool operator != (const BISDSP_BIS_B_BEAM_DATA& other_) const;

    void swap(BISDSP_BIS_B_BEAM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint32_t m_unSubFrameNo_;
    uint16_t m_usAxisId_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_oReserved_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L> m_aBISBeamData_;

};

inline void swap(BISDSP_BIS_B_BEAM_DATA& a, BISDSP_BIS_B_BEAM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_B_BEAM_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_B_DETECTION_CW_DATA {
  public:
    BISDSP_BIS_B_DETECTION_CW_DATA();

    BISDSP_BIS_B_DETECTION_CW_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint32_t ulFramNo,uint32_t unSubFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usReserved,uint16_t unSensorGain,uint16_t unBFWindowType,uint16_t unTxSourceTargetNo,uint16_t unPulseID,uint32_t ulRemoveClutter,float fMinDopplerSpeed,uint32_t reserved3,uint32_t reserved4,const ST_DATE_TIME& stDetectionTime,uint16_t reserved1,const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw,const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize,const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo,const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo,bool bCWDrcPulseOnOff,float fPRICW,uint16_t usUsing3AxisDPDInfoFlag,uint16_t unPRISubFrameNoCW,uint16_t unPingNoCW,uint16_t usDirectPulseFlagCW,uint16_t usDirectPulseIndexCW,float fSoundVel,float fSourceToSensorDist,float fSourceToSensorBear,uint16_t usDirExistTDFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx,uint16_t usDirExistAudioFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx,uint16_t reserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_B_DETECTION_CW_DATA (BISDSP_BIS_B_DETECTION_CW_DATA&&) = default;
    BISDSP_BIS_B_DETECTION_CW_DATA& operator=(BISDSP_BIS_B_DETECTION_CW_DATA&&) = default;
    BISDSP_BIS_B_DETECTION_CW_DATA& operator=(const BISDSP_BIS_B_DETECTION_CW_DATA&) = default;
    BISDSP_BIS_B_DETECTION_CW_DATA(const BISDSP_BIS_B_DETECTION_CW_DATA&) = default;
    #else
    BISDSP_BIS_B_DETECTION_CW_DATA(BISDSP_BIS_B_DETECTION_CW_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_B_DETECTION_CW_DATA& operator=(BISDSP_BIS_B_DETECTION_CW_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint32_t& ulFramNo() OMG_NOEXCEPT {
        return m_ulFramNo_;
    }

    const uint32_t& ulFramNo() const OMG_NOEXCEPT {
        return m_ulFramNo_;
    }

    void ulFramNo(uint32_t value) {
        m_ulFramNo_ = value;
    }

    uint32_t& unSubFrameNo() OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    const uint32_t& unSubFrameNo() const OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    void unSubFrameNo(uint32_t value) {
        m_unSubFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& unSensorGain() OMG_NOEXCEPT {
        return m_unSensorGain_;
    }

    const uint16_t& unSensorGain() const OMG_NOEXCEPT {
        return m_unSensorGain_;
    }

    void unSensorGain(uint16_t value) {
        m_unSensorGain_ = value;
    }

    uint16_t& unBFWindowType() OMG_NOEXCEPT {
        return m_unBFWindowType_;
    }

    const uint16_t& unBFWindowType() const OMG_NOEXCEPT {
        return m_unBFWindowType_;
    }

    void unBFWindowType(uint16_t value) {
        m_unBFWindowType_ = value;
    }

    uint16_t& unTxSourceTargetNo() OMG_NOEXCEPT {
        return m_unTxSourceTargetNo_;
    }

    const uint16_t& unTxSourceTargetNo() const OMG_NOEXCEPT {
        return m_unTxSourceTargetNo_;
    }

    void unTxSourceTargetNo(uint16_t value) {
        m_unTxSourceTargetNo_ = value;
    }

    uint16_t& unPulseID() OMG_NOEXCEPT {
        return m_unPulseID_;
    }

    const uint16_t& unPulseID() const OMG_NOEXCEPT {
        return m_unPulseID_;
    }

    void unPulseID(uint16_t value) {
        m_unPulseID_ = value;
    }

    uint32_t& ulRemoveClutter() OMG_NOEXCEPT {
        return m_ulRemoveClutter_;
    }

    const uint32_t& ulRemoveClutter() const OMG_NOEXCEPT {
        return m_ulRemoveClutter_;
    }

    void ulRemoveClutter(uint32_t value) {
        m_ulRemoveClutter_ = value;
    }

    float& fMinDopplerSpeed() OMG_NOEXCEPT {
        return m_fMinDopplerSpeed_;
    }

    const float& fMinDopplerSpeed() const OMG_NOEXCEPT {
        return m_fMinDopplerSpeed_;
    }

    void fMinDopplerSpeed(float value) {
        m_fMinDopplerSpeed_ = value;
    }

    uint32_t& reserved3() OMG_NOEXCEPT {
        return m_reserved3_;
    }

    const uint32_t& reserved3() const OMG_NOEXCEPT {
        return m_reserved3_;
    }

    void reserved3(uint32_t value) {
        m_reserved3_ = value;
    }

    uint32_t& reserved4() OMG_NOEXCEPT {
        return m_reserved4_;
    }

    const uint32_t& reserved4() const OMG_NOEXCEPT {
        return m_reserved4_;
    }

    void reserved4(uint32_t value) {
        m_reserved4_ = value;
    }

    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& reserved1() OMG_NOEXCEPT {
        return m_reserved1_;
    }

    const uint16_t& reserved1() const OMG_NOEXCEPT {
        return m_reserved1_;
    }

    void reserved1(uint16_t value) {
        m_reserved1_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw() OMG_NOEXCEPT {
        return m_aCWDetInfoRaw_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw() const OMG_NOEXCEPT {
        return m_aCWDetInfoRaw_;
    }

    void aCWDetInfoRaw(const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& value) {
        m_aCWDetInfoRaw_ = value;
    }

    void aCWDetInfoRaw(::dds::core::array< ::dds::core::array< float, 64L>, 129L>&& value) {
        m_aCWDetInfoRaw_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize() OMG_NOEXCEPT {
        return m_aCWDetInfoNormalize_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize() const OMG_NOEXCEPT {
        return m_aCWDetInfoNormalize_;
    }

    void aCWDetInfoNormalize(const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& value) {
        m_aCWDetInfoNormalize_ = value;
    }

    void aCWDetInfoNormalize(::dds::core::array< ::dds::core::array< float, 64L>, 129L>&& value) {
        m_aCWDetInfoNormalize_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo() OMG_NOEXCEPT {
        return m_aCWDetInfoRangeInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo() const OMG_NOEXCEPT {
        return m_aCWDetInfoRangeInfo_;
    }

    void aCWDetInfoRangeInfo(const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& value) {
        m_aCWDetInfoRangeInfo_ = value;
    }

    void aCWDetInfoRangeInfo(::dds::core::array< ::dds::core::array< float, 64L>, 256L>&& value) {
        m_aCWDetInfoRangeInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo() OMG_NOEXCEPT {
        return m_aCWDetInfoDopplerInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo() const OMG_NOEXCEPT {
        return m_aCWDetInfoDopplerInfo_;
    }

    void aCWDetInfoDopplerInfo(const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& value) {
        m_aCWDetInfoDopplerInfo_ = value;
    }

    void aCWDetInfoDopplerInfo(::dds::core::array< ::dds::core::array< float, 64L>, 256L>&& value) {
        m_aCWDetInfoDopplerInfo_ = std::move(value);
    }
    bool& bCWDrcPulseOnOff() OMG_NOEXCEPT {
        return m_bCWDrcPulseOnOff_;
    }

    const bool& bCWDrcPulseOnOff() const OMG_NOEXCEPT {
        return m_bCWDrcPulseOnOff_;
    }

    void bCWDrcPulseOnOff(bool value) {
        m_bCWDrcPulseOnOff_ = value;
    }

    float& fPRICW() OMG_NOEXCEPT {
        return m_fPRICW_;
    }

    const float& fPRICW() const OMG_NOEXCEPT {
        return m_fPRICW_;
    }

    void fPRICW(float value) {
        m_fPRICW_ = value;
    }

    uint16_t& usUsing3AxisDPDInfoFlag() OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    const uint16_t& usUsing3AxisDPDInfoFlag() const OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    void usUsing3AxisDPDInfoFlag(uint16_t value) {
        m_usUsing3AxisDPDInfoFlag_ = value;
    }

    uint16_t& unPRISubFrameNoCW() OMG_NOEXCEPT {
        return m_unPRISubFrameNoCW_;
    }

    const uint16_t& unPRISubFrameNoCW() const OMG_NOEXCEPT {
        return m_unPRISubFrameNoCW_;
    }

    void unPRISubFrameNoCW(uint16_t value) {
        m_unPRISubFrameNoCW_ = value;
    }

    uint16_t& unPingNoCW() OMG_NOEXCEPT {
        return m_unPingNoCW_;
    }

    const uint16_t& unPingNoCW() const OMG_NOEXCEPT {
        return m_unPingNoCW_;
    }

    void unPingNoCW(uint16_t value) {
        m_unPingNoCW_ = value;
    }

    uint16_t& usDirectPulseFlagCW() OMG_NOEXCEPT {
        return m_usDirectPulseFlagCW_;
    }

    const uint16_t& usDirectPulseFlagCW() const OMG_NOEXCEPT {
        return m_usDirectPulseFlagCW_;
    }

    void usDirectPulseFlagCW(uint16_t value) {
        m_usDirectPulseFlagCW_ = value;
    }

    uint16_t& usDirectPulseIndexCW() OMG_NOEXCEPT {
        return m_usDirectPulseIndexCW_;
    }

    const uint16_t& usDirectPulseIndexCW() const OMG_NOEXCEPT {
        return m_usDirectPulseIndexCW_;
    }

    void usDirectPulseIndexCW(uint16_t value) {
        m_usDirectPulseIndexCW_ = value;
    }

    float& fSoundVel() OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    const float& fSoundVel() const OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    void fSoundVel(float value) {
        m_fSoundVel_ = value;
    }

    float& fSourceToSensorDist() OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    const float& fSourceToSensorDist() const OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    void fSourceToSensorDist(float value) {
        m_fSourceToSensorDist_ = value;
    }

    float& fSourceToSensorBear() OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    const float& fSourceToSensorBear() const OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    void fSourceToSensorBear(float value) {
        m_fSourceToSensorBear_ = value;
    }

    uint16_t& usDirExistTDFlag() OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    const uint16_t& usDirExistTDFlag() const OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    void usDirExistTDFlag(uint16_t value) {
        m_usDirExistTDFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    void usDirExistTDSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistTDSamIdx_ = value;
    }

    void usDirExistTDSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistTDSamIdx_ = std::move(value);
    }
    uint16_t& usDirExistAudioFlag() OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    const uint16_t& usDirExistAudioFlag() const OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    void usDirExistAudioFlag(uint16_t value) {
        m_usDirExistAudioFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    void usDirExistAudioSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistAudioSamIdx_ = value;
    }

    void usDirExistAudioSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistAudioSamIdx_ = std::move(value);
    }
    uint16_t& reserved2() OMG_NOEXCEPT {
        return m_reserved2_;
    }

    const uint16_t& reserved2() const OMG_NOEXCEPT {
        return m_reserved2_;
    }

    void reserved2(uint16_t value) {
        m_reserved2_ = value;
    }

    bool operator == (const BISDSP_BIS_B_DETECTION_CW_DATA& other_) const;
    bool operator != (const BISDSP_BIS_B_DETECTION_CW_DATA& other_) const;

    void swap(BISDSP_BIS_B_DETECTION_CW_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint32_t m_ulFramNo_;
    uint32_t m_unSubFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usReserved_;
    uint16_t m_unSensorGain_;
    uint16_t m_unBFWindowType_;
    uint16_t m_unTxSourceTargetNo_;
    uint16_t m_unPulseID_;
    uint32_t m_ulRemoveClutter_;
    float m_fMinDopplerSpeed_;
    uint32_t m_reserved3_;
    uint32_t m_reserved4_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_reserved1_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L> m_aCWDetInfoRaw_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L> m_aCWDetInfoNormalize_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L> m_aCWDetInfoRangeInfo_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L> m_aCWDetInfoDopplerInfo_;
    bool m_bCWDrcPulseOnOff_;
    float m_fPRICW_;
    uint16_t m_usUsing3AxisDPDInfoFlag_;
    uint16_t m_unPRISubFrameNoCW_;
    uint16_t m_unPingNoCW_;
    uint16_t m_usDirectPulseFlagCW_;
    uint16_t m_usDirectPulseIndexCW_;
    float m_fSoundVel_;
    float m_fSourceToSensorDist_;
    float m_fSourceToSensorBear_;
    uint16_t m_usDirExistTDFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistTDSamIdx_;
    uint16_t m_usDirExistAudioFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistAudioSamIdx_;
    uint16_t m_reserved2_;

};

inline void swap(BISDSP_BIS_B_DETECTION_CW_DATA& a, BISDSP_BIS_B_DETECTION_CW_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_B_DETECTION_CW_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_B_DETECTION_FM_DATA {
  public:
    BISDSP_BIS_B_DETECTION_FM_DATA();

    BISDSP_BIS_B_DETECTION_FM_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint32_t ulFrameNo,uint32_t usSubFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBFWindowType,uint16_t usTxSourceTargetNo,uint16_t usPulseID,const ST_DATE_TIME& stCommTime,const ST_DATE_TIME& stDetectionTime,uint16_t reserved1,const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw,const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize,const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo,bool bFMDrcPulseOnOff,float fPRIFM,uint16_t usUsing3AxisDPDInfoFlag,uint16_t unPRISubFrameNoFM,uint16_t unPingNoFM,uint16_t usDirectPulseFlagFM,uint16_t usDirectPulseIndexFM,float fSoundVel,float fSourceToSensorDist,float fSourceToSensorBear,uint16_t usDirExistTDFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx,uint16_t usDirExistAudioFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx,uint16_t reserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_B_DETECTION_FM_DATA (BISDSP_BIS_B_DETECTION_FM_DATA&&) = default;
    BISDSP_BIS_B_DETECTION_FM_DATA& operator=(BISDSP_BIS_B_DETECTION_FM_DATA&&) = default;
    BISDSP_BIS_B_DETECTION_FM_DATA& operator=(const BISDSP_BIS_B_DETECTION_FM_DATA&) = default;
    BISDSP_BIS_B_DETECTION_FM_DATA(const BISDSP_BIS_B_DETECTION_FM_DATA&) = default;
    #else
    BISDSP_BIS_B_DETECTION_FM_DATA(BISDSP_BIS_B_DETECTION_FM_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_B_DETECTION_FM_DATA& operator=(BISDSP_BIS_B_DETECTION_FM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint32_t& usSubFrameNo() OMG_NOEXCEPT {
        return m_usSubFrameNo_;
    }

    const uint32_t& usSubFrameNo() const OMG_NOEXCEPT {
        return m_usSubFrameNo_;
    }

    void usSubFrameNo(uint32_t value) {
        m_usSubFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBFWindowType() OMG_NOEXCEPT {
        return m_usBFWindowType_;
    }

    const uint16_t& usBFWindowType() const OMG_NOEXCEPT {
        return m_usBFWindowType_;
    }

    void usBFWindowType(uint16_t value) {
        m_usBFWindowType_ = value;
    }

    uint16_t& usTxSourceTargetNo() OMG_NOEXCEPT {
        return m_usTxSourceTargetNo_;
    }

    const uint16_t& usTxSourceTargetNo() const OMG_NOEXCEPT {
        return m_usTxSourceTargetNo_;
    }

    void usTxSourceTargetNo(uint16_t value) {
        m_usTxSourceTargetNo_ = value;
    }

    uint16_t& usPulseID() OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    const uint16_t& usPulseID() const OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    void usPulseID(uint16_t value) {
        m_usPulseID_ = value;
    }

    ST_DATE_TIME& stCommTime() OMG_NOEXCEPT {
        return m_stCommTime_;
    }

    const ST_DATE_TIME& stCommTime() const OMG_NOEXCEPT {
        return m_stCommTime_;
    }

    void stCommTime(const ST_DATE_TIME& value) {
        m_stCommTime_ = value;
    }

    void stCommTime(ST_DATE_TIME&& value) {
        m_stCommTime_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& reserved1() OMG_NOEXCEPT {
        return m_reserved1_;
    }

    const uint16_t& reserved1() const OMG_NOEXCEPT {
        return m_reserved1_;
    }

    void reserved1(uint16_t value) {
        m_reserved1_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw() OMG_NOEXCEPT {
        return m_aFMDetInfoRaw_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw() const OMG_NOEXCEPT {
        return m_aFMDetInfoRaw_;
    }

    void aFMDetInfoRaw(const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& value) {
        m_aFMDetInfoRaw_ = value;
    }

    void aFMDetInfoRaw(::dds::core::array< ::dds::core::array< float, 256L>, 129L>&& value) {
        m_aFMDetInfoRaw_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize() OMG_NOEXCEPT {
        return m_aFMDetInfoNormalize_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize() const OMG_NOEXCEPT {
        return m_aFMDetInfoNormalize_;
    }

    void aFMDetInfoNormalize(const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& value) {
        m_aFMDetInfoNormalize_ = value;
    }

    void aFMDetInfoNormalize(::dds::core::array< ::dds::core::array< float, 256L>, 129L>&& value) {
        m_aFMDetInfoNormalize_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo() OMG_NOEXCEPT {
        return m_aFMDetInfoRangeInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo() const OMG_NOEXCEPT {
        return m_aFMDetInfoRangeInfo_;
    }

    void aFMDetInfoRangeInfo(const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& value) {
        m_aFMDetInfoRangeInfo_ = value;
    }

    void aFMDetInfoRangeInfo(::dds::core::array< ::dds::core::array< float, 256L>, 256L>&& value) {
        m_aFMDetInfoRangeInfo_ = std::move(value);
    }
    bool& bFMDrcPulseOnOff() OMG_NOEXCEPT {
        return m_bFMDrcPulseOnOff_;
    }

    const bool& bFMDrcPulseOnOff() const OMG_NOEXCEPT {
        return m_bFMDrcPulseOnOff_;
    }

    void bFMDrcPulseOnOff(bool value) {
        m_bFMDrcPulseOnOff_ = value;
    }

    float& fPRIFM() OMG_NOEXCEPT {
        return m_fPRIFM_;
    }

    const float& fPRIFM() const OMG_NOEXCEPT {
        return m_fPRIFM_;
    }

    void fPRIFM(float value) {
        m_fPRIFM_ = value;
    }

    uint16_t& usUsing3AxisDPDInfoFlag() OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    const uint16_t& usUsing3AxisDPDInfoFlag() const OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    void usUsing3AxisDPDInfoFlag(uint16_t value) {
        m_usUsing3AxisDPDInfoFlag_ = value;
    }

    uint16_t& unPRISubFrameNoFM() OMG_NOEXCEPT {
        return m_unPRISubFrameNoFM_;
    }

    const uint16_t& unPRISubFrameNoFM() const OMG_NOEXCEPT {
        return m_unPRISubFrameNoFM_;
    }

    void unPRISubFrameNoFM(uint16_t value) {
        m_unPRISubFrameNoFM_ = value;
    }

    uint16_t& unPingNoFM() OMG_NOEXCEPT {
        return m_unPingNoFM_;
    }

    const uint16_t& unPingNoFM() const OMG_NOEXCEPT {
        return m_unPingNoFM_;
    }

    void unPingNoFM(uint16_t value) {
        m_unPingNoFM_ = value;
    }

    uint16_t& usDirectPulseFlagFM() OMG_NOEXCEPT {
        return m_usDirectPulseFlagFM_;
    }

    const uint16_t& usDirectPulseFlagFM() const OMG_NOEXCEPT {
        return m_usDirectPulseFlagFM_;
    }

    void usDirectPulseFlagFM(uint16_t value) {
        m_usDirectPulseFlagFM_ = value;
    }

    uint16_t& usDirectPulseIndexFM() OMG_NOEXCEPT {
        return m_usDirectPulseIndexFM_;
    }

    const uint16_t& usDirectPulseIndexFM() const OMG_NOEXCEPT {
        return m_usDirectPulseIndexFM_;
    }

    void usDirectPulseIndexFM(uint16_t value) {
        m_usDirectPulseIndexFM_ = value;
    }

    float& fSoundVel() OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    const float& fSoundVel() const OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    void fSoundVel(float value) {
        m_fSoundVel_ = value;
    }

    float& fSourceToSensorDist() OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    const float& fSourceToSensorDist() const OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    void fSourceToSensorDist(float value) {
        m_fSourceToSensorDist_ = value;
    }

    float& fSourceToSensorBear() OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    const float& fSourceToSensorBear() const OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    void fSourceToSensorBear(float value) {
        m_fSourceToSensorBear_ = value;
    }

    uint16_t& usDirExistTDFlag() OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    const uint16_t& usDirExistTDFlag() const OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    void usDirExistTDFlag(uint16_t value) {
        m_usDirExistTDFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    void usDirExistTDSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistTDSamIdx_ = value;
    }

    void usDirExistTDSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistTDSamIdx_ = std::move(value);
    }
    uint16_t& usDirExistAudioFlag() OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    const uint16_t& usDirExistAudioFlag() const OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    void usDirExistAudioFlag(uint16_t value) {
        m_usDirExistAudioFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    void usDirExistAudioSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistAudioSamIdx_ = value;
    }

    void usDirExistAudioSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistAudioSamIdx_ = std::move(value);
    }
    uint16_t& reserved2() OMG_NOEXCEPT {
        return m_reserved2_;
    }

    const uint16_t& reserved2() const OMG_NOEXCEPT {
        return m_reserved2_;
    }

    void reserved2(uint16_t value) {
        m_reserved2_ = value;
    }

    bool operator == (const BISDSP_BIS_B_DETECTION_FM_DATA& other_) const;
    bool operator != (const BISDSP_BIS_B_DETECTION_FM_DATA& other_) const;

    void swap(BISDSP_BIS_B_DETECTION_FM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint32_t m_ulFrameNo_;
    uint32_t m_usSubFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBFWindowType_;
    uint16_t m_usTxSourceTargetNo_;
    uint16_t m_usPulseID_;
    ST_DATE_TIME m_stCommTime_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_reserved1_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L> m_aFMDetInfoRaw_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L> m_aFMDetInfoNormalize_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 256L> m_aFMDetInfoRangeInfo_;
    bool m_bFMDrcPulseOnOff_;
    float m_fPRIFM_;
    uint16_t m_usUsing3AxisDPDInfoFlag_;
    uint16_t m_unPRISubFrameNoFM_;
    uint16_t m_unPingNoFM_;
    uint16_t m_usDirectPulseFlagFM_;
    uint16_t m_usDirectPulseIndexFM_;
    float m_fSoundVel_;
    float m_fSourceToSensorDist_;
    float m_fSourceToSensorBear_;
    uint16_t m_usDirExistTDFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistTDSamIdx_;
    uint16_t m_usDirExistAudioFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistAudioSamIdx_;
    uint16_t m_reserved2_;

};

inline void swap(BISDSP_BIS_B_DETECTION_FM_DATA& a, BISDSP_BIS_B_DETECTION_FM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_B_DETECTION_FM_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_B_ENE_DATA {
  public:
    BISDSP_BIS_B_ENE_DATA();

    BISDSP_BIS_B_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint32_t ulFrameNo,const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_B_ENE_DATA (BISDSP_BIS_B_ENE_DATA&&) = default;
    BISDSP_BIS_B_ENE_DATA& operator=(BISDSP_BIS_B_ENE_DATA&&) = default;
    BISDSP_BIS_B_ENE_DATA& operator=(const BISDSP_BIS_B_ENE_DATA&) = default;
    BISDSP_BIS_B_ENE_DATA(const BISDSP_BIS_B_ENE_DATA&) = default;
    #else
    BISDSP_BIS_B_ENE_DATA(BISDSP_BIS_B_ENE_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_B_ENE_DATA& operator=(BISDSP_BIS_B_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo() OMG_NOEXCEPT {
        return m_aENEInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo() const OMG_NOEXCEPT {
        return m_aENEInfo_;
    }

    void aENEInfo(const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& value) {
        m_aENEInfo_ = value;
    }

    void aENEInfo(::dds::core::array< ::dds::core::array< float, 7L>, 256L>&& value) {
        m_aENEInfo_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_B_ENE_DATA& other_) const;
    bool operator != (const BISDSP_BIS_B_ENE_DATA& other_) const;

    void swap(BISDSP_BIS_B_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint32_t m_ulFrameNo_;
    ::dds::core::array< ::dds::core::array< float, 7L>, 256L> m_aENEInfo_;

};

inline void swap(BISDSP_BIS_B_ENE_DATA& a, BISDSP_BIS_B_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_B_ENE_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO {
  public:
    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO();

    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,const ::dds::core::array< uint16_t, 2L>& unDetBeamNo,const ST_DATE_TIME& stDetectionStartTime,const ST_DATE_TIME& stDetectionEndTime,uint16_t Reserved,uint16_t usStftResType,const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut,const ::dds::core::array< float, 2L>& fFC,const ::dds::core::array< float, 2L>& fBW,const ::dds::core::array< float, 2L>& fPL,uint16_t unPulseType,uint16_t usAPDInfoChgFlag,const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID,const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore,const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision,const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO (BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO&&) = default;
    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& operator=(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO&&) = default;
    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& operator=(const BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO&) = default;
    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO(const BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO&) = default;
    #else
    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& operator=(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& unDetBeamNo() OMG_NOEXCEPT {
        return m_unDetBeamNo_;
    }

    const ::dds::core::array< uint16_t, 2L>& unDetBeamNo() const OMG_NOEXCEPT {
        return m_unDetBeamNo_;
    }

    void unDetBeamNo(const ::dds::core::array< uint16_t, 2L>& value) {
        m_unDetBeamNo_ = value;
    }

    void unDetBeamNo(::dds::core::array< uint16_t, 2L>&& value) {
        m_unDetBeamNo_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionStartTime() OMG_NOEXCEPT {
        return m_stDetectionStartTime_;
    }

    const ST_DATE_TIME& stDetectionStartTime() const OMG_NOEXCEPT {
        return m_stDetectionStartTime_;
    }

    void stDetectionStartTime(const ST_DATE_TIME& value) {
        m_stDetectionStartTime_ = value;
    }

    void stDetectionStartTime(ST_DATE_TIME&& value) {
        m_stDetectionStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionEndTime() OMG_NOEXCEPT {
        return m_stDetectionEndTime_;
    }

    const ST_DATE_TIME& stDetectionEndTime() const OMG_NOEXCEPT {
        return m_stDetectionEndTime_;
    }

    void stDetectionEndTime(const ST_DATE_TIME& value) {
        m_stDetectionEndTime_ = value;
    }

    void stDetectionEndTime(ST_DATE_TIME&& value) {
        m_stDetectionEndTime_ = std::move(value);
    }
    uint16_t& Reserved() OMG_NOEXCEPT {
        return m_Reserved_;
    }

    const uint16_t& Reserved() const OMG_NOEXCEPT {
        return m_Reserved_;
    }

    void Reserved(uint16_t value) {
        m_Reserved_ = value;
    }

    uint16_t& usStftResType() OMG_NOEXCEPT {
        return m_usStftResType_;
    }

    const uint16_t& usStftResType() const OMG_NOEXCEPT {
        return m_usStftResType_;
    }

    void usStftResType(uint16_t value) {
        m_usStftResType_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut() OMG_NOEXCEPT {
        return m_aStftOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& aStftOut() const OMG_NOEXCEPT {
        return m_aStftOut_;
    }

    void aStftOut(const ::dds::core::array< ::dds::core::array< float, 753L>, 640L>& value) {
        m_aStftOut_ = value;
    }

    void aStftOut(::dds::core::array< ::dds::core::array< float, 753L>, 640L>&& value) {
        m_aStftOut_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fFC() OMG_NOEXCEPT {
        return m_fFC_;
    }

    const ::dds::core::array< float, 2L>& fFC() const OMG_NOEXCEPT {
        return m_fFC_;
    }

    void fFC(const ::dds::core::array< float, 2L>& value) {
        m_fFC_ = value;
    }

    void fFC(::dds::core::array< float, 2L>&& value) {
        m_fFC_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fBW() OMG_NOEXCEPT {
        return m_fBW_;
    }

    const ::dds::core::array< float, 2L>& fBW() const OMG_NOEXCEPT {
        return m_fBW_;
    }

    void fBW(const ::dds::core::array< float, 2L>& value) {
        m_fBW_ = value;
    }

    void fBW(::dds::core::array< float, 2L>&& value) {
        m_fBW_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fPL() OMG_NOEXCEPT {
        return m_fPL_;
    }

    const ::dds::core::array< float, 2L>& fPL() const OMG_NOEXCEPT {
        return m_fPL_;
    }

    void fPL(const ::dds::core::array< float, 2L>& value) {
        m_fPL_ = value;
    }

    void fPL(::dds::core::array< float, 2L>&& value) {
        m_fPL_ = std::move(value);
    }
    uint16_t& unPulseType() OMG_NOEXCEPT {
        return m_unPulseType_;
    }

    const uint16_t& unPulseType() const OMG_NOEXCEPT {
        return m_unPulseType_;
    }

    void unPulseType(uint16_t value) {
        m_unPulseType_ = value;
    }

    uint16_t& usAPDInfoChgFlag() OMG_NOEXCEPT {
        return m_usAPDInfoChgFlag_;
    }

    const uint16_t& usAPDInfoChgFlag() const OMG_NOEXCEPT {
        return m_usAPDInfoChgFlag_;
    }

    void usAPDInfoChgFlag(uint16_t value) {
        m_usAPDInfoChgFlag_ = value;
    }

    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID() OMG_NOEXCEPT {
        return m_aDBMatchingID_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aDBMatchingID() const OMG_NOEXCEPT {
        return m_aDBMatchingID_;
    }

    void aDBMatchingID(const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& value) {
        m_aDBMatchingID_ = value;
    }

    void aDBMatchingID(::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>&& value) {
        m_aDBMatchingID_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore() OMG_NOEXCEPT {
        return m_aDBMatchingScore_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aDBMatchingScore() const OMG_NOEXCEPT {
        return m_aDBMatchingScore_;
    }

    void aDBMatchingScore(const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& value) {
        m_aDBMatchingScore_ = value;
    }

    void aDBMatchingScore(::dds::core::array< ::dds::core::array< float, 2L>, 10L>&& value) {
        m_aDBMatchingScore_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision() OMG_NOEXCEPT {
        return m_aActivePulseDecision_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& aActivePulseDecision() const OMG_NOEXCEPT {
        return m_aActivePulseDecision_;
    }

    void aActivePulseDecision(const ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>& value) {
        m_aActivePulseDecision_ = value;
    }

    void aActivePulseDecision(::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L>&& value) {
        m_aActivePulseDecision_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore() OMG_NOEXCEPT {
        return m_aTableResultsScore_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& aTableResultsScore() const OMG_NOEXCEPT {
        return m_aTableResultsScore_;
    }

    void aTableResultsScore(const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& value) {
        m_aTableResultsScore_ = value;
    }

    void aTableResultsScore(::dds::core::array< ::dds::core::array< float, 2L>, 10L>&& value) {
        m_aTableResultsScore_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable() OMG_NOEXCEPT {
        return m_aDBtable_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& aDBtable() const OMG_NOEXCEPT {
        return m_aDBtable_;
    }

    void aDBtable(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>& value) {
        m_aDBtable_ = value;
    }

    void aDBtable(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L>&& value) {
        m_aDBtable_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& other_) const;
    bool operator != (const BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& other_) const;

    void swap(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    ::dds::core::array< uint16_t, 2L> m_unDetBeamNo_;
    ST_DATE_TIME m_stDetectionStartTime_;
    ST_DATE_TIME m_stDetectionEndTime_;
    uint16_t m_Reserved_;
    uint16_t m_usStftResType_;
    ::dds::core::array< ::dds::core::array< float, 753L>, 640L> m_aStftOut_;
    ::dds::core::array< float, 2L> m_fFC_;
    ::dds::core::array< float, 2L> m_fBW_;
    ::dds::core::array< float, 2L> m_fPL_;
    uint16_t m_unPulseType_;
    uint16_t m_usAPDInfoChgFlag_;
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L> m_aDBMatchingID_;
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L> m_aDBMatchingScore_;
    ::dds::core::array< ::dds::core::array< int32_t, 2L>, 10L> m_aActivePulseDecision_;
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L> m_aTableResultsScore_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 3L>, 2L>, 10L> m_aDBtable_;

};

inline void swap(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& a, BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& sample);

class NDDSUSERDllExport BISDSP_BIS_C_AGC_CTRL_INFO {
  public:
    BISDSP_BIS_C_AGC_CTRL_INFO();

    BISDSP_BIS_C_AGC_CTRL_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t unAutoGainCntrlVal,const ::dds::core::array< float, 148L>& aSensorEnergy,float fTotalEnergy);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_C_AGC_CTRL_INFO (BISDSP_BIS_C_AGC_CTRL_INFO&&) = default;
    BISDSP_BIS_C_AGC_CTRL_INFO& operator=(BISDSP_BIS_C_AGC_CTRL_INFO&&) = default;
    BISDSP_BIS_C_AGC_CTRL_INFO& operator=(const BISDSP_BIS_C_AGC_CTRL_INFO&) = default;
    BISDSP_BIS_C_AGC_CTRL_INFO(const BISDSP_BIS_C_AGC_CTRL_INFO&) = default;
    #else
    BISDSP_BIS_C_AGC_CTRL_INFO(BISDSP_BIS_C_AGC_CTRL_INFO&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_C_AGC_CTRL_INFO& operator=(BISDSP_BIS_C_AGC_CTRL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& unAutoGainCntrlVal() OMG_NOEXCEPT {
        return m_unAutoGainCntrlVal_;
    }

    const uint16_t& unAutoGainCntrlVal() const OMG_NOEXCEPT {
        return m_unAutoGainCntrlVal_;
    }

    void unAutoGainCntrlVal(uint16_t value) {
        m_unAutoGainCntrlVal_ = value;
    }

    ::dds::core::array< float, 148L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 148L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 148L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 148L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    bool operator == (const BISDSP_BIS_C_AGC_CTRL_INFO& other_) const;
    bool operator != (const BISDSP_BIS_C_AGC_CTRL_INFO& other_) const;

    void swap(BISDSP_BIS_C_AGC_CTRL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_unAutoGainCntrlVal_;
    ::dds::core::array< float, 148L> m_aSensorEnergy_;
    float m_fTotalEnergy_;

};

inline void swap(BISDSP_BIS_C_AGC_CTRL_INFO& a, BISDSP_BIS_C_AGC_CTRL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_C_AGC_CTRL_INFO& sample);

class NDDSUSERDllExport BISDSP_BIS_C_BEAM_DATA {
  public:
    BISDSP_BIS_C_BEAM_DATA();

    BISDSP_BIS_C_BEAM_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint32_t unSubFrameNo,uint16_t usAxisId,const ST_DATE_TIME& stAcqusitionTime,uint16_t oReserved,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_C_BEAM_DATA (BISDSP_BIS_C_BEAM_DATA&&) = default;
    BISDSP_BIS_C_BEAM_DATA& operator=(BISDSP_BIS_C_BEAM_DATA&&) = default;
    BISDSP_BIS_C_BEAM_DATA& operator=(const BISDSP_BIS_C_BEAM_DATA&) = default;
    BISDSP_BIS_C_BEAM_DATA(const BISDSP_BIS_C_BEAM_DATA&) = default;
    #else
    BISDSP_BIS_C_BEAM_DATA(BISDSP_BIS_C_BEAM_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_C_BEAM_DATA& operator=(BISDSP_BIS_C_BEAM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint32_t& unSubFrameNo() OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    const uint32_t& unSubFrameNo() const OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    void unSubFrameNo(uint32_t value) {
        m_unSubFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& oReserved() OMG_NOEXCEPT {
        return m_oReserved_;
    }

    const uint16_t& oReserved() const OMG_NOEXCEPT {
        return m_oReserved_;
    }

    void oReserved(uint16_t value) {
        m_oReserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData() OMG_NOEXCEPT {
        return m_aBISBeamData_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& aBISBeamData() const OMG_NOEXCEPT {
        return m_aBISBeamData_;
    }

    void aBISBeamData(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>& value) {
        m_aBISBeamData_ = value;
    }

    void aBISBeamData(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L>&& value) {
        m_aBISBeamData_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_C_BEAM_DATA& other_) const;
    bool operator != (const BISDSP_BIS_C_BEAM_DATA& other_) const;

    void swap(BISDSP_BIS_C_BEAM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint32_t m_unSubFrameNo_;
    uint16_t m_usAxisId_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_oReserved_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8192L>, 129L>, 2L> m_aBISBeamData_;

};

inline void swap(BISDSP_BIS_C_BEAM_DATA& a, BISDSP_BIS_C_BEAM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_C_BEAM_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_C_DETECTION_CW_DATA {
  public:
    BISDSP_BIS_C_DETECTION_CW_DATA();

    BISDSP_BIS_C_DETECTION_CW_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint32_t ulFramNo,uint32_t unSubFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usReserved,uint16_t unSensorGain,uint16_t unBFWindowType,uint16_t unTxSourceTargetNo,uint16_t unPulseID,uint32_t ulRemoveClutter,float fMinDopplerSpeed,uint32_t reserved3,uint32_t reserved4,const ST_DATE_TIME& stDetectionTime,uint16_t reserved1,const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw,const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize,const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo,const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo,bool bCWDrcPulseOnOff,float fPRICW,uint16_t usUsing3AxisDPDInfoFlag,uint16_t unPRISubFrameNoCW,uint16_t unPingNoCW,uint16_t usDirectPulseFlagCW,uint16_t usDirectPulseIndexCW,float fSoundVel,float fSourceToSensorDist,float fSourceToSensorBear,uint16_t usDirExistTDFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx,uint16_t usDirExistAudioFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx,uint16_t reserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_C_DETECTION_CW_DATA (BISDSP_BIS_C_DETECTION_CW_DATA&&) = default;
    BISDSP_BIS_C_DETECTION_CW_DATA& operator=(BISDSP_BIS_C_DETECTION_CW_DATA&&) = default;
    BISDSP_BIS_C_DETECTION_CW_DATA& operator=(const BISDSP_BIS_C_DETECTION_CW_DATA&) = default;
    BISDSP_BIS_C_DETECTION_CW_DATA(const BISDSP_BIS_C_DETECTION_CW_DATA&) = default;
    #else
    BISDSP_BIS_C_DETECTION_CW_DATA(BISDSP_BIS_C_DETECTION_CW_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_C_DETECTION_CW_DATA& operator=(BISDSP_BIS_C_DETECTION_CW_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint32_t& ulFramNo() OMG_NOEXCEPT {
        return m_ulFramNo_;
    }

    const uint32_t& ulFramNo() const OMG_NOEXCEPT {
        return m_ulFramNo_;
    }

    void ulFramNo(uint32_t value) {
        m_ulFramNo_ = value;
    }

    uint32_t& unSubFrameNo() OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    const uint32_t& unSubFrameNo() const OMG_NOEXCEPT {
        return m_unSubFrameNo_;
    }

    void unSubFrameNo(uint32_t value) {
        m_unSubFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& unSensorGain() OMG_NOEXCEPT {
        return m_unSensorGain_;
    }

    const uint16_t& unSensorGain() const OMG_NOEXCEPT {
        return m_unSensorGain_;
    }

    void unSensorGain(uint16_t value) {
        m_unSensorGain_ = value;
    }

    uint16_t& unBFWindowType() OMG_NOEXCEPT {
        return m_unBFWindowType_;
    }

    const uint16_t& unBFWindowType() const OMG_NOEXCEPT {
        return m_unBFWindowType_;
    }

    void unBFWindowType(uint16_t value) {
        m_unBFWindowType_ = value;
    }

    uint16_t& unTxSourceTargetNo() OMG_NOEXCEPT {
        return m_unTxSourceTargetNo_;
    }

    const uint16_t& unTxSourceTargetNo() const OMG_NOEXCEPT {
        return m_unTxSourceTargetNo_;
    }

    void unTxSourceTargetNo(uint16_t value) {
        m_unTxSourceTargetNo_ = value;
    }

    uint16_t& unPulseID() OMG_NOEXCEPT {
        return m_unPulseID_;
    }

    const uint16_t& unPulseID() const OMG_NOEXCEPT {
        return m_unPulseID_;
    }

    void unPulseID(uint16_t value) {
        m_unPulseID_ = value;
    }

    uint32_t& ulRemoveClutter() OMG_NOEXCEPT {
        return m_ulRemoveClutter_;
    }

    const uint32_t& ulRemoveClutter() const OMG_NOEXCEPT {
        return m_ulRemoveClutter_;
    }

    void ulRemoveClutter(uint32_t value) {
        m_ulRemoveClutter_ = value;
    }

    float& fMinDopplerSpeed() OMG_NOEXCEPT {
        return m_fMinDopplerSpeed_;
    }

    const float& fMinDopplerSpeed() const OMG_NOEXCEPT {
        return m_fMinDopplerSpeed_;
    }

    void fMinDopplerSpeed(float value) {
        m_fMinDopplerSpeed_ = value;
    }

    uint32_t& reserved3() OMG_NOEXCEPT {
        return m_reserved3_;
    }

    const uint32_t& reserved3() const OMG_NOEXCEPT {
        return m_reserved3_;
    }

    void reserved3(uint32_t value) {
        m_reserved3_ = value;
    }

    uint32_t& reserved4() OMG_NOEXCEPT {
        return m_reserved4_;
    }

    const uint32_t& reserved4() const OMG_NOEXCEPT {
        return m_reserved4_;
    }

    void reserved4(uint32_t value) {
        m_reserved4_ = value;
    }

    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& reserved1() OMG_NOEXCEPT {
        return m_reserved1_;
    }

    const uint16_t& reserved1() const OMG_NOEXCEPT {
        return m_reserved1_;
    }

    void reserved1(uint16_t value) {
        m_reserved1_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw() OMG_NOEXCEPT {
        return m_aCWDetInfoRaw_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoRaw() const OMG_NOEXCEPT {
        return m_aCWDetInfoRaw_;
    }

    void aCWDetInfoRaw(const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& value) {
        m_aCWDetInfoRaw_ = value;
    }

    void aCWDetInfoRaw(::dds::core::array< ::dds::core::array< float, 64L>, 129L>&& value) {
        m_aCWDetInfoRaw_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize() OMG_NOEXCEPT {
        return m_aCWDetInfoNormalize_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& aCWDetInfoNormalize() const OMG_NOEXCEPT {
        return m_aCWDetInfoNormalize_;
    }

    void aCWDetInfoNormalize(const ::dds::core::array< ::dds::core::array< float, 64L>, 129L>& value) {
        m_aCWDetInfoNormalize_ = value;
    }

    void aCWDetInfoNormalize(::dds::core::array< ::dds::core::array< float, 64L>, 129L>&& value) {
        m_aCWDetInfoNormalize_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo() OMG_NOEXCEPT {
        return m_aCWDetInfoRangeInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoRangeInfo() const OMG_NOEXCEPT {
        return m_aCWDetInfoRangeInfo_;
    }

    void aCWDetInfoRangeInfo(const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& value) {
        m_aCWDetInfoRangeInfo_ = value;
    }

    void aCWDetInfoRangeInfo(::dds::core::array< ::dds::core::array< float, 64L>, 256L>&& value) {
        m_aCWDetInfoRangeInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo() OMG_NOEXCEPT {
        return m_aCWDetInfoDopplerInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& aCWDetInfoDopplerInfo() const OMG_NOEXCEPT {
        return m_aCWDetInfoDopplerInfo_;
    }

    void aCWDetInfoDopplerInfo(const ::dds::core::array< ::dds::core::array< float, 64L>, 256L>& value) {
        m_aCWDetInfoDopplerInfo_ = value;
    }

    void aCWDetInfoDopplerInfo(::dds::core::array< ::dds::core::array< float, 64L>, 256L>&& value) {
        m_aCWDetInfoDopplerInfo_ = std::move(value);
    }
    bool& bCWDrcPulseOnOff() OMG_NOEXCEPT {
        return m_bCWDrcPulseOnOff_;
    }

    const bool& bCWDrcPulseOnOff() const OMG_NOEXCEPT {
        return m_bCWDrcPulseOnOff_;
    }

    void bCWDrcPulseOnOff(bool value) {
        m_bCWDrcPulseOnOff_ = value;
    }

    float& fPRICW() OMG_NOEXCEPT {
        return m_fPRICW_;
    }

    const float& fPRICW() const OMG_NOEXCEPT {
        return m_fPRICW_;
    }

    void fPRICW(float value) {
        m_fPRICW_ = value;
    }

    uint16_t& usUsing3AxisDPDInfoFlag() OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    const uint16_t& usUsing3AxisDPDInfoFlag() const OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    void usUsing3AxisDPDInfoFlag(uint16_t value) {
        m_usUsing3AxisDPDInfoFlag_ = value;
    }

    uint16_t& unPRISubFrameNoCW() OMG_NOEXCEPT {
        return m_unPRISubFrameNoCW_;
    }

    const uint16_t& unPRISubFrameNoCW() const OMG_NOEXCEPT {
        return m_unPRISubFrameNoCW_;
    }

    void unPRISubFrameNoCW(uint16_t value) {
        m_unPRISubFrameNoCW_ = value;
    }

    uint16_t& unPingNoCW() OMG_NOEXCEPT {
        return m_unPingNoCW_;
    }

    const uint16_t& unPingNoCW() const OMG_NOEXCEPT {
        return m_unPingNoCW_;
    }

    void unPingNoCW(uint16_t value) {
        m_unPingNoCW_ = value;
    }

    uint16_t& usDirectPulseFlagCW() OMG_NOEXCEPT {
        return m_usDirectPulseFlagCW_;
    }

    const uint16_t& usDirectPulseFlagCW() const OMG_NOEXCEPT {
        return m_usDirectPulseFlagCW_;
    }

    void usDirectPulseFlagCW(uint16_t value) {
        m_usDirectPulseFlagCW_ = value;
    }

    uint16_t& usDirectPulseIndexCW() OMG_NOEXCEPT {
        return m_usDirectPulseIndexCW_;
    }

    const uint16_t& usDirectPulseIndexCW() const OMG_NOEXCEPT {
        return m_usDirectPulseIndexCW_;
    }

    void usDirectPulseIndexCW(uint16_t value) {
        m_usDirectPulseIndexCW_ = value;
    }

    float& fSoundVel() OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    const float& fSoundVel() const OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    void fSoundVel(float value) {
        m_fSoundVel_ = value;
    }

    float& fSourceToSensorDist() OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    const float& fSourceToSensorDist() const OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    void fSourceToSensorDist(float value) {
        m_fSourceToSensorDist_ = value;
    }

    float& fSourceToSensorBear() OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    const float& fSourceToSensorBear() const OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    void fSourceToSensorBear(float value) {
        m_fSourceToSensorBear_ = value;
    }

    uint16_t& usDirExistTDFlag() OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    const uint16_t& usDirExistTDFlag() const OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    void usDirExistTDFlag(uint16_t value) {
        m_usDirExistTDFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    void usDirExistTDSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistTDSamIdx_ = value;
    }

    void usDirExistTDSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistTDSamIdx_ = std::move(value);
    }
    uint16_t& usDirExistAudioFlag() OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    const uint16_t& usDirExistAudioFlag() const OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    void usDirExistAudioFlag(uint16_t value) {
        m_usDirExistAudioFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    void usDirExistAudioSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistAudioSamIdx_ = value;
    }

    void usDirExistAudioSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistAudioSamIdx_ = std::move(value);
    }
    uint16_t& reserved2() OMG_NOEXCEPT {
        return m_reserved2_;
    }

    const uint16_t& reserved2() const OMG_NOEXCEPT {
        return m_reserved2_;
    }

    void reserved2(uint16_t value) {
        m_reserved2_ = value;
    }

    bool operator == (const BISDSP_BIS_C_DETECTION_CW_DATA& other_) const;
    bool operator != (const BISDSP_BIS_C_DETECTION_CW_DATA& other_) const;

    void swap(BISDSP_BIS_C_DETECTION_CW_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint32_t m_ulFramNo_;
    uint32_t m_unSubFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usReserved_;
    uint16_t m_unSensorGain_;
    uint16_t m_unBFWindowType_;
    uint16_t m_unTxSourceTargetNo_;
    uint16_t m_unPulseID_;
    uint32_t m_ulRemoveClutter_;
    float m_fMinDopplerSpeed_;
    uint32_t m_reserved3_;
    uint32_t m_reserved4_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_reserved1_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L> m_aCWDetInfoRaw_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 129L> m_aCWDetInfoNormalize_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L> m_aCWDetInfoRangeInfo_;
    ::dds::core::array< ::dds::core::array< float, 64L>, 256L> m_aCWDetInfoDopplerInfo_;
    bool m_bCWDrcPulseOnOff_;
    float m_fPRICW_;
    uint16_t m_usUsing3AxisDPDInfoFlag_;
    uint16_t m_unPRISubFrameNoCW_;
    uint16_t m_unPingNoCW_;
    uint16_t m_usDirectPulseFlagCW_;
    uint16_t m_usDirectPulseIndexCW_;
    float m_fSoundVel_;
    float m_fSourceToSensorDist_;
    float m_fSourceToSensorBear_;
    uint16_t m_usDirExistTDFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistTDSamIdx_;
    uint16_t m_usDirExistAudioFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistAudioSamIdx_;
    uint16_t m_reserved2_;

};

inline void swap(BISDSP_BIS_C_DETECTION_CW_DATA& a, BISDSP_BIS_C_DETECTION_CW_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_C_DETECTION_CW_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_C_DETECTION_FM_DATA {
  public:
    BISDSP_BIS_C_DETECTION_FM_DATA();

    BISDSP_BIS_C_DETECTION_FM_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint32_t ulFrameNo,uint32_t usSubFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBFWindowType,uint16_t usTxSourceTargetNo,uint16_t usPulseID,const ST_DATE_TIME& stCommTime,const ST_DATE_TIME& stDetectionTime,uint16_t reserved1,const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw,const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize,const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo,bool bFMDrcPulseOnOff,float fPRIFM,uint16_t usUsing3AxisDPDInfoFlag,uint16_t unPRISubFrameNoFM,uint16_t unPingNoFM,uint16_t usDirectPulseFlagFM,uint16_t usDirectPulseIndexFM,float fSoundVel,float fSourceToSensorDist,float fSourceToSensorBear,uint16_t usDirExistTDFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx,uint16_t usDirExistAudioFlag,const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx,uint16_t reserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_C_DETECTION_FM_DATA (BISDSP_BIS_C_DETECTION_FM_DATA&&) = default;
    BISDSP_BIS_C_DETECTION_FM_DATA& operator=(BISDSP_BIS_C_DETECTION_FM_DATA&&) = default;
    BISDSP_BIS_C_DETECTION_FM_DATA& operator=(const BISDSP_BIS_C_DETECTION_FM_DATA&) = default;
    BISDSP_BIS_C_DETECTION_FM_DATA(const BISDSP_BIS_C_DETECTION_FM_DATA&) = default;
    #else
    BISDSP_BIS_C_DETECTION_FM_DATA(BISDSP_BIS_C_DETECTION_FM_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_C_DETECTION_FM_DATA& operator=(BISDSP_BIS_C_DETECTION_FM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint32_t& usSubFrameNo() OMG_NOEXCEPT {
        return m_usSubFrameNo_;
    }

    const uint32_t& usSubFrameNo() const OMG_NOEXCEPT {
        return m_usSubFrameNo_;
    }

    void usSubFrameNo(uint32_t value) {
        m_usSubFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBFWindowType() OMG_NOEXCEPT {
        return m_usBFWindowType_;
    }

    const uint16_t& usBFWindowType() const OMG_NOEXCEPT {
        return m_usBFWindowType_;
    }

    void usBFWindowType(uint16_t value) {
        m_usBFWindowType_ = value;
    }

    uint16_t& usTxSourceTargetNo() OMG_NOEXCEPT {
        return m_usTxSourceTargetNo_;
    }

    const uint16_t& usTxSourceTargetNo() const OMG_NOEXCEPT {
        return m_usTxSourceTargetNo_;
    }

    void usTxSourceTargetNo(uint16_t value) {
        m_usTxSourceTargetNo_ = value;
    }

    uint16_t& usPulseID() OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    const uint16_t& usPulseID() const OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    void usPulseID(uint16_t value) {
        m_usPulseID_ = value;
    }

    ST_DATE_TIME& stCommTime() OMG_NOEXCEPT {
        return m_stCommTime_;
    }

    const ST_DATE_TIME& stCommTime() const OMG_NOEXCEPT {
        return m_stCommTime_;
    }

    void stCommTime(const ST_DATE_TIME& value) {
        m_stCommTime_ = value;
    }

    void stCommTime(ST_DATE_TIME&& value) {
        m_stCommTime_ = std::move(value);
    }
    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& reserved1() OMG_NOEXCEPT {
        return m_reserved1_;
    }

    const uint16_t& reserved1() const OMG_NOEXCEPT {
        return m_reserved1_;
    }

    void reserved1(uint16_t value) {
        m_reserved1_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw() OMG_NOEXCEPT {
        return m_aFMDetInfoRaw_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoRaw() const OMG_NOEXCEPT {
        return m_aFMDetInfoRaw_;
    }

    void aFMDetInfoRaw(const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& value) {
        m_aFMDetInfoRaw_ = value;
    }

    void aFMDetInfoRaw(::dds::core::array< ::dds::core::array< float, 256L>, 129L>&& value) {
        m_aFMDetInfoRaw_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize() OMG_NOEXCEPT {
        return m_aFMDetInfoNormalize_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& aFMDetInfoNormalize() const OMG_NOEXCEPT {
        return m_aFMDetInfoNormalize_;
    }

    void aFMDetInfoNormalize(const ::dds::core::array< ::dds::core::array< float, 256L>, 129L>& value) {
        m_aFMDetInfoNormalize_ = value;
    }

    void aFMDetInfoNormalize(::dds::core::array< ::dds::core::array< float, 256L>, 129L>&& value) {
        m_aFMDetInfoNormalize_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo() OMG_NOEXCEPT {
        return m_aFMDetInfoRangeInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& aFMDetInfoRangeInfo() const OMG_NOEXCEPT {
        return m_aFMDetInfoRangeInfo_;
    }

    void aFMDetInfoRangeInfo(const ::dds::core::array< ::dds::core::array< float, 256L>, 256L>& value) {
        m_aFMDetInfoRangeInfo_ = value;
    }

    void aFMDetInfoRangeInfo(::dds::core::array< ::dds::core::array< float, 256L>, 256L>&& value) {
        m_aFMDetInfoRangeInfo_ = std::move(value);
    }
    bool& bFMDrcPulseOnOff() OMG_NOEXCEPT {
        return m_bFMDrcPulseOnOff_;
    }

    const bool& bFMDrcPulseOnOff() const OMG_NOEXCEPT {
        return m_bFMDrcPulseOnOff_;
    }

    void bFMDrcPulseOnOff(bool value) {
        m_bFMDrcPulseOnOff_ = value;
    }

    float& fPRIFM() OMG_NOEXCEPT {
        return m_fPRIFM_;
    }

    const float& fPRIFM() const OMG_NOEXCEPT {
        return m_fPRIFM_;
    }

    void fPRIFM(float value) {
        m_fPRIFM_ = value;
    }

    uint16_t& usUsing3AxisDPDInfoFlag() OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    const uint16_t& usUsing3AxisDPDInfoFlag() const OMG_NOEXCEPT {
        return m_usUsing3AxisDPDInfoFlag_;
    }

    void usUsing3AxisDPDInfoFlag(uint16_t value) {
        m_usUsing3AxisDPDInfoFlag_ = value;
    }

    uint16_t& unPRISubFrameNoFM() OMG_NOEXCEPT {
        return m_unPRISubFrameNoFM_;
    }

    const uint16_t& unPRISubFrameNoFM() const OMG_NOEXCEPT {
        return m_unPRISubFrameNoFM_;
    }

    void unPRISubFrameNoFM(uint16_t value) {
        m_unPRISubFrameNoFM_ = value;
    }

    uint16_t& unPingNoFM() OMG_NOEXCEPT {
        return m_unPingNoFM_;
    }

    const uint16_t& unPingNoFM() const OMG_NOEXCEPT {
        return m_unPingNoFM_;
    }

    void unPingNoFM(uint16_t value) {
        m_unPingNoFM_ = value;
    }

    uint16_t& usDirectPulseFlagFM() OMG_NOEXCEPT {
        return m_usDirectPulseFlagFM_;
    }

    const uint16_t& usDirectPulseFlagFM() const OMG_NOEXCEPT {
        return m_usDirectPulseFlagFM_;
    }

    void usDirectPulseFlagFM(uint16_t value) {
        m_usDirectPulseFlagFM_ = value;
    }

    uint16_t& usDirectPulseIndexFM() OMG_NOEXCEPT {
        return m_usDirectPulseIndexFM_;
    }

    const uint16_t& usDirectPulseIndexFM() const OMG_NOEXCEPT {
        return m_usDirectPulseIndexFM_;
    }

    void usDirectPulseIndexFM(uint16_t value) {
        m_usDirectPulseIndexFM_ = value;
    }

    float& fSoundVel() OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    const float& fSoundVel() const OMG_NOEXCEPT {
        return m_fSoundVel_;
    }

    void fSoundVel(float value) {
        m_fSoundVel_ = value;
    }

    float& fSourceToSensorDist() OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    const float& fSourceToSensorDist() const OMG_NOEXCEPT {
        return m_fSourceToSensorDist_;
    }

    void fSourceToSensorDist(float value) {
        m_fSourceToSensorDist_ = value;
    }

    float& fSourceToSensorBear() OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    const float& fSourceToSensorBear() const OMG_NOEXCEPT {
        return m_fSourceToSensorBear_;
    }

    void fSourceToSensorBear(float value) {
        m_fSourceToSensorBear_ = value;
    }

    uint16_t& usDirExistTDFlag() OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    const uint16_t& usDirExistTDFlag() const OMG_NOEXCEPT {
        return m_usDirExistTDFlag_;
    }

    void usDirExistTDFlag(uint16_t value) {
        m_usDirExistTDFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistTDSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistTDSamIdx_;
    }

    void usDirExistTDSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistTDSamIdx_ = value;
    }

    void usDirExistTDSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistTDSamIdx_ = std::move(value);
    }
    uint16_t& usDirExistAudioFlag() OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    const uint16_t& usDirExistAudioFlag() const OMG_NOEXCEPT {
        return m_usDirExistAudioFlag_;
    }

    void usDirExistAudioFlag(uint16_t value) {
        m_usDirExistAudioFlag_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    const ::dds::core::array< uint16_t, 2L>& usDirExistAudioSamIdx() const OMG_NOEXCEPT {
        return m_usDirExistAudioSamIdx_;
    }

    void usDirExistAudioSamIdx(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usDirExistAudioSamIdx_ = value;
    }

    void usDirExistAudioSamIdx(::dds::core::array< uint16_t, 2L>&& value) {
        m_usDirExistAudioSamIdx_ = std::move(value);
    }
    uint16_t& reserved2() OMG_NOEXCEPT {
        return m_reserved2_;
    }

    const uint16_t& reserved2() const OMG_NOEXCEPT {
        return m_reserved2_;
    }

    void reserved2(uint16_t value) {
        m_reserved2_ = value;
    }

    bool operator == (const BISDSP_BIS_C_DETECTION_FM_DATA& other_) const;
    bool operator != (const BISDSP_BIS_C_DETECTION_FM_DATA& other_) const;

    void swap(BISDSP_BIS_C_DETECTION_FM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint32_t m_ulFrameNo_;
    uint32_t m_usSubFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBFWindowType_;
    uint16_t m_usTxSourceTargetNo_;
    uint16_t m_usPulseID_;
    ST_DATE_TIME m_stCommTime_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_reserved1_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L> m_aFMDetInfoRaw_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 129L> m_aFMDetInfoNormalize_;
    ::dds::core::array< ::dds::core::array< float, 256L>, 256L> m_aFMDetInfoRangeInfo_;
    bool m_bFMDrcPulseOnOff_;
    float m_fPRIFM_;
    uint16_t m_usUsing3AxisDPDInfoFlag_;
    uint16_t m_unPRISubFrameNoFM_;
    uint16_t m_unPingNoFM_;
    uint16_t m_usDirectPulseFlagFM_;
    uint16_t m_usDirectPulseIndexFM_;
    float m_fSoundVel_;
    float m_fSourceToSensorDist_;
    float m_fSourceToSensorBear_;
    uint16_t m_usDirExistTDFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistTDSamIdx_;
    uint16_t m_usDirExistAudioFlag_;
    ::dds::core::array< uint16_t, 2L> m_usDirExistAudioSamIdx_;
    uint16_t m_reserved2_;

};

inline void swap(BISDSP_BIS_C_DETECTION_FM_DATA& a, BISDSP_BIS_C_DETECTION_FM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_C_DETECTION_FM_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_C_ENE_DATA {
  public:
    BISDSP_BIS_C_ENE_DATA();

    BISDSP_BIS_C_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint32_t ulFrameNo,const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_C_ENE_DATA (BISDSP_BIS_C_ENE_DATA&&) = default;
    BISDSP_BIS_C_ENE_DATA& operator=(BISDSP_BIS_C_ENE_DATA&&) = default;
    BISDSP_BIS_C_ENE_DATA& operator=(const BISDSP_BIS_C_ENE_DATA&) = default;
    BISDSP_BIS_C_ENE_DATA(const BISDSP_BIS_C_ENE_DATA&) = default;
    #else
    BISDSP_BIS_C_ENE_DATA(BISDSP_BIS_C_ENE_DATA&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_C_ENE_DATA& operator=(BISDSP_BIS_C_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo() OMG_NOEXCEPT {
        return m_aENEInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEInfo() const OMG_NOEXCEPT {
        return m_aENEInfo_;
    }

    void aENEInfo(const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& value) {
        m_aENEInfo_ = value;
    }

    void aENEInfo(::dds::core::array< ::dds::core::array< float, 7L>, 256L>&& value) {
        m_aENEInfo_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_C_ENE_DATA& other_) const;
    bool operator != (const BISDSP_BIS_C_ENE_DATA& other_) const;

    void swap(BISDSP_BIS_C_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint32_t m_ulFrameNo_;
    ::dds::core::array< ::dds::core::array< float, 7L>, 256L> m_aENEInfo_;

};

inline void swap(BISDSP_BIS_C_ENE_DATA& a, BISDSP_BIS_C_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_C_ENE_DATA& sample);

class NDDSUSERDllExport BISDSP_BIS_DPD_INFO {
  public:
    BISDSP_BIS_DPD_INFO();

    BISDSP_BIS_DPD_INFO(const ST_MSG_HEADER& stMsgHeader,int32_t nPulseType,const ::dds::core::array< int32_t, 3L>& aSendDeviceID,uint32_t ulSubFrameNo,uint16_t usDirectPulseIndex,float fPRI,const ::dds::core::array< float, 3L>& fRngSrcRcv);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    BISDSP_BIS_DPD_INFO (BISDSP_BIS_DPD_INFO&&) = default;
    BISDSP_BIS_DPD_INFO& operator=(BISDSP_BIS_DPD_INFO&&) = default;
    BISDSP_BIS_DPD_INFO& operator=(const BISDSP_BIS_DPD_INFO&) = default;
    BISDSP_BIS_DPD_INFO(const BISDSP_BIS_DPD_INFO&) = default;
    #else
    BISDSP_BIS_DPD_INFO(BISDSP_BIS_DPD_INFO&& other_) OMG_NOEXCEPT;  
    BISDSP_BIS_DPD_INFO& operator=(BISDSP_BIS_DPD_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int32_t& nPulseType() OMG_NOEXCEPT {
        return m_nPulseType_;
    }

    const int32_t& nPulseType() const OMG_NOEXCEPT {
        return m_nPulseType_;
    }

    void nPulseType(int32_t value) {
        m_nPulseType_ = value;
    }

    ::dds::core::array< int32_t, 3L>& aSendDeviceID() OMG_NOEXCEPT {
        return m_aSendDeviceID_;
    }

    const ::dds::core::array< int32_t, 3L>& aSendDeviceID() const OMG_NOEXCEPT {
        return m_aSendDeviceID_;
    }

    void aSendDeviceID(const ::dds::core::array< int32_t, 3L>& value) {
        m_aSendDeviceID_ = value;
    }

    void aSendDeviceID(::dds::core::array< int32_t, 3L>&& value) {
        m_aSendDeviceID_ = std::move(value);
    }
    uint32_t& ulSubFrameNo() OMG_NOEXCEPT {
        return m_ulSubFrameNo_;
    }

    const uint32_t& ulSubFrameNo() const OMG_NOEXCEPT {
        return m_ulSubFrameNo_;
    }

    void ulSubFrameNo(uint32_t value) {
        m_ulSubFrameNo_ = value;
    }

    uint16_t& usDirectPulseIndex() OMG_NOEXCEPT {
        return m_usDirectPulseIndex_;
    }

    const uint16_t& usDirectPulseIndex() const OMG_NOEXCEPT {
        return m_usDirectPulseIndex_;
    }

    void usDirectPulseIndex(uint16_t value) {
        m_usDirectPulseIndex_ = value;
    }

    float& fPRI() OMG_NOEXCEPT {
        return m_fPRI_;
    }

    const float& fPRI() const OMG_NOEXCEPT {
        return m_fPRI_;
    }

    void fPRI(float value) {
        m_fPRI_ = value;
    }

    ::dds::core::array< float, 3L>& fRngSrcRcv() OMG_NOEXCEPT {
        return m_fRngSrcRcv_;
    }

    const ::dds::core::array< float, 3L>& fRngSrcRcv() const OMG_NOEXCEPT {
        return m_fRngSrcRcv_;
    }

    void fRngSrcRcv(const ::dds::core::array< float, 3L>& value) {
        m_fRngSrcRcv_ = value;
    }

    void fRngSrcRcv(::dds::core::array< float, 3L>&& value) {
        m_fRngSrcRcv_ = std::move(value);
    }

    bool operator == (const BISDSP_BIS_DPD_INFO& other_) const;
    bool operator != (const BISDSP_BIS_DPD_INFO& other_) const;

    void swap(BISDSP_BIS_DPD_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int32_t m_nPulseType_;
    ::dds::core::array< int32_t, 3L> m_aSendDeviceID_;
    uint32_t m_ulSubFrameNo_;
    uint16_t m_usDirectPulseIndex_;
    float m_fPRI_;
    ::dds::core::array< float, 3L> m_fRngSrcRcv_;

};

inline void swap(BISDSP_BIS_DPD_INFO& a, BISDSP_BIS_DPD_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const BISDSP_BIS_DPD_INFO& sample);

class NDDSUSERDllExport CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA {
  public:
    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA();

    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 2L>& aSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA (CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& operator=(const CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA&) = default;
    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA(const CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 2L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 2L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() const OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    void aMonitoringSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& value) {
        m_aMonitoringSensorSig_ = value;
    }

    void aMonitoringSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>&& value) {
        m_aMonitoringSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 2L> m_aSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L> m_aMonitoringSensorSig_;

};

inline void swap(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& a, CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA {
  public:
    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA();

    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA (CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& operator=(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& operator=(const CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA&) = default;
    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA(const CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& operator=(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() const OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    void aMonitoringSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& value) {
        m_aMonitoringSensorSig_ = value;
    }

    void aMonitoringSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>&& value) {
        m_aMonitoringSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L> m_aMonitoringSensorSig_;

};

inline void swap(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& a, CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_A_SENSOR_SIGNAL_DATA {
  public:
    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA();

    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 144L>& aSensorStatus,const ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA (CTRMGR_BIS_A_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& operator=(const CTRMGR_BIS_A_SENSOR_SIGNAL_DATA&) = default;
    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA(const CTRMGR_BIS_A_SENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 144L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 144L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 144L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 144L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus() OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus() const OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    void aMonitoringSensorStatus(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aMonitoringSensorStatus_ = value;
    }

    void aMonitoringSensorStatus(::dds::core::array< uint16_t, 2L>&& value) {
        m_aMonitoringSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 144L> m_aSensorStatus_;
    ::dds::core::array< uint16_t, 2L> m_aMonitoringSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L> m_aSensorSig_;

};

inline void swap(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& a, CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA {
  public:
    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA();

    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA (CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& operator=(const CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA&) = default;
    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA(const CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L> m_aSensorSig_;

};

inline void swap(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& a, CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA {
  public:
    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA();

    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 2L>& aSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA (CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& operator=(const CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA&) = default;
    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA(const CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 2L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 2L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() const OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    void aMonitoringSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& value) {
        m_aMonitoringSensorSig_ = value;
    }

    void aMonitoringSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>&& value) {
        m_aMonitoringSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 2L> m_aSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L> m_aMonitoringSensorSig_;

};

inline void swap(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& a, CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA {
  public:
    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA();

    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA (CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& operator=(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& operator=(const CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA&) = default;
    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA(const CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& operator=(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() const OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    void aMonitoringSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& value) {
        m_aMonitoringSensorSig_ = value;
    }

    void aMonitoringSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>&& value) {
        m_aMonitoringSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L> m_aMonitoringSensorSig_;

};

inline void swap(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& a, CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_B_SENSOR_SIGNAL_DATA {
  public:
    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA();

    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 144L>& aSensorStatus,const ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA (CTRMGR_BIS_B_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& operator=(const CTRMGR_BIS_B_SENSOR_SIGNAL_DATA&) = default;
    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA(const CTRMGR_BIS_B_SENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 144L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 144L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 144L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 144L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus() OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus() const OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    void aMonitoringSensorStatus(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aMonitoringSensorStatus_ = value;
    }

    void aMonitoringSensorStatus(::dds::core::array< uint16_t, 2L>&& value) {
        m_aMonitoringSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 144L> m_aSensorStatus_;
    ::dds::core::array< uint16_t, 2L> m_aMonitoringSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L> m_aSensorSig_;

};

inline void swap(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& a, CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA {
  public:
    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA();

    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA (CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& operator=(const CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA&) = default;
    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA(const CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L> m_aSensorSig_;

};

inline void swap(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& a, CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA {
  public:
    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA();

    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 2L>& aSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA (CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& operator=(const CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA&) = default;
    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA(const CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 2L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 2L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() const OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    void aMonitoringSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& value) {
        m_aMonitoringSensorSig_ = value;
    }

    void aMonitoringSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>&& value) {
        m_aMonitoringSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 2L> m_aSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L> m_aMonitoringSensorSig_;

};

inline void swap(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& a, CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA {
  public:
    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA();

    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA (CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& operator=(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& operator=(const CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA&) = default;
    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA(const CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& operator=(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& aMonitoringSensorSig() const OMG_NOEXCEPT {
        return m_aMonitoringSensorSig_;
    }

    void aMonitoringSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>& value) {
        m_aMonitoringSensorSig_ = value;
    }

    void aMonitoringSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L>&& value) {
        m_aMonitoringSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 2L> m_aMonitoringSensorSig_;

};

inline void swap(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& a, CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_C_SENSOR_SIGNAL_DATA {
  public:
    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA();

    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 144L>& aSensorStatus,const ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA (CTRMGR_BIS_C_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& operator=(const CTRMGR_BIS_C_SENSOR_SIGNAL_DATA&) = default;
    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA(const CTRMGR_BIS_C_SENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& operator=(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 144L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 144L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 144L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 144L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus() OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 2L>& aMonitoringSensorStatus() const OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    void aMonitoringSensorStatus(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aMonitoringSensorStatus_ = value;
    }

    void aMonitoringSensorStatus(::dds::core::array< uint16_t, 2L>&& value) {
        m_aMonitoringSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 144L> m_aSensorStatus_;
    ::dds::core::array< uint16_t, 2L> m_aMonitoringSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L> m_aSensorSig_;

};

inline void swap(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& a, CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA {
  public:
    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA();

    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA (CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& operator=(const CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA&) = default;
    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA(const CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA&) = default;
    #else
    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 16384L>, 144L> m_aSensorSig_;

};

inline void swap(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& a, CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& sample);

class NDDSUSERDllExport ST_BIS_ENE_DATA {
  public:
    ST_BIS_ENE_DATA();

    ST_BIS_ENE_DATA(uint32_t ulFrameNo,uint16_t usAxisID,uint16_t usReserved,const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEOutput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_ENE_DATA (ST_BIS_ENE_DATA&&) = default;
    ST_BIS_ENE_DATA& operator=(ST_BIS_ENE_DATA&&) = default;
    ST_BIS_ENE_DATA& operator=(const ST_BIS_ENE_DATA&) = default;
    ST_BIS_ENE_DATA(const ST_BIS_ENE_DATA&) = default;
    #else
    ST_BIS_ENE_DATA(ST_BIS_ENE_DATA&& other_) OMG_NOEXCEPT;  
    ST_BIS_ENE_DATA& operator=(ST_BIS_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEOutput() OMG_NOEXCEPT {
        return m_aENEOutput_;
    }

    const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& aENEOutput() const OMG_NOEXCEPT {
        return m_aENEOutput_;
    }

    void aENEOutput(const ::dds::core::array< ::dds::core::array< float, 7L>, 256L>& value) {
        m_aENEOutput_ = value;
    }

    void aENEOutput(::dds::core::array< ::dds::core::array< float, 7L>, 256L>&& value) {
        m_aENEOutput_ = std::move(value);
    }

    bool operator == (const ST_BIS_ENE_DATA& other_) const;
    bool operator != (const ST_BIS_ENE_DATA& other_) const;

    void swap(ST_BIS_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisID_;
    uint16_t m_usReserved_;
    ::dds::core::array< ::dds::core::array< float, 7L>, 256L> m_aENEOutput_;

};

inline void swap(ST_BIS_ENE_DATA& a, ST_BIS_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_ENE_DATA& sample);

class NDDSUSERDllExport CTRMGR_BIS_ENE_DATA {
  public:
    CTRMGR_BIS_ENE_DATA();

    CTRMGR_BIS_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisFaultStatus,const ::dds::core::array< ST_BIS_ENE_DATA, 3L>& stENEData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_ENE_DATA (CTRMGR_BIS_ENE_DATA&&) = default;
    CTRMGR_BIS_ENE_DATA& operator=(CTRMGR_BIS_ENE_DATA&&) = default;
    CTRMGR_BIS_ENE_DATA& operator=(const CTRMGR_BIS_ENE_DATA&) = default;
    CTRMGR_BIS_ENE_DATA(const CTRMGR_BIS_ENE_DATA&) = default;
    #else
    CTRMGR_BIS_ENE_DATA(CTRMGR_BIS_ENE_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_ENE_DATA& operator=(CTRMGR_BIS_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisFaultStatus() OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    const uint16_t& usAxisFaultStatus() const OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    void usAxisFaultStatus(uint16_t value) {
        m_usAxisFaultStatus_ = value;
    }

    ::dds::core::array< ST_BIS_ENE_DATA, 3L>& stENEData() OMG_NOEXCEPT {
        return m_stENEData_;
    }

    const ::dds::core::array< ST_BIS_ENE_DATA, 3L>& stENEData() const OMG_NOEXCEPT {
        return m_stENEData_;
    }

    void stENEData(const ::dds::core::array< ST_BIS_ENE_DATA, 3L>& value) {
        m_stENEData_ = value;
    }

    void stENEData(::dds::core::array< ST_BIS_ENE_DATA, 3L>&& value) {
        m_stENEData_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_ENE_DATA& other_) const;
    bool operator != (const CTRMGR_BIS_ENE_DATA& other_) const;

    void swap(CTRMGR_BIS_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisFaultStatus_;
    ::dds::core::array< ST_BIS_ENE_DATA, 3L> m_stENEData_;

};

inline void swap(CTRMGR_BIS_ENE_DATA& a, CTRMGR_BIS_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_ENE_DATA& sample);

class NDDSUSERDllExport ST_IFC_POWERSUPPLY_STATUS {
  public:
    ST_IFC_POWERSUPPLY_STATUS();

    ST_IFC_POWERSUPPLY_STATUS(uint8_t oStatus,uint8_t oPowerStatus,float fOutputCurrent,float fOutputVoltage,float fOutputPower);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_IFC_POWERSUPPLY_STATUS (ST_IFC_POWERSUPPLY_STATUS&&) = default;
    ST_IFC_POWERSUPPLY_STATUS& operator=(ST_IFC_POWERSUPPLY_STATUS&&) = default;
    ST_IFC_POWERSUPPLY_STATUS& operator=(const ST_IFC_POWERSUPPLY_STATUS&) = default;
    ST_IFC_POWERSUPPLY_STATUS(const ST_IFC_POWERSUPPLY_STATUS&) = default;
    #else
    ST_IFC_POWERSUPPLY_STATUS(ST_IFC_POWERSUPPLY_STATUS&& other_) OMG_NOEXCEPT;  
    ST_IFC_POWERSUPPLY_STATUS& operator=(ST_IFC_POWERSUPPLY_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    uint8_t& oPowerStatus() OMG_NOEXCEPT {
        return m_oPowerStatus_;
    }

    const uint8_t& oPowerStatus() const OMG_NOEXCEPT {
        return m_oPowerStatus_;
    }

    void oPowerStatus(uint8_t value) {
        m_oPowerStatus_ = value;
    }

    float& fOutputCurrent() OMG_NOEXCEPT {
        return m_fOutputCurrent_;
    }

    const float& fOutputCurrent() const OMG_NOEXCEPT {
        return m_fOutputCurrent_;
    }

    void fOutputCurrent(float value) {
        m_fOutputCurrent_ = value;
    }

    float& fOutputVoltage() OMG_NOEXCEPT {
        return m_fOutputVoltage_;
    }

    const float& fOutputVoltage() const OMG_NOEXCEPT {
        return m_fOutputVoltage_;
    }

    void fOutputVoltage(float value) {
        m_fOutputVoltage_ = value;
    }

    float& fOutputPower() OMG_NOEXCEPT {
        return m_fOutputPower_;
    }

    const float& fOutputPower() const OMG_NOEXCEPT {
        return m_fOutputPower_;
    }

    void fOutputPower(float value) {
        m_fOutputPower_ = value;
    }

    bool operator == (const ST_IFC_POWERSUPPLY_STATUS& other_) const;
    bool operator != (const ST_IFC_POWERSUPPLY_STATUS& other_) const;

    void swap(ST_IFC_POWERSUPPLY_STATUS& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oStatus_;
    uint8_t m_oPowerStatus_;
    float m_fOutputCurrent_;
    float m_fOutputVoltage_;
    float m_fOutputPower_;

};

inline void swap(ST_IFC_POWERSUPPLY_STATUS& a, ST_IFC_POWERSUPPLY_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_IFC_POWERSUPPLY_STATUS& sample);

class NDDSUSERDllExport ST_SENSOR_IFC_STATUS {
  public:
    ST_SENSOR_IFC_STATUS();

    ST_SENSOR_IFC_STATUS(uint8_t oProcessorStatus,uint8_t oReceiverFPGAStatus,float fReceiverFPGAVoltage,uint8_t oReceiverCommBoardStatus,uint8_t oReceiverFanStatus,uint8_t oReceiverTemperature,const ::dds::core::array< ST_IFC_POWERSUPPLY_STATUS, 3L>& stPowerSupplyStatus,uint8_t oPowerControllerStatus,const ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerStatus,uint8_t oProcessorPowerStatus,uint8_t oReceiverPowerStatus,uint8_t oNetworkPowerStatus,uint8_t oDisplayPowerStatus,const ::dds::core::array< uint8_t, 2L>& oPowerControllerFanStatus,const ::dds::core::array< float, 3L>& aPowerSupplyInputVoltage,uint8_t oErrCode1,uint8_t oErrCode2,const ::dds::core::array< uint8_t, 9L>& oVoltageTransfomerStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SENSOR_IFC_STATUS (ST_SENSOR_IFC_STATUS&&) = default;
    ST_SENSOR_IFC_STATUS& operator=(ST_SENSOR_IFC_STATUS&&) = default;
    ST_SENSOR_IFC_STATUS& operator=(const ST_SENSOR_IFC_STATUS&) = default;
    ST_SENSOR_IFC_STATUS(const ST_SENSOR_IFC_STATUS&) = default;
    #else
    ST_SENSOR_IFC_STATUS(ST_SENSOR_IFC_STATUS&& other_) OMG_NOEXCEPT;  
    ST_SENSOR_IFC_STATUS& operator=(ST_SENSOR_IFC_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oProcessorStatus() OMG_NOEXCEPT {
        return m_oProcessorStatus_;
    }

    const uint8_t& oProcessorStatus() const OMG_NOEXCEPT {
        return m_oProcessorStatus_;
    }

    void oProcessorStatus(uint8_t value) {
        m_oProcessorStatus_ = value;
    }

    uint8_t& oReceiverFPGAStatus() OMG_NOEXCEPT {
        return m_oReceiverFPGAStatus_;
    }

    const uint8_t& oReceiverFPGAStatus() const OMG_NOEXCEPT {
        return m_oReceiverFPGAStatus_;
    }

    void oReceiverFPGAStatus(uint8_t value) {
        m_oReceiverFPGAStatus_ = value;
    }

    float& fReceiverFPGAVoltage() OMG_NOEXCEPT {
        return m_fReceiverFPGAVoltage_;
    }

    const float& fReceiverFPGAVoltage() const OMG_NOEXCEPT {
        return m_fReceiverFPGAVoltage_;
    }

    void fReceiverFPGAVoltage(float value) {
        m_fReceiverFPGAVoltage_ = value;
    }

    uint8_t& oReceiverCommBoardStatus() OMG_NOEXCEPT {
        return m_oReceiverCommBoardStatus_;
    }

    const uint8_t& oReceiverCommBoardStatus() const OMG_NOEXCEPT {
        return m_oReceiverCommBoardStatus_;
    }

    void oReceiverCommBoardStatus(uint8_t value) {
        m_oReceiverCommBoardStatus_ = value;
    }

    uint8_t& oReceiverFanStatus() OMG_NOEXCEPT {
        return m_oReceiverFanStatus_;
    }

    const uint8_t& oReceiverFanStatus() const OMG_NOEXCEPT {
        return m_oReceiverFanStatus_;
    }

    void oReceiverFanStatus(uint8_t value) {
        m_oReceiverFanStatus_ = value;
    }

    uint8_t& oReceiverTemperature() OMG_NOEXCEPT {
        return m_oReceiverTemperature_;
    }

    const uint8_t& oReceiverTemperature() const OMG_NOEXCEPT {
        return m_oReceiverTemperature_;
    }

    void oReceiverTemperature(uint8_t value) {
        m_oReceiverTemperature_ = value;
    }

    ::dds::core::array< ST_IFC_POWERSUPPLY_STATUS, 3L>& stPowerSupplyStatus() OMG_NOEXCEPT {
        return m_stPowerSupplyStatus_;
    }

    const ::dds::core::array< ST_IFC_POWERSUPPLY_STATUS, 3L>& stPowerSupplyStatus() const OMG_NOEXCEPT {
        return m_stPowerSupplyStatus_;
    }

    void stPowerSupplyStatus(const ::dds::core::array< ST_IFC_POWERSUPPLY_STATUS, 3L>& value) {
        m_stPowerSupplyStatus_ = value;
    }

    void stPowerSupplyStatus(::dds::core::array< ST_IFC_POWERSUPPLY_STATUS, 3L>&& value) {
        m_stPowerSupplyStatus_ = std::move(value);
    }
    uint8_t& oPowerControllerStatus() OMG_NOEXCEPT {
        return m_oPowerControllerStatus_;
    }

    const uint8_t& oPowerControllerStatus() const OMG_NOEXCEPT {
        return m_oPowerControllerStatus_;
    }

    void oPowerControllerStatus(uint8_t value) {
        m_oPowerControllerStatus_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerStatus() OMG_NOEXCEPT {
        return m_oPowerSupplyPowerStatus_;
    }

    const ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerStatus() const OMG_NOEXCEPT {
        return m_oPowerSupplyPowerStatus_;
    }

    void oPowerSupplyPowerStatus(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oPowerSupplyPowerStatus_ = value;
    }

    void oPowerSupplyPowerStatus(::dds::core::array< uint8_t, 3L>&& value) {
        m_oPowerSupplyPowerStatus_ = std::move(value);
    }
    uint8_t& oProcessorPowerStatus() OMG_NOEXCEPT {
        return m_oProcessorPowerStatus_;
    }

    const uint8_t& oProcessorPowerStatus() const OMG_NOEXCEPT {
        return m_oProcessorPowerStatus_;
    }

    void oProcessorPowerStatus(uint8_t value) {
        m_oProcessorPowerStatus_ = value;
    }

    uint8_t& oReceiverPowerStatus() OMG_NOEXCEPT {
        return m_oReceiverPowerStatus_;
    }

    const uint8_t& oReceiverPowerStatus() const OMG_NOEXCEPT {
        return m_oReceiverPowerStatus_;
    }

    void oReceiverPowerStatus(uint8_t value) {
        m_oReceiverPowerStatus_ = value;
    }

    uint8_t& oNetworkPowerStatus() OMG_NOEXCEPT {
        return m_oNetworkPowerStatus_;
    }

    const uint8_t& oNetworkPowerStatus() const OMG_NOEXCEPT {
        return m_oNetworkPowerStatus_;
    }

    void oNetworkPowerStatus(uint8_t value) {
        m_oNetworkPowerStatus_ = value;
    }

    uint8_t& oDisplayPowerStatus() OMG_NOEXCEPT {
        return m_oDisplayPowerStatus_;
    }

    const uint8_t& oDisplayPowerStatus() const OMG_NOEXCEPT {
        return m_oDisplayPowerStatus_;
    }

    void oDisplayPowerStatus(uint8_t value) {
        m_oDisplayPowerStatus_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oPowerControllerFanStatus() OMG_NOEXCEPT {
        return m_oPowerControllerFanStatus_;
    }

    const ::dds::core::array< uint8_t, 2L>& oPowerControllerFanStatus() const OMG_NOEXCEPT {
        return m_oPowerControllerFanStatus_;
    }

    void oPowerControllerFanStatus(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oPowerControllerFanStatus_ = value;
    }

    void oPowerControllerFanStatus(::dds::core::array< uint8_t, 2L>&& value) {
        m_oPowerControllerFanStatus_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& aPowerSupplyInputVoltage() OMG_NOEXCEPT {
        return m_aPowerSupplyInputVoltage_;
    }

    const ::dds::core::array< float, 3L>& aPowerSupplyInputVoltage() const OMG_NOEXCEPT {
        return m_aPowerSupplyInputVoltage_;
    }

    void aPowerSupplyInputVoltage(const ::dds::core::array< float, 3L>& value) {
        m_aPowerSupplyInputVoltage_ = value;
    }

    void aPowerSupplyInputVoltage(::dds::core::array< float, 3L>&& value) {
        m_aPowerSupplyInputVoltage_ = std::move(value);
    }
    uint8_t& oErrCode1() OMG_NOEXCEPT {
        return m_oErrCode1_;
    }

    const uint8_t& oErrCode1() const OMG_NOEXCEPT {
        return m_oErrCode1_;
    }

    void oErrCode1(uint8_t value) {
        m_oErrCode1_ = value;
    }

    uint8_t& oErrCode2() OMG_NOEXCEPT {
        return m_oErrCode2_;
    }

    const uint8_t& oErrCode2() const OMG_NOEXCEPT {
        return m_oErrCode2_;
    }

    void oErrCode2(uint8_t value) {
        m_oErrCode2_ = value;
    }

    ::dds::core::array< uint8_t, 9L>& oVoltageTransfomerStatus() OMG_NOEXCEPT {
        return m_oVoltageTransfomerStatus_;
    }

    const ::dds::core::array< uint8_t, 9L>& oVoltageTransfomerStatus() const OMG_NOEXCEPT {
        return m_oVoltageTransfomerStatus_;
    }

    void oVoltageTransfomerStatus(const ::dds::core::array< uint8_t, 9L>& value) {
        m_oVoltageTransfomerStatus_ = value;
    }

    void oVoltageTransfomerStatus(::dds::core::array< uint8_t, 9L>&& value) {
        m_oVoltageTransfomerStatus_ = std::move(value);
    }

    bool operator == (const ST_SENSOR_IFC_STATUS& other_) const;
    bool operator != (const ST_SENSOR_IFC_STATUS& other_) const;

    void swap(ST_SENSOR_IFC_STATUS& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oProcessorStatus_;
    uint8_t m_oReceiverFPGAStatus_;
    float m_fReceiverFPGAVoltage_;
    uint8_t m_oReceiverCommBoardStatus_;
    uint8_t m_oReceiverFanStatus_;
    uint8_t m_oReceiverTemperature_;
    ::dds::core::array< ST_IFC_POWERSUPPLY_STATUS, 3L> m_stPowerSupplyStatus_;
    uint8_t m_oPowerControllerStatus_;
    ::dds::core::array< uint8_t, 3L> m_oPowerSupplyPowerStatus_;
    uint8_t m_oProcessorPowerStatus_;
    uint8_t m_oReceiverPowerStatus_;
    uint8_t m_oNetworkPowerStatus_;
    uint8_t m_oDisplayPowerStatus_;
    ::dds::core::array< uint8_t, 2L> m_oPowerControllerFanStatus_;
    ::dds::core::array< float, 3L> m_aPowerSupplyInputVoltage_;
    uint8_t m_oErrCode1_;
    uint8_t m_oErrCode2_;
    ::dds::core::array< uint8_t, 9L> m_oVoltageTransfomerStatus_;

};

inline void swap(ST_SENSOR_IFC_STATUS& a, ST_SENSOR_IFC_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SENSOR_IFC_STATUS& sample);

class NDDSUSERDllExport CTRMGR_BIS_SENSOR_IFC_STATUS {
  public:
    CTRMGR_BIS_SENSOR_IFC_STATUS();

    CTRMGR_BIS_SENSOR_IFC_STATUS(const ST_MSG_HEADER& stMsgHeader,const ST_SENSOR_IFC_STATUS& stSensorIFCStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_SENSOR_IFC_STATUS (CTRMGR_BIS_SENSOR_IFC_STATUS&&) = default;
    CTRMGR_BIS_SENSOR_IFC_STATUS& operator=(CTRMGR_BIS_SENSOR_IFC_STATUS&&) = default;
    CTRMGR_BIS_SENSOR_IFC_STATUS& operator=(const CTRMGR_BIS_SENSOR_IFC_STATUS&) = default;
    CTRMGR_BIS_SENSOR_IFC_STATUS(const CTRMGR_BIS_SENSOR_IFC_STATUS&) = default;
    #else
    CTRMGR_BIS_SENSOR_IFC_STATUS(CTRMGR_BIS_SENSOR_IFC_STATUS&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_SENSOR_IFC_STATUS& operator=(CTRMGR_BIS_SENSOR_IFC_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_SENSOR_IFC_STATUS& stSensorIFCStatus() OMG_NOEXCEPT {
        return m_stSensorIFCStatus_;
    }

    const ST_SENSOR_IFC_STATUS& stSensorIFCStatus() const OMG_NOEXCEPT {
        return m_stSensorIFCStatus_;
    }

    void stSensorIFCStatus(const ST_SENSOR_IFC_STATUS& value) {
        m_stSensorIFCStatus_ = value;
    }

    void stSensorIFCStatus(ST_SENSOR_IFC_STATUS&& value) {
        m_stSensorIFCStatus_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_SENSOR_IFC_STATUS& other_) const;
    bool operator != (const CTRMGR_BIS_SENSOR_IFC_STATUS& other_) const;

    void swap(CTRMGR_BIS_SENSOR_IFC_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_SENSOR_IFC_STATUS m_stSensorIFCStatus_;

};

inline void swap(CTRMGR_BIS_SENSOR_IFC_STATUS& a, CTRMGR_BIS_SENSOR_IFC_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_SENSOR_IFC_STATUS& sample);

class NDDSUSERDllExport CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT {
  public:
    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT();

    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 3L>& usPowerCtrlResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT (CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT&&) = default;
    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& operator=(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT&&) = default;
    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& operator=(const CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT&) = default;
    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT(const CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT&) = default;
    #else
    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& operator=(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 3L>& usPowerCtrlResult() OMG_NOEXCEPT {
        return m_usPowerCtrlResult_;
    }

    const ::dds::core::array< uint16_t, 3L>& usPowerCtrlResult() const OMG_NOEXCEPT {
        return m_usPowerCtrlResult_;
    }

    void usPowerCtrlResult(const ::dds::core::array< uint16_t, 3L>& value) {
        m_usPowerCtrlResult_ = value;
    }

    void usPowerCtrlResult(::dds::core::array< uint16_t, 3L>&& value) {
        m_usPowerCtrlResult_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& other_) const;
    bool operator != (const CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& other_) const;

    void swap(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 3L> m_usPowerCtrlResult_;

};

inline void swap(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& a, CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& sample);

class NDDSUSERDllExport ST_BIS_SENSOR_STATUS {
  public:
    ST_BIS_SENSOR_STATUS();

    ST_BIS_SENSOR_STATUS(uint8_t oAxisID,uint8_t oMainMUXID,uint8_t oEOSwitch1ID,uint8_t oMainMuxFPGAStatus,uint8_t oSwitchCircuitFPGAStatusA,uint8_t oSwitchCircuitFPGAStatusB,uint8_t oSwitchCircuitStatusA,uint8_t oSwitchCircuitStatusB,uint8_t oMainMuxStatusA,uint8_t oMainMuxStatusB,uint8_t oMainSensorGain,uint8_t oSubSensorGain,uint8_t oEOSwitch2ID,const ::dds::core::array< uint8_t, 144L>& aSensorStatus,const ::dds::core::array< uint8_t, 4L>& aMonitoringSensorStatus,const ::dds::core::array< uint8_t, 26L>& aSubMuxStatus,uint16_t usSensorGainCtrlMode,const ::dds::core::array< float, 148L>& aSensorEnergy,float fTotalEnergy,uint32_t ulFrameNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_SENSOR_STATUS (ST_BIS_SENSOR_STATUS&&) = default;
    ST_BIS_SENSOR_STATUS& operator=(ST_BIS_SENSOR_STATUS&&) = default;
    ST_BIS_SENSOR_STATUS& operator=(const ST_BIS_SENSOR_STATUS&) = default;
    ST_BIS_SENSOR_STATUS(const ST_BIS_SENSOR_STATUS&) = default;
    #else
    ST_BIS_SENSOR_STATUS(ST_BIS_SENSOR_STATUS&& other_) OMG_NOEXCEPT;  
    ST_BIS_SENSOR_STATUS& operator=(ST_BIS_SENSOR_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oMainMUXID() OMG_NOEXCEPT {
        return m_oMainMUXID_;
    }

    const uint8_t& oMainMUXID() const OMG_NOEXCEPT {
        return m_oMainMUXID_;
    }

    void oMainMUXID(uint8_t value) {
        m_oMainMUXID_ = value;
    }

    uint8_t& oEOSwitch1ID() OMG_NOEXCEPT {
        return m_oEOSwitch1ID_;
    }

    const uint8_t& oEOSwitch1ID() const OMG_NOEXCEPT {
        return m_oEOSwitch1ID_;
    }

    void oEOSwitch1ID(uint8_t value) {
        m_oEOSwitch1ID_ = value;
    }

    uint8_t& oMainMuxFPGAStatus() OMG_NOEXCEPT {
        return m_oMainMuxFPGAStatus_;
    }

    const uint8_t& oMainMuxFPGAStatus() const OMG_NOEXCEPT {
        return m_oMainMuxFPGAStatus_;
    }

    void oMainMuxFPGAStatus(uint8_t value) {
        m_oMainMuxFPGAStatus_ = value;
    }

    uint8_t& oSwitchCircuitFPGAStatusA() OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusA_;
    }

    const uint8_t& oSwitchCircuitFPGAStatusA() const OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusA_;
    }

    void oSwitchCircuitFPGAStatusA(uint8_t value) {
        m_oSwitchCircuitFPGAStatusA_ = value;
    }

    uint8_t& oSwitchCircuitFPGAStatusB() OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusB_;
    }

    const uint8_t& oSwitchCircuitFPGAStatusB() const OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusB_;
    }

    void oSwitchCircuitFPGAStatusB(uint8_t value) {
        m_oSwitchCircuitFPGAStatusB_ = value;
    }

    uint8_t& oSwitchCircuitStatusA() OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusA_;
    }

    const uint8_t& oSwitchCircuitStatusA() const OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusA_;
    }

    void oSwitchCircuitStatusA(uint8_t value) {
        m_oSwitchCircuitStatusA_ = value;
    }

    uint8_t& oSwitchCircuitStatusB() OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusB_;
    }

    const uint8_t& oSwitchCircuitStatusB() const OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusB_;
    }

    void oSwitchCircuitStatusB(uint8_t value) {
        m_oSwitchCircuitStatusB_ = value;
    }

    uint8_t& oMainMuxStatusA() OMG_NOEXCEPT {
        return m_oMainMuxStatusA_;
    }

    const uint8_t& oMainMuxStatusA() const OMG_NOEXCEPT {
        return m_oMainMuxStatusA_;
    }

    void oMainMuxStatusA(uint8_t value) {
        m_oMainMuxStatusA_ = value;
    }

    uint8_t& oMainMuxStatusB() OMG_NOEXCEPT {
        return m_oMainMuxStatusB_;
    }

    const uint8_t& oMainMuxStatusB() const OMG_NOEXCEPT {
        return m_oMainMuxStatusB_;
    }

    void oMainMuxStatusB(uint8_t value) {
        m_oMainMuxStatusB_ = value;
    }

    uint8_t& oMainSensorGain() OMG_NOEXCEPT {
        return m_oMainSensorGain_;
    }

    const uint8_t& oMainSensorGain() const OMG_NOEXCEPT {
        return m_oMainSensorGain_;
    }

    void oMainSensorGain(uint8_t value) {
        m_oMainSensorGain_ = value;
    }

    uint8_t& oSubSensorGain() OMG_NOEXCEPT {
        return m_oSubSensorGain_;
    }

    const uint8_t& oSubSensorGain() const OMG_NOEXCEPT {
        return m_oSubSensorGain_;
    }

    void oSubSensorGain(uint8_t value) {
        m_oSubSensorGain_ = value;
    }

    uint8_t& oEOSwitch2ID() OMG_NOEXCEPT {
        return m_oEOSwitch2ID_;
    }

    const uint8_t& oEOSwitch2ID() const OMG_NOEXCEPT {
        return m_oEOSwitch2ID_;
    }

    void oEOSwitch2ID(uint8_t value) {
        m_oEOSwitch2ID_ = value;
    }

    ::dds::core::array< uint8_t, 144L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint8_t, 144L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint8_t, 144L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint8_t, 144L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 4L>& aMonitoringSensorStatus() OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    const ::dds::core::array< uint8_t, 4L>& aMonitoringSensorStatus() const OMG_NOEXCEPT {
        return m_aMonitoringSensorStatus_;
    }

    void aMonitoringSensorStatus(const ::dds::core::array< uint8_t, 4L>& value) {
        m_aMonitoringSensorStatus_ = value;
    }

    void aMonitoringSensorStatus(::dds::core::array< uint8_t, 4L>&& value) {
        m_aMonitoringSensorStatus_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 26L>& aSubMuxStatus() OMG_NOEXCEPT {
        return m_aSubMuxStatus_;
    }

    const ::dds::core::array< uint8_t, 26L>& aSubMuxStatus() const OMG_NOEXCEPT {
        return m_aSubMuxStatus_;
    }

    void aSubMuxStatus(const ::dds::core::array< uint8_t, 26L>& value) {
        m_aSubMuxStatus_ = value;
    }

    void aSubMuxStatus(::dds::core::array< uint8_t, 26L>&& value) {
        m_aSubMuxStatus_ = std::move(value);
    }
    uint16_t& usSensorGainCtrlMode() OMG_NOEXCEPT {
        return m_usSensorGainCtrlMode_;
    }

    const uint16_t& usSensorGainCtrlMode() const OMG_NOEXCEPT {
        return m_usSensorGainCtrlMode_;
    }

    void usSensorGainCtrlMode(uint16_t value) {
        m_usSensorGainCtrlMode_ = value;
    }

    ::dds::core::array< float, 148L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 148L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 148L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 148L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    bool operator == (const ST_BIS_SENSOR_STATUS& other_) const;
    bool operator != (const ST_BIS_SENSOR_STATUS& other_) const;

    void swap(ST_BIS_SENSOR_STATUS& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAxisID_;
    uint8_t m_oMainMUXID_;
    uint8_t m_oEOSwitch1ID_;
    uint8_t m_oMainMuxFPGAStatus_;
    uint8_t m_oSwitchCircuitFPGAStatusA_;
    uint8_t m_oSwitchCircuitFPGAStatusB_;
    uint8_t m_oSwitchCircuitStatusA_;
    uint8_t m_oSwitchCircuitStatusB_;
    uint8_t m_oMainMuxStatusA_;
    uint8_t m_oMainMuxStatusB_;
    uint8_t m_oMainSensorGain_;
    uint8_t m_oSubSensorGain_;
    uint8_t m_oEOSwitch2ID_;
    ::dds::core::array< uint8_t, 144L> m_aSensorStatus_;
    ::dds::core::array< uint8_t, 4L> m_aMonitoringSensorStatus_;
    ::dds::core::array< uint8_t, 26L> m_aSubMuxStatus_;
    uint16_t m_usSensorGainCtrlMode_;
    ::dds::core::array< float, 148L> m_aSensorEnergy_;
    float m_fTotalEnergy_;
    uint32_t m_ulFrameNo_;

};

inline void swap(ST_BIS_SENSOR_STATUS& a, ST_BIS_SENSOR_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_SENSOR_STATUS& sample);

class NDDSUSERDllExport CTRMGR_BIS_SENSOR_STATUS {
  public:
    CTRMGR_BIS_SENSOR_STATUS();

    CTRMGR_BIS_SENSOR_STATUS(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& stSensorStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_BIS_SENSOR_STATUS (CTRMGR_BIS_SENSOR_STATUS&&) = default;
    CTRMGR_BIS_SENSOR_STATUS& operator=(CTRMGR_BIS_SENSOR_STATUS&&) = default;
    CTRMGR_BIS_SENSOR_STATUS& operator=(const CTRMGR_BIS_SENSOR_STATUS&) = default;
    CTRMGR_BIS_SENSOR_STATUS(const CTRMGR_BIS_SENSOR_STATUS&) = default;
    #else
    CTRMGR_BIS_SENSOR_STATUS(CTRMGR_BIS_SENSOR_STATUS&& other_) OMG_NOEXCEPT;  
    CTRMGR_BIS_SENSOR_STATUS& operator=(CTRMGR_BIS_SENSOR_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& stSensorStatus() OMG_NOEXCEPT {
        return m_stSensorStatus_;
    }

    const ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& stSensorStatus() const OMG_NOEXCEPT {
        return m_stSensorStatus_;
    }

    void stSensorStatus(const ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& value) {
        m_stSensorStatus_ = value;
    }

    void stSensorStatus(::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>&& value) {
        m_stSensorStatus_ = std::move(value);
    }

    bool operator == (const CTRMGR_BIS_SENSOR_STATUS& other_) const;
    bool operator != (const CTRMGR_BIS_SENSOR_STATUS& other_) const;

    void swap(CTRMGR_BIS_SENSOR_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L> m_stSensorStatus_;

};

inline void swap(CTRMGR_BIS_SENSOR_STATUS& a, CTRMGR_BIS_SENSOR_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_BIS_SENSOR_STATUS& sample);

class NDDSUSERDllExport CTRMGR_LAS_A_FREQ_DETECTION_CONTROL {
  public:
    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL();

    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint16_t usBbIntegTimeABF,uint16_t usNbIntegTimeABF);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL (CTRMGR_LAS_A_FREQ_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& operator=(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& operator=(const CTRMGR_LAS_A_FREQ_DETECTION_CONTROL&) = default;
    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL(const CTRMGR_LAS_A_FREQ_DETECTION_CONTROL&) = default;
    #else
    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& operator=(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint16_t& usBbIntegTimeABF() OMG_NOEXCEPT {
        return m_usBbIntegTimeABF_;
    }

    const uint16_t& usBbIntegTimeABF() const OMG_NOEXCEPT {
        return m_usBbIntegTimeABF_;
    }

    void usBbIntegTimeABF(uint16_t value) {
        m_usBbIntegTimeABF_ = value;
    }

    uint16_t& usNbIntegTimeABF() OMG_NOEXCEPT {
        return m_usNbIntegTimeABF_;
    }

    const uint16_t& usNbIntegTimeABF() const OMG_NOEXCEPT {
        return m_usNbIntegTimeABF_;
    }

    void usNbIntegTimeABF(uint16_t value) {
        m_usNbIntegTimeABF_ = value;
    }

    bool operator == (const CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& other_) const;
    bool operator != (const CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& other_) const;

    void swap(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint16_t m_usBbIntegTimeABF_;
    uint16_t m_usNbIntegTimeABF_;

};

inline void swap(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& a, CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& sample);

class NDDSUSERDllExport CTRMGR_LAS_A_SENSOR_SIGNAL_DATA {
  public:
    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA();

    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 240L>& aSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA (CTRMGR_LAS_A_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& operator=(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& operator=(const CTRMGR_LAS_A_SENSOR_SIGNAL_DATA&) = default;
    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA(const CTRMGR_LAS_A_SENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& operator=(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 240L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 240L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 240L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 240L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 240L> m_aSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L> m_aSensorSig_;

};

inline void swap(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& a, CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA {
  public:
    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA();

    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA (CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& operator=(const CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA&) = default;
    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA(const CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA&) = default;
    #else
    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L> m_aSensorSig_;

};

inline void swap(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& a, CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_A_TIME_DETECTION_CONTROL {
  public:
    CTRMGR_LAS_A_TIME_DETECTION_CONTROL();

    CTRMGR_LAS_A_TIME_DETECTION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint16_t usBbIntegTimeCBF,uint16_t usNbIntegTimeCBF);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_A_TIME_DETECTION_CONTROL (CTRMGR_LAS_A_TIME_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_A_TIME_DETECTION_CONTROL& operator=(CTRMGR_LAS_A_TIME_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_A_TIME_DETECTION_CONTROL& operator=(const CTRMGR_LAS_A_TIME_DETECTION_CONTROL&) = default;
    CTRMGR_LAS_A_TIME_DETECTION_CONTROL(const CTRMGR_LAS_A_TIME_DETECTION_CONTROL&) = default;
    #else
    CTRMGR_LAS_A_TIME_DETECTION_CONTROL(CTRMGR_LAS_A_TIME_DETECTION_CONTROL&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_A_TIME_DETECTION_CONTROL& operator=(CTRMGR_LAS_A_TIME_DETECTION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint16_t& usBbIntegTimeCBF() OMG_NOEXCEPT {
        return m_usBbIntegTimeCBF_;
    }

    const uint16_t& usBbIntegTimeCBF() const OMG_NOEXCEPT {
        return m_usBbIntegTimeCBF_;
    }

    void usBbIntegTimeCBF(uint16_t value) {
        m_usBbIntegTimeCBF_ = value;
    }

    uint16_t& usNbIntegTimeCBF() OMG_NOEXCEPT {
        return m_usNbIntegTimeCBF_;
    }

    const uint16_t& usNbIntegTimeCBF() const OMG_NOEXCEPT {
        return m_usNbIntegTimeCBF_;
    }

    void usNbIntegTimeCBF(uint16_t value) {
        m_usNbIntegTimeCBF_ = value;
    }

    bool operator == (const CTRMGR_LAS_A_TIME_DETECTION_CONTROL& other_) const;
    bool operator != (const CTRMGR_LAS_A_TIME_DETECTION_CONTROL& other_) const;

    void swap(CTRMGR_LAS_A_TIME_DETECTION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint16_t m_usBbIntegTimeCBF_;
    uint16_t m_usNbIntegTimeCBF_;

};

inline void swap(CTRMGR_LAS_A_TIME_DETECTION_CONTROL& a, CTRMGR_LAS_A_TIME_DETECTION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_A_TIME_DETECTION_CONTROL& sample);

class NDDSUSERDllExport CTRMGR_LAS_B_FREQ_DETECTION_CONTROL {
  public:
    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL();

    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint16_t usBbIntegTimeABF,uint16_t usNbIntegTimeABF);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL (CTRMGR_LAS_B_FREQ_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& operator=(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& operator=(const CTRMGR_LAS_B_FREQ_DETECTION_CONTROL&) = default;
    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL(const CTRMGR_LAS_B_FREQ_DETECTION_CONTROL&) = default;
    #else
    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& operator=(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint16_t& usBbIntegTimeABF() OMG_NOEXCEPT {
        return m_usBbIntegTimeABF_;
    }

    const uint16_t& usBbIntegTimeABF() const OMG_NOEXCEPT {
        return m_usBbIntegTimeABF_;
    }

    void usBbIntegTimeABF(uint16_t value) {
        m_usBbIntegTimeABF_ = value;
    }

    uint16_t& usNbIntegTimeABF() OMG_NOEXCEPT {
        return m_usNbIntegTimeABF_;
    }

    const uint16_t& usNbIntegTimeABF() const OMG_NOEXCEPT {
        return m_usNbIntegTimeABF_;
    }

    void usNbIntegTimeABF(uint16_t value) {
        m_usNbIntegTimeABF_ = value;
    }

    bool operator == (const CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& other_) const;
    bool operator != (const CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& other_) const;

    void swap(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint16_t m_usBbIntegTimeABF_;
    uint16_t m_usNbIntegTimeABF_;

};

inline void swap(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& a, CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& sample);

class NDDSUSERDllExport CTRMGR_LAS_B_SENSOR_SIGNAL_DATA {
  public:
    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA();

    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 240L>& aSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA (CTRMGR_LAS_B_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& operator=(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& operator=(const CTRMGR_LAS_B_SENSOR_SIGNAL_DATA&) = default;
    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA(const CTRMGR_LAS_B_SENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& operator=(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 240L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 240L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 240L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 240L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 240L> m_aSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L> m_aSensorSig_;

};

inline void swap(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& a, CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA {
  public:
    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA();

    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA (CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& operator=(const CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA&) = default;
    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA(const CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA&) = default;
    #else
    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L> m_aSensorSig_;

};

inline void swap(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& a, CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_B_TIME_DETECTION_CONTROL {
  public:
    CTRMGR_LAS_B_TIME_DETECTION_CONTROL();

    CTRMGR_LAS_B_TIME_DETECTION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint16_t usBbIntegTimeCBF,uint16_t usNbIntegTimeCBF);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_B_TIME_DETECTION_CONTROL (CTRMGR_LAS_B_TIME_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_B_TIME_DETECTION_CONTROL& operator=(CTRMGR_LAS_B_TIME_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_B_TIME_DETECTION_CONTROL& operator=(const CTRMGR_LAS_B_TIME_DETECTION_CONTROL&) = default;
    CTRMGR_LAS_B_TIME_DETECTION_CONTROL(const CTRMGR_LAS_B_TIME_DETECTION_CONTROL&) = default;
    #else
    CTRMGR_LAS_B_TIME_DETECTION_CONTROL(CTRMGR_LAS_B_TIME_DETECTION_CONTROL&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_B_TIME_DETECTION_CONTROL& operator=(CTRMGR_LAS_B_TIME_DETECTION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint16_t& usBbIntegTimeCBF() OMG_NOEXCEPT {
        return m_usBbIntegTimeCBF_;
    }

    const uint16_t& usBbIntegTimeCBF() const OMG_NOEXCEPT {
        return m_usBbIntegTimeCBF_;
    }

    void usBbIntegTimeCBF(uint16_t value) {
        m_usBbIntegTimeCBF_ = value;
    }

    uint16_t& usNbIntegTimeCBF() OMG_NOEXCEPT {
        return m_usNbIntegTimeCBF_;
    }

    const uint16_t& usNbIntegTimeCBF() const OMG_NOEXCEPT {
        return m_usNbIntegTimeCBF_;
    }

    void usNbIntegTimeCBF(uint16_t value) {
        m_usNbIntegTimeCBF_ = value;
    }

    bool operator == (const CTRMGR_LAS_B_TIME_DETECTION_CONTROL& other_) const;
    bool operator != (const CTRMGR_LAS_B_TIME_DETECTION_CONTROL& other_) const;

    void swap(CTRMGR_LAS_B_TIME_DETECTION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint16_t m_usBbIntegTimeCBF_;
    uint16_t m_usNbIntegTimeCBF_;

};

inline void swap(CTRMGR_LAS_B_TIME_DETECTION_CONTROL& a, CTRMGR_LAS_B_TIME_DETECTION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_B_TIME_DETECTION_CONTROL& sample);

class NDDSUSERDllExport CTRMGR_LAS_C_FREQ_DETECTION_CONTROL {
  public:
    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL();

    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint16_t usBbIntegTimeABF,uint16_t usNbIntegTimeABF);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL (CTRMGR_LAS_C_FREQ_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& operator=(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& operator=(const CTRMGR_LAS_C_FREQ_DETECTION_CONTROL&) = default;
    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL(const CTRMGR_LAS_C_FREQ_DETECTION_CONTROL&) = default;
    #else
    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& operator=(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint16_t& usBbIntegTimeABF() OMG_NOEXCEPT {
        return m_usBbIntegTimeABF_;
    }

    const uint16_t& usBbIntegTimeABF() const OMG_NOEXCEPT {
        return m_usBbIntegTimeABF_;
    }

    void usBbIntegTimeABF(uint16_t value) {
        m_usBbIntegTimeABF_ = value;
    }

    uint16_t& usNbIntegTimeABF() OMG_NOEXCEPT {
        return m_usNbIntegTimeABF_;
    }

    const uint16_t& usNbIntegTimeABF() const OMG_NOEXCEPT {
        return m_usNbIntegTimeABF_;
    }

    void usNbIntegTimeABF(uint16_t value) {
        m_usNbIntegTimeABF_ = value;
    }

    bool operator == (const CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& other_) const;
    bool operator != (const CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& other_) const;

    void swap(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint16_t m_usBbIntegTimeABF_;
    uint16_t m_usNbIntegTimeABF_;

};

inline void swap(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& a, CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& sample);

class NDDSUSERDllExport CTRMGR_LAS_C_SENSOR_SIGNAL_DATA {
  public:
    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA();

    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< uint16_t, 240L>& aSensorStatus,const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA (CTRMGR_LAS_C_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& operator=(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& operator=(const CTRMGR_LAS_C_SENSOR_SIGNAL_DATA&) = default;
    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA(const CTRMGR_LAS_C_SENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& operator=(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< uint16_t, 240L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint16_t, 240L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint16_t, 240L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint16_t, 240L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< uint16_t, 240L> m_aSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L> m_aSensorSig_;

};

inline void swap(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& a, CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA {
  public:
    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA();

    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t usSensorGain,const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA (CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& operator=(const CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA&) = default;
    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA(const CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA&) = default;
    #else
    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_usSensorGain_;
    ::dds::core::array< ::dds::core::array< uint16_t, 2048L>, 240L> m_aSensorSig_;

};

inline void swap(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& a, CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_C_TIME_DETECTION_CONTROL {
  public:
    CTRMGR_LAS_C_TIME_DETECTION_CONTROL();

    CTRMGR_LAS_C_TIME_DETECTION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t reserved,uint16_t usBbIntegTimeCBF,uint16_t usNbIntegTimeCBF);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_C_TIME_DETECTION_CONTROL (CTRMGR_LAS_C_TIME_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_C_TIME_DETECTION_CONTROL& operator=(CTRMGR_LAS_C_TIME_DETECTION_CONTROL&&) = default;
    CTRMGR_LAS_C_TIME_DETECTION_CONTROL& operator=(const CTRMGR_LAS_C_TIME_DETECTION_CONTROL&) = default;
    CTRMGR_LAS_C_TIME_DETECTION_CONTROL(const CTRMGR_LAS_C_TIME_DETECTION_CONTROL&) = default;
    #else
    CTRMGR_LAS_C_TIME_DETECTION_CONTROL(CTRMGR_LAS_C_TIME_DETECTION_CONTROL&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_C_TIME_DETECTION_CONTROL& operator=(CTRMGR_LAS_C_TIME_DETECTION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    uint16_t& usBbIntegTimeCBF() OMG_NOEXCEPT {
        return m_usBbIntegTimeCBF_;
    }

    const uint16_t& usBbIntegTimeCBF() const OMG_NOEXCEPT {
        return m_usBbIntegTimeCBF_;
    }

    void usBbIntegTimeCBF(uint16_t value) {
        m_usBbIntegTimeCBF_ = value;
    }

    uint16_t& usNbIntegTimeCBF() OMG_NOEXCEPT {
        return m_usNbIntegTimeCBF_;
    }

    const uint16_t& usNbIntegTimeCBF() const OMG_NOEXCEPT {
        return m_usNbIntegTimeCBF_;
    }

    void usNbIntegTimeCBF(uint16_t value) {
        m_usNbIntegTimeCBF_ = value;
    }

    bool operator == (const CTRMGR_LAS_C_TIME_DETECTION_CONTROL& other_) const;
    bool operator != (const CTRMGR_LAS_C_TIME_DETECTION_CONTROL& other_) const;

    void swap(CTRMGR_LAS_C_TIME_DETECTION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    uint16_t m_usBbIntegTimeCBF_;
    uint16_t m_usNbIntegTimeCBF_;

};

inline void swap(CTRMGR_LAS_C_TIME_DETECTION_CONTROL& a, CTRMGR_LAS_C_TIME_DETECTION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_C_TIME_DETECTION_CONTROL& sample);

class NDDSUSERDllExport ST_LAS_TIME_DM_DETECTION_DATA {
  public:
    ST_LAS_TIME_DM_DETECTION_DATA();

    ST_LAS_TIME_DM_DETECTION_DATA(uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisID,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBBIntegrationTime,uint16_t usNBIntegrationTime,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDEMONOutput,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDEMONOutput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_TIME_DM_DETECTION_DATA (ST_LAS_TIME_DM_DETECTION_DATA&&) = default;
    ST_LAS_TIME_DM_DETECTION_DATA& operator=(ST_LAS_TIME_DM_DETECTION_DATA&&) = default;
    ST_LAS_TIME_DM_DETECTION_DATA& operator=(const ST_LAS_TIME_DM_DETECTION_DATA&) = default;
    ST_LAS_TIME_DM_DETECTION_DATA(const ST_LAS_TIME_DM_DETECTION_DATA&) = default;
    #else
    ST_LAS_TIME_DM_DETECTION_DATA(ST_LAS_TIME_DM_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    ST_LAS_TIME_DM_DETECTION_DATA& operator=(ST_LAS_TIME_DM_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBBIntegrationTime() OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    const uint16_t& usBBIntegrationTime() const OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    void usBBIntegrationTime(uint16_t value) {
        m_usBBIntegrationTime_ = value;
    }

    uint16_t& usNBIntegrationTime() OMG_NOEXCEPT {
        return m_usNBIntegrationTime_;
    }

    const uint16_t& usNBIntegrationTime() const OMG_NOEXCEPT {
        return m_usNBIntegrationTime_;
    }

    void usNBIntegrationTime(uint16_t value) {
        m_usNBIntegrationTime_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDEMONOutput() OMG_NOEXCEPT {
        return m_aNormDEMONOutput_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDEMONOutput() const OMG_NOEXCEPT {
        return m_aNormDEMONOutput_;
    }

    void aNormDEMONOutput(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aNormDEMONOutput_ = value;
    }

    void aNormDEMONOutput(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aNormDEMONOutput_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDEMONOutput() OMG_NOEXCEPT {
        return m_aDEMONOutput_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDEMONOutput() const OMG_NOEXCEPT {
        return m_aDEMONOutput_;
    }

    void aDEMONOutput(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aDEMONOutput_ = value;
    }

    void aDEMONOutput(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aDEMONOutput_ = std::move(value);
    }

    bool operator == (const ST_LAS_TIME_DM_DETECTION_DATA& other_) const;
    bool operator != (const ST_LAS_TIME_DM_DETECTION_DATA& other_) const;

    void swap(ST_LAS_TIME_DM_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisID_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBBIntegrationTime_;
    uint16_t m_usNBIntegrationTime_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aNormDEMONOutput_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aDEMONOutput_;

};

inline void swap(ST_LAS_TIME_DM_DETECTION_DATA& a, ST_LAS_TIME_DM_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_TIME_DM_DETECTION_DATA& sample);

class NDDSUSERDllExport ST_LAS_FREQ_DM_DETECTION_DATA {
  public:
    ST_LAS_FREQ_DM_DETECTION_DATA();

    ST_LAS_FREQ_DM_DETECTION_DATA(uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisID,uint16_t usBBIntegrationTime,uint16_t unNBIntegrationTime,uint16_t usReserved,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_FREQ_DM_DETECTION_DATA (ST_LAS_FREQ_DM_DETECTION_DATA&&) = default;
    ST_LAS_FREQ_DM_DETECTION_DATA& operator=(ST_LAS_FREQ_DM_DETECTION_DATA&&) = default;
    ST_LAS_FREQ_DM_DETECTION_DATA& operator=(const ST_LAS_FREQ_DM_DETECTION_DATA&) = default;
    ST_LAS_FREQ_DM_DETECTION_DATA(const ST_LAS_FREQ_DM_DETECTION_DATA&) = default;
    #else
    ST_LAS_FREQ_DM_DETECTION_DATA(ST_LAS_FREQ_DM_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    ST_LAS_FREQ_DM_DETECTION_DATA& operator=(ST_LAS_FREQ_DM_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    uint16_t& usBBIntegrationTime() OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    const uint16_t& usBBIntegrationTime() const OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    void usBBIntegrationTime(uint16_t value) {
        m_usBBIntegrationTime_ = value;
    }

    uint16_t& unNBIntegrationTime() OMG_NOEXCEPT {
        return m_unNBIntegrationTime_;
    }

    const uint16_t& unNBIntegrationTime() const OMG_NOEXCEPT {
        return m_unNBIntegrationTime_;
    }

    void unNBIntegrationTime(uint16_t value) {
        m_unNBIntegrationTime_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }

    bool operator == (const ST_LAS_FREQ_DM_DETECTION_DATA& other_) const;
    bool operator != (const ST_LAS_FREQ_DM_DETECTION_DATA& other_) const;

    void swap(ST_LAS_FREQ_DM_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisID_;
    uint16_t m_usBBIntegrationTime_;
    uint16_t m_unNBIntegrationTime_;
    uint16_t m_usReserved_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;

};

inline void swap(ST_LAS_FREQ_DM_DETECTION_DATA& a, ST_LAS_FREQ_DM_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_FREQ_DM_DETECTION_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_DETECTION_DATA {
  public:
    CTRMGR_LAS_DETECTION_DATA();

    CTRMGR_LAS_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisFaultStatus,const ::dds::core::array< ST_LAS_TIME_DM_DETECTION_DATA, 3L>& stTimeDmDetectionData,const ::dds::core::array< ST_LAS_FREQ_DM_DETECTION_DATA, 3L>& stFreqDmDetectionData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_DETECTION_DATA (CTRMGR_LAS_DETECTION_DATA&&) = default;
    CTRMGR_LAS_DETECTION_DATA& operator=(CTRMGR_LAS_DETECTION_DATA&&) = default;
    CTRMGR_LAS_DETECTION_DATA& operator=(const CTRMGR_LAS_DETECTION_DATA&) = default;
    CTRMGR_LAS_DETECTION_DATA(const CTRMGR_LAS_DETECTION_DATA&) = default;
    #else
    CTRMGR_LAS_DETECTION_DATA(CTRMGR_LAS_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_DETECTION_DATA& operator=(CTRMGR_LAS_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisFaultStatus() OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    const uint16_t& usAxisFaultStatus() const OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    void usAxisFaultStatus(uint16_t value) {
        m_usAxisFaultStatus_ = value;
    }

    ::dds::core::array< ST_LAS_TIME_DM_DETECTION_DATA, 3L>& stTimeDmDetectionData() OMG_NOEXCEPT {
        return m_stTimeDmDetectionData_;
    }

    const ::dds::core::array< ST_LAS_TIME_DM_DETECTION_DATA, 3L>& stTimeDmDetectionData() const OMG_NOEXCEPT {
        return m_stTimeDmDetectionData_;
    }

    void stTimeDmDetectionData(const ::dds::core::array< ST_LAS_TIME_DM_DETECTION_DATA, 3L>& value) {
        m_stTimeDmDetectionData_ = value;
    }

    void stTimeDmDetectionData(::dds::core::array< ST_LAS_TIME_DM_DETECTION_DATA, 3L>&& value) {
        m_stTimeDmDetectionData_ = std::move(value);
    }
    ::dds::core::array< ST_LAS_FREQ_DM_DETECTION_DATA, 3L>& stFreqDmDetectionData() OMG_NOEXCEPT {
        return m_stFreqDmDetectionData_;
    }

    const ::dds::core::array< ST_LAS_FREQ_DM_DETECTION_DATA, 3L>& stFreqDmDetectionData() const OMG_NOEXCEPT {
        return m_stFreqDmDetectionData_;
    }

    void stFreqDmDetectionData(const ::dds::core::array< ST_LAS_FREQ_DM_DETECTION_DATA, 3L>& value) {
        m_stFreqDmDetectionData_ = value;
    }

    void stFreqDmDetectionData(::dds::core::array< ST_LAS_FREQ_DM_DETECTION_DATA, 3L>&& value) {
        m_stFreqDmDetectionData_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_DETECTION_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_DETECTION_DATA& other_) const;

    void swap(CTRMGR_LAS_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisFaultStatus_;
    ::dds::core::array< ST_LAS_TIME_DM_DETECTION_DATA, 3L> m_stTimeDmDetectionData_;
    ::dds::core::array< ST_LAS_FREQ_DM_DETECTION_DATA, 3L> m_stFreqDmDetectionData_;

};

inline void swap(CTRMGR_LAS_DETECTION_DATA& a, CTRMGR_LAS_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_DETECTION_DATA& sample);

class NDDSUSERDllExport ST_LAS_ENE_DATA {
  public:
    ST_LAS_ENE_DATA();

    ST_LAS_ENE_DATA(uint32_t ulFrameNo,uint16_t usAxisID,uint16_t usReserved,const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aENEOutput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_ENE_DATA (ST_LAS_ENE_DATA&&) = default;
    ST_LAS_ENE_DATA& operator=(ST_LAS_ENE_DATA&&) = default;
    ST_LAS_ENE_DATA& operator=(const ST_LAS_ENE_DATA&) = default;
    ST_LAS_ENE_DATA(const ST_LAS_ENE_DATA&) = default;
    #else
    ST_LAS_ENE_DATA(ST_LAS_ENE_DATA&& other_) OMG_NOEXCEPT;  
    ST_LAS_ENE_DATA& operator=(ST_LAS_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aENEOutput() OMG_NOEXCEPT {
        return m_aENEOutput_;
    }

    const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aENEOutput() const OMG_NOEXCEPT {
        return m_aENEOutput_;
    }

    void aENEOutput(const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& value) {
        m_aENEOutput_ = value;
    }

    void aENEOutput(::dds::core::array< ::dds::core::array< float, 15L>, 256L>&& value) {
        m_aENEOutput_ = std::move(value);
    }

    bool operator == (const ST_LAS_ENE_DATA& other_) const;
    bool operator != (const ST_LAS_ENE_DATA& other_) const;

    void swap(ST_LAS_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisID_;
    uint16_t m_usReserved_;
    ::dds::core::array< ::dds::core::array< float, 15L>, 256L> m_aENEOutput_;

};

inline void swap(ST_LAS_ENE_DATA& a, ST_LAS_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_ENE_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_ENE_DATA {
  public:
    CTRMGR_LAS_ENE_DATA();

    CTRMGR_LAS_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisFaultStatus,const ::dds::core::array< ST_LAS_ENE_DATA, 3L>& stENEData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_ENE_DATA (CTRMGR_LAS_ENE_DATA&&) = default;
    CTRMGR_LAS_ENE_DATA& operator=(CTRMGR_LAS_ENE_DATA&&) = default;
    CTRMGR_LAS_ENE_DATA& operator=(const CTRMGR_LAS_ENE_DATA&) = default;
    CTRMGR_LAS_ENE_DATA(const CTRMGR_LAS_ENE_DATA&) = default;
    #else
    CTRMGR_LAS_ENE_DATA(CTRMGR_LAS_ENE_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_ENE_DATA& operator=(CTRMGR_LAS_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisFaultStatus() OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    const uint16_t& usAxisFaultStatus() const OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    void usAxisFaultStatus(uint16_t value) {
        m_usAxisFaultStatus_ = value;
    }

    ::dds::core::array< ST_LAS_ENE_DATA, 3L>& stENEData() OMG_NOEXCEPT {
        return m_stENEData_;
    }

    const ::dds::core::array< ST_LAS_ENE_DATA, 3L>& stENEData() const OMG_NOEXCEPT {
        return m_stENEData_;
    }

    void stENEData(const ::dds::core::array< ST_LAS_ENE_DATA, 3L>& value) {
        m_stENEData_ = value;
    }

    void stENEData(::dds::core::array< ST_LAS_ENE_DATA, 3L>&& value) {
        m_stENEData_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_ENE_DATA& other_) const;
    bool operator != (const CTRMGR_LAS_ENE_DATA& other_) const;

    void swap(CTRMGR_LAS_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisFaultStatus_;
    ::dds::core::array< ST_LAS_ENE_DATA, 3L> m_stENEData_;

};

inline void swap(CTRMGR_LAS_ENE_DATA& a, CTRMGR_LAS_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_ENE_DATA& sample);

class NDDSUSERDllExport CTRMGR_LAS_SENSOR_IFC_STATUS {
  public:
    CTRMGR_LAS_SENSOR_IFC_STATUS();

    CTRMGR_LAS_SENSOR_IFC_STATUS(const ST_MSG_HEADER& stMsgHeader,const ST_SENSOR_IFC_STATUS& stSensorIFCStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_SENSOR_IFC_STATUS (CTRMGR_LAS_SENSOR_IFC_STATUS&&) = default;
    CTRMGR_LAS_SENSOR_IFC_STATUS& operator=(CTRMGR_LAS_SENSOR_IFC_STATUS&&) = default;
    CTRMGR_LAS_SENSOR_IFC_STATUS& operator=(const CTRMGR_LAS_SENSOR_IFC_STATUS&) = default;
    CTRMGR_LAS_SENSOR_IFC_STATUS(const CTRMGR_LAS_SENSOR_IFC_STATUS&) = default;
    #else
    CTRMGR_LAS_SENSOR_IFC_STATUS(CTRMGR_LAS_SENSOR_IFC_STATUS&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_SENSOR_IFC_STATUS& operator=(CTRMGR_LAS_SENSOR_IFC_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_SENSOR_IFC_STATUS& stSensorIFCStatus() OMG_NOEXCEPT {
        return m_stSensorIFCStatus_;
    }

    const ST_SENSOR_IFC_STATUS& stSensorIFCStatus() const OMG_NOEXCEPT {
        return m_stSensorIFCStatus_;
    }

    void stSensorIFCStatus(const ST_SENSOR_IFC_STATUS& value) {
        m_stSensorIFCStatus_ = value;
    }

    void stSensorIFCStatus(ST_SENSOR_IFC_STATUS&& value) {
        m_stSensorIFCStatus_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_SENSOR_IFC_STATUS& other_) const;
    bool operator != (const CTRMGR_LAS_SENSOR_IFC_STATUS& other_) const;

    void swap(CTRMGR_LAS_SENSOR_IFC_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_SENSOR_IFC_STATUS m_stSensorIFCStatus_;

};

inline void swap(CTRMGR_LAS_SENSOR_IFC_STATUS& a, CTRMGR_LAS_SENSOR_IFC_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_SENSOR_IFC_STATUS& sample);

class NDDSUSERDllExport CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT {
  public:
    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT();

    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 3L>& usPowerCtrlResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT (CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT&&) = default;
    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& operator=(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT&&) = default;
    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& operator=(const CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT&) = default;
    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT(const CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT&) = default;
    #else
    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& operator=(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 3L>& usPowerCtrlResult() OMG_NOEXCEPT {
        return m_usPowerCtrlResult_;
    }

    const ::dds::core::array< uint16_t, 3L>& usPowerCtrlResult() const OMG_NOEXCEPT {
        return m_usPowerCtrlResult_;
    }

    void usPowerCtrlResult(const ::dds::core::array< uint16_t, 3L>& value) {
        m_usPowerCtrlResult_ = value;
    }

    void usPowerCtrlResult(::dds::core::array< uint16_t, 3L>&& value) {
        m_usPowerCtrlResult_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& other_) const;
    bool operator != (const CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& other_) const;

    void swap(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 3L> m_usPowerCtrlResult_;

};

inline void swap(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& a, CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& sample);

class NDDSUSERDllExport ST_LAS_SENSOR_STATUS {
  public:
    ST_LAS_SENSOR_STATUS();

    ST_LAS_SENSOR_STATUS(uint8_t oAxisID,uint8_t oMainMUXID,uint8_t oEOSwitch1ID,uint8_t oMainMuxFPGAStatus,uint8_t oSwitchCircuitFPGAStatusA,uint8_t oSwitchCircuitFPGAStatusB,uint8_t oSwitchCircuitStatusA,uint8_t oSwitchCircuitStatusB,uint8_t oMainMuxStatusA,uint8_t oMainMuxStatusB,uint8_t oSensorGain,uint8_t oEOSwitch2ID,const ::dds::core::array< uint8_t, 240L>& aSensorStatus,const ::dds::core::array< uint8_t, 28L>& aSubMuxStatus,uint16_t usSensorGainCtrlMode,const ::dds::core::array< float, 240L>& aSensorEnergy,float fTotalEnergy,uint32_t ulFrameNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_SENSOR_STATUS (ST_LAS_SENSOR_STATUS&&) = default;
    ST_LAS_SENSOR_STATUS& operator=(ST_LAS_SENSOR_STATUS&&) = default;
    ST_LAS_SENSOR_STATUS& operator=(const ST_LAS_SENSOR_STATUS&) = default;
    ST_LAS_SENSOR_STATUS(const ST_LAS_SENSOR_STATUS&) = default;
    #else
    ST_LAS_SENSOR_STATUS(ST_LAS_SENSOR_STATUS&& other_) OMG_NOEXCEPT;  
    ST_LAS_SENSOR_STATUS& operator=(ST_LAS_SENSOR_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oMainMUXID() OMG_NOEXCEPT {
        return m_oMainMUXID_;
    }

    const uint8_t& oMainMUXID() const OMG_NOEXCEPT {
        return m_oMainMUXID_;
    }

    void oMainMUXID(uint8_t value) {
        m_oMainMUXID_ = value;
    }

    uint8_t& oEOSwitch1ID() OMG_NOEXCEPT {
        return m_oEOSwitch1ID_;
    }

    const uint8_t& oEOSwitch1ID() const OMG_NOEXCEPT {
        return m_oEOSwitch1ID_;
    }

    void oEOSwitch1ID(uint8_t value) {
        m_oEOSwitch1ID_ = value;
    }

    uint8_t& oMainMuxFPGAStatus() OMG_NOEXCEPT {
        return m_oMainMuxFPGAStatus_;
    }

    const uint8_t& oMainMuxFPGAStatus() const OMG_NOEXCEPT {
        return m_oMainMuxFPGAStatus_;
    }

    void oMainMuxFPGAStatus(uint8_t value) {
        m_oMainMuxFPGAStatus_ = value;
    }

    uint8_t& oSwitchCircuitFPGAStatusA() OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusA_;
    }

    const uint8_t& oSwitchCircuitFPGAStatusA() const OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusA_;
    }

    void oSwitchCircuitFPGAStatusA(uint8_t value) {
        m_oSwitchCircuitFPGAStatusA_ = value;
    }

    uint8_t& oSwitchCircuitFPGAStatusB() OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusB_;
    }

    const uint8_t& oSwitchCircuitFPGAStatusB() const OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusB_;
    }

    void oSwitchCircuitFPGAStatusB(uint8_t value) {
        m_oSwitchCircuitFPGAStatusB_ = value;
    }

    uint8_t& oSwitchCircuitStatusA() OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusA_;
    }

    const uint8_t& oSwitchCircuitStatusA() const OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusA_;
    }

    void oSwitchCircuitStatusA(uint8_t value) {
        m_oSwitchCircuitStatusA_ = value;
    }

    uint8_t& oSwitchCircuitStatusB() OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusB_;
    }

    const uint8_t& oSwitchCircuitStatusB() const OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusB_;
    }

    void oSwitchCircuitStatusB(uint8_t value) {
        m_oSwitchCircuitStatusB_ = value;
    }

    uint8_t& oMainMuxStatusA() OMG_NOEXCEPT {
        return m_oMainMuxStatusA_;
    }

    const uint8_t& oMainMuxStatusA() const OMG_NOEXCEPT {
        return m_oMainMuxStatusA_;
    }

    void oMainMuxStatusA(uint8_t value) {
        m_oMainMuxStatusA_ = value;
    }

    uint8_t& oMainMuxStatusB() OMG_NOEXCEPT {
        return m_oMainMuxStatusB_;
    }

    const uint8_t& oMainMuxStatusB() const OMG_NOEXCEPT {
        return m_oMainMuxStatusB_;
    }

    void oMainMuxStatusB(uint8_t value) {
        m_oMainMuxStatusB_ = value;
    }

    uint8_t& oSensorGain() OMG_NOEXCEPT {
        return m_oSensorGain_;
    }

    const uint8_t& oSensorGain() const OMG_NOEXCEPT {
        return m_oSensorGain_;
    }

    void oSensorGain(uint8_t value) {
        m_oSensorGain_ = value;
    }

    uint8_t& oEOSwitch2ID() OMG_NOEXCEPT {
        return m_oEOSwitch2ID_;
    }

    const uint8_t& oEOSwitch2ID() const OMG_NOEXCEPT {
        return m_oEOSwitch2ID_;
    }

    void oEOSwitch2ID(uint8_t value) {
        m_oEOSwitch2ID_ = value;
    }

    ::dds::core::array< uint8_t, 240L>& aSensorStatus() OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    const ::dds::core::array< uint8_t, 240L>& aSensorStatus() const OMG_NOEXCEPT {
        return m_aSensorStatus_;
    }

    void aSensorStatus(const ::dds::core::array< uint8_t, 240L>& value) {
        m_aSensorStatus_ = value;
    }

    void aSensorStatus(::dds::core::array< uint8_t, 240L>&& value) {
        m_aSensorStatus_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 28L>& aSubMuxStatus() OMG_NOEXCEPT {
        return m_aSubMuxStatus_;
    }

    const ::dds::core::array< uint8_t, 28L>& aSubMuxStatus() const OMG_NOEXCEPT {
        return m_aSubMuxStatus_;
    }

    void aSubMuxStatus(const ::dds::core::array< uint8_t, 28L>& value) {
        m_aSubMuxStatus_ = value;
    }

    void aSubMuxStatus(::dds::core::array< uint8_t, 28L>&& value) {
        m_aSubMuxStatus_ = std::move(value);
    }
    uint16_t& usSensorGainCtrlMode() OMG_NOEXCEPT {
        return m_usSensorGainCtrlMode_;
    }

    const uint16_t& usSensorGainCtrlMode() const OMG_NOEXCEPT {
        return m_usSensorGainCtrlMode_;
    }

    void usSensorGainCtrlMode(uint16_t value) {
        m_usSensorGainCtrlMode_ = value;
    }

    ::dds::core::array< float, 240L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 240L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 240L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 240L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    bool operator == (const ST_LAS_SENSOR_STATUS& other_) const;
    bool operator != (const ST_LAS_SENSOR_STATUS& other_) const;

    void swap(ST_LAS_SENSOR_STATUS& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAxisID_;
    uint8_t m_oMainMUXID_;
    uint8_t m_oEOSwitch1ID_;
    uint8_t m_oMainMuxFPGAStatus_;
    uint8_t m_oSwitchCircuitFPGAStatusA_;
    uint8_t m_oSwitchCircuitFPGAStatusB_;
    uint8_t m_oSwitchCircuitStatusA_;
    uint8_t m_oSwitchCircuitStatusB_;
    uint8_t m_oMainMuxStatusA_;
    uint8_t m_oMainMuxStatusB_;
    uint8_t m_oSensorGain_;
    uint8_t m_oEOSwitch2ID_;
    ::dds::core::array< uint8_t, 240L> m_aSensorStatus_;
    ::dds::core::array< uint8_t, 28L> m_aSubMuxStatus_;
    uint16_t m_usSensorGainCtrlMode_;
    ::dds::core::array< float, 240L> m_aSensorEnergy_;
    float m_fTotalEnergy_;
    uint32_t m_ulFrameNo_;

};

inline void swap(ST_LAS_SENSOR_STATUS& a, ST_LAS_SENSOR_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_SENSOR_STATUS& sample);

class NDDSUSERDllExport CTRMGR_LAS_SENSOR_STATUS {
  public:
    CTRMGR_LAS_SENSOR_STATUS();

    CTRMGR_LAS_SENSOR_STATUS(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& stSensorStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_LAS_SENSOR_STATUS (CTRMGR_LAS_SENSOR_STATUS&&) = default;
    CTRMGR_LAS_SENSOR_STATUS& operator=(CTRMGR_LAS_SENSOR_STATUS&&) = default;
    CTRMGR_LAS_SENSOR_STATUS& operator=(const CTRMGR_LAS_SENSOR_STATUS&) = default;
    CTRMGR_LAS_SENSOR_STATUS(const CTRMGR_LAS_SENSOR_STATUS&) = default;
    #else
    CTRMGR_LAS_SENSOR_STATUS(CTRMGR_LAS_SENSOR_STATUS&& other_) OMG_NOEXCEPT;  
    CTRMGR_LAS_SENSOR_STATUS& operator=(CTRMGR_LAS_SENSOR_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& stSensorStatus() OMG_NOEXCEPT {
        return m_stSensorStatus_;
    }

    const ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& stSensorStatus() const OMG_NOEXCEPT {
        return m_stSensorStatus_;
    }

    void stSensorStatus(const ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& value) {
        m_stSensorStatus_ = value;
    }

    void stSensorStatus(::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>&& value) {
        m_stSensorStatus_ = std::move(value);
    }

    bool operator == (const CTRMGR_LAS_SENSOR_STATUS& other_) const;
    bool operator != (const CTRMGR_LAS_SENSOR_STATUS& other_) const;

    void swap(CTRMGR_LAS_SENSOR_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L> m_stSensorStatus_;

};

inline void swap(CTRMGR_LAS_SENSOR_STATUS& a, CTRMGR_LAS_SENSOR_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_LAS_SENSOR_STATUS& sample);

class NDDSUSERDllExport ST_MAS_DETECTION_EXCLUSION_FREQ_INFO {
  public:
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO();

    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO(uint16_t unNoOfBbdExcFreq,const ::dds::core::array< uint16_t, 10L>& unBbdExcStartFreq,const ::dds::core::array< uint16_t, 10L>& unBbdExcEndFreq,uint16_t unNoOfNbdExcFreq,const ::dds::core::array< uint16_t, 30L>& unNbdExcStartFreq,const ::dds::core::array< uint16_t, 30L>& unNbdExcEndFreq);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO (ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&&) = default;
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& operator=(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&&) = default;
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& operator=(const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&) = default;
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO(const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&) = default;
    #else
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&& other_) OMG_NOEXCEPT;  
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& operator=(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& unNoOfBbdExcFreq() OMG_NOEXCEPT {
        return m_unNoOfBbdExcFreq_;
    }

    const uint16_t& unNoOfBbdExcFreq() const OMG_NOEXCEPT {
        return m_unNoOfBbdExcFreq_;
    }

    void unNoOfBbdExcFreq(uint16_t value) {
        m_unNoOfBbdExcFreq_ = value;
    }

    ::dds::core::array< uint16_t, 10L>& unBbdExcStartFreq() OMG_NOEXCEPT {
        return m_unBbdExcStartFreq_;
    }

    const ::dds::core::array< uint16_t, 10L>& unBbdExcStartFreq() const OMG_NOEXCEPT {
        return m_unBbdExcStartFreq_;
    }

    void unBbdExcStartFreq(const ::dds::core::array< uint16_t, 10L>& value) {
        m_unBbdExcStartFreq_ = value;
    }

    void unBbdExcStartFreq(::dds::core::array< uint16_t, 10L>&& value) {
        m_unBbdExcStartFreq_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 10L>& unBbdExcEndFreq() OMG_NOEXCEPT {
        return m_unBbdExcEndFreq_;
    }

    const ::dds::core::array< uint16_t, 10L>& unBbdExcEndFreq() const OMG_NOEXCEPT {
        return m_unBbdExcEndFreq_;
    }

    void unBbdExcEndFreq(const ::dds::core::array< uint16_t, 10L>& value) {
        m_unBbdExcEndFreq_ = value;
    }

    void unBbdExcEndFreq(::dds::core::array< uint16_t, 10L>&& value) {
        m_unBbdExcEndFreq_ = std::move(value);
    }
    uint16_t& unNoOfNbdExcFreq() OMG_NOEXCEPT {
        return m_unNoOfNbdExcFreq_;
    }

    const uint16_t& unNoOfNbdExcFreq() const OMG_NOEXCEPT {
        return m_unNoOfNbdExcFreq_;
    }

    void unNoOfNbdExcFreq(uint16_t value) {
        m_unNoOfNbdExcFreq_ = value;
    }

    ::dds::core::array< uint16_t, 30L>& unNbdExcStartFreq() OMG_NOEXCEPT {
        return m_unNbdExcStartFreq_;
    }

    const ::dds::core::array< uint16_t, 30L>& unNbdExcStartFreq() const OMG_NOEXCEPT {
        return m_unNbdExcStartFreq_;
    }

    void unNbdExcStartFreq(const ::dds::core::array< uint16_t, 30L>& value) {
        m_unNbdExcStartFreq_ = value;
    }

    void unNbdExcStartFreq(::dds::core::array< uint16_t, 30L>&& value) {
        m_unNbdExcStartFreq_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 30L>& unNbdExcEndFreq() OMG_NOEXCEPT {
        return m_unNbdExcEndFreq_;
    }

    const ::dds::core::array< uint16_t, 30L>& unNbdExcEndFreq() const OMG_NOEXCEPT {
        return m_unNbdExcEndFreq_;
    }

    void unNbdExcEndFreq(const ::dds::core::array< uint16_t, 30L>& value) {
        m_unNbdExcEndFreq_ = value;
    }

    void unNbdExcEndFreq(::dds::core::array< uint16_t, 30L>&& value) {
        m_unNbdExcEndFreq_ = std::move(value);
    }

    bool operator == (const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& other_) const;
    bool operator != (const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& other_) const;

    void swap(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_unNoOfBbdExcFreq_;
    ::dds::core::array< uint16_t, 10L> m_unBbdExcStartFreq_;
    ::dds::core::array< uint16_t, 10L> m_unBbdExcEndFreq_;
    uint16_t m_unNoOfNbdExcFreq_;
    ::dds::core::array< uint16_t, 30L> m_unNbdExcStartFreq_;
    ::dds::core::array< uint16_t, 30L> m_unNbdExcEndFreq_;

};

inline void swap(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& a, ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& sample);

class NDDSUSERDllExport CTRMGR_MAS_DETECTION_CONTROL {
  public:
    CTRMGR_MAS_DETECTION_CONTROL();

    CTRMGR_MAS_DETECTION_CONTROL(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 2L>& usIntegTime,const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_DETECTION_CONTROL (CTRMGR_MAS_DETECTION_CONTROL&&) = default;
    CTRMGR_MAS_DETECTION_CONTROL& operator=(CTRMGR_MAS_DETECTION_CONTROL&&) = default;
    CTRMGR_MAS_DETECTION_CONTROL& operator=(const CTRMGR_MAS_DETECTION_CONTROL&) = default;
    CTRMGR_MAS_DETECTION_CONTROL(const CTRMGR_MAS_DETECTION_CONTROL&) = default;
    #else
    CTRMGR_MAS_DETECTION_CONTROL(CTRMGR_MAS_DETECTION_CONTROL&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_DETECTION_CONTROL& operator=(CTRMGR_MAS_DETECTION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& usIntegTime() OMG_NOEXCEPT {
        return m_usIntegTime_;
    }

    const ::dds::core::array< uint16_t, 2L>& usIntegTime() const OMG_NOEXCEPT {
        return m_usIntegTime_;
    }

    void usIntegTime(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usIntegTime_ = value;
    }

    void usIntegTime(::dds::core::array< uint16_t, 2L>&& value) {
        m_usIntegTime_ = std::move(value);
    }
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() const OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    void stMASDetFreqExcInfo(const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& value) {
        m_stMASDetFreqExcInfo_ = value;
    }

    void stMASDetFreqExcInfo(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&& value) {
        m_stMASDetFreqExcInfo_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_DETECTION_CONTROL& other_) const;
    bool operator != (const CTRMGR_MAS_DETECTION_CONTROL& other_) const;

    void swap(CTRMGR_MAS_DETECTION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 2L> m_usIntegTime_;
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO m_stMASDetFreqExcInfo_;

};

inline void swap(CTRMGR_MAS_DETECTION_CONTROL& a, CTRMGR_MAS_DETECTION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_DETECTION_CONTROL& sample);

class NDDSUSERDllExport ST_MAS_DETECTION_DATA {
  public:
    ST_MAS_DETECTION_DATA();

    ST_MAS_DETECTION_DATA(uint16_t usReserved,uint16_t usSensorGain,uint16_t usNBIntegrationTime,const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo,const ::dds::core::array< float, 800L>& aBBDEngInfo,const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& aNBDEngInfo,const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& aLOFARSigNorm,const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& aDEMONSig,const ::dds::core::array< float, 800L>& aMagTgtDetectionInfo,const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& aMagTgtDetectionInfoAxis,const ::dds::core::array< float, 49L>& fALineMagSyntheSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_DETECTION_DATA (ST_MAS_DETECTION_DATA&&) = default;
    ST_MAS_DETECTION_DATA& operator=(ST_MAS_DETECTION_DATA&&) = default;
    ST_MAS_DETECTION_DATA& operator=(const ST_MAS_DETECTION_DATA&) = default;
    ST_MAS_DETECTION_DATA(const ST_MAS_DETECTION_DATA&) = default;
    #else
    ST_MAS_DETECTION_DATA(ST_MAS_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    ST_MAS_DETECTION_DATA& operator=(ST_MAS_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usNBIntegrationTime() OMG_NOEXCEPT {
        return m_usNBIntegrationTime_;
    }

    const uint16_t& usNBIntegrationTime() const OMG_NOEXCEPT {
        return m_usNBIntegrationTime_;
    }

    void usNBIntegrationTime(uint16_t value) {
        m_usNBIntegrationTime_ = value;
    }

    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() const OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    void stMASDetFreqExcInfo(const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& value) {
        m_stMASDetFreqExcInfo_ = value;
    }

    void stMASDetFreqExcInfo(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&& value) {
        m_stMASDetFreqExcInfo_ = std::move(value);
    }
    ::dds::core::array< float, 800L>& aBBDEngInfo() OMG_NOEXCEPT {
        return m_aBBDEngInfo_;
    }

    const ::dds::core::array< float, 800L>& aBBDEngInfo() const OMG_NOEXCEPT {
        return m_aBBDEngInfo_;
    }

    void aBBDEngInfo(const ::dds::core::array< float, 800L>& value) {
        m_aBBDEngInfo_ = value;
    }

    void aBBDEngInfo(::dds::core::array< float, 800L>&& value) {
        m_aBBDEngInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& aNBDEngInfo() OMG_NOEXCEPT {
        return m_aNBDEngInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& aNBDEngInfo() const OMG_NOEXCEPT {
        return m_aNBDEngInfo_;
    }

    void aNBDEngInfo(const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& value) {
        m_aNBDEngInfo_ = value;
    }

    void aNBDEngInfo(::dds::core::array< ::dds::core::array< float, 800L>, 5L>&& value) {
        m_aNBDEngInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& aLOFARSigNorm() OMG_NOEXCEPT {
        return m_aLOFARSigNorm_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& aLOFARSigNorm() const OMG_NOEXCEPT {
        return m_aLOFARSigNorm_;
    }

    void aLOFARSigNorm(const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& value) {
        m_aLOFARSigNorm_ = value;
    }

    void aLOFARSigNorm(::dds::core::array< ::dds::core::array< float, 1601L>, 25L>&& value) {
        m_aLOFARSigNorm_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& aDEMONSig() OMG_NOEXCEPT {
        return m_aDEMONSig_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& aDEMONSig() const OMG_NOEXCEPT {
        return m_aDEMONSig_;
    }

    void aDEMONSig(const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& value) {
        m_aDEMONSig_ = value;
    }

    void aDEMONSig(::dds::core::array< ::dds::core::array< float, 1601L>, 25L>&& value) {
        m_aDEMONSig_ = std::move(value);
    }
    ::dds::core::array< float, 800L>& aMagTgtDetectionInfo() OMG_NOEXCEPT {
        return m_aMagTgtDetectionInfo_;
    }

    const ::dds::core::array< float, 800L>& aMagTgtDetectionInfo() const OMG_NOEXCEPT {
        return m_aMagTgtDetectionInfo_;
    }

    void aMagTgtDetectionInfo(const ::dds::core::array< float, 800L>& value) {
        m_aMagTgtDetectionInfo_ = value;
    }

    void aMagTgtDetectionInfo(::dds::core::array< float, 800L>&& value) {
        m_aMagTgtDetectionInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& aMagTgtDetectionInfoAxis() OMG_NOEXCEPT {
        return m_aMagTgtDetectionInfoAxis_;
    }

    const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& aMagTgtDetectionInfoAxis() const OMG_NOEXCEPT {
        return m_aMagTgtDetectionInfoAxis_;
    }

    void aMagTgtDetectionInfoAxis(const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& value) {
        m_aMagTgtDetectionInfoAxis_ = value;
    }

    void aMagTgtDetectionInfoAxis(::dds::core::array< ::dds::core::array< float, 49L>, 4L>&& value) {
        m_aMagTgtDetectionInfoAxis_ = std::move(value);
    }
    ::dds::core::array< float, 49L>& fALineMagSyntheSig() OMG_NOEXCEPT {
        return m_fALineMagSyntheSig_;
    }

    const ::dds::core::array< float, 49L>& fALineMagSyntheSig() const OMG_NOEXCEPT {
        return m_fALineMagSyntheSig_;
    }

    void fALineMagSyntheSig(const ::dds::core::array< float, 49L>& value) {
        m_fALineMagSyntheSig_ = value;
    }

    void fALineMagSyntheSig(::dds::core::array< float, 49L>&& value) {
        m_fALineMagSyntheSig_ = std::move(value);
    }

    bool operator == (const ST_MAS_DETECTION_DATA& other_) const;
    bool operator != (const ST_MAS_DETECTION_DATA& other_) const;

    void swap(ST_MAS_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usNBIntegrationTime_;
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO m_stMASDetFreqExcInfo_;
    ::dds::core::array< float, 800L> m_aBBDEngInfo_;
    ::dds::core::array< ::dds::core::array< float, 800L>, 5L> m_aNBDEngInfo_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L> m_aLOFARSigNorm_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L> m_aDEMONSig_;
    ::dds::core::array< float, 800L> m_aMagTgtDetectionInfo_;
    ::dds::core::array< ::dds::core::array< float, 49L>, 4L> m_aMagTgtDetectionInfoAxis_;
    ::dds::core::array< float, 49L> m_fALineMagSyntheSig_;

};

inline void swap(ST_MAS_DETECTION_DATA& a, ST_MAS_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_DETECTION_DATA& sample);

class NDDSUSERDllExport CTRMGR_MAS_DETECTION_DATA {
  public:
    CTRMGR_MAS_DETECTION_DATA();

    CTRMGR_MAS_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,const ::dds::core::array< ST_MAS_DETECTION_DATA, 2L>& aDetectionData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_DETECTION_DATA (CTRMGR_MAS_DETECTION_DATA&&) = default;
    CTRMGR_MAS_DETECTION_DATA& operator=(CTRMGR_MAS_DETECTION_DATA&&) = default;
    CTRMGR_MAS_DETECTION_DATA& operator=(const CTRMGR_MAS_DETECTION_DATA&) = default;
    CTRMGR_MAS_DETECTION_DATA(const CTRMGR_MAS_DETECTION_DATA&) = default;
    #else
    CTRMGR_MAS_DETECTION_DATA(CTRMGR_MAS_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_DETECTION_DATA& operator=(CTRMGR_MAS_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    ::dds::core::array< ST_MAS_DETECTION_DATA, 2L>& aDetectionData() OMG_NOEXCEPT {
        return m_aDetectionData_;
    }

    const ::dds::core::array< ST_MAS_DETECTION_DATA, 2L>& aDetectionData() const OMG_NOEXCEPT {
        return m_aDetectionData_;
    }

    void aDetectionData(const ::dds::core::array< ST_MAS_DETECTION_DATA, 2L>& value) {
        m_aDetectionData_ = value;
    }

    void aDetectionData(::dds::core::array< ST_MAS_DETECTION_DATA, 2L>&& value) {
        m_aDetectionData_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_DETECTION_DATA& other_) const;
    bool operator != (const CTRMGR_MAS_DETECTION_DATA& other_) const;

    void swap(CTRMGR_MAS_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    ::dds::core::array< ST_MAS_DETECTION_DATA, 2L> m_aDetectionData_;

};

inline void swap(CTRMGR_MAS_DETECTION_DATA& a, CTRMGR_MAS_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_DETECTION_DATA& sample);

class NDDSUSERDllExport ST_MAS_ENE_DATA {
  public:
    ST_MAS_ENE_DATA();

    ST_MAS_ENE_DATA(uint16_t usAxisID,const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aENEOutput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_ENE_DATA (ST_MAS_ENE_DATA&&) = default;
    ST_MAS_ENE_DATA& operator=(ST_MAS_ENE_DATA&&) = default;
    ST_MAS_ENE_DATA& operator=(const ST_MAS_ENE_DATA&) = default;
    ST_MAS_ENE_DATA(const ST_MAS_ENE_DATA&) = default;
    #else
    ST_MAS_ENE_DATA(ST_MAS_ENE_DATA&& other_) OMG_NOEXCEPT;  
    ST_MAS_ENE_DATA& operator=(ST_MAS_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aENEOutput() OMG_NOEXCEPT {
        return m_aENEOutput_;
    }

    const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aENEOutput() const OMG_NOEXCEPT {
        return m_aENEOutput_;
    }

    void aENEOutput(const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& value) {
        m_aENEOutput_ = value;
    }

    void aENEOutput(::dds::core::array< ::dds::core::array< float, 15L>, 25L>&& value) {
        m_aENEOutput_ = std::move(value);
    }

    bool operator == (const ST_MAS_ENE_DATA& other_) const;
    bool operator != (const ST_MAS_ENE_DATA& other_) const;

    void swap(ST_MAS_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usAxisID_;
    ::dds::core::array< ::dds::core::array< float, 15L>, 25L> m_aENEOutput_;

};

inline void swap(ST_MAS_ENE_DATA& a, ST_MAS_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_ENE_DATA& sample);

class NDDSUSERDllExport CTRMGR_MAS_ENE_DATA {
  public:
    CTRMGR_MAS_ENE_DATA();

    CTRMGR_MAS_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ::dds::core::array< ST_MAS_ENE_DATA, 2L>& aENEData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_ENE_DATA (CTRMGR_MAS_ENE_DATA&&) = default;
    CTRMGR_MAS_ENE_DATA& operator=(CTRMGR_MAS_ENE_DATA&&) = default;
    CTRMGR_MAS_ENE_DATA& operator=(const CTRMGR_MAS_ENE_DATA&) = default;
    CTRMGR_MAS_ENE_DATA(const CTRMGR_MAS_ENE_DATA&) = default;
    #else
    CTRMGR_MAS_ENE_DATA(CTRMGR_MAS_ENE_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_ENE_DATA& operator=(CTRMGR_MAS_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ::dds::core::array< ST_MAS_ENE_DATA, 2L>& aENEData() OMG_NOEXCEPT {
        return m_aENEData_;
    }

    const ::dds::core::array< ST_MAS_ENE_DATA, 2L>& aENEData() const OMG_NOEXCEPT {
        return m_aENEData_;
    }

    void aENEData(const ::dds::core::array< ST_MAS_ENE_DATA, 2L>& value) {
        m_aENEData_ = value;
    }

    void aENEData(::dds::core::array< ST_MAS_ENE_DATA, 2L>&& value) {
        m_aENEData_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_ENE_DATA& other_) const;
    bool operator != (const CTRMGR_MAS_ENE_DATA& other_) const;

    void swap(CTRMGR_MAS_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ::dds::core::array< ST_MAS_ENE_DATA, 2L> m_aENEData_;

};

inline void swap(CTRMGR_MAS_ENE_DATA& a, CTRMGR_MAS_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_ENE_DATA& sample);

class NDDSUSERDllExport CTRMGR_MAS_SENSOR_IFC_STATUS {
  public:
    CTRMGR_MAS_SENSOR_IFC_STATUS();

    CTRMGR_MAS_SENSOR_IFC_STATUS(const ST_MSG_HEADER& stMsgHeader,const ST_SENSOR_IFC_STATUS& stSensorIFCStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_SENSOR_IFC_STATUS (CTRMGR_MAS_SENSOR_IFC_STATUS&&) = default;
    CTRMGR_MAS_SENSOR_IFC_STATUS& operator=(CTRMGR_MAS_SENSOR_IFC_STATUS&&) = default;
    CTRMGR_MAS_SENSOR_IFC_STATUS& operator=(const CTRMGR_MAS_SENSOR_IFC_STATUS&) = default;
    CTRMGR_MAS_SENSOR_IFC_STATUS(const CTRMGR_MAS_SENSOR_IFC_STATUS&) = default;
    #else
    CTRMGR_MAS_SENSOR_IFC_STATUS(CTRMGR_MAS_SENSOR_IFC_STATUS&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_SENSOR_IFC_STATUS& operator=(CTRMGR_MAS_SENSOR_IFC_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_SENSOR_IFC_STATUS& stSensorIFCStatus() OMG_NOEXCEPT {
        return m_stSensorIFCStatus_;
    }

    const ST_SENSOR_IFC_STATUS& stSensorIFCStatus() const OMG_NOEXCEPT {
        return m_stSensorIFCStatus_;
    }

    void stSensorIFCStatus(const ST_SENSOR_IFC_STATUS& value) {
        m_stSensorIFCStatus_ = value;
    }

    void stSensorIFCStatus(ST_SENSOR_IFC_STATUS&& value) {
        m_stSensorIFCStatus_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_SENSOR_IFC_STATUS& other_) const;
    bool operator != (const CTRMGR_MAS_SENSOR_IFC_STATUS& other_) const;

    void swap(CTRMGR_MAS_SENSOR_IFC_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_SENSOR_IFC_STATUS m_stSensorIFCStatus_;

};

inline void swap(CTRMGR_MAS_SENSOR_IFC_STATUS& a, CTRMGR_MAS_SENSOR_IFC_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_SENSOR_IFC_STATUS& sample);

class NDDSUSERDllExport CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT {
  public:
    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT();

    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 2L>& usPowerCtrlResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT (CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT&&) = default;
    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& operator=(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT&&) = default;
    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& operator=(const CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT&) = default;
    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT(const CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT&) = default;
    #else
    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& operator=(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& usPowerCtrlResult() OMG_NOEXCEPT {
        return m_usPowerCtrlResult_;
    }

    const ::dds::core::array< uint16_t, 2L>& usPowerCtrlResult() const OMG_NOEXCEPT {
        return m_usPowerCtrlResult_;
    }

    void usPowerCtrlResult(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usPowerCtrlResult_ = value;
    }

    void usPowerCtrlResult(::dds::core::array< uint16_t, 2L>&& value) {
        m_usPowerCtrlResult_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& other_) const;
    bool operator != (const CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& other_) const;

    void swap(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 2L> m_usPowerCtrlResult_;

};

inline void swap(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& a, CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& sample);

class NDDSUSERDllExport ST_MAS_SENSOR_SIG {
  public:
    ST_MAS_SENSOR_SIG();

    ST_MAS_SENSOR_SIG(uint16_t usAxisID,const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAcoSensorSig,const ::dds::core::array< uint8_t, 50L>& aAcoSensorStatus,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& aMagSensorSig,const ::dds::core::array< uint8_t, 49L>& aMagSensorStatus,uint16_t aSensorGain);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_SENSOR_SIG (ST_MAS_SENSOR_SIG&&) = default;
    ST_MAS_SENSOR_SIG& operator=(ST_MAS_SENSOR_SIG&&) = default;
    ST_MAS_SENSOR_SIG& operator=(const ST_MAS_SENSOR_SIG&) = default;
    ST_MAS_SENSOR_SIG(const ST_MAS_SENSOR_SIG&) = default;
    #else
    ST_MAS_SENSOR_SIG(ST_MAS_SENSOR_SIG&& other_) OMG_NOEXCEPT;  
    ST_MAS_SENSOR_SIG& operator=(ST_MAS_SENSOR_SIG&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAcoSensorSig() OMG_NOEXCEPT {
        return m_aAcoSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAcoSensorSig() const OMG_NOEXCEPT {
        return m_aAcoSensorSig_;
    }

    void aAcoSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& value) {
        m_aAcoSensorSig_ = value;
    }

    void aAcoSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>&& value) {
        m_aAcoSensorSig_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 50L>& aAcoSensorStatus() OMG_NOEXCEPT {
        return m_aAcoSensorStatus_;
    }

    const ::dds::core::array< uint8_t, 50L>& aAcoSensorStatus() const OMG_NOEXCEPT {
        return m_aAcoSensorStatus_;
    }

    void aAcoSensorStatus(const ::dds::core::array< uint8_t, 50L>& value) {
        m_aAcoSensorStatus_ = value;
    }

    void aAcoSensorStatus(::dds::core::array< uint8_t, 50L>&& value) {
        m_aAcoSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& aMagSensorSig() OMG_NOEXCEPT {
        return m_aMagSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& aMagSensorSig() const OMG_NOEXCEPT {
        return m_aMagSensorSig_;
    }

    void aMagSensorSig(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& value) {
        m_aMagSensorSig_ = value;
    }

    void aMagSensorSig(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>&& value) {
        m_aMagSensorSig_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 49L>& aMagSensorStatus() OMG_NOEXCEPT {
        return m_aMagSensorStatus_;
    }

    const ::dds::core::array< uint8_t, 49L>& aMagSensorStatus() const OMG_NOEXCEPT {
        return m_aMagSensorStatus_;
    }

    void aMagSensorStatus(const ::dds::core::array< uint8_t, 49L>& value) {
        m_aMagSensorStatus_ = value;
    }

    void aMagSensorStatus(::dds::core::array< uint8_t, 49L>&& value) {
        m_aMagSensorStatus_ = std::move(value);
    }
    uint16_t& aSensorGain() OMG_NOEXCEPT {
        return m_aSensorGain_;
    }

    const uint16_t& aSensorGain() const OMG_NOEXCEPT {
        return m_aSensorGain_;
    }

    void aSensorGain(uint16_t value) {
        m_aSensorGain_ = value;
    }

    bool operator == (const ST_MAS_SENSOR_SIG& other_) const;
    bool operator != (const ST_MAS_SENSOR_SIG& other_) const;

    void swap(ST_MAS_SENSOR_SIG& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usAxisID_;
    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L> m_aAcoSensorSig_;
    ::dds::core::array< uint8_t, 50L> m_aAcoSensorStatus_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L> m_aMagSensorSig_;
    ::dds::core::array< uint8_t, 49L> m_aMagSensorStatus_;
    uint16_t m_aSensorGain_;

};

inline void swap(ST_MAS_SENSOR_SIG& a, ST_MAS_SENSOR_SIG& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_SENSOR_SIG& sample);

class NDDSUSERDllExport CTRMGR_MAS_SENSOR_SIGNAL_DATA {
  public:
    CTRMGR_MAS_SENSOR_SIGNAL_DATA();

    CTRMGR_MAS_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,const ::dds::core::array< ST_MAS_SENSOR_SIG, 2L>& aSensorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_SENSOR_SIGNAL_DATA (CTRMGR_MAS_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_MAS_SENSOR_SIGNAL_DATA& operator=(CTRMGR_MAS_SENSOR_SIGNAL_DATA&&) = default;
    CTRMGR_MAS_SENSOR_SIGNAL_DATA& operator=(const CTRMGR_MAS_SENSOR_SIGNAL_DATA&) = default;
    CTRMGR_MAS_SENSOR_SIGNAL_DATA(const CTRMGR_MAS_SENSOR_SIGNAL_DATA&) = default;
    #else
    CTRMGR_MAS_SENSOR_SIGNAL_DATA(CTRMGR_MAS_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_SENSOR_SIGNAL_DATA& operator=(CTRMGR_MAS_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    ::dds::core::array< ST_MAS_SENSOR_SIG, 2L>& aSensorSig() OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    const ::dds::core::array< ST_MAS_SENSOR_SIG, 2L>& aSensorSig() const OMG_NOEXCEPT {
        return m_aSensorSig_;
    }

    void aSensorSig(const ::dds::core::array< ST_MAS_SENSOR_SIG, 2L>& value) {
        m_aSensorSig_ = value;
    }

    void aSensorSig(::dds::core::array< ST_MAS_SENSOR_SIG, 2L>&& value) {
        m_aSensorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_MAS_SENSOR_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_MAS_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    ::dds::core::array< ST_MAS_SENSOR_SIG, 2L> m_aSensorSig_;

};

inline void swap(CTRMGR_MAS_SENSOR_SIGNAL_DATA& a, CTRMGR_MAS_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport ST_MAS_SENSOR_STATUS {
  public:
    ST_MAS_SENSOR_STATUS();

    ST_MAS_SENSOR_STATUS(uint8_t oAxisID,uint8_t oMainMUXID,uint8_t oEOSwitch1ID,uint8_t oMainMuxFPGAStatus,uint8_t oSwitchCircuitFPGAStatusA,uint8_t oSwitchCircuitFPGAStatusB,uint8_t oSwitchCircuitStatusA,uint8_t oSwitchCircuitStatusB,uint8_t oMainMuxControlStatusA,uint8_t oMainMuxControlStatusB,uint8_t oMainMuxACOStatusA,uint8_t oMainMuxACOStatusB,const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceMAGStatus,const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceFPGAStatus,const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceACOStatusA,const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceACOStatusB,const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceControlStatusA,const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceControlStatusB,uint8_t oSensorGain,uint8_t oEOSwitch2ID,const ::dds::core::array< uint8_t, 25L>& aACOSensorStatus,const ::dds::core::array< uint8_t, 49L>& aMAGSensorStatus,uint16_t usSensorGainCtrlMode,const ::dds::core::array< float, 25L>& aSensorEnergy,float fTotalEnergy,uint32_t ulFrameNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_SENSOR_STATUS (ST_MAS_SENSOR_STATUS&&) = default;
    ST_MAS_SENSOR_STATUS& operator=(ST_MAS_SENSOR_STATUS&&) = default;
    ST_MAS_SENSOR_STATUS& operator=(const ST_MAS_SENSOR_STATUS&) = default;
    ST_MAS_SENSOR_STATUS(const ST_MAS_SENSOR_STATUS&) = default;
    #else
    ST_MAS_SENSOR_STATUS(ST_MAS_SENSOR_STATUS&& other_) OMG_NOEXCEPT;  
    ST_MAS_SENSOR_STATUS& operator=(ST_MAS_SENSOR_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oMainMUXID() OMG_NOEXCEPT {
        return m_oMainMUXID_;
    }

    const uint8_t& oMainMUXID() const OMG_NOEXCEPT {
        return m_oMainMUXID_;
    }

    void oMainMUXID(uint8_t value) {
        m_oMainMUXID_ = value;
    }

    uint8_t& oEOSwitch1ID() OMG_NOEXCEPT {
        return m_oEOSwitch1ID_;
    }

    const uint8_t& oEOSwitch1ID() const OMG_NOEXCEPT {
        return m_oEOSwitch1ID_;
    }

    void oEOSwitch1ID(uint8_t value) {
        m_oEOSwitch1ID_ = value;
    }

    uint8_t& oMainMuxFPGAStatus() OMG_NOEXCEPT {
        return m_oMainMuxFPGAStatus_;
    }

    const uint8_t& oMainMuxFPGAStatus() const OMG_NOEXCEPT {
        return m_oMainMuxFPGAStatus_;
    }

    void oMainMuxFPGAStatus(uint8_t value) {
        m_oMainMuxFPGAStatus_ = value;
    }

    uint8_t& oSwitchCircuitFPGAStatusA() OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusA_;
    }

    const uint8_t& oSwitchCircuitFPGAStatusA() const OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusA_;
    }

    void oSwitchCircuitFPGAStatusA(uint8_t value) {
        m_oSwitchCircuitFPGAStatusA_ = value;
    }

    uint8_t& oSwitchCircuitFPGAStatusB() OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusB_;
    }

    const uint8_t& oSwitchCircuitFPGAStatusB() const OMG_NOEXCEPT {
        return m_oSwitchCircuitFPGAStatusB_;
    }

    void oSwitchCircuitFPGAStatusB(uint8_t value) {
        m_oSwitchCircuitFPGAStatusB_ = value;
    }

    uint8_t& oSwitchCircuitStatusA() OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusA_;
    }

    const uint8_t& oSwitchCircuitStatusA() const OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusA_;
    }

    void oSwitchCircuitStatusA(uint8_t value) {
        m_oSwitchCircuitStatusA_ = value;
    }

    uint8_t& oSwitchCircuitStatusB() OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusB_;
    }

    const uint8_t& oSwitchCircuitStatusB() const OMG_NOEXCEPT {
        return m_oSwitchCircuitStatusB_;
    }

    void oSwitchCircuitStatusB(uint8_t value) {
        m_oSwitchCircuitStatusB_ = value;
    }

    uint8_t& oMainMuxControlStatusA() OMG_NOEXCEPT {
        return m_oMainMuxControlStatusA_;
    }

    const uint8_t& oMainMuxControlStatusA() const OMG_NOEXCEPT {
        return m_oMainMuxControlStatusA_;
    }

    void oMainMuxControlStatusA(uint8_t value) {
        m_oMainMuxControlStatusA_ = value;
    }

    uint8_t& oMainMuxControlStatusB() OMG_NOEXCEPT {
        return m_oMainMuxControlStatusB_;
    }

    const uint8_t& oMainMuxControlStatusB() const OMG_NOEXCEPT {
        return m_oMainMuxControlStatusB_;
    }

    void oMainMuxControlStatusB(uint8_t value) {
        m_oMainMuxControlStatusB_ = value;
    }

    uint8_t& oMainMuxACOStatusA() OMG_NOEXCEPT {
        return m_oMainMuxACOStatusA_;
    }

    const uint8_t& oMainMuxACOStatusA() const OMG_NOEXCEPT {
        return m_oMainMuxACOStatusA_;
    }

    void oMainMuxACOStatusA(uint8_t value) {
        m_oMainMuxACOStatusA_ = value;
    }

    uint8_t& oMainMuxACOStatusB() OMG_NOEXCEPT {
        return m_oMainMuxACOStatusB_;
    }

    const uint8_t& oMainMuxACOStatusB() const OMG_NOEXCEPT {
        return m_oMainMuxACOStatusB_;
    }

    void oMainMuxACOStatusB(uint8_t value) {
        m_oMainMuxACOStatusB_ = value;
    }

    ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceMAGStatus() OMG_NOEXCEPT {
        return m_aDigitalCommDeviceMAGStatus_;
    }

    const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceMAGStatus() const OMG_NOEXCEPT {
        return m_aDigitalCommDeviceMAGStatus_;
    }

    void aDigitalCommDeviceMAGStatus(const ::dds::core::array< uint8_t, 50L>& value) {
        m_aDigitalCommDeviceMAGStatus_ = value;
    }

    void aDigitalCommDeviceMAGStatus(::dds::core::array< uint8_t, 50L>&& value) {
        m_aDigitalCommDeviceMAGStatus_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceFPGAStatus() OMG_NOEXCEPT {
        return m_aDigitalCommDeviceFPGAStatus_;
    }

    const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceFPGAStatus() const OMG_NOEXCEPT {
        return m_aDigitalCommDeviceFPGAStatus_;
    }

    void aDigitalCommDeviceFPGAStatus(const ::dds::core::array< uint8_t, 50L>& value) {
        m_aDigitalCommDeviceFPGAStatus_ = value;
    }

    void aDigitalCommDeviceFPGAStatus(::dds::core::array< uint8_t, 50L>&& value) {
        m_aDigitalCommDeviceFPGAStatus_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceACOStatusA() OMG_NOEXCEPT {
        return m_aDigitalCommDeviceACOStatusA_;
    }

    const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceACOStatusA() const OMG_NOEXCEPT {
        return m_aDigitalCommDeviceACOStatusA_;
    }

    void aDigitalCommDeviceACOStatusA(const ::dds::core::array< uint8_t, 50L>& value) {
        m_aDigitalCommDeviceACOStatusA_ = value;
    }

    void aDigitalCommDeviceACOStatusA(::dds::core::array< uint8_t, 50L>&& value) {
        m_aDigitalCommDeviceACOStatusA_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceACOStatusB() OMG_NOEXCEPT {
        return m_aDigitalCommDeviceACOStatusB_;
    }

    const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceACOStatusB() const OMG_NOEXCEPT {
        return m_aDigitalCommDeviceACOStatusB_;
    }

    void aDigitalCommDeviceACOStatusB(const ::dds::core::array< uint8_t, 50L>& value) {
        m_aDigitalCommDeviceACOStatusB_ = value;
    }

    void aDigitalCommDeviceACOStatusB(::dds::core::array< uint8_t, 50L>&& value) {
        m_aDigitalCommDeviceACOStatusB_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceControlStatusA() OMG_NOEXCEPT {
        return m_aDigitalCommDeviceControlStatusA_;
    }

    const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceControlStatusA() const OMG_NOEXCEPT {
        return m_aDigitalCommDeviceControlStatusA_;
    }

    void aDigitalCommDeviceControlStatusA(const ::dds::core::array< uint8_t, 50L>& value) {
        m_aDigitalCommDeviceControlStatusA_ = value;
    }

    void aDigitalCommDeviceControlStatusA(::dds::core::array< uint8_t, 50L>&& value) {
        m_aDigitalCommDeviceControlStatusA_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceControlStatusB() OMG_NOEXCEPT {
        return m_aDigitalCommDeviceControlStatusB_;
    }

    const ::dds::core::array< uint8_t, 50L>& aDigitalCommDeviceControlStatusB() const OMG_NOEXCEPT {
        return m_aDigitalCommDeviceControlStatusB_;
    }

    void aDigitalCommDeviceControlStatusB(const ::dds::core::array< uint8_t, 50L>& value) {
        m_aDigitalCommDeviceControlStatusB_ = value;
    }

    void aDigitalCommDeviceControlStatusB(::dds::core::array< uint8_t, 50L>&& value) {
        m_aDigitalCommDeviceControlStatusB_ = std::move(value);
    }
    uint8_t& oSensorGain() OMG_NOEXCEPT {
        return m_oSensorGain_;
    }

    const uint8_t& oSensorGain() const OMG_NOEXCEPT {
        return m_oSensorGain_;
    }

    void oSensorGain(uint8_t value) {
        m_oSensorGain_ = value;
    }

    uint8_t& oEOSwitch2ID() OMG_NOEXCEPT {
        return m_oEOSwitch2ID_;
    }

    const uint8_t& oEOSwitch2ID() const OMG_NOEXCEPT {
        return m_oEOSwitch2ID_;
    }

    void oEOSwitch2ID(uint8_t value) {
        m_oEOSwitch2ID_ = value;
    }

    ::dds::core::array< uint8_t, 25L>& aACOSensorStatus() OMG_NOEXCEPT {
        return m_aACOSensorStatus_;
    }

    const ::dds::core::array< uint8_t, 25L>& aACOSensorStatus() const OMG_NOEXCEPT {
        return m_aACOSensorStatus_;
    }

    void aACOSensorStatus(const ::dds::core::array< uint8_t, 25L>& value) {
        m_aACOSensorStatus_ = value;
    }

    void aACOSensorStatus(::dds::core::array< uint8_t, 25L>&& value) {
        m_aACOSensorStatus_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 49L>& aMAGSensorStatus() OMG_NOEXCEPT {
        return m_aMAGSensorStatus_;
    }

    const ::dds::core::array< uint8_t, 49L>& aMAGSensorStatus() const OMG_NOEXCEPT {
        return m_aMAGSensorStatus_;
    }

    void aMAGSensorStatus(const ::dds::core::array< uint8_t, 49L>& value) {
        m_aMAGSensorStatus_ = value;
    }

    void aMAGSensorStatus(::dds::core::array< uint8_t, 49L>&& value) {
        m_aMAGSensorStatus_ = std::move(value);
    }
    uint16_t& usSensorGainCtrlMode() OMG_NOEXCEPT {
        return m_usSensorGainCtrlMode_;
    }

    const uint16_t& usSensorGainCtrlMode() const OMG_NOEXCEPT {
        return m_usSensorGainCtrlMode_;
    }

    void usSensorGainCtrlMode(uint16_t value) {
        m_usSensorGainCtrlMode_ = value;
    }

    ::dds::core::array< float, 25L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 25L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 25L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 25L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    bool operator == (const ST_MAS_SENSOR_STATUS& other_) const;
    bool operator != (const ST_MAS_SENSOR_STATUS& other_) const;

    void swap(ST_MAS_SENSOR_STATUS& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAxisID_;
    uint8_t m_oMainMUXID_;
    uint8_t m_oEOSwitch1ID_;
    uint8_t m_oMainMuxFPGAStatus_;
    uint8_t m_oSwitchCircuitFPGAStatusA_;
    uint8_t m_oSwitchCircuitFPGAStatusB_;
    uint8_t m_oSwitchCircuitStatusA_;
    uint8_t m_oSwitchCircuitStatusB_;
    uint8_t m_oMainMuxControlStatusA_;
    uint8_t m_oMainMuxControlStatusB_;
    uint8_t m_oMainMuxACOStatusA_;
    uint8_t m_oMainMuxACOStatusB_;
    ::dds::core::array< uint8_t, 50L> m_aDigitalCommDeviceMAGStatus_;
    ::dds::core::array< uint8_t, 50L> m_aDigitalCommDeviceFPGAStatus_;
    ::dds::core::array< uint8_t, 50L> m_aDigitalCommDeviceACOStatusA_;
    ::dds::core::array< uint8_t, 50L> m_aDigitalCommDeviceACOStatusB_;
    ::dds::core::array< uint8_t, 50L> m_aDigitalCommDeviceControlStatusA_;
    ::dds::core::array< uint8_t, 50L> m_aDigitalCommDeviceControlStatusB_;
    uint8_t m_oSensorGain_;
    uint8_t m_oEOSwitch2ID_;
    ::dds::core::array< uint8_t, 25L> m_aACOSensorStatus_;
    ::dds::core::array< uint8_t, 49L> m_aMAGSensorStatus_;
    uint16_t m_usSensorGainCtrlMode_;
    ::dds::core::array< float, 25L> m_aSensorEnergy_;
    float m_fTotalEnergy_;
    uint32_t m_ulFrameNo_;

};

inline void swap(ST_MAS_SENSOR_STATUS& a, ST_MAS_SENSOR_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_SENSOR_STATUS& sample);

class NDDSUSERDllExport CTRMGR_MAS_SENSOR_STATUS {
  public:
    CTRMGR_MAS_SENSOR_STATUS();

    CTRMGR_MAS_SENSOR_STATUS(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& stSensorStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_SENSOR_STATUS (CTRMGR_MAS_SENSOR_STATUS&&) = default;
    CTRMGR_MAS_SENSOR_STATUS& operator=(CTRMGR_MAS_SENSOR_STATUS&&) = default;
    CTRMGR_MAS_SENSOR_STATUS& operator=(const CTRMGR_MAS_SENSOR_STATUS&) = default;
    CTRMGR_MAS_SENSOR_STATUS(const CTRMGR_MAS_SENSOR_STATUS&) = default;
    #else
    CTRMGR_MAS_SENSOR_STATUS(CTRMGR_MAS_SENSOR_STATUS&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_SENSOR_STATUS& operator=(CTRMGR_MAS_SENSOR_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& stSensorStatus() OMG_NOEXCEPT {
        return m_stSensorStatus_;
    }

    const ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& stSensorStatus() const OMG_NOEXCEPT {
        return m_stSensorStatus_;
    }

    void stSensorStatus(const ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& value) {
        m_stSensorStatus_ = value;
    }

    void stSensorStatus(::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>&& value) {
        m_stSensorStatus_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_SENSOR_STATUS& other_) const;
    bool operator != (const CTRMGR_MAS_SENSOR_STATUS& other_) const;

    void swap(CTRMGR_MAS_SENSOR_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L> m_stSensorStatus_;

};

inline void swap(CTRMGR_MAS_SENSOR_STATUS& a, CTRMGR_MAS_SENSOR_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_SENSOR_STATUS& sample);

class NDDSUSERDllExport ST_MAS_SIMULATOR_SIG {
  public:
    ST_MAS_SIMULATOR_SIG();

    ST_MAS_SIMULATOR_SIG(uint16_t usAxisID,const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAcoSensorSig,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& aMagSensorSig,uint16_t aSensorGain);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_SIMULATOR_SIG (ST_MAS_SIMULATOR_SIG&&) = default;
    ST_MAS_SIMULATOR_SIG& operator=(ST_MAS_SIMULATOR_SIG&&) = default;
    ST_MAS_SIMULATOR_SIG& operator=(const ST_MAS_SIMULATOR_SIG&) = default;
    ST_MAS_SIMULATOR_SIG(const ST_MAS_SIMULATOR_SIG&) = default;
    #else
    ST_MAS_SIMULATOR_SIG(ST_MAS_SIMULATOR_SIG&& other_) OMG_NOEXCEPT;  
    ST_MAS_SIMULATOR_SIG& operator=(ST_MAS_SIMULATOR_SIG&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAcoSensorSig() OMG_NOEXCEPT {
        return m_aAcoSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAcoSensorSig() const OMG_NOEXCEPT {
        return m_aAcoSensorSig_;
    }

    void aAcoSensorSig(const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& value) {
        m_aAcoSensorSig_ = value;
    }

    void aAcoSensorSig(::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>&& value) {
        m_aAcoSensorSig_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& aMagSensorSig() OMG_NOEXCEPT {
        return m_aMagSensorSig_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& aMagSensorSig() const OMG_NOEXCEPT {
        return m_aMagSensorSig_;
    }

    void aMagSensorSig(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>& value) {
        m_aMagSensorSig_ = value;
    }

    void aMagSensorSig(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L>&& value) {
        m_aMagSensorSig_ = std::move(value);
    }
    uint16_t& aSensorGain() OMG_NOEXCEPT {
        return m_aSensorGain_;
    }

    const uint16_t& aSensorGain() const OMG_NOEXCEPT {
        return m_aSensorGain_;
    }

    void aSensorGain(uint16_t value) {
        m_aSensorGain_ = value;
    }

    bool operator == (const ST_MAS_SIMULATOR_SIG& other_) const;
    bool operator != (const ST_MAS_SIMULATOR_SIG& other_) const;

    void swap(ST_MAS_SIMULATOR_SIG& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usAxisID_;
    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L> m_aAcoSensorSig_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 8L>, 49L>, 3L> m_aMagSensorSig_;
    uint16_t m_aSensorGain_;

};

inline void swap(ST_MAS_SIMULATOR_SIG& a, ST_MAS_SIMULATOR_SIG& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_SIMULATOR_SIG& sample);

class NDDSUSERDllExport CTRMGR_MAS_SIMULATION_SIGNAL_DATA {
  public:
    CTRMGR_MAS_SIMULATION_SIGNAL_DATA();

    CTRMGR_MAS_SIMULATION_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ::dds::core::array< ST_MAS_SIMULATOR_SIG, 2L>& aSimulatorSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    CTRMGR_MAS_SIMULATION_SIGNAL_DATA (CTRMGR_MAS_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_MAS_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_MAS_SIMULATION_SIGNAL_DATA&&) = default;
    CTRMGR_MAS_SIMULATION_SIGNAL_DATA& operator=(const CTRMGR_MAS_SIMULATION_SIGNAL_DATA&) = default;
    CTRMGR_MAS_SIMULATION_SIGNAL_DATA(const CTRMGR_MAS_SIMULATION_SIGNAL_DATA&) = default;
    #else
    CTRMGR_MAS_SIMULATION_SIGNAL_DATA(CTRMGR_MAS_SIMULATION_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    CTRMGR_MAS_SIMULATION_SIGNAL_DATA& operator=(CTRMGR_MAS_SIMULATION_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ::dds::core::array< ST_MAS_SIMULATOR_SIG, 2L>& aSimulatorSig() OMG_NOEXCEPT {
        return m_aSimulatorSig_;
    }

    const ::dds::core::array< ST_MAS_SIMULATOR_SIG, 2L>& aSimulatorSig() const OMG_NOEXCEPT {
        return m_aSimulatorSig_;
    }

    void aSimulatorSig(const ::dds::core::array< ST_MAS_SIMULATOR_SIG, 2L>& value) {
        m_aSimulatorSig_ = value;
    }

    void aSimulatorSig(::dds::core::array< ST_MAS_SIMULATOR_SIG, 2L>&& value) {
        m_aSimulatorSig_ = std::move(value);
    }

    bool operator == (const CTRMGR_MAS_SIMULATION_SIGNAL_DATA& other_) const;
    bool operator != (const CTRMGR_MAS_SIMULATION_SIGNAL_DATA& other_) const;

    void swap(CTRMGR_MAS_SIMULATION_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ::dds::core::array< ST_MAS_SIMULATOR_SIG, 2L> m_aSimulatorSig_;

};

inline void swap(CTRMGR_MAS_SIMULATION_SIGNAL_DATA& a, CTRMGR_MAS_SIMULATION_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const CTRMGR_MAS_SIMULATION_SIGNAL_DATA& sample);

class NDDSUSERDllExport ST_AS_TS_INFO {
  public:
    ST_AS_TS_INFO();

    ST_AS_TS_INFO(bool bTSTypeFlag,float fASSingleTargetStrengthInfo,uint16_t usFreqNum,const ::dds::core::array< float, 5L>& fFreqInfo,uint16_t usBearingNum,const ::dds::core::array< float, 36L>& fBearingInfo,const ::dds::core::array< ::dds::core::array< float, 36L>, 5L>& fASTargetStrengthInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_TS_INFO (ST_AS_TS_INFO&&) = default;
    ST_AS_TS_INFO& operator=(ST_AS_TS_INFO&&) = default;
    ST_AS_TS_INFO& operator=(const ST_AS_TS_INFO&) = default;
    ST_AS_TS_INFO(const ST_AS_TS_INFO&) = default;
    #else
    ST_AS_TS_INFO(ST_AS_TS_INFO&& other_) OMG_NOEXCEPT;  
    ST_AS_TS_INFO& operator=(ST_AS_TS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    bool& bTSTypeFlag() OMG_NOEXCEPT {
        return m_bTSTypeFlag_;
    }

    const bool& bTSTypeFlag() const OMG_NOEXCEPT {
        return m_bTSTypeFlag_;
    }

    void bTSTypeFlag(bool value) {
        m_bTSTypeFlag_ = value;
    }

    float& fASSingleTargetStrengthInfo() OMG_NOEXCEPT {
        return m_fASSingleTargetStrengthInfo_;
    }

    const float& fASSingleTargetStrengthInfo() const OMG_NOEXCEPT {
        return m_fASSingleTargetStrengthInfo_;
    }

    void fASSingleTargetStrengthInfo(float value) {
        m_fASSingleTargetStrengthInfo_ = value;
    }

    uint16_t& usFreqNum() OMG_NOEXCEPT {
        return m_usFreqNum_;
    }

    const uint16_t& usFreqNum() const OMG_NOEXCEPT {
        return m_usFreqNum_;
    }

    void usFreqNum(uint16_t value) {
        m_usFreqNum_ = value;
    }

    ::dds::core::array< float, 5L>& fFreqInfo() OMG_NOEXCEPT {
        return m_fFreqInfo_;
    }

    const ::dds::core::array< float, 5L>& fFreqInfo() const OMG_NOEXCEPT {
        return m_fFreqInfo_;
    }

    void fFreqInfo(const ::dds::core::array< float, 5L>& value) {
        m_fFreqInfo_ = value;
    }

    void fFreqInfo(::dds::core::array< float, 5L>&& value) {
        m_fFreqInfo_ = std::move(value);
    }
    uint16_t& usBearingNum() OMG_NOEXCEPT {
        return m_usBearingNum_;
    }

    const uint16_t& usBearingNum() const OMG_NOEXCEPT {
        return m_usBearingNum_;
    }

    void usBearingNum(uint16_t value) {
        m_usBearingNum_ = value;
    }

    ::dds::core::array< float, 36L>& fBearingInfo() OMG_NOEXCEPT {
        return m_fBearingInfo_;
    }

    const ::dds::core::array< float, 36L>& fBearingInfo() const OMG_NOEXCEPT {
        return m_fBearingInfo_;
    }

    void fBearingInfo(const ::dds::core::array< float, 36L>& value) {
        m_fBearingInfo_ = value;
    }

    void fBearingInfo(::dds::core::array< float, 36L>&& value) {
        m_fBearingInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 36L>, 5L>& fASTargetStrengthInfo() OMG_NOEXCEPT {
        return m_fASTargetStrengthInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 36L>, 5L>& fASTargetStrengthInfo() const OMG_NOEXCEPT {
        return m_fASTargetStrengthInfo_;
    }

    void fASTargetStrengthInfo(const ::dds::core::array< ::dds::core::array< float, 36L>, 5L>& value) {
        m_fASTargetStrengthInfo_ = value;
    }

    void fASTargetStrengthInfo(::dds::core::array< ::dds::core::array< float, 36L>, 5L>&& value) {
        m_fASTargetStrengthInfo_ = std::move(value);
    }

    bool operator == (const ST_AS_TS_INFO& other_) const;
    bool operator != (const ST_AS_TS_INFO& other_) const;

    void swap(ST_AS_TS_INFO& other_) OMG_NOEXCEPT ;

  private:

    bool m_bTSTypeFlag_;
    float m_fASSingleTargetStrengthInfo_;
    uint16_t m_usFreqNum_;
    ::dds::core::array< float, 5L> m_fFreqInfo_;
    uint16_t m_usBearingNum_;
    ::dds::core::array< float, 36L> m_fBearingInfo_;
    ::dds::core::array< ::dds::core::array< float, 36L>, 5L> m_fASTargetStrengthInfo_;

};

inline void swap(ST_AS_TS_INFO& a, ST_AS_TS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_TS_INFO& sample);

class NDDSUSERDllExport ST_BI_TS_INFO {
  public:
    ST_BI_TS_INFO();

    ST_BI_TS_INFO(bool bTSTypeFlag,float fTargetStrengthInfo,uint16_t usIncidenceNum,const ::dds::core::array< float, 36L>& fIncidenceInfo,uint16_t usReflectionNum,const ::dds::core::array< float, 36L>& fReflectionInfo,const ::dds::core::array< ::dds::core::array< float, 36L>, 36L>& fMatTargetStrengthInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BI_TS_INFO (ST_BI_TS_INFO&&) = default;
    ST_BI_TS_INFO& operator=(ST_BI_TS_INFO&&) = default;
    ST_BI_TS_INFO& operator=(const ST_BI_TS_INFO&) = default;
    ST_BI_TS_INFO(const ST_BI_TS_INFO&) = default;
    #else
    ST_BI_TS_INFO(ST_BI_TS_INFO&& other_) OMG_NOEXCEPT;  
    ST_BI_TS_INFO& operator=(ST_BI_TS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    bool& bTSTypeFlag() OMG_NOEXCEPT {
        return m_bTSTypeFlag_;
    }

    const bool& bTSTypeFlag() const OMG_NOEXCEPT {
        return m_bTSTypeFlag_;
    }

    void bTSTypeFlag(bool value) {
        m_bTSTypeFlag_ = value;
    }

    float& fTargetStrengthInfo() OMG_NOEXCEPT {
        return m_fTargetStrengthInfo_;
    }

    const float& fTargetStrengthInfo() const OMG_NOEXCEPT {
        return m_fTargetStrengthInfo_;
    }

    void fTargetStrengthInfo(float value) {
        m_fTargetStrengthInfo_ = value;
    }

    uint16_t& usIncidenceNum() OMG_NOEXCEPT {
        return m_usIncidenceNum_;
    }

    const uint16_t& usIncidenceNum() const OMG_NOEXCEPT {
        return m_usIncidenceNum_;
    }

    void usIncidenceNum(uint16_t value) {
        m_usIncidenceNum_ = value;
    }

    ::dds::core::array< float, 36L>& fIncidenceInfo() OMG_NOEXCEPT {
        return m_fIncidenceInfo_;
    }

    const ::dds::core::array< float, 36L>& fIncidenceInfo() const OMG_NOEXCEPT {
        return m_fIncidenceInfo_;
    }

    void fIncidenceInfo(const ::dds::core::array< float, 36L>& value) {
        m_fIncidenceInfo_ = value;
    }

    void fIncidenceInfo(::dds::core::array< float, 36L>&& value) {
        m_fIncidenceInfo_ = std::move(value);
    }
    uint16_t& usReflectionNum() OMG_NOEXCEPT {
        return m_usReflectionNum_;
    }

    const uint16_t& usReflectionNum() const OMG_NOEXCEPT {
        return m_usReflectionNum_;
    }

    void usReflectionNum(uint16_t value) {
        m_usReflectionNum_ = value;
    }

    ::dds::core::array< float, 36L>& fReflectionInfo() OMG_NOEXCEPT {
        return m_fReflectionInfo_;
    }

    const ::dds::core::array< float, 36L>& fReflectionInfo() const OMG_NOEXCEPT {
        return m_fReflectionInfo_;
    }

    void fReflectionInfo(const ::dds::core::array< float, 36L>& value) {
        m_fReflectionInfo_ = value;
    }

    void fReflectionInfo(::dds::core::array< float, 36L>&& value) {
        m_fReflectionInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 36L>, 36L>& fMatTargetStrengthInfo() OMG_NOEXCEPT {
        return m_fMatTargetStrengthInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 36L>, 36L>& fMatTargetStrengthInfo() const OMG_NOEXCEPT {
        return m_fMatTargetStrengthInfo_;
    }

    void fMatTargetStrengthInfo(const ::dds::core::array< ::dds::core::array< float, 36L>, 36L>& value) {
        m_fMatTargetStrengthInfo_ = value;
    }

    void fMatTargetStrengthInfo(::dds::core::array< ::dds::core::array< float, 36L>, 36L>&& value) {
        m_fMatTargetStrengthInfo_ = std::move(value);
    }

    bool operator == (const ST_BI_TS_INFO& other_) const;
    bool operator != (const ST_BI_TS_INFO& other_) const;

    void swap(ST_BI_TS_INFO& other_) OMG_NOEXCEPT ;

  private:

    bool m_bTSTypeFlag_;
    float m_fTargetStrengthInfo_;
    uint16_t m_usIncidenceNum_;
    ::dds::core::array< float, 36L> m_fIncidenceInfo_;
    uint16_t m_usReflectionNum_;
    ::dds::core::array< float, 36L> m_fReflectionInfo_;
    ::dds::core::array< ::dds::core::array< float, 36L>, 36L> m_fMatTargetStrengthInfo_;

};

inline void swap(ST_BI_TS_INFO& a, ST_BI_TS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BI_TS_INFO& sample);

class NDDSUSERDllExport ST_SOUND_INFO {
  public:
    ST_SOUND_INFO();

    ST_SOUND_INFO(uint8_t oSoundPulseMode,uint8_t oSoundType,float fSoundFreq,float fSoundLevel,float fSoundPulseLength,float fSoundBandWidth);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SOUND_INFO (ST_SOUND_INFO&&) = default;
    ST_SOUND_INFO& operator=(ST_SOUND_INFO&&) = default;
    ST_SOUND_INFO& operator=(const ST_SOUND_INFO&) = default;
    ST_SOUND_INFO(const ST_SOUND_INFO&) = default;
    #else
    ST_SOUND_INFO(ST_SOUND_INFO&& other_) OMG_NOEXCEPT;  
    ST_SOUND_INFO& operator=(ST_SOUND_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oSoundPulseMode() OMG_NOEXCEPT {
        return m_oSoundPulseMode_;
    }

    const uint8_t& oSoundPulseMode() const OMG_NOEXCEPT {
        return m_oSoundPulseMode_;
    }

    void oSoundPulseMode(uint8_t value) {
        m_oSoundPulseMode_ = value;
    }

    uint8_t& oSoundType() OMG_NOEXCEPT {
        return m_oSoundType_;
    }

    const uint8_t& oSoundType() const OMG_NOEXCEPT {
        return m_oSoundType_;
    }

    void oSoundType(uint8_t value) {
        m_oSoundType_ = value;
    }

    float& fSoundFreq() OMG_NOEXCEPT {
        return m_fSoundFreq_;
    }

    const float& fSoundFreq() const OMG_NOEXCEPT {
        return m_fSoundFreq_;
    }

    void fSoundFreq(float value) {
        m_fSoundFreq_ = value;
    }

    float& fSoundLevel() OMG_NOEXCEPT {
        return m_fSoundLevel_;
    }

    const float& fSoundLevel() const OMG_NOEXCEPT {
        return m_fSoundLevel_;
    }

    void fSoundLevel(float value) {
        m_fSoundLevel_ = value;
    }

    float& fSoundPulseLength() OMG_NOEXCEPT {
        return m_fSoundPulseLength_;
    }

    const float& fSoundPulseLength() const OMG_NOEXCEPT {
        return m_fSoundPulseLength_;
    }

    void fSoundPulseLength(float value) {
        m_fSoundPulseLength_ = value;
    }

    float& fSoundBandWidth() OMG_NOEXCEPT {
        return m_fSoundBandWidth_;
    }

    const float& fSoundBandWidth() const OMG_NOEXCEPT {
        return m_fSoundBandWidth_;
    }

    void fSoundBandWidth(float value) {
        m_fSoundBandWidth_ = value;
    }

    bool operator == (const ST_SOUND_INFO& other_) const;
    bool operator != (const ST_SOUND_INFO& other_) const;

    void swap(ST_SOUND_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oSoundPulseMode_;
    uint8_t m_oSoundType_;
    float m_fSoundFreq_;
    float m_fSoundLevel_;
    float m_fSoundPulseLength_;
    float m_fSoundBandWidth_;

};

inline void swap(ST_SOUND_INFO& a, ST_SOUND_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SOUND_INFO& sample);

class NDDSUSERDllExport ST_PERIOD_PARAM_MNG_INFO {
  public:
    ST_PERIOD_PARAM_MNG_INFO();

    ST_PERIOD_PARAM_MNG_INFO(uint16_t usID,const ::dds::core::array< uint8_t, 64L>& oName,uint16_t usMonth,uint16_t usDay,const ::dds::core::array< float, 15L>& fNBTargetSourceLevel,const ::dds::core::array< float, 4L>& fBBTargetSourceLevel,float fASTargetSpeed,const ST_AS_TS_INFO& stASTSInfo,bool bASAutoNoiseFlag,const ::dds::core::array< float, 3L>& fASAmbientNoise,uint8_t oASSeaState,float fBISTargetSpeed,const ST_BI_TS_INFO& stBITSInfo,float fBISTransmitterDepth,const ST_SOUND_INFO& stBISSoundInfo,double dBISSrcPosLat,double dBISSrcPosLon);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_PERIOD_PARAM_MNG_INFO (ST_PERIOD_PARAM_MNG_INFO&&) = default;
    ST_PERIOD_PARAM_MNG_INFO& operator=(ST_PERIOD_PARAM_MNG_INFO&&) = default;
    ST_PERIOD_PARAM_MNG_INFO& operator=(const ST_PERIOD_PARAM_MNG_INFO&) = default;
    ST_PERIOD_PARAM_MNG_INFO(const ST_PERIOD_PARAM_MNG_INFO&) = default;
    #else
    ST_PERIOD_PARAM_MNG_INFO(ST_PERIOD_PARAM_MNG_INFO&& other_) OMG_NOEXCEPT;  
    ST_PERIOD_PARAM_MNG_INFO& operator=(ST_PERIOD_PARAM_MNG_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usID() OMG_NOEXCEPT {
        return m_usID_;
    }

    const uint16_t& usID() const OMG_NOEXCEPT {
        return m_usID_;
    }

    void usID(uint16_t value) {
        m_usID_ = value;
    }

    ::dds::core::array< uint8_t, 64L>& oName() OMG_NOEXCEPT {
        return m_oName_;
    }

    const ::dds::core::array< uint8_t, 64L>& oName() const OMG_NOEXCEPT {
        return m_oName_;
    }

    void oName(const ::dds::core::array< uint8_t, 64L>& value) {
        m_oName_ = value;
    }

    void oName(::dds::core::array< uint8_t, 64L>&& value) {
        m_oName_ = std::move(value);
    }
    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    ::dds::core::array< float, 15L>& fNBTargetSourceLevel() OMG_NOEXCEPT {
        return m_fNBTargetSourceLevel_;
    }

    const ::dds::core::array< float, 15L>& fNBTargetSourceLevel() const OMG_NOEXCEPT {
        return m_fNBTargetSourceLevel_;
    }

    void fNBTargetSourceLevel(const ::dds::core::array< float, 15L>& value) {
        m_fNBTargetSourceLevel_ = value;
    }

    void fNBTargetSourceLevel(::dds::core::array< float, 15L>&& value) {
        m_fNBTargetSourceLevel_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fBBTargetSourceLevel() OMG_NOEXCEPT {
        return m_fBBTargetSourceLevel_;
    }

    const ::dds::core::array< float, 4L>& fBBTargetSourceLevel() const OMG_NOEXCEPT {
        return m_fBBTargetSourceLevel_;
    }

    void fBBTargetSourceLevel(const ::dds::core::array< float, 4L>& value) {
        m_fBBTargetSourceLevel_ = value;
    }

    void fBBTargetSourceLevel(::dds::core::array< float, 4L>&& value) {
        m_fBBTargetSourceLevel_ = std::move(value);
    }
    float& fASTargetSpeed() OMG_NOEXCEPT {
        return m_fASTargetSpeed_;
    }

    const float& fASTargetSpeed() const OMG_NOEXCEPT {
        return m_fASTargetSpeed_;
    }

    void fASTargetSpeed(float value) {
        m_fASTargetSpeed_ = value;
    }

    ST_AS_TS_INFO& stASTSInfo() OMG_NOEXCEPT {
        return m_stASTSInfo_;
    }

    const ST_AS_TS_INFO& stASTSInfo() const OMG_NOEXCEPT {
        return m_stASTSInfo_;
    }

    void stASTSInfo(const ST_AS_TS_INFO& value) {
        m_stASTSInfo_ = value;
    }

    void stASTSInfo(ST_AS_TS_INFO&& value) {
        m_stASTSInfo_ = std::move(value);
    }
    bool& bASAutoNoiseFlag() OMG_NOEXCEPT {
        return m_bASAutoNoiseFlag_;
    }

    const bool& bASAutoNoiseFlag() const OMG_NOEXCEPT {
        return m_bASAutoNoiseFlag_;
    }

    void bASAutoNoiseFlag(bool value) {
        m_bASAutoNoiseFlag_ = value;
    }

    ::dds::core::array< float, 3L>& fASAmbientNoise() OMG_NOEXCEPT {
        return m_fASAmbientNoise_;
    }

    const ::dds::core::array< float, 3L>& fASAmbientNoise() const OMG_NOEXCEPT {
        return m_fASAmbientNoise_;
    }

    void fASAmbientNoise(const ::dds::core::array< float, 3L>& value) {
        m_fASAmbientNoise_ = value;
    }

    void fASAmbientNoise(::dds::core::array< float, 3L>&& value) {
        m_fASAmbientNoise_ = std::move(value);
    }
    uint8_t& oASSeaState() OMG_NOEXCEPT {
        return m_oASSeaState_;
    }

    const uint8_t& oASSeaState() const OMG_NOEXCEPT {
        return m_oASSeaState_;
    }

    void oASSeaState(uint8_t value) {
        m_oASSeaState_ = value;
    }

    float& fBISTargetSpeed() OMG_NOEXCEPT {
        return m_fBISTargetSpeed_;
    }

    const float& fBISTargetSpeed() const OMG_NOEXCEPT {
        return m_fBISTargetSpeed_;
    }

    void fBISTargetSpeed(float value) {
        m_fBISTargetSpeed_ = value;
    }

    ST_BI_TS_INFO& stBITSInfo() OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    const ST_BI_TS_INFO& stBITSInfo() const OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    void stBITSInfo(const ST_BI_TS_INFO& value) {
        m_stBITSInfo_ = value;
    }

    void stBITSInfo(ST_BI_TS_INFO&& value) {
        m_stBITSInfo_ = std::move(value);
    }
    float& fBISTransmitterDepth() OMG_NOEXCEPT {
        return m_fBISTransmitterDepth_;
    }

    const float& fBISTransmitterDepth() const OMG_NOEXCEPT {
        return m_fBISTransmitterDepth_;
    }

    void fBISTransmitterDepth(float value) {
        m_fBISTransmitterDepth_ = value;
    }

    ST_SOUND_INFO& stBISSoundInfo() OMG_NOEXCEPT {
        return m_stBISSoundInfo_;
    }

    const ST_SOUND_INFO& stBISSoundInfo() const OMG_NOEXCEPT {
        return m_stBISSoundInfo_;
    }

    void stBISSoundInfo(const ST_SOUND_INFO& value) {
        m_stBISSoundInfo_ = value;
    }

    void stBISSoundInfo(ST_SOUND_INFO&& value) {
        m_stBISSoundInfo_ = std::move(value);
    }
    double& dBISSrcPosLat() OMG_NOEXCEPT {
        return m_dBISSrcPosLat_;
    }

    const double& dBISSrcPosLat() const OMG_NOEXCEPT {
        return m_dBISSrcPosLat_;
    }

    void dBISSrcPosLat(double value) {
        m_dBISSrcPosLat_ = value;
    }

    double& dBISSrcPosLon() OMG_NOEXCEPT {
        return m_dBISSrcPosLon_;
    }

    const double& dBISSrcPosLon() const OMG_NOEXCEPT {
        return m_dBISSrcPosLon_;
    }

    void dBISSrcPosLon(double value) {
        m_dBISSrcPosLon_ = value;
    }

    bool operator == (const ST_PERIOD_PARAM_MNG_INFO& other_) const;
    bool operator != (const ST_PERIOD_PARAM_MNG_INFO& other_) const;

    void swap(ST_PERIOD_PARAM_MNG_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usID_;
    ::dds::core::array< uint8_t, 64L> m_oName_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;
    ::dds::core::array< float, 15L> m_fNBTargetSourceLevel_;
    ::dds::core::array< float, 4L> m_fBBTargetSourceLevel_;
    float m_fASTargetSpeed_;
    ST_AS_TS_INFO m_stASTSInfo_;
    bool m_bASAutoNoiseFlag_;
    ::dds::core::array< float, 3L> m_fASAmbientNoise_;
    uint8_t m_oASSeaState_;
    float m_fBISTargetSpeed_;
    ST_BI_TS_INFO m_stBITSInfo_;
    float m_fBISTransmitterDepth_;
    ST_SOUND_INFO m_stBISSoundInfo_;
    double m_dBISSrcPosLat_;
    double m_dBISSrcPosLon_;

};

inline void swap(ST_PERIOD_PARAM_MNG_INFO& a, ST_PERIOD_PARAM_MNG_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_PERIOD_PARAM_MNG_INFO& sample);

class NDDSUSERDllExport DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT {
  public:
    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT();

    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t usDataNum,uint8_t oRequestCommand,const ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& stPeriodParamInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT (DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT&&) = default;
    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& operator=(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT&&) = default;
    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& operator=(const DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT&) = default;
    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT(const DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT&) = default;
    #else
    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT&& other_) OMG_NOEXCEPT;  
    DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& operator=(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& stPeriodParamInfo() OMG_NOEXCEPT {
        return m_stPeriodParamInfo_;
    }

    const ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& stPeriodParamInfo() const OMG_NOEXCEPT {
        return m_stPeriodParamInfo_;
    }

    void stPeriodParamInfo(const ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& value) {
        m_stPeriodParamInfo_ = value;
    }

    void stPeriodParamInfo(::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>&& value) {
        m_stPeriodParamInfo_ = std::move(value);
    }

    bool operator == (const DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& other_) const;
    bool operator != (const DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& other_) const;

    void swap(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usDataNum_;
    uint8_t m_oRequestCommand_;
    ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L> m_stPeriodParamInfo_;

};

inline void swap(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& a, DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& sample);

class NDDSUSERDllExport DATMGR_AS_THREAT_AREA_INFO {
  public:
    DATMGR_AS_THREAT_AREA_INFO();

    DATMGR_AS_THREAT_AREA_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oInfoType,const ::dds::core::array< float, 3L>& fRange,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_AS_THREAT_AREA_INFO (DATMGR_AS_THREAT_AREA_INFO&&) = default;
    DATMGR_AS_THREAT_AREA_INFO& operator=(DATMGR_AS_THREAT_AREA_INFO&&) = default;
    DATMGR_AS_THREAT_AREA_INFO& operator=(const DATMGR_AS_THREAT_AREA_INFO&) = default;
    DATMGR_AS_THREAT_AREA_INFO(const DATMGR_AS_THREAT_AREA_INFO&) = default;
    #else
    DATMGR_AS_THREAT_AREA_INFO(DATMGR_AS_THREAT_AREA_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_AS_THREAT_AREA_INFO& operator=(DATMGR_AS_THREAT_AREA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oInfoType() OMG_NOEXCEPT {
        return m_oInfoType_;
    }

    const uint8_t& oInfoType() const OMG_NOEXCEPT {
        return m_oInfoType_;
    }

    void oInfoType(uint8_t value) {
        m_oInfoType_ = value;
    }

    ::dds::core::array< float, 3L>& fRange() OMG_NOEXCEPT {
        return m_fRange_;
    }

    const ::dds::core::array< float, 3L>& fRange() const OMG_NOEXCEPT {
        return m_fRange_;
    }

    void fRange(const ::dds::core::array< float, 3L>& value) {
        m_fRange_ = value;
    }

    void fRange(::dds::core::array< float, 3L>&& value) {
        m_fRange_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const DATMGR_AS_THREAT_AREA_INFO& other_) const;
    bool operator != (const DATMGR_AS_THREAT_AREA_INFO& other_) const;

    void swap(DATMGR_AS_THREAT_AREA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oInfoType_;
    ::dds::core::array< float, 3L> m_fRange_;
    uint16_t m_usReserved_;

};

inline void swap(DATMGR_AS_THREAT_AREA_INFO& a, DATMGR_AS_THREAT_AREA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_AS_THREAT_AREA_INFO& sample);

class NDDSUSERDllExport DATMGR_BIS_ACTIVE_PULSE_DB {
  public:
    DATMGR_BIS_ACTIVE_PULSE_DB();

    DATMGR_BIS_ACTIVE_PULSE_DB(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< int32_t, 3L>& aDBReqDeviceID,int32_t DBNum,const ::dds::core::array< ::dds::core::array< float, 3L>, 1000L>& aActivePulseDB);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_BIS_ACTIVE_PULSE_DB (DATMGR_BIS_ACTIVE_PULSE_DB&&) = default;
    DATMGR_BIS_ACTIVE_PULSE_DB& operator=(DATMGR_BIS_ACTIVE_PULSE_DB&&) = default;
    DATMGR_BIS_ACTIVE_PULSE_DB& operator=(const DATMGR_BIS_ACTIVE_PULSE_DB&) = default;
    DATMGR_BIS_ACTIVE_PULSE_DB(const DATMGR_BIS_ACTIVE_PULSE_DB&) = default;
    #else
    DATMGR_BIS_ACTIVE_PULSE_DB(DATMGR_BIS_ACTIVE_PULSE_DB&& other_) OMG_NOEXCEPT;  
    DATMGR_BIS_ACTIVE_PULSE_DB& operator=(DATMGR_BIS_ACTIVE_PULSE_DB&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< int32_t, 3L>& aDBReqDeviceID() OMG_NOEXCEPT {
        return m_aDBReqDeviceID_;
    }

    const ::dds::core::array< int32_t, 3L>& aDBReqDeviceID() const OMG_NOEXCEPT {
        return m_aDBReqDeviceID_;
    }

    void aDBReqDeviceID(const ::dds::core::array< int32_t, 3L>& value) {
        m_aDBReqDeviceID_ = value;
    }

    void aDBReqDeviceID(::dds::core::array< int32_t, 3L>&& value) {
        m_aDBReqDeviceID_ = std::move(value);
    }
    int32_t& DBNum() OMG_NOEXCEPT {
        return m_DBNum_;
    }

    const int32_t& DBNum() const OMG_NOEXCEPT {
        return m_DBNum_;
    }

    void DBNum(int32_t value) {
        m_DBNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 3L>, 1000L>& aActivePulseDB() OMG_NOEXCEPT {
        return m_aActivePulseDB_;
    }

    const ::dds::core::array< ::dds::core::array< float, 3L>, 1000L>& aActivePulseDB() const OMG_NOEXCEPT {
        return m_aActivePulseDB_;
    }

    void aActivePulseDB(const ::dds::core::array< ::dds::core::array< float, 3L>, 1000L>& value) {
        m_aActivePulseDB_ = value;
    }

    void aActivePulseDB(::dds::core::array< ::dds::core::array< float, 3L>, 1000L>&& value) {
        m_aActivePulseDB_ = std::move(value);
    }

    bool operator == (const DATMGR_BIS_ACTIVE_PULSE_DB& other_) const;
    bool operator != (const DATMGR_BIS_ACTIVE_PULSE_DB& other_) const;

    void swap(DATMGR_BIS_ACTIVE_PULSE_DB& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< int32_t, 3L> m_aDBReqDeviceID_;
    int32_t m_DBNum_;
    ::dds::core::array< ::dds::core::array< float, 3L>, 1000L> m_aActivePulseDB_;

};

inline void swap(DATMGR_BIS_ACTIVE_PULSE_DB& a, DATMGR_BIS_ACTIVE_PULSE_DB& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_BIS_ACTIVE_PULSE_DB& sample);

class NDDSUSERDllExport DATMGR_BIS_AUDIO_SIG_INFO {
  public:
    DATMGR_BIS_AUDIO_SIG_INFO();

    DATMGR_BIS_AUDIO_SIG_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNum,uint8_t oAxis,uint16_t unAngle,uint8_t oFreqBand,uint16_t usTargetNumber,uint16_t unBISPulseType,float fBISCenterFreq,float fBISBandwidth,float fBISPulseLength,const ::dds::core::array< int16_t, 8192L>& nBISAudioSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_BIS_AUDIO_SIG_INFO (DATMGR_BIS_AUDIO_SIG_INFO&&) = default;
    DATMGR_BIS_AUDIO_SIG_INFO& operator=(DATMGR_BIS_AUDIO_SIG_INFO&&) = default;
    DATMGR_BIS_AUDIO_SIG_INFO& operator=(const DATMGR_BIS_AUDIO_SIG_INFO&) = default;
    DATMGR_BIS_AUDIO_SIG_INFO(const DATMGR_BIS_AUDIO_SIG_INFO&) = default;
    #else
    DATMGR_BIS_AUDIO_SIG_INFO(DATMGR_BIS_AUDIO_SIG_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_BIS_AUDIO_SIG_INFO& operator=(DATMGR_BIS_AUDIO_SIG_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNum() OMG_NOEXCEPT {
        return m_ulFrameNum_;
    }

    const uint32_t& ulFrameNum() const OMG_NOEXCEPT {
        return m_ulFrameNum_;
    }

    void ulFrameNum(uint32_t value) {
        m_ulFrameNum_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& unAngle() OMG_NOEXCEPT {
        return m_unAngle_;
    }

    const uint16_t& unAngle() const OMG_NOEXCEPT {
        return m_unAngle_;
    }

    void unAngle(uint16_t value) {
        m_unAngle_ = value;
    }

    uint8_t& oFreqBand() OMG_NOEXCEPT {
        return m_oFreqBand_;
    }

    const uint8_t& oFreqBand() const OMG_NOEXCEPT {
        return m_oFreqBand_;
    }

    void oFreqBand(uint8_t value) {
        m_oFreqBand_ = value;
    }

    uint16_t& usTargetNumber() OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    const uint16_t& usTargetNumber() const OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    void usTargetNumber(uint16_t value) {
        m_usTargetNumber_ = value;
    }

    uint16_t& unBISPulseType() OMG_NOEXCEPT {
        return m_unBISPulseType_;
    }

    const uint16_t& unBISPulseType() const OMG_NOEXCEPT {
        return m_unBISPulseType_;
    }

    void unBISPulseType(uint16_t value) {
        m_unBISPulseType_ = value;
    }

    float& fBISCenterFreq() OMG_NOEXCEPT {
        return m_fBISCenterFreq_;
    }

    const float& fBISCenterFreq() const OMG_NOEXCEPT {
        return m_fBISCenterFreq_;
    }

    void fBISCenterFreq(float value) {
        m_fBISCenterFreq_ = value;
    }

    float& fBISBandwidth() OMG_NOEXCEPT {
        return m_fBISBandwidth_;
    }

    const float& fBISBandwidth() const OMG_NOEXCEPT {
        return m_fBISBandwidth_;
    }

    void fBISBandwidth(float value) {
        m_fBISBandwidth_ = value;
    }

    float& fBISPulseLength() OMG_NOEXCEPT {
        return m_fBISPulseLength_;
    }

    const float& fBISPulseLength() const OMG_NOEXCEPT {
        return m_fBISPulseLength_;
    }

    void fBISPulseLength(float value) {
        m_fBISPulseLength_ = value;
    }

    ::dds::core::array< int16_t, 8192L>& nBISAudioSig() OMG_NOEXCEPT {
        return m_nBISAudioSig_;
    }

    const ::dds::core::array< int16_t, 8192L>& nBISAudioSig() const OMG_NOEXCEPT {
        return m_nBISAudioSig_;
    }

    void nBISAudioSig(const ::dds::core::array< int16_t, 8192L>& value) {
        m_nBISAudioSig_ = value;
    }

    void nBISAudioSig(::dds::core::array< int16_t, 8192L>&& value) {
        m_nBISAudioSig_ = std::move(value);
    }

    bool operator == (const DATMGR_BIS_AUDIO_SIG_INFO& other_) const;
    bool operator != (const DATMGR_BIS_AUDIO_SIG_INFO& other_) const;

    void swap(DATMGR_BIS_AUDIO_SIG_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNum_;
    uint8_t m_oAxis_;
    uint16_t m_unAngle_;
    uint8_t m_oFreqBand_;
    uint16_t m_usTargetNumber_;
    uint16_t m_unBISPulseType_;
    float m_fBISCenterFreq_;
    float m_fBISBandwidth_;
    float m_fBISPulseLength_;
    ::dds::core::array< int16_t, 8192L> m_nBISAudioSig_;

};

inline void swap(DATMGR_BIS_AUDIO_SIG_INFO& a, DATMGR_BIS_AUDIO_SIG_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_BIS_AUDIO_SIG_INFO& sample);

class NDDSUSERDllExport DATMGR_BIS_SOURCE_DB_CONTROL_RESULT {
  public:
    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT();

    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint8_t oRequestResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT (DATMGR_BIS_SOURCE_DB_CONTROL_RESULT&&) = default;
    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& operator=(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT&&) = default;
    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& operator=(const DATMGR_BIS_SOURCE_DB_CONTROL_RESULT&) = default;
    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT(const DATMGR_BIS_SOURCE_DB_CONTROL_RESULT&) = default;
    #else
    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT&& other_) OMG_NOEXCEPT;  
    DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& operator=(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint8_t& oRequestResult() OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    const uint8_t& oRequestResult() const OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    void oRequestResult(uint8_t value) {
        m_oRequestResult_ = value;
    }

    bool operator == (const DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& other_) const;
    bool operator != (const DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& other_) const;

    void swap(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint8_t m_oRequestResult_;

};

inline void swap(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& a, DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& sample);

class NDDSUSERDllExport ST_BIS_SOURCE_DB {
  public:
    ST_BIS_SOURCE_DB();

    ST_BIS_SOURCE_DB(uint16_t usID,uint16_t usTxMode,float fCenterFreq,float fBandWidth,uint16_t usPulseLength,uint16_t usTxPower,uint16_t usSourceType,uint16_t usShip,const ::dds::core::array< uint8_t, 256L>& szComment);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_SOURCE_DB (ST_BIS_SOURCE_DB&&) = default;
    ST_BIS_SOURCE_DB& operator=(ST_BIS_SOURCE_DB&&) = default;
    ST_BIS_SOURCE_DB& operator=(const ST_BIS_SOURCE_DB&) = default;
    ST_BIS_SOURCE_DB(const ST_BIS_SOURCE_DB&) = default;
    #else
    ST_BIS_SOURCE_DB(ST_BIS_SOURCE_DB&& other_) OMG_NOEXCEPT;  
    ST_BIS_SOURCE_DB& operator=(ST_BIS_SOURCE_DB&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usID() OMG_NOEXCEPT {
        return m_usID_;
    }

    const uint16_t& usID() const OMG_NOEXCEPT {
        return m_usID_;
    }

    void usID(uint16_t value) {
        m_usID_ = value;
    }

    uint16_t& usTxMode() OMG_NOEXCEPT {
        return m_usTxMode_;
    }

    const uint16_t& usTxMode() const OMG_NOEXCEPT {
        return m_usTxMode_;
    }

    void usTxMode(uint16_t value) {
        m_usTxMode_ = value;
    }

    float& fCenterFreq() OMG_NOEXCEPT {
        return m_fCenterFreq_;
    }

    const float& fCenterFreq() const OMG_NOEXCEPT {
        return m_fCenterFreq_;
    }

    void fCenterFreq(float value) {
        m_fCenterFreq_ = value;
    }

    float& fBandWidth() OMG_NOEXCEPT {
        return m_fBandWidth_;
    }

    const float& fBandWidth() const OMG_NOEXCEPT {
        return m_fBandWidth_;
    }

    void fBandWidth(float value) {
        m_fBandWidth_ = value;
    }

    uint16_t& usPulseLength() OMG_NOEXCEPT {
        return m_usPulseLength_;
    }

    const uint16_t& usPulseLength() const OMG_NOEXCEPT {
        return m_usPulseLength_;
    }

    void usPulseLength(uint16_t value) {
        m_usPulseLength_ = value;
    }

    uint16_t& usTxPower() OMG_NOEXCEPT {
        return m_usTxPower_;
    }

    const uint16_t& usTxPower() const OMG_NOEXCEPT {
        return m_usTxPower_;
    }

    void usTxPower(uint16_t value) {
        m_usTxPower_ = value;
    }

    uint16_t& usSourceType() OMG_NOEXCEPT {
        return m_usSourceType_;
    }

    const uint16_t& usSourceType() const OMG_NOEXCEPT {
        return m_usSourceType_;
    }

    void usSourceType(uint16_t value) {
        m_usSourceType_ = value;
    }

    uint16_t& usShip() OMG_NOEXCEPT {
        return m_usShip_;
    }

    const uint16_t& usShip() const OMG_NOEXCEPT {
        return m_usShip_;
    }

    void usShip(uint16_t value) {
        m_usShip_ = value;
    }

    ::dds::core::array< uint8_t, 256L>& szComment() OMG_NOEXCEPT {
        return m_szComment_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComment() const OMG_NOEXCEPT {
        return m_szComment_;
    }

    void szComment(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComment_ = value;
    }

    void szComment(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComment_ = std::move(value);
    }

    bool operator == (const ST_BIS_SOURCE_DB& other_) const;
    bool operator != (const ST_BIS_SOURCE_DB& other_) const;

    void swap(ST_BIS_SOURCE_DB& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usID_;
    uint16_t m_usTxMode_;
    float m_fCenterFreq_;
    float m_fBandWidth_;
    uint16_t m_usPulseLength_;
    uint16_t m_usTxPower_;
    uint16_t m_usSourceType_;
    uint16_t m_usShip_;
    ::dds::core::array< uint8_t, 256L> m_szComment_;

};

inline void swap(ST_BIS_SOURCE_DB& a, ST_BIS_SOURCE_DB& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_SOURCE_DB& sample);

class NDDSUSERDllExport ST_BIS_SOURCE_TYPE_MATCHING_INFO {
  public:
    ST_BIS_SOURCE_TYPE_MATCHING_INFO();

    ST_BIS_SOURCE_TYPE_MATCHING_INFO(uint16_t usKey,const ::dds::core::array< uint8_t, 100L>& szSourceType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_SOURCE_TYPE_MATCHING_INFO (ST_BIS_SOURCE_TYPE_MATCHING_INFO&&) = default;
    ST_BIS_SOURCE_TYPE_MATCHING_INFO& operator=(ST_BIS_SOURCE_TYPE_MATCHING_INFO&&) = default;
    ST_BIS_SOURCE_TYPE_MATCHING_INFO& operator=(const ST_BIS_SOURCE_TYPE_MATCHING_INFO&) = default;
    ST_BIS_SOURCE_TYPE_MATCHING_INFO(const ST_BIS_SOURCE_TYPE_MATCHING_INFO&) = default;
    #else
    ST_BIS_SOURCE_TYPE_MATCHING_INFO(ST_BIS_SOURCE_TYPE_MATCHING_INFO&& other_) OMG_NOEXCEPT;  
    ST_BIS_SOURCE_TYPE_MATCHING_INFO& operator=(ST_BIS_SOURCE_TYPE_MATCHING_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usKey() OMG_NOEXCEPT {
        return m_usKey_;
    }

    const uint16_t& usKey() const OMG_NOEXCEPT {
        return m_usKey_;
    }

    void usKey(uint16_t value) {
        m_usKey_ = value;
    }

    ::dds::core::array< uint8_t, 100L>& szSourceType() OMG_NOEXCEPT {
        return m_szSourceType_;
    }

    const ::dds::core::array< uint8_t, 100L>& szSourceType() const OMG_NOEXCEPT {
        return m_szSourceType_;
    }

    void szSourceType(const ::dds::core::array< uint8_t, 100L>& value) {
        m_szSourceType_ = value;
    }

    void szSourceType(::dds::core::array< uint8_t, 100L>&& value) {
        m_szSourceType_ = std::move(value);
    }

    bool operator == (const ST_BIS_SOURCE_TYPE_MATCHING_INFO& other_) const;
    bool operator != (const ST_BIS_SOURCE_TYPE_MATCHING_INFO& other_) const;

    void swap(ST_BIS_SOURCE_TYPE_MATCHING_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usKey_;
    ::dds::core::array< uint8_t, 100L> m_szSourceType_;

};

inline void swap(ST_BIS_SOURCE_TYPE_MATCHING_INFO& a, ST_BIS_SOURCE_TYPE_MATCHING_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_SOURCE_TYPE_MATCHING_INFO& sample);

class NDDSUSERDllExport ST_BIS_SOURCE_SHIP_MATCHING_INFO {
  public:
    ST_BIS_SOURCE_SHIP_MATCHING_INFO();

    ST_BIS_SOURCE_SHIP_MATCHING_INFO(uint16_t usKey,const ::dds::core::array< uint8_t, 100L>& szShipInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_SOURCE_SHIP_MATCHING_INFO (ST_BIS_SOURCE_SHIP_MATCHING_INFO&&) = default;
    ST_BIS_SOURCE_SHIP_MATCHING_INFO& operator=(ST_BIS_SOURCE_SHIP_MATCHING_INFO&&) = default;
    ST_BIS_SOURCE_SHIP_MATCHING_INFO& operator=(const ST_BIS_SOURCE_SHIP_MATCHING_INFO&) = default;
    ST_BIS_SOURCE_SHIP_MATCHING_INFO(const ST_BIS_SOURCE_SHIP_MATCHING_INFO&) = default;
    #else
    ST_BIS_SOURCE_SHIP_MATCHING_INFO(ST_BIS_SOURCE_SHIP_MATCHING_INFO&& other_) OMG_NOEXCEPT;  
    ST_BIS_SOURCE_SHIP_MATCHING_INFO& operator=(ST_BIS_SOURCE_SHIP_MATCHING_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usKey() OMG_NOEXCEPT {
        return m_usKey_;
    }

    const uint16_t& usKey() const OMG_NOEXCEPT {
        return m_usKey_;
    }

    void usKey(uint16_t value) {
        m_usKey_ = value;
    }

    ::dds::core::array< uint8_t, 100L>& szShipInfo() OMG_NOEXCEPT {
        return m_szShipInfo_;
    }

    const ::dds::core::array< uint8_t, 100L>& szShipInfo() const OMG_NOEXCEPT {
        return m_szShipInfo_;
    }

    void szShipInfo(const ::dds::core::array< uint8_t, 100L>& value) {
        m_szShipInfo_ = value;
    }

    void szShipInfo(::dds::core::array< uint8_t, 100L>&& value) {
        m_szShipInfo_ = std::move(value);
    }

    bool operator == (const ST_BIS_SOURCE_SHIP_MATCHING_INFO& other_) const;
    bool operator != (const ST_BIS_SOURCE_SHIP_MATCHING_INFO& other_) const;

    void swap(ST_BIS_SOURCE_SHIP_MATCHING_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usKey_;
    ::dds::core::array< uint8_t, 100L> m_szShipInfo_;

};

inline void swap(ST_BIS_SOURCE_SHIP_MATCHING_INFO& a, ST_BIS_SOURCE_SHIP_MATCHING_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_SOURCE_SHIP_MATCHING_INFO& sample);

class NDDSUSERDllExport DATMGR_BIS_SOURCE_DB_INFO {
  public:
    DATMGR_BIS_SOURCE_DB_INFO();

    DATMGR_BIS_SOURCE_DB_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usDataNum,const ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& stBISSourceDBInfo,const ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& stTypeMatchingInfo,const ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& stShipMatchingInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_BIS_SOURCE_DB_INFO (DATMGR_BIS_SOURCE_DB_INFO&&) = default;
    DATMGR_BIS_SOURCE_DB_INFO& operator=(DATMGR_BIS_SOURCE_DB_INFO&&) = default;
    DATMGR_BIS_SOURCE_DB_INFO& operator=(const DATMGR_BIS_SOURCE_DB_INFO&) = default;
    DATMGR_BIS_SOURCE_DB_INFO(const DATMGR_BIS_SOURCE_DB_INFO&) = default;
    #else
    DATMGR_BIS_SOURCE_DB_INFO(DATMGR_BIS_SOURCE_DB_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_BIS_SOURCE_DB_INFO& operator=(DATMGR_BIS_SOURCE_DB_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& stBISSourceDBInfo() OMG_NOEXCEPT {
        return m_stBISSourceDBInfo_;
    }

    const ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& stBISSourceDBInfo() const OMG_NOEXCEPT {
        return m_stBISSourceDBInfo_;
    }

    void stBISSourceDBInfo(const ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& value) {
        m_stBISSourceDBInfo_ = value;
    }

    void stBISSourceDBInfo(::dds::core::array< ST_BIS_SOURCE_DB, 1000L>&& value) {
        m_stBISSourceDBInfo_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& stTypeMatchingInfo() OMG_NOEXCEPT {
        return m_stTypeMatchingInfo_;
    }

    const ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& stTypeMatchingInfo() const OMG_NOEXCEPT {
        return m_stTypeMatchingInfo_;
    }

    void stTypeMatchingInfo(const ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& value) {
        m_stTypeMatchingInfo_ = value;
    }

    void stTypeMatchingInfo(::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>&& value) {
        m_stTypeMatchingInfo_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& stShipMatchingInfo() OMG_NOEXCEPT {
        return m_stShipMatchingInfo_;
    }

    const ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& stShipMatchingInfo() const OMG_NOEXCEPT {
        return m_stShipMatchingInfo_;
    }

    void stShipMatchingInfo(const ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& value) {
        m_stShipMatchingInfo_ = value;
    }

    void stShipMatchingInfo(::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>&& value) {
        m_stShipMatchingInfo_ = std::move(value);
    }

    bool operator == (const DATMGR_BIS_SOURCE_DB_INFO& other_) const;
    bool operator != (const DATMGR_BIS_SOURCE_DB_INFO& other_) const;

    void swap(DATMGR_BIS_SOURCE_DB_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usDataNum_;
    ::dds::core::array< ST_BIS_SOURCE_DB, 1000L> m_stBISSourceDBInfo_;
    ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L> m_stTypeMatchingInfo_;
    ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L> m_stShipMatchingInfo_;

};

inline void swap(DATMGR_BIS_SOURCE_DB_INFO& a, DATMGR_BIS_SOURCE_DB_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_BIS_SOURCE_DB_INFO& sample);

class NDDSUSERDllExport ST_HARMONIC_INFO {
  public:
    ST_HARMONIC_INFO();

    ST_HARMONIC_INFO(uint16_t usHarmonicNum,float fFundFreq,const ::dds::core::array< float, 200L>& Hfreq,const ::dds::core::array< uint16_t, 200L>& Hnum);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HARMONIC_INFO (ST_HARMONIC_INFO&&) = default;
    ST_HARMONIC_INFO& operator=(ST_HARMONIC_INFO&&) = default;
    ST_HARMONIC_INFO& operator=(const ST_HARMONIC_INFO&) = default;
    ST_HARMONIC_INFO(const ST_HARMONIC_INFO&) = default;
    #else
    ST_HARMONIC_INFO(ST_HARMONIC_INFO&& other_) OMG_NOEXCEPT;  
    ST_HARMONIC_INFO& operator=(ST_HARMONIC_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usHarmonicNum() OMG_NOEXCEPT {
        return m_usHarmonicNum_;
    }

    const uint16_t& usHarmonicNum() const OMG_NOEXCEPT {
        return m_usHarmonicNum_;
    }

    void usHarmonicNum(uint16_t value) {
        m_usHarmonicNum_ = value;
    }

    float& fFundFreq() OMG_NOEXCEPT {
        return m_fFundFreq_;
    }

    const float& fFundFreq() const OMG_NOEXCEPT {
        return m_fFundFreq_;
    }

    void fFundFreq(float value) {
        m_fFundFreq_ = value;
    }

    ::dds::core::array< float, 200L>& Hfreq() OMG_NOEXCEPT {
        return m_Hfreq_;
    }

    const ::dds::core::array< float, 200L>& Hfreq() const OMG_NOEXCEPT {
        return m_Hfreq_;
    }

    void Hfreq(const ::dds::core::array< float, 200L>& value) {
        m_Hfreq_ = value;
    }

    void Hfreq(::dds::core::array< float, 200L>&& value) {
        m_Hfreq_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 200L>& Hnum() OMG_NOEXCEPT {
        return m_Hnum_;
    }

    const ::dds::core::array< uint16_t, 200L>& Hnum() const OMG_NOEXCEPT {
        return m_Hnum_;
    }

    void Hnum(const ::dds::core::array< uint16_t, 200L>& value) {
        m_Hnum_ = value;
    }

    void Hnum(::dds::core::array< uint16_t, 200L>&& value) {
        m_Hnum_ = std::move(value);
    }

    bool operator == (const ST_HARMONIC_INFO& other_) const;
    bool operator != (const ST_HARMONIC_INFO& other_) const;

    void swap(ST_HARMONIC_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usHarmonicNum_;
    float m_fFundFreq_;
    ::dds::core::array< float, 200L> m_Hfreq_;
    ::dds::core::array< uint16_t, 200L> m_Hnum_;

};

inline void swap(ST_HARMONIC_INFO& a, ST_HARMONIC_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HARMONIC_INFO& sample);

class NDDSUSERDllExport ST_FEATURE_FREQ_INFO {
  public:
    ST_FEATURE_FREQ_INFO();

    ST_FEATURE_FREQ_INFO(uint16_t usTonalNum,const ::dds::core::array< float, 200L>& fLOFARFreq,uint16_t usHarmonicSetNum,const ::dds::core::array< ST_HARMONIC_INFO, 100L>& stLOFARHarInfo,uint16_t usDEMONFreqNum,const ::dds::core::array< float, 100L>& fDEMONFreq);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_FEATURE_FREQ_INFO (ST_FEATURE_FREQ_INFO&&) = default;
    ST_FEATURE_FREQ_INFO& operator=(ST_FEATURE_FREQ_INFO&&) = default;
    ST_FEATURE_FREQ_INFO& operator=(const ST_FEATURE_FREQ_INFO&) = default;
    ST_FEATURE_FREQ_INFO(const ST_FEATURE_FREQ_INFO&) = default;
    #else
    ST_FEATURE_FREQ_INFO(ST_FEATURE_FREQ_INFO&& other_) OMG_NOEXCEPT;  
    ST_FEATURE_FREQ_INFO& operator=(ST_FEATURE_FREQ_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTonalNum() OMG_NOEXCEPT {
        return m_usTonalNum_;
    }

    const uint16_t& usTonalNum() const OMG_NOEXCEPT {
        return m_usTonalNum_;
    }

    void usTonalNum(uint16_t value) {
        m_usTonalNum_ = value;
    }

    ::dds::core::array< float, 200L>& fLOFARFreq() OMG_NOEXCEPT {
        return m_fLOFARFreq_;
    }

    const ::dds::core::array< float, 200L>& fLOFARFreq() const OMG_NOEXCEPT {
        return m_fLOFARFreq_;
    }

    void fLOFARFreq(const ::dds::core::array< float, 200L>& value) {
        m_fLOFARFreq_ = value;
    }

    void fLOFARFreq(::dds::core::array< float, 200L>&& value) {
        m_fLOFARFreq_ = std::move(value);
    }
    uint16_t& usHarmonicSetNum() OMG_NOEXCEPT {
        return m_usHarmonicSetNum_;
    }

    const uint16_t& usHarmonicSetNum() const OMG_NOEXCEPT {
        return m_usHarmonicSetNum_;
    }

    void usHarmonicSetNum(uint16_t value) {
        m_usHarmonicSetNum_ = value;
    }

    ::dds::core::array< ST_HARMONIC_INFO, 100L>& stLOFARHarInfo() OMG_NOEXCEPT {
        return m_stLOFARHarInfo_;
    }

    const ::dds::core::array< ST_HARMONIC_INFO, 100L>& stLOFARHarInfo() const OMG_NOEXCEPT {
        return m_stLOFARHarInfo_;
    }

    void stLOFARHarInfo(const ::dds::core::array< ST_HARMONIC_INFO, 100L>& value) {
        m_stLOFARHarInfo_ = value;
    }

    void stLOFARHarInfo(::dds::core::array< ST_HARMONIC_INFO, 100L>&& value) {
        m_stLOFARHarInfo_ = std::move(value);
    }
    uint16_t& usDEMONFreqNum() OMG_NOEXCEPT {
        return m_usDEMONFreqNum_;
    }

    const uint16_t& usDEMONFreqNum() const OMG_NOEXCEPT {
        return m_usDEMONFreqNum_;
    }

    void usDEMONFreqNum(uint16_t value) {
        m_usDEMONFreqNum_ = value;
    }

    ::dds::core::array< float, 100L>& fDEMONFreq() OMG_NOEXCEPT {
        return m_fDEMONFreq_;
    }

    const ::dds::core::array< float, 100L>& fDEMONFreq() const OMG_NOEXCEPT {
        return m_fDEMONFreq_;
    }

    void fDEMONFreq(const ::dds::core::array< float, 100L>& value) {
        m_fDEMONFreq_ = value;
    }

    void fDEMONFreq(::dds::core::array< float, 100L>&& value) {
        m_fDEMONFreq_ = std::move(value);
    }

    bool operator == (const ST_FEATURE_FREQ_INFO& other_) const;
    bool operator != (const ST_FEATURE_FREQ_INFO& other_) const;

    void swap(ST_FEATURE_FREQ_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTonalNum_;
    ::dds::core::array< float, 200L> m_fLOFARFreq_;
    uint16_t m_usHarmonicSetNum_;
    ::dds::core::array< ST_HARMONIC_INFO, 100L> m_stLOFARHarInfo_;
    uint16_t m_usDEMONFreqNum_;
    ::dds::core::array< float, 100L> m_fDEMONFreq_;

};

inline void swap(ST_FEATURE_FREQ_INFO& a, ST_FEATURE_FREQ_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_FEATURE_FREQ_INFO& sample);

class NDDSUSERDllExport ST_CLA_RESULT_INFO {
  public:
    ST_CLA_RESULT_INFO();

    ST_CLA_RESULT_INFO(uint32_t ulChar_id,const ::dds::core::array< char, 31L>& acClassKor,const ::dds::core::array< char, 31L>& acNameKor,double dSpeed,const ::dds::core::array< char, 81L>& acUser_countries,const ::dds::core::array< char, 16L>& acShipSub,const ::dds::core::array< char, 10L>& acClaRet,double dScore);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_CLA_RESULT_INFO (ST_CLA_RESULT_INFO&&) = default;
    ST_CLA_RESULT_INFO& operator=(ST_CLA_RESULT_INFO&&) = default;
    ST_CLA_RESULT_INFO& operator=(const ST_CLA_RESULT_INFO&) = default;
    ST_CLA_RESULT_INFO(const ST_CLA_RESULT_INFO&) = default;
    #else
    ST_CLA_RESULT_INFO(ST_CLA_RESULT_INFO&& other_) OMG_NOEXCEPT;  
    ST_CLA_RESULT_INFO& operator=(ST_CLA_RESULT_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulChar_id() OMG_NOEXCEPT {
        return m_ulChar_id_;
    }

    const uint32_t& ulChar_id() const OMG_NOEXCEPT {
        return m_ulChar_id_;
    }

    void ulChar_id(uint32_t value) {
        m_ulChar_id_ = value;
    }

    ::dds::core::array< char, 31L>& acClassKor() OMG_NOEXCEPT {
        return m_acClassKor_;
    }

    const ::dds::core::array< char, 31L>& acClassKor() const OMG_NOEXCEPT {
        return m_acClassKor_;
    }

    void acClassKor(const ::dds::core::array< char, 31L>& value) {
        m_acClassKor_ = value;
    }

    void acClassKor(::dds::core::array< char, 31L>&& value) {
        m_acClassKor_ = std::move(value);
    }
    ::dds::core::array< char, 31L>& acNameKor() OMG_NOEXCEPT {
        return m_acNameKor_;
    }

    const ::dds::core::array< char, 31L>& acNameKor() const OMG_NOEXCEPT {
        return m_acNameKor_;
    }

    void acNameKor(const ::dds::core::array< char, 31L>& value) {
        m_acNameKor_ = value;
    }

    void acNameKor(::dds::core::array< char, 31L>&& value) {
        m_acNameKor_ = std::move(value);
    }
    double& dSpeed() OMG_NOEXCEPT {
        return m_dSpeed_;
    }

    const double& dSpeed() const OMG_NOEXCEPT {
        return m_dSpeed_;
    }

    void dSpeed(double value) {
        m_dSpeed_ = value;
    }

    ::dds::core::array< char, 81L>& acUser_countries() OMG_NOEXCEPT {
        return m_acUser_countries_;
    }

    const ::dds::core::array< char, 81L>& acUser_countries() const OMG_NOEXCEPT {
        return m_acUser_countries_;
    }

    void acUser_countries(const ::dds::core::array< char, 81L>& value) {
        m_acUser_countries_ = value;
    }

    void acUser_countries(::dds::core::array< char, 81L>&& value) {
        m_acUser_countries_ = std::move(value);
    }
    ::dds::core::array< char, 16L>& acShipSub() OMG_NOEXCEPT {
        return m_acShipSub_;
    }

    const ::dds::core::array< char, 16L>& acShipSub() const OMG_NOEXCEPT {
        return m_acShipSub_;
    }

    void acShipSub(const ::dds::core::array< char, 16L>& value) {
        m_acShipSub_ = value;
    }

    void acShipSub(::dds::core::array< char, 16L>&& value) {
        m_acShipSub_ = std::move(value);
    }
    ::dds::core::array< char, 10L>& acClaRet() OMG_NOEXCEPT {
        return m_acClaRet_;
    }

    const ::dds::core::array< char, 10L>& acClaRet() const OMG_NOEXCEPT {
        return m_acClaRet_;
    }

    void acClaRet(const ::dds::core::array< char, 10L>& value) {
        m_acClaRet_ = value;
    }

    void acClaRet(::dds::core::array< char, 10L>&& value) {
        m_acClaRet_ = std::move(value);
    }
    double& dScore() OMG_NOEXCEPT {
        return m_dScore_;
    }

    const double& dScore() const OMG_NOEXCEPT {
        return m_dScore_;
    }

    void dScore(double value) {
        m_dScore_ = value;
    }

    bool operator == (const ST_CLA_RESULT_INFO& other_) const;
    bool operator != (const ST_CLA_RESULT_INFO& other_) const;

    void swap(ST_CLA_RESULT_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulChar_id_;
    ::dds::core::array< char, 31L> m_acClassKor_;
    ::dds::core::array< char, 31L> m_acNameKor_;
    double m_dSpeed_;
    ::dds::core::array< char, 81L> m_acUser_countries_;
    ::dds::core::array< char, 16L> m_acShipSub_;
    ::dds::core::array< char, 10L> m_acClaRet_;
    double m_dScore_;

};

inline void swap(ST_CLA_RESULT_INFO& a, ST_CLA_RESULT_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_CLA_RESULT_INFO& sample);

class NDDSUSERDllExport DATMGR_CLASSIFICATION_RESULT {
  public:
    DATMGR_CLASSIFICATION_RESULT();

    DATMGR_CLASSIFICATION_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oClaType,uint16_t usDataIndex,uint16_t usGlobalTargetNum,const ST_DATE_TIME& stReqTime,const ST_DATE_TIME& stSendTime,uint16_t usClaRetNum,uint16_t usSensorID,uint16_t usBeamNum,const ST_FEATURE_FREQ_INFO& stFeatureInfo,const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAResult,const ::dds::core::array< uint8_t, 256L>& szComments,uint16_t usLOFARFrameNum,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram,uint16_t usDEMONFrameNum,const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_CLASSIFICATION_RESULT (DATMGR_CLASSIFICATION_RESULT&&) = default;
    DATMGR_CLASSIFICATION_RESULT& operator=(DATMGR_CLASSIFICATION_RESULT&&) = default;
    DATMGR_CLASSIFICATION_RESULT& operator=(const DATMGR_CLASSIFICATION_RESULT&) = default;
    DATMGR_CLASSIFICATION_RESULT(const DATMGR_CLASSIFICATION_RESULT&) = default;
    #else
    DATMGR_CLASSIFICATION_RESULT(DATMGR_CLASSIFICATION_RESULT&& other_) OMG_NOEXCEPT;  
    DATMGR_CLASSIFICATION_RESULT& operator=(DATMGR_CLASSIFICATION_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oClaType() OMG_NOEXCEPT {
        return m_oClaType_;
    }

    const uint8_t& oClaType() const OMG_NOEXCEPT {
        return m_oClaType_;
    }

    void oClaType(uint8_t value) {
        m_oClaType_ = value;
    }

    uint16_t& usDataIndex() OMG_NOEXCEPT {
        return m_usDataIndex_;
    }

    const uint16_t& usDataIndex() const OMG_NOEXCEPT {
        return m_usDataIndex_;
    }

    void usDataIndex(uint16_t value) {
        m_usDataIndex_ = value;
    }

    uint16_t& usGlobalTargetNum() OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    const uint16_t& usGlobalTargetNum() const OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    void usGlobalTargetNum(uint16_t value) {
        m_usGlobalTargetNum_ = value;
    }

    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    ST_DATE_TIME& stSendTime() OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    const ST_DATE_TIME& stSendTime() const OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    void stSendTime(const ST_DATE_TIME& value) {
        m_stSendTime_ = value;
    }

    void stSendTime(ST_DATE_TIME&& value) {
        m_stSendTime_ = std::move(value);
    }
    uint16_t& usClaRetNum() OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    const uint16_t& usClaRetNum() const OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    void usClaRetNum(uint16_t value) {
        m_usClaRetNum_ = value;
    }

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usBeamNum() OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    const uint16_t& usBeamNum() const OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    void usBeamNum(uint16_t value) {
        m_usBeamNum_ = value;
    }

    ST_FEATURE_FREQ_INFO& stFeatureInfo() OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    const ST_FEATURE_FREQ_INFO& stFeatureInfo() const OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    void stFeatureInfo(const ST_FEATURE_FREQ_INFO& value) {
        m_stFeatureInfo_ = value;
    }

    void stFeatureInfo(ST_FEATURE_FREQ_INFO&& value) {
        m_stFeatureInfo_ = std::move(value);
    }
    ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAResult() OMG_NOEXCEPT {
        return m_stCLAResult_;
    }

    const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAResult() const OMG_NOEXCEPT {
        return m_stCLAResult_;
    }

    void stCLAResult(const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& value) {
        m_stCLAResult_ = value;
    }

    void stCLAResult(::dds::core::array< ST_CLA_RESULT_INFO, 8L>&& value) {
        m_stCLAResult_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& szComments() OMG_NOEXCEPT {
        return m_szComments_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComments() const OMG_NOEXCEPT {
        return m_szComments_;
    }

    void szComments(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComments_ = value;
    }

    void szComments(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComments_ = std::move(value);
    }
    uint16_t& usLOFARFrameNum() OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    const uint16_t& usLOFARFrameNum() const OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    void usLOFARFrameNum(uint16_t value) {
        m_usLOFARFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() const OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    void fLOFARGram(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& value) {
        m_fLOFARGram_ = value;
    }

    void fLOFARGram(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>&& value) {
        m_fLOFARGram_ = std::move(value);
    }
    uint16_t& usDEMONFrameNum() OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    const uint16_t& usDEMONFrameNum() const OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    void usDEMONFrameNum(uint16_t value) {
        m_usDEMONFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() const OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    void fDEMONGram(const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& value) {
        m_fDEMONGram_ = value;
    }

    void fDEMONGram(::dds::core::array< ::dds::core::array< float, 1601L>, 300L>&& value) {
        m_fDEMONGram_ = std::move(value);
    }

    bool operator == (const DATMGR_CLASSIFICATION_RESULT& other_) const;
    bool operator != (const DATMGR_CLASSIFICATION_RESULT& other_) const;

    void swap(DATMGR_CLASSIFICATION_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oClaType_;
    uint16_t m_usDataIndex_;
    uint16_t m_usGlobalTargetNum_;
    ST_DATE_TIME m_stReqTime_;
    ST_DATE_TIME m_stSendTime_;
    uint16_t m_usClaRetNum_;
    uint16_t m_usSensorID_;
    uint16_t m_usBeamNum_;
    ST_FEATURE_FREQ_INFO m_stFeatureInfo_;
    ::dds::core::array< ST_CLA_RESULT_INFO, 8L> m_stCLAResult_;
    ::dds::core::array< uint8_t, 256L> m_szComments_;
    uint16_t m_usLOFARFrameNum_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L> m_fLOFARGram_;
    uint16_t m_usDEMONFrameNum_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L> m_fDEMONGram_;

};

inline void swap(DATMGR_CLASSIFICATION_RESULT& a, DATMGR_CLASSIFICATION_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_CLASSIFICATION_RESULT& sample);

class NDDSUSERDllExport DATMGR_CLASSIFICATION_RESULT_LIST {
  public:
    DATMGR_CLASSIFICATION_RESULT_LIST();

    DATMGR_CLASSIFICATION_RESULT_LIST(const ST_MSG_HEADER& stMsgHeader,uint8_t oClaType,uint16_t usTotalPageNum,uint16_t usCurrentPageNum,uint16_t usDataNum,const ::dds::core::array< uint16_t, 100L>& usDataIndex,const ::dds::core::array< uint16_t, 100L>& usGlobalTargetNum,const ::dds::core::array< ST_DATE_TIME, 100L>& stReqTime,const ::dds::core::array< ST_DATE_TIME, 100L>& stSendTime,const ::dds::core::array< uint16_t, 100L>& usSensorID,const ::dds::core::array< uint16_t, 100L>& usBeamNum,const ::dds::core::array< ::dds::core::array< ST_CLA_RESULT_INFO, 8L>, 100L>& stCLAResult,const ::dds::core::array< ::dds::core::array< uint8_t, 256L>, 100L>& szComments);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_CLASSIFICATION_RESULT_LIST (DATMGR_CLASSIFICATION_RESULT_LIST&&) = default;
    DATMGR_CLASSIFICATION_RESULT_LIST& operator=(DATMGR_CLASSIFICATION_RESULT_LIST&&) = default;
    DATMGR_CLASSIFICATION_RESULT_LIST& operator=(const DATMGR_CLASSIFICATION_RESULT_LIST&) = default;
    DATMGR_CLASSIFICATION_RESULT_LIST(const DATMGR_CLASSIFICATION_RESULT_LIST&) = default;
    #else
    DATMGR_CLASSIFICATION_RESULT_LIST(DATMGR_CLASSIFICATION_RESULT_LIST&& other_) OMG_NOEXCEPT;  
    DATMGR_CLASSIFICATION_RESULT_LIST& operator=(DATMGR_CLASSIFICATION_RESULT_LIST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oClaType() OMG_NOEXCEPT {
        return m_oClaType_;
    }

    const uint8_t& oClaType() const OMG_NOEXCEPT {
        return m_oClaType_;
    }

    void oClaType(uint8_t value) {
        m_oClaType_ = value;
    }

    uint16_t& usTotalPageNum() OMG_NOEXCEPT {
        return m_usTotalPageNum_;
    }

    const uint16_t& usTotalPageNum() const OMG_NOEXCEPT {
        return m_usTotalPageNum_;
    }

    void usTotalPageNum(uint16_t value) {
        m_usTotalPageNum_ = value;
    }

    uint16_t& usCurrentPageNum() OMG_NOEXCEPT {
        return m_usCurrentPageNum_;
    }

    const uint16_t& usCurrentPageNum() const OMG_NOEXCEPT {
        return m_usCurrentPageNum_;
    }

    void usCurrentPageNum(uint16_t value) {
        m_usCurrentPageNum_ = value;
    }

    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    ::dds::core::array< uint16_t, 100L>& usDataIndex() OMG_NOEXCEPT {
        return m_usDataIndex_;
    }

    const ::dds::core::array< uint16_t, 100L>& usDataIndex() const OMG_NOEXCEPT {
        return m_usDataIndex_;
    }

    void usDataIndex(const ::dds::core::array< uint16_t, 100L>& value) {
        m_usDataIndex_ = value;
    }

    void usDataIndex(::dds::core::array< uint16_t, 100L>&& value) {
        m_usDataIndex_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 100L>& usGlobalTargetNum() OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    const ::dds::core::array< uint16_t, 100L>& usGlobalTargetNum() const OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    void usGlobalTargetNum(const ::dds::core::array< uint16_t, 100L>& value) {
        m_usGlobalTargetNum_ = value;
    }

    void usGlobalTargetNum(::dds::core::array< uint16_t, 100L>&& value) {
        m_usGlobalTargetNum_ = std::move(value);
    }
    ::dds::core::array< ST_DATE_TIME, 100L>& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ::dds::core::array< ST_DATE_TIME, 100L>& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ::dds::core::array< ST_DATE_TIME, 100L>& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(::dds::core::array< ST_DATE_TIME, 100L>&& value) {
        m_stReqTime_ = std::move(value);
    }
    ::dds::core::array< ST_DATE_TIME, 100L>& stSendTime() OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    const ::dds::core::array< ST_DATE_TIME, 100L>& stSendTime() const OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    void stSendTime(const ::dds::core::array< ST_DATE_TIME, 100L>& value) {
        m_stSendTime_ = value;
    }

    void stSendTime(::dds::core::array< ST_DATE_TIME, 100L>&& value) {
        m_stSendTime_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 100L>& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const ::dds::core::array< uint16_t, 100L>& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(const ::dds::core::array< uint16_t, 100L>& value) {
        m_usSensorID_ = value;
    }

    void usSensorID(::dds::core::array< uint16_t, 100L>&& value) {
        m_usSensorID_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 100L>& usBeamNum() OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    const ::dds::core::array< uint16_t, 100L>& usBeamNum() const OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    void usBeamNum(const ::dds::core::array< uint16_t, 100L>& value) {
        m_usBeamNum_ = value;
    }

    void usBeamNum(::dds::core::array< uint16_t, 100L>&& value) {
        m_usBeamNum_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ST_CLA_RESULT_INFO, 8L>, 100L>& stCLAResult() OMG_NOEXCEPT {
        return m_stCLAResult_;
    }

    const ::dds::core::array< ::dds::core::array< ST_CLA_RESULT_INFO, 8L>, 100L>& stCLAResult() const OMG_NOEXCEPT {
        return m_stCLAResult_;
    }

    void stCLAResult(const ::dds::core::array< ::dds::core::array< ST_CLA_RESULT_INFO, 8L>, 100L>& value) {
        m_stCLAResult_ = value;
    }

    void stCLAResult(::dds::core::array< ::dds::core::array< ST_CLA_RESULT_INFO, 8L>, 100L>&& value) {
        m_stCLAResult_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint8_t, 256L>, 100L>& szComments() OMG_NOEXCEPT {
        return m_szComments_;
    }

    const ::dds::core::array< ::dds::core::array< uint8_t, 256L>, 100L>& szComments() const OMG_NOEXCEPT {
        return m_szComments_;
    }

    void szComments(const ::dds::core::array< ::dds::core::array< uint8_t, 256L>, 100L>& value) {
        m_szComments_ = value;
    }

    void szComments(::dds::core::array< ::dds::core::array< uint8_t, 256L>, 100L>&& value) {
        m_szComments_ = std::move(value);
    }

    bool operator == (const DATMGR_CLASSIFICATION_RESULT_LIST& other_) const;
    bool operator != (const DATMGR_CLASSIFICATION_RESULT_LIST& other_) const;

    void swap(DATMGR_CLASSIFICATION_RESULT_LIST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oClaType_;
    uint16_t m_usTotalPageNum_;
    uint16_t m_usCurrentPageNum_;
    uint16_t m_usDataNum_;
    ::dds::core::array< uint16_t, 100L> m_usDataIndex_;
    ::dds::core::array< uint16_t, 100L> m_usGlobalTargetNum_;
    ::dds::core::array< ST_DATE_TIME, 100L> m_stReqTime_;
    ::dds::core::array< ST_DATE_TIME, 100L> m_stSendTime_;
    ::dds::core::array< uint16_t, 100L> m_usSensorID_;
    ::dds::core::array< uint16_t, 100L> m_usBeamNum_;
    ::dds::core::array< ::dds::core::array< ST_CLA_RESULT_INFO, 8L>, 100L> m_stCLAResult_;
    ::dds::core::array< ::dds::core::array< uint8_t, 256L>, 100L> m_szComments_;

};

inline void swap(DATMGR_CLASSIFICATION_RESULT_LIST& a, DATMGR_CLASSIFICATION_RESULT_LIST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_CLASSIFICATION_RESULT_LIST& sample);

class NDDSUSERDllExport DATMGR_CLA_MANAGE_RESULT {
  public:
    DATMGR_CLA_MANAGE_RESULT();

    DATMGR_CLA_MANAGE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint8_t oRequestResult,uint8_t oDetailReason);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_CLA_MANAGE_RESULT (DATMGR_CLA_MANAGE_RESULT&&) = default;
    DATMGR_CLA_MANAGE_RESULT& operator=(DATMGR_CLA_MANAGE_RESULT&&) = default;
    DATMGR_CLA_MANAGE_RESULT& operator=(const DATMGR_CLA_MANAGE_RESULT&) = default;
    DATMGR_CLA_MANAGE_RESULT(const DATMGR_CLA_MANAGE_RESULT&) = default;
    #else
    DATMGR_CLA_MANAGE_RESULT(DATMGR_CLA_MANAGE_RESULT&& other_) OMG_NOEXCEPT;  
    DATMGR_CLA_MANAGE_RESULT& operator=(DATMGR_CLA_MANAGE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint8_t& oRequestResult() OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    const uint8_t& oRequestResult() const OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    void oRequestResult(uint8_t value) {
        m_oRequestResult_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    bool operator == (const DATMGR_CLA_MANAGE_RESULT& other_) const;
    bool operator != (const DATMGR_CLA_MANAGE_RESULT& other_) const;

    void swap(DATMGR_CLA_MANAGE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint8_t m_oRequestResult_;
    uint8_t m_oDetailReason_;

};

inline void swap(DATMGR_CLA_MANAGE_RESULT& a, DATMGR_CLA_MANAGE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_CLA_MANAGE_RESULT& sample);

class NDDSUSERDllExport DATMGR_LAS_AUDIO_SIG_INFO {
  public:
    DATMGR_LAS_AUDIO_SIG_INFO();

    DATMGR_LAS_AUDIO_SIG_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNum,uint8_t oAxis,uint16_t unAngle,uint8_t oFreqBand,uint16_t usTargetNumber,const ::dds::core::array< int16_t, 2048L>& nLASAudioSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_LAS_AUDIO_SIG_INFO (DATMGR_LAS_AUDIO_SIG_INFO&&) = default;
    DATMGR_LAS_AUDIO_SIG_INFO& operator=(DATMGR_LAS_AUDIO_SIG_INFO&&) = default;
    DATMGR_LAS_AUDIO_SIG_INFO& operator=(const DATMGR_LAS_AUDIO_SIG_INFO&) = default;
    DATMGR_LAS_AUDIO_SIG_INFO(const DATMGR_LAS_AUDIO_SIG_INFO&) = default;
    #else
    DATMGR_LAS_AUDIO_SIG_INFO(DATMGR_LAS_AUDIO_SIG_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_LAS_AUDIO_SIG_INFO& operator=(DATMGR_LAS_AUDIO_SIG_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNum() OMG_NOEXCEPT {
        return m_ulFrameNum_;
    }

    const uint32_t& ulFrameNum() const OMG_NOEXCEPT {
        return m_ulFrameNum_;
    }

    void ulFrameNum(uint32_t value) {
        m_ulFrameNum_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& unAngle() OMG_NOEXCEPT {
        return m_unAngle_;
    }

    const uint16_t& unAngle() const OMG_NOEXCEPT {
        return m_unAngle_;
    }

    void unAngle(uint16_t value) {
        m_unAngle_ = value;
    }

    uint8_t& oFreqBand() OMG_NOEXCEPT {
        return m_oFreqBand_;
    }

    const uint8_t& oFreqBand() const OMG_NOEXCEPT {
        return m_oFreqBand_;
    }

    void oFreqBand(uint8_t value) {
        m_oFreqBand_ = value;
    }

    uint16_t& usTargetNumber() OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    const uint16_t& usTargetNumber() const OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    void usTargetNumber(uint16_t value) {
        m_usTargetNumber_ = value;
    }

    ::dds::core::array< int16_t, 2048L>& nLASAudioSig() OMG_NOEXCEPT {
        return m_nLASAudioSig_;
    }

    const ::dds::core::array< int16_t, 2048L>& nLASAudioSig() const OMG_NOEXCEPT {
        return m_nLASAudioSig_;
    }

    void nLASAudioSig(const ::dds::core::array< int16_t, 2048L>& value) {
        m_nLASAudioSig_ = value;
    }

    void nLASAudioSig(::dds::core::array< int16_t, 2048L>&& value) {
        m_nLASAudioSig_ = std::move(value);
    }

    bool operator == (const DATMGR_LAS_AUDIO_SIG_INFO& other_) const;
    bool operator != (const DATMGR_LAS_AUDIO_SIG_INFO& other_) const;

    void swap(DATMGR_LAS_AUDIO_SIG_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNum_;
    uint8_t m_oAxis_;
    uint16_t m_unAngle_;
    uint8_t m_oFreqBand_;
    uint16_t m_usTargetNumber_;
    ::dds::core::array< int16_t, 2048L> m_nLASAudioSig_;

};

inline void swap(DATMGR_LAS_AUDIO_SIG_INFO& a, DATMGR_LAS_AUDIO_SIG_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_LAS_AUDIO_SIG_INFO& sample);

class NDDSUSERDllExport ST_EXTRACTED_GRAM {
  public:
    ST_EXTRACTED_GRAM();

    ST_EXTRACTED_GRAM(uint16_t usExtractedGramIndex,const ::dds::core::array< uint8_t, 30L>& szUserID,const ST_DATE_TIME& stSaveTime,const ::dds::core::array< uint8_t, 256L>& szUserTag,uint8_t oSensorType,const ::dds::core::array< float, 4L>& aFreq);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EXTRACTED_GRAM (ST_EXTRACTED_GRAM&&) = default;
    ST_EXTRACTED_GRAM& operator=(ST_EXTRACTED_GRAM&&) = default;
    ST_EXTRACTED_GRAM& operator=(const ST_EXTRACTED_GRAM&) = default;
    ST_EXTRACTED_GRAM(const ST_EXTRACTED_GRAM&) = default;
    #else
    ST_EXTRACTED_GRAM(ST_EXTRACTED_GRAM&& other_) OMG_NOEXCEPT;  
    ST_EXTRACTED_GRAM& operator=(ST_EXTRACTED_GRAM&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usExtractedGramIndex() OMG_NOEXCEPT {
        return m_usExtractedGramIndex_;
    }

    const uint16_t& usExtractedGramIndex() const OMG_NOEXCEPT {
        return m_usExtractedGramIndex_;
    }

    void usExtractedGramIndex(uint16_t value) {
        m_usExtractedGramIndex_ = value;
    }

    ::dds::core::array< uint8_t, 30L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 30L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 30L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 30L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ST_DATE_TIME& stSaveTime() OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    const ST_DATE_TIME& stSaveTime() const OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    void stSaveTime(const ST_DATE_TIME& value) {
        m_stSaveTime_ = value;
    }

    void stSaveTime(ST_DATE_TIME&& value) {
        m_stSaveTime_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& szUserTag() OMG_NOEXCEPT {
        return m_szUserTag_;
    }

    const ::dds::core::array< uint8_t, 256L>& szUserTag() const OMG_NOEXCEPT {
        return m_szUserTag_;
    }

    void szUserTag(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szUserTag_ = value;
    }

    void szUserTag(::dds::core::array< uint8_t, 256L>&& value) {
        m_szUserTag_ = std::move(value);
    }
    uint8_t& oSensorType() OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    const uint8_t& oSensorType() const OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    void oSensorType(uint8_t value) {
        m_oSensorType_ = value;
    }

    ::dds::core::array< float, 4L>& aFreq() OMG_NOEXCEPT {
        return m_aFreq_;
    }

    const ::dds::core::array< float, 4L>& aFreq() const OMG_NOEXCEPT {
        return m_aFreq_;
    }

    void aFreq(const ::dds::core::array< float, 4L>& value) {
        m_aFreq_ = value;
    }

    void aFreq(::dds::core::array< float, 4L>&& value) {
        m_aFreq_ = std::move(value);
    }

    bool operator == (const ST_EXTRACTED_GRAM& other_) const;
    bool operator != (const ST_EXTRACTED_GRAM& other_) const;

    void swap(ST_EXTRACTED_GRAM& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usExtractedGramIndex_;
    ::dds::core::array< uint8_t, 30L> m_szUserID_;
    ST_DATE_TIME m_stSaveTime_;
    ::dds::core::array< uint8_t, 256L> m_szUserTag_;
    uint8_t m_oSensorType_;
    ::dds::core::array< float, 4L> m_aFreq_;

};

inline void swap(ST_EXTRACTED_GRAM& a, ST_EXTRACTED_GRAM& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EXTRACTED_GRAM& sample);

class NDDSUSERDllExport DATMGR_LAS_EXTRACTED_GRAM_INFO {
  public:
    DATMGR_LAS_EXTRACTED_GRAM_INFO();

    DATMGR_LAS_EXTRACTED_GRAM_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_EXTRACTED_GRAM& stExtractedGramInfo,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 80L>& aLASExtractedGram);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_LAS_EXTRACTED_GRAM_INFO (DATMGR_LAS_EXTRACTED_GRAM_INFO&&) = default;
    DATMGR_LAS_EXTRACTED_GRAM_INFO& operator=(DATMGR_LAS_EXTRACTED_GRAM_INFO&&) = default;
    DATMGR_LAS_EXTRACTED_GRAM_INFO& operator=(const DATMGR_LAS_EXTRACTED_GRAM_INFO&) = default;
    DATMGR_LAS_EXTRACTED_GRAM_INFO(const DATMGR_LAS_EXTRACTED_GRAM_INFO&) = default;
    #else
    DATMGR_LAS_EXTRACTED_GRAM_INFO(DATMGR_LAS_EXTRACTED_GRAM_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_LAS_EXTRACTED_GRAM_INFO& operator=(DATMGR_LAS_EXTRACTED_GRAM_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_EXTRACTED_GRAM& stExtractedGramInfo() OMG_NOEXCEPT {
        return m_stExtractedGramInfo_;
    }

    const ST_EXTRACTED_GRAM& stExtractedGramInfo() const OMG_NOEXCEPT {
        return m_stExtractedGramInfo_;
    }

    void stExtractedGramInfo(const ST_EXTRACTED_GRAM& value) {
        m_stExtractedGramInfo_ = value;
    }

    void stExtractedGramInfo(ST_EXTRACTED_GRAM&& value) {
        m_stExtractedGramInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 80L>& aLASExtractedGram() OMG_NOEXCEPT {
        return m_aLASExtractedGram_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 80L>& aLASExtractedGram() const OMG_NOEXCEPT {
        return m_aLASExtractedGram_;
    }

    void aLASExtractedGram(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 80L>& value) {
        m_aLASExtractedGram_ = value;
    }

    void aLASExtractedGram(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 80L>&& value) {
        m_aLASExtractedGram_ = std::move(value);
    }

    bool operator == (const DATMGR_LAS_EXTRACTED_GRAM_INFO& other_) const;
    bool operator != (const DATMGR_LAS_EXTRACTED_GRAM_INFO& other_) const;

    void swap(DATMGR_LAS_EXTRACTED_GRAM_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_EXTRACTED_GRAM m_stExtractedGramInfo_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 80L> m_aLASExtractedGram_;

};

inline void swap(DATMGR_LAS_EXTRACTED_GRAM_INFO& a, DATMGR_LAS_EXTRACTED_GRAM_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_LAS_EXTRACTED_GRAM_INFO& sample);

class NDDSUSERDllExport DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL {
  public:
    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL();

    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usGlobalTgtNo,float fSpeed,uint16_t usLOFARFreqCnt,const ::dds::core::array< float, 24L>& aLOFARFreq,uint16_t usDEMONFreqCnt,const ::dds::core::array< float, 6L>& aDEMONFreq,const ST_DATE_TIME& fReqTime,uint16_t usSensorID,uint16_t usShipType,uint16_t usFriendlyInfo,uint32_t ulMaintainTime,uint16_t usLASFrameNum,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLASGram,uint16_t usDEMONFrameNum,const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram,uint16_t usAutoManualMode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL (DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL&&) = default;
    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& operator=(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL&&) = default;
    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& operator=(const DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL&) = default;
    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL(const DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL&) = default;
    #else
    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL&& other_) OMG_NOEXCEPT;  
    DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& operator=(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usGlobalTgtNo() OMG_NOEXCEPT {
        return m_usGlobalTgtNo_;
    }

    const uint16_t& usGlobalTgtNo() const OMG_NOEXCEPT {
        return m_usGlobalTgtNo_;
    }

    void usGlobalTgtNo(uint16_t value) {
        m_usGlobalTgtNo_ = value;
    }

    float& fSpeed() OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    const float& fSpeed() const OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    void fSpeed(float value) {
        m_fSpeed_ = value;
    }

    uint16_t& usLOFARFreqCnt() OMG_NOEXCEPT {
        return m_usLOFARFreqCnt_;
    }

    const uint16_t& usLOFARFreqCnt() const OMG_NOEXCEPT {
        return m_usLOFARFreqCnt_;
    }

    void usLOFARFreqCnt(uint16_t value) {
        m_usLOFARFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aLOFARFreq() OMG_NOEXCEPT {
        return m_aLOFARFreq_;
    }

    const ::dds::core::array< float, 24L>& aLOFARFreq() const OMG_NOEXCEPT {
        return m_aLOFARFreq_;
    }

    void aLOFARFreq(const ::dds::core::array< float, 24L>& value) {
        m_aLOFARFreq_ = value;
    }

    void aLOFARFreq(::dds::core::array< float, 24L>&& value) {
        m_aLOFARFreq_ = std::move(value);
    }
    uint16_t& usDEMONFreqCnt() OMG_NOEXCEPT {
        return m_usDEMONFreqCnt_;
    }

    const uint16_t& usDEMONFreqCnt() const OMG_NOEXCEPT {
        return m_usDEMONFreqCnt_;
    }

    void usDEMONFreqCnt(uint16_t value) {
        m_usDEMONFreqCnt_ = value;
    }

    ::dds::core::array< float, 6L>& aDEMONFreq() OMG_NOEXCEPT {
        return m_aDEMONFreq_;
    }

    const ::dds::core::array< float, 6L>& aDEMONFreq() const OMG_NOEXCEPT {
        return m_aDEMONFreq_;
    }

    void aDEMONFreq(const ::dds::core::array< float, 6L>& value) {
        m_aDEMONFreq_ = value;
    }

    void aDEMONFreq(::dds::core::array< float, 6L>&& value) {
        m_aDEMONFreq_ = std::move(value);
    }
    ST_DATE_TIME& fReqTime() OMG_NOEXCEPT {
        return m_fReqTime_;
    }

    const ST_DATE_TIME& fReqTime() const OMG_NOEXCEPT {
        return m_fReqTime_;
    }

    void fReqTime(const ST_DATE_TIME& value) {
        m_fReqTime_ = value;
    }

    void fReqTime(ST_DATE_TIME&& value) {
        m_fReqTime_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usShipType() OMG_NOEXCEPT {
        return m_usShipType_;
    }

    const uint16_t& usShipType() const OMG_NOEXCEPT {
        return m_usShipType_;
    }

    void usShipType(uint16_t value) {
        m_usShipType_ = value;
    }

    uint16_t& usFriendlyInfo() OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    const uint16_t& usFriendlyInfo() const OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    void usFriendlyInfo(uint16_t value) {
        m_usFriendlyInfo_ = value;
    }

    uint32_t& ulMaintainTime() OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    const uint32_t& ulMaintainTime() const OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    void ulMaintainTime(uint32_t value) {
        m_ulMaintainTime_ = value;
    }

    uint16_t& usLASFrameNum() OMG_NOEXCEPT {
        return m_usLASFrameNum_;
    }

    const uint16_t& usLASFrameNum() const OMG_NOEXCEPT {
        return m_usLASFrameNum_;
    }

    void usLASFrameNum(uint16_t value) {
        m_usLASFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLASGram() OMG_NOEXCEPT {
        return m_fLASGram_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLASGram() const OMG_NOEXCEPT {
        return m_fLASGram_;
    }

    void fLASGram(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& value) {
        m_fLASGram_ = value;
    }

    void fLASGram(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>&& value) {
        m_fLASGram_ = std::move(value);
    }
    uint16_t& usDEMONFrameNum() OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    const uint16_t& usDEMONFrameNum() const OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    void usDEMONFrameNum(uint16_t value) {
        m_usDEMONFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() const OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    void fDEMONGram(const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& value) {
        m_fDEMONGram_ = value;
    }

    void fDEMONGram(::dds::core::array< ::dds::core::array< float, 1601L>, 300L>&& value) {
        m_fDEMONGram_ = std::move(value);
    }
    uint16_t& usAutoManualMode() OMG_NOEXCEPT {
        return m_usAutoManualMode_;
    }

    const uint16_t& usAutoManualMode() const OMG_NOEXCEPT {
        return m_usAutoManualMode_;
    }

    void usAutoManualMode(uint16_t value) {
        m_usAutoManualMode_ = value;
    }

    bool operator == (const DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& other_) const;
    bool operator != (const DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& other_) const;

    void swap(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usGlobalTgtNo_;
    float m_fSpeed_;
    uint16_t m_usLOFARFreqCnt_;
    ::dds::core::array< float, 24L> m_aLOFARFreq_;
    uint16_t m_usDEMONFreqCnt_;
    ::dds::core::array< float, 6L> m_aDEMONFreq_;
    ST_DATE_TIME m_fReqTime_;
    uint16_t m_usSensorID_;
    uint16_t m_usShipType_;
    uint16_t m_usFriendlyInfo_;
    uint32_t m_ulMaintainTime_;
    uint16_t m_usLASFrameNum_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L> m_fLASGram_;
    uint16_t m_usDEMONFrameNum_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L> m_fDEMONGram_;
    uint16_t m_usAutoManualMode_;

};

inline void swap(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& a, DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& sample);

class NDDSUSERDllExport DATMGR_MAS_AUDIO_SIG_INFO {
  public:
    DATMGR_MAS_AUDIO_SIG_INFO();

    DATMGR_MAS_AUDIO_SIG_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNum,uint8_t oAxis,uint8_t oChannel,uint16_t usTargetNumber,const ::dds::core::array< int16_t, 4096L>& nMASAudioSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_MAS_AUDIO_SIG_INFO (DATMGR_MAS_AUDIO_SIG_INFO&&) = default;
    DATMGR_MAS_AUDIO_SIG_INFO& operator=(DATMGR_MAS_AUDIO_SIG_INFO&&) = default;
    DATMGR_MAS_AUDIO_SIG_INFO& operator=(const DATMGR_MAS_AUDIO_SIG_INFO&) = default;
    DATMGR_MAS_AUDIO_SIG_INFO(const DATMGR_MAS_AUDIO_SIG_INFO&) = default;
    #else
    DATMGR_MAS_AUDIO_SIG_INFO(DATMGR_MAS_AUDIO_SIG_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_MAS_AUDIO_SIG_INFO& operator=(DATMGR_MAS_AUDIO_SIG_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNum() OMG_NOEXCEPT {
        return m_ulFrameNum_;
    }

    const uint32_t& ulFrameNum() const OMG_NOEXCEPT {
        return m_ulFrameNum_;
    }

    void ulFrameNum(uint32_t value) {
        m_ulFrameNum_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint8_t& oChannel() OMG_NOEXCEPT {
        return m_oChannel_;
    }

    const uint8_t& oChannel() const OMG_NOEXCEPT {
        return m_oChannel_;
    }

    void oChannel(uint8_t value) {
        m_oChannel_ = value;
    }

    uint16_t& usTargetNumber() OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    const uint16_t& usTargetNumber() const OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    void usTargetNumber(uint16_t value) {
        m_usTargetNumber_ = value;
    }

    ::dds::core::array< int16_t, 4096L>& nMASAudioSig() OMG_NOEXCEPT {
        return m_nMASAudioSig_;
    }

    const ::dds::core::array< int16_t, 4096L>& nMASAudioSig() const OMG_NOEXCEPT {
        return m_nMASAudioSig_;
    }

    void nMASAudioSig(const ::dds::core::array< int16_t, 4096L>& value) {
        m_nMASAudioSig_ = value;
    }

    void nMASAudioSig(::dds::core::array< int16_t, 4096L>&& value) {
        m_nMASAudioSig_ = std::move(value);
    }

    bool operator == (const DATMGR_MAS_AUDIO_SIG_INFO& other_) const;
    bool operator != (const DATMGR_MAS_AUDIO_SIG_INFO& other_) const;

    void swap(DATMGR_MAS_AUDIO_SIG_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNum_;
    uint8_t m_oAxis_;
    uint8_t m_oChannel_;
    uint16_t m_usTargetNumber_;
    ::dds::core::array< int16_t, 4096L> m_nMASAudioSig_;

};

inline void swap(DATMGR_MAS_AUDIO_SIG_INFO& a, DATMGR_MAS_AUDIO_SIG_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_MAS_AUDIO_SIG_INFO& sample);

class NDDSUSERDllExport DATMGR_MAS_EXTRACTED_GRAM_INFO {
  public:
    DATMGR_MAS_EXTRACTED_GRAM_INFO();

    DATMGR_MAS_EXTRACTED_GRAM_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_EXTRACTED_GRAM& stExtractedGramInfo,const ::dds::core::array< ::dds::core::array< float, 1601L>, 80L>& aMASExtractedGram);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_MAS_EXTRACTED_GRAM_INFO (DATMGR_MAS_EXTRACTED_GRAM_INFO&&) = default;
    DATMGR_MAS_EXTRACTED_GRAM_INFO& operator=(DATMGR_MAS_EXTRACTED_GRAM_INFO&&) = default;
    DATMGR_MAS_EXTRACTED_GRAM_INFO& operator=(const DATMGR_MAS_EXTRACTED_GRAM_INFO&) = default;
    DATMGR_MAS_EXTRACTED_GRAM_INFO(const DATMGR_MAS_EXTRACTED_GRAM_INFO&) = default;
    #else
    DATMGR_MAS_EXTRACTED_GRAM_INFO(DATMGR_MAS_EXTRACTED_GRAM_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_MAS_EXTRACTED_GRAM_INFO& operator=(DATMGR_MAS_EXTRACTED_GRAM_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_EXTRACTED_GRAM& stExtractedGramInfo() OMG_NOEXCEPT {
        return m_stExtractedGramInfo_;
    }

    const ST_EXTRACTED_GRAM& stExtractedGramInfo() const OMG_NOEXCEPT {
        return m_stExtractedGramInfo_;
    }

    void stExtractedGramInfo(const ST_EXTRACTED_GRAM& value) {
        m_stExtractedGramInfo_ = value;
    }

    void stExtractedGramInfo(ST_EXTRACTED_GRAM&& value) {
        m_stExtractedGramInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 80L>& aMASExtractedGram() OMG_NOEXCEPT {
        return m_aMASExtractedGram_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 80L>& aMASExtractedGram() const OMG_NOEXCEPT {
        return m_aMASExtractedGram_;
    }

    void aMASExtractedGram(const ::dds::core::array< ::dds::core::array< float, 1601L>, 80L>& value) {
        m_aMASExtractedGram_ = value;
    }

    void aMASExtractedGram(::dds::core::array< ::dds::core::array< float, 1601L>, 80L>&& value) {
        m_aMASExtractedGram_ = std::move(value);
    }

    bool operator == (const DATMGR_MAS_EXTRACTED_GRAM_INFO& other_) const;
    bool operator != (const DATMGR_MAS_EXTRACTED_GRAM_INFO& other_) const;

    void swap(DATMGR_MAS_EXTRACTED_GRAM_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_EXTRACTED_GRAM m_stExtractedGramInfo_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 80L> m_aMASExtractedGram_;

};

inline void swap(DATMGR_MAS_EXTRACTED_GRAM_INFO& a, DATMGR_MAS_EXTRACTED_GRAM_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_MAS_EXTRACTED_GRAM_INFO& sample);

class NDDSUSERDllExport DATMGR_OI_CLASSIFICATION_GRAM_INFO {
  public:
    DATMGR_OI_CLASSIFICATION_GRAM_INFO();

    DATMGR_OI_CLASSIFICATION_GRAM_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_DATE_TIME& stSelectTime,uint8_t oAxis,uint16_t usBeamNum,uint16_t usLOFARFrameNum,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram,uint16_t usDEMONFrameNum,const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OI_CLASSIFICATION_GRAM_INFO (DATMGR_OI_CLASSIFICATION_GRAM_INFO&&) = default;
    DATMGR_OI_CLASSIFICATION_GRAM_INFO& operator=(DATMGR_OI_CLASSIFICATION_GRAM_INFO&&) = default;
    DATMGR_OI_CLASSIFICATION_GRAM_INFO& operator=(const DATMGR_OI_CLASSIFICATION_GRAM_INFO&) = default;
    DATMGR_OI_CLASSIFICATION_GRAM_INFO(const DATMGR_OI_CLASSIFICATION_GRAM_INFO&) = default;
    #else
    DATMGR_OI_CLASSIFICATION_GRAM_INFO(DATMGR_OI_CLASSIFICATION_GRAM_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OI_CLASSIFICATION_GRAM_INFO& operator=(DATMGR_OI_CLASSIFICATION_GRAM_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_DATE_TIME& stSelectTime() OMG_NOEXCEPT {
        return m_stSelectTime_;
    }

    const ST_DATE_TIME& stSelectTime() const OMG_NOEXCEPT {
        return m_stSelectTime_;
    }

    void stSelectTime(const ST_DATE_TIME& value) {
        m_stSelectTime_ = value;
    }

    void stSelectTime(ST_DATE_TIME&& value) {
        m_stSelectTime_ = std::move(value);
    }
    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& usBeamNum() OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    const uint16_t& usBeamNum() const OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    void usBeamNum(uint16_t value) {
        m_usBeamNum_ = value;
    }

    uint16_t& usLOFARFrameNum() OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    const uint16_t& usLOFARFrameNum() const OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    void usLOFARFrameNum(uint16_t value) {
        m_usLOFARFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() const OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    void fLOFARGram(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& value) {
        m_fLOFARGram_ = value;
    }

    void fLOFARGram(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>&& value) {
        m_fLOFARGram_ = std::move(value);
    }
    uint16_t& usDEMONFrameNum() OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    const uint16_t& usDEMONFrameNum() const OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    void usDEMONFrameNum(uint16_t value) {
        m_usDEMONFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() const OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    void fDEMONGram(const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& value) {
        m_fDEMONGram_ = value;
    }

    void fDEMONGram(::dds::core::array< ::dds::core::array< float, 1601L>, 300L>&& value) {
        m_fDEMONGram_ = std::move(value);
    }

    bool operator == (const DATMGR_OI_CLASSIFICATION_GRAM_INFO& other_) const;
    bool operator != (const DATMGR_OI_CLASSIFICATION_GRAM_INFO& other_) const;

    void swap(DATMGR_OI_CLASSIFICATION_GRAM_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_DATE_TIME m_stSelectTime_;
    uint8_t m_oAxis_;
    uint16_t m_usBeamNum_;
    uint16_t m_usLOFARFrameNum_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L> m_fLOFARGram_;
    uint16_t m_usDEMONFrameNum_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L> m_fDEMONGram_;

};

inline void swap(DATMGR_OI_CLASSIFICATION_GRAM_INFO& a, DATMGR_OI_CLASSIFICATION_GRAM_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OI_CLASSIFICATION_GRAM_INFO& sample);

class NDDSUSERDllExport DATMGR_OPER_BACKUP_STATUS_INFO {
  public:
    DATMGR_OPER_BACKUP_STATUS_INFO();

    DATMGR_OPER_BACKUP_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oDataType,uint8_t oOperBackupStatus,float fProgressRate,uint8_t oDetailReason);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OPER_BACKUP_STATUS_INFO (DATMGR_OPER_BACKUP_STATUS_INFO&&) = default;
    DATMGR_OPER_BACKUP_STATUS_INFO& operator=(DATMGR_OPER_BACKUP_STATUS_INFO&&) = default;
    DATMGR_OPER_BACKUP_STATUS_INFO& operator=(const DATMGR_OPER_BACKUP_STATUS_INFO&) = default;
    DATMGR_OPER_BACKUP_STATUS_INFO(const DATMGR_OPER_BACKUP_STATUS_INFO&) = default;
    #else
    DATMGR_OPER_BACKUP_STATUS_INFO(DATMGR_OPER_BACKUP_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OPER_BACKUP_STATUS_INFO& operator=(DATMGR_OPER_BACKUP_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oDataType() OMG_NOEXCEPT {
        return m_oDataType_;
    }

    const uint8_t& oDataType() const OMG_NOEXCEPT {
        return m_oDataType_;
    }

    void oDataType(uint8_t value) {
        m_oDataType_ = value;
    }

    uint8_t& oOperBackupStatus() OMG_NOEXCEPT {
        return m_oOperBackupStatus_;
    }

    const uint8_t& oOperBackupStatus() const OMG_NOEXCEPT {
        return m_oOperBackupStatus_;
    }

    void oOperBackupStatus(uint8_t value) {
        m_oOperBackupStatus_ = value;
    }

    float& fProgressRate() OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    const float& fProgressRate() const OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    void fProgressRate(float value) {
        m_fProgressRate_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    bool operator == (const DATMGR_OPER_BACKUP_STATUS_INFO& other_) const;
    bool operator != (const DATMGR_OPER_BACKUP_STATUS_INFO& other_) const;

    void swap(DATMGR_OPER_BACKUP_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oDataType_;
    uint8_t m_oOperBackupStatus_;
    float m_fProgressRate_;
    uint8_t m_oDetailReason_;

};

inline void swap(DATMGR_OPER_BACKUP_STATUS_INFO& a, DATMGR_OPER_BACKUP_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OPER_BACKUP_STATUS_INFO& sample);

class NDDSUSERDllExport DATMGR_OPER_DELETE_STATUS_INFO {
  public:
    DATMGR_OPER_DELETE_STATUS_INFO();

    DATMGR_OPER_DELETE_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oOperDeleteStatus,uint8_t oDetailReason,float fProgressRate);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OPER_DELETE_STATUS_INFO (DATMGR_OPER_DELETE_STATUS_INFO&&) = default;
    DATMGR_OPER_DELETE_STATUS_INFO& operator=(DATMGR_OPER_DELETE_STATUS_INFO&&) = default;
    DATMGR_OPER_DELETE_STATUS_INFO& operator=(const DATMGR_OPER_DELETE_STATUS_INFO&) = default;
    DATMGR_OPER_DELETE_STATUS_INFO(const DATMGR_OPER_DELETE_STATUS_INFO&) = default;
    #else
    DATMGR_OPER_DELETE_STATUS_INFO(DATMGR_OPER_DELETE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OPER_DELETE_STATUS_INFO& operator=(DATMGR_OPER_DELETE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oOperDeleteStatus() OMG_NOEXCEPT {
        return m_oOperDeleteStatus_;
    }

    const uint8_t& oOperDeleteStatus() const OMG_NOEXCEPT {
        return m_oOperDeleteStatus_;
    }

    void oOperDeleteStatus(uint8_t value) {
        m_oOperDeleteStatus_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    float& fProgressRate() OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    const float& fProgressRate() const OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    void fProgressRate(float value) {
        m_fProgressRate_ = value;
    }

    bool operator == (const DATMGR_OPER_DELETE_STATUS_INFO& other_) const;
    bool operator != (const DATMGR_OPER_DELETE_STATUS_INFO& other_) const;

    void swap(DATMGR_OPER_DELETE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oOperDeleteStatus_;
    uint8_t m_oDetailReason_;
    float m_fProgressRate_;

};

inline void swap(DATMGR_OPER_DELETE_STATUS_INFO& a, DATMGR_OPER_DELETE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OPER_DELETE_STATUS_INFO& sample);

class NDDSUSERDllExport DATMGR_OPER_EDIT_STATUS_INFO {
  public:
    DATMGR_OPER_EDIT_STATUS_INFO();

    DATMGR_OPER_EDIT_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oOperEditStatus,uint8_t oDetailReason,float fProgressRate);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OPER_EDIT_STATUS_INFO (DATMGR_OPER_EDIT_STATUS_INFO&&) = default;
    DATMGR_OPER_EDIT_STATUS_INFO& operator=(DATMGR_OPER_EDIT_STATUS_INFO&&) = default;
    DATMGR_OPER_EDIT_STATUS_INFO& operator=(const DATMGR_OPER_EDIT_STATUS_INFO&) = default;
    DATMGR_OPER_EDIT_STATUS_INFO(const DATMGR_OPER_EDIT_STATUS_INFO&) = default;
    #else
    DATMGR_OPER_EDIT_STATUS_INFO(DATMGR_OPER_EDIT_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OPER_EDIT_STATUS_INFO& operator=(DATMGR_OPER_EDIT_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oOperEditStatus() OMG_NOEXCEPT {
        return m_oOperEditStatus_;
    }

    const uint8_t& oOperEditStatus() const OMG_NOEXCEPT {
        return m_oOperEditStatus_;
    }

    void oOperEditStatus(uint8_t value) {
        m_oOperEditStatus_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    float& fProgressRate() OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    const float& fProgressRate() const OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    void fProgressRate(float value) {
        m_fProgressRate_ = value;
    }

    bool operator == (const DATMGR_OPER_EDIT_STATUS_INFO& other_) const;
    bool operator != (const DATMGR_OPER_EDIT_STATUS_INFO& other_) const;

    void swap(DATMGR_OPER_EDIT_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oOperEditStatus_;
    uint8_t m_oDetailReason_;
    float m_fProgressRate_;

};

inline void swap(DATMGR_OPER_EDIT_STATUS_INFO& a, DATMGR_OPER_EDIT_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OPER_EDIT_STATUS_INFO& sample);

class NDDSUSERDllExport ST_OPER_HISTORY {
  public:
    ST_OPER_HISTORY();

    ST_OPER_HISTORY(const ::dds::core::array< uint8_t, 20L>& szIP,const ::dds::core::array< uint8_t, 20L>& szAppName,const ::dds::core::array< uint8_t, 32L>& szUserID,const ::dds::core::array< uint8_t, 32L>& szUserName,const ST_DATE_TIME& stEventTime,uint16_t usType,uint16_t usPriority,const ::dds::core::array< uint8_t, 512L>& szContents);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_OPER_HISTORY (ST_OPER_HISTORY&&) = default;
    ST_OPER_HISTORY& operator=(ST_OPER_HISTORY&&) = default;
    ST_OPER_HISTORY& operator=(const ST_OPER_HISTORY&) = default;
    ST_OPER_HISTORY(const ST_OPER_HISTORY&) = default;
    #else
    ST_OPER_HISTORY(ST_OPER_HISTORY&& other_) OMG_NOEXCEPT;  
    ST_OPER_HISTORY& operator=(ST_OPER_HISTORY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 20L>& szIP() OMG_NOEXCEPT {
        return m_szIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& szIP() const OMG_NOEXCEPT {
        return m_szIP_;
    }

    void szIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_szIP_ = value;
    }

    void szIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_szIP_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& szAppName() OMG_NOEXCEPT {
        return m_szAppName_;
    }

    const ::dds::core::array< uint8_t, 20L>& szAppName() const OMG_NOEXCEPT {
        return m_szAppName_;
    }

    void szAppName(const ::dds::core::array< uint8_t, 20L>& value) {
        m_szAppName_ = value;
    }

    void szAppName(::dds::core::array< uint8_t, 20L>&& value) {
        m_szAppName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 32L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 32L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 32L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& szUserName() OMG_NOEXCEPT {
        return m_szUserName_;
    }

    const ::dds::core::array< uint8_t, 32L>& szUserName() const OMG_NOEXCEPT {
        return m_szUserName_;
    }

    void szUserName(const ::dds::core::array< uint8_t, 32L>& value) {
        m_szUserName_ = value;
    }

    void szUserName(::dds::core::array< uint8_t, 32L>&& value) {
        m_szUserName_ = std::move(value);
    }
    ST_DATE_TIME& stEventTime() OMG_NOEXCEPT {
        return m_stEventTime_;
    }

    const ST_DATE_TIME& stEventTime() const OMG_NOEXCEPT {
        return m_stEventTime_;
    }

    void stEventTime(const ST_DATE_TIME& value) {
        m_stEventTime_ = value;
    }

    void stEventTime(ST_DATE_TIME&& value) {
        m_stEventTime_ = std::move(value);
    }
    uint16_t& usType() OMG_NOEXCEPT {
        return m_usType_;
    }

    const uint16_t& usType() const OMG_NOEXCEPT {
        return m_usType_;
    }

    void usType(uint16_t value) {
        m_usType_ = value;
    }

    uint16_t& usPriority() OMG_NOEXCEPT {
        return m_usPriority_;
    }

    const uint16_t& usPriority() const OMG_NOEXCEPT {
        return m_usPriority_;
    }

    void usPriority(uint16_t value) {
        m_usPriority_ = value;
    }

    ::dds::core::array< uint8_t, 512L>& szContents() OMG_NOEXCEPT {
        return m_szContents_;
    }

    const ::dds::core::array< uint8_t, 512L>& szContents() const OMG_NOEXCEPT {
        return m_szContents_;
    }

    void szContents(const ::dds::core::array< uint8_t, 512L>& value) {
        m_szContents_ = value;
    }

    void szContents(::dds::core::array< uint8_t, 512L>&& value) {
        m_szContents_ = std::move(value);
    }

    bool operator == (const ST_OPER_HISTORY& other_) const;
    bool operator != (const ST_OPER_HISTORY& other_) const;

    void swap(ST_OPER_HISTORY& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 20L> m_szIP_;
    ::dds::core::array< uint8_t, 20L> m_szAppName_;
    ::dds::core::array< uint8_t, 32L> m_szUserID_;
    ::dds::core::array< uint8_t, 32L> m_szUserName_;
    ST_DATE_TIME m_stEventTime_;
    uint16_t m_usType_;
    uint16_t m_usPriority_;
    ::dds::core::array< uint8_t, 512L> m_szContents_;

};

inline void swap(ST_OPER_HISTORY& a, ST_OPER_HISTORY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_OPER_HISTORY& sample);

class NDDSUSERDllExport DATMGR_OPER_HISTORY_INFO {
  public:
    DATMGR_OPER_HISTORY_INFO();

    DATMGR_OPER_HISTORY_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t unTotalPageNum,uint16_t unCurrentPageNum,uint16_t unDataNum,const ::dds::core::array< ST_OPER_HISTORY, 30L>& stOperHistory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OPER_HISTORY_INFO (DATMGR_OPER_HISTORY_INFO&&) = default;
    DATMGR_OPER_HISTORY_INFO& operator=(DATMGR_OPER_HISTORY_INFO&&) = default;
    DATMGR_OPER_HISTORY_INFO& operator=(const DATMGR_OPER_HISTORY_INFO&) = default;
    DATMGR_OPER_HISTORY_INFO(const DATMGR_OPER_HISTORY_INFO&) = default;
    #else
    DATMGR_OPER_HISTORY_INFO(DATMGR_OPER_HISTORY_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OPER_HISTORY_INFO& operator=(DATMGR_OPER_HISTORY_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unTotalPageNum() OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    const uint16_t& unTotalPageNum() const OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    void unTotalPageNum(uint16_t value) {
        m_unTotalPageNum_ = value;
    }

    uint16_t& unCurrentPageNum() OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    const uint16_t& unCurrentPageNum() const OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    void unCurrentPageNum(uint16_t value) {
        m_unCurrentPageNum_ = value;
    }

    uint16_t& unDataNum() OMG_NOEXCEPT {
        return m_unDataNum_;
    }

    const uint16_t& unDataNum() const OMG_NOEXCEPT {
        return m_unDataNum_;
    }

    void unDataNum(uint16_t value) {
        m_unDataNum_ = value;
    }

    ::dds::core::array< ST_OPER_HISTORY, 30L>& stOperHistory() OMG_NOEXCEPT {
        return m_stOperHistory_;
    }

    const ::dds::core::array< ST_OPER_HISTORY, 30L>& stOperHistory() const OMG_NOEXCEPT {
        return m_stOperHistory_;
    }

    void stOperHistory(const ::dds::core::array< ST_OPER_HISTORY, 30L>& value) {
        m_stOperHistory_ = value;
    }

    void stOperHistory(::dds::core::array< ST_OPER_HISTORY, 30L>&& value) {
        m_stOperHistory_ = std::move(value);
    }

    bool operator == (const DATMGR_OPER_HISTORY_INFO& other_) const;
    bool operator != (const DATMGR_OPER_HISTORY_INFO& other_) const;

    void swap(DATMGR_OPER_HISTORY_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unTotalPageNum_;
    uint16_t m_unCurrentPageNum_;
    uint16_t m_unDataNum_;
    ::dds::core::array< ST_OPER_HISTORY, 30L> m_stOperHistory_;

};

inline void swap(DATMGR_OPER_HISTORY_INFO& a, DATMGR_OPER_HISTORY_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OPER_HISTORY_INFO& sample);

class NDDSUSERDllExport ST_OPER_DATA_LIST {
  public:
    ST_OPER_DATA_LIST();

    ST_OPER_DATA_LIST(uint32_t ulOperDataIndex,const ST_DATE_TIME& stStartTime,const ST_DATE_TIME& stEndTime,const ::dds::core::array< uint8_t, 30L>& usUserID,const ::dds::core::array< uint8_t, 256L>& szComments,float fDataSize,uint8_t oNASDriveIndex,uint8_t oIsStored);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_OPER_DATA_LIST (ST_OPER_DATA_LIST&&) = default;
    ST_OPER_DATA_LIST& operator=(ST_OPER_DATA_LIST&&) = default;
    ST_OPER_DATA_LIST& operator=(const ST_OPER_DATA_LIST&) = default;
    ST_OPER_DATA_LIST(const ST_OPER_DATA_LIST&) = default;
    #else
    ST_OPER_DATA_LIST(ST_OPER_DATA_LIST&& other_) OMG_NOEXCEPT;  
    ST_OPER_DATA_LIST& operator=(ST_OPER_DATA_LIST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulOperDataIndex() OMG_NOEXCEPT {
        return m_ulOperDataIndex_;
    }

    const uint32_t& ulOperDataIndex() const OMG_NOEXCEPT {
        return m_ulOperDataIndex_;
    }

    void ulOperDataIndex(uint32_t value) {
        m_ulOperDataIndex_ = value;
    }

    ST_DATE_TIME& stStartTime() OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    const ST_DATE_TIME& stStartTime() const OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    void stStartTime(const ST_DATE_TIME& value) {
        m_stStartTime_ = value;
    }

    void stStartTime(ST_DATE_TIME&& value) {
        m_stStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stEndTime() OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    const ST_DATE_TIME& stEndTime() const OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    void stEndTime(const ST_DATE_TIME& value) {
        m_stEndTime_ = value;
    }

    void stEndTime(ST_DATE_TIME&& value) {
        m_stEndTime_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 30L>& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const ::dds::core::array< uint8_t, 30L>& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(const ::dds::core::array< uint8_t, 30L>& value) {
        m_usUserID_ = value;
    }

    void usUserID(::dds::core::array< uint8_t, 30L>&& value) {
        m_usUserID_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& szComments() OMG_NOEXCEPT {
        return m_szComments_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComments() const OMG_NOEXCEPT {
        return m_szComments_;
    }

    void szComments(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComments_ = value;
    }

    void szComments(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComments_ = std::move(value);
    }
    float& fDataSize() OMG_NOEXCEPT {
        return m_fDataSize_;
    }

    const float& fDataSize() const OMG_NOEXCEPT {
        return m_fDataSize_;
    }

    void fDataSize(float value) {
        m_fDataSize_ = value;
    }

    uint8_t& oNASDriveIndex() OMG_NOEXCEPT {
        return m_oNASDriveIndex_;
    }

    const uint8_t& oNASDriveIndex() const OMG_NOEXCEPT {
        return m_oNASDriveIndex_;
    }

    void oNASDriveIndex(uint8_t value) {
        m_oNASDriveIndex_ = value;
    }

    uint8_t& oIsStored() OMG_NOEXCEPT {
        return m_oIsStored_;
    }

    const uint8_t& oIsStored() const OMG_NOEXCEPT {
        return m_oIsStored_;
    }

    void oIsStored(uint8_t value) {
        m_oIsStored_ = value;
    }

    bool operator == (const ST_OPER_DATA_LIST& other_) const;
    bool operator != (const ST_OPER_DATA_LIST& other_) const;

    void swap(ST_OPER_DATA_LIST& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulOperDataIndex_;
    ST_DATE_TIME m_stStartTime_;
    ST_DATE_TIME m_stEndTime_;
    ::dds::core::array< uint8_t, 30L> m_usUserID_;
    ::dds::core::array< uint8_t, 256L> m_szComments_;
    float m_fDataSize_;
    uint8_t m_oNASDriveIndex_;
    uint8_t m_oIsStored_;

};

inline void swap(ST_OPER_DATA_LIST& a, ST_OPER_DATA_LIST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_OPER_DATA_LIST& sample);

class NDDSUSERDllExport DATMGR_OPER_LIST_INFO {
  public:
    DATMGR_OPER_LIST_INFO();

    DATMGR_OPER_LIST_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oListType,uint16_t unTotalPageNum,uint32_t ulTotalDataNum,uint16_t unCurrentPageNum,uint16_t unDataNum,const ::dds::core::array< ST_OPER_DATA_LIST, 30L>& stOperDataList,float fStorageUsageRate,uint32_t ulStorageUsageSpace,uint32_t ulStorageFreeSpace);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OPER_LIST_INFO (DATMGR_OPER_LIST_INFO&&) = default;
    DATMGR_OPER_LIST_INFO& operator=(DATMGR_OPER_LIST_INFO&&) = default;
    DATMGR_OPER_LIST_INFO& operator=(const DATMGR_OPER_LIST_INFO&) = default;
    DATMGR_OPER_LIST_INFO(const DATMGR_OPER_LIST_INFO&) = default;
    #else
    DATMGR_OPER_LIST_INFO(DATMGR_OPER_LIST_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OPER_LIST_INFO& operator=(DATMGR_OPER_LIST_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oListType() OMG_NOEXCEPT {
        return m_oListType_;
    }

    const uint8_t& oListType() const OMG_NOEXCEPT {
        return m_oListType_;
    }

    void oListType(uint8_t value) {
        m_oListType_ = value;
    }

    uint16_t& unTotalPageNum() OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    const uint16_t& unTotalPageNum() const OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    void unTotalPageNum(uint16_t value) {
        m_unTotalPageNum_ = value;
    }

    uint32_t& ulTotalDataNum() OMG_NOEXCEPT {
        return m_ulTotalDataNum_;
    }

    const uint32_t& ulTotalDataNum() const OMG_NOEXCEPT {
        return m_ulTotalDataNum_;
    }

    void ulTotalDataNum(uint32_t value) {
        m_ulTotalDataNum_ = value;
    }

    uint16_t& unCurrentPageNum() OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    const uint16_t& unCurrentPageNum() const OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    void unCurrentPageNum(uint16_t value) {
        m_unCurrentPageNum_ = value;
    }

    uint16_t& unDataNum() OMG_NOEXCEPT {
        return m_unDataNum_;
    }

    const uint16_t& unDataNum() const OMG_NOEXCEPT {
        return m_unDataNum_;
    }

    void unDataNum(uint16_t value) {
        m_unDataNum_ = value;
    }

    ::dds::core::array< ST_OPER_DATA_LIST, 30L>& stOperDataList() OMG_NOEXCEPT {
        return m_stOperDataList_;
    }

    const ::dds::core::array< ST_OPER_DATA_LIST, 30L>& stOperDataList() const OMG_NOEXCEPT {
        return m_stOperDataList_;
    }

    void stOperDataList(const ::dds::core::array< ST_OPER_DATA_LIST, 30L>& value) {
        m_stOperDataList_ = value;
    }

    void stOperDataList(::dds::core::array< ST_OPER_DATA_LIST, 30L>&& value) {
        m_stOperDataList_ = std::move(value);
    }
    float& fStorageUsageRate() OMG_NOEXCEPT {
        return m_fStorageUsageRate_;
    }

    const float& fStorageUsageRate() const OMG_NOEXCEPT {
        return m_fStorageUsageRate_;
    }

    void fStorageUsageRate(float value) {
        m_fStorageUsageRate_ = value;
    }

    uint32_t& ulStorageUsageSpace() OMG_NOEXCEPT {
        return m_ulStorageUsageSpace_;
    }

    const uint32_t& ulStorageUsageSpace() const OMG_NOEXCEPT {
        return m_ulStorageUsageSpace_;
    }

    void ulStorageUsageSpace(uint32_t value) {
        m_ulStorageUsageSpace_ = value;
    }

    uint32_t& ulStorageFreeSpace() OMG_NOEXCEPT {
        return m_ulStorageFreeSpace_;
    }

    const uint32_t& ulStorageFreeSpace() const OMG_NOEXCEPT {
        return m_ulStorageFreeSpace_;
    }

    void ulStorageFreeSpace(uint32_t value) {
        m_ulStorageFreeSpace_ = value;
    }

    bool operator == (const DATMGR_OPER_LIST_INFO& other_) const;
    bool operator != (const DATMGR_OPER_LIST_INFO& other_) const;

    void swap(DATMGR_OPER_LIST_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oListType_;
    uint16_t m_unTotalPageNum_;
    uint32_t m_ulTotalDataNum_;
    uint16_t m_unCurrentPageNum_;
    uint16_t m_unDataNum_;
    ::dds::core::array< ST_OPER_DATA_LIST, 30L> m_stOperDataList_;
    float m_fStorageUsageRate_;
    uint32_t m_ulStorageUsageSpace_;
    uint32_t m_ulStorageFreeSpace_;

};

inline void swap(DATMGR_OPER_LIST_INFO& a, DATMGR_OPER_LIST_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OPER_LIST_INFO& sample);

class NDDSUSERDllExport DATMGR_OPER_RESTORE_STATUS_INFO {
  public:
    DATMGR_OPER_RESTORE_STATUS_INFO();

    DATMGR_OPER_RESTORE_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oDataType,uint8_t oOperRestoreStatus,float fProgressRate,uint8_t oDetailReason);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OPER_RESTORE_STATUS_INFO (DATMGR_OPER_RESTORE_STATUS_INFO&&) = default;
    DATMGR_OPER_RESTORE_STATUS_INFO& operator=(DATMGR_OPER_RESTORE_STATUS_INFO&&) = default;
    DATMGR_OPER_RESTORE_STATUS_INFO& operator=(const DATMGR_OPER_RESTORE_STATUS_INFO&) = default;
    DATMGR_OPER_RESTORE_STATUS_INFO(const DATMGR_OPER_RESTORE_STATUS_INFO&) = default;
    #else
    DATMGR_OPER_RESTORE_STATUS_INFO(DATMGR_OPER_RESTORE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OPER_RESTORE_STATUS_INFO& operator=(DATMGR_OPER_RESTORE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oDataType() OMG_NOEXCEPT {
        return m_oDataType_;
    }

    const uint8_t& oDataType() const OMG_NOEXCEPT {
        return m_oDataType_;
    }

    void oDataType(uint8_t value) {
        m_oDataType_ = value;
    }

    uint8_t& oOperRestoreStatus() OMG_NOEXCEPT {
        return m_oOperRestoreStatus_;
    }

    const uint8_t& oOperRestoreStatus() const OMG_NOEXCEPT {
        return m_oOperRestoreStatus_;
    }

    void oOperRestoreStatus(uint8_t value) {
        m_oOperRestoreStatus_ = value;
    }

    float& fProgressRate() OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    const float& fProgressRate() const OMG_NOEXCEPT {
        return m_fProgressRate_;
    }

    void fProgressRate(float value) {
        m_fProgressRate_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    bool operator == (const DATMGR_OPER_RESTORE_STATUS_INFO& other_) const;
    bool operator != (const DATMGR_OPER_RESTORE_STATUS_INFO& other_) const;

    void swap(DATMGR_OPER_RESTORE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oDataType_;
    uint8_t m_oOperRestoreStatus_;
    float m_fProgressRate_;
    uint8_t m_oDetailReason_;

};

inline void swap(DATMGR_OPER_RESTORE_STATUS_INFO& a, DATMGR_OPER_RESTORE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OPER_RESTORE_STATUS_INFO& sample);

class NDDSUSERDllExport DATMGR_OPER_SAVE_STATUS_INFO {
  public:
    DATMGR_OPER_SAVE_STATUS_INFO();

    DATMGR_OPER_SAVE_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 5L>& aSaveRegion,uint8_t oOperSaveStatus,uint8_t oDetailReason,const ST_DATE_TIME& stStartTime,uint32_t ulElapsedTime,float fDataSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_OPER_SAVE_STATUS_INFO (DATMGR_OPER_SAVE_STATUS_INFO&&) = default;
    DATMGR_OPER_SAVE_STATUS_INFO& operator=(DATMGR_OPER_SAVE_STATUS_INFO&&) = default;
    DATMGR_OPER_SAVE_STATUS_INFO& operator=(const DATMGR_OPER_SAVE_STATUS_INFO&) = default;
    DATMGR_OPER_SAVE_STATUS_INFO(const DATMGR_OPER_SAVE_STATUS_INFO&) = default;
    #else
    DATMGR_OPER_SAVE_STATUS_INFO(DATMGR_OPER_SAVE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_OPER_SAVE_STATUS_INFO& operator=(DATMGR_OPER_SAVE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 5L>& aSaveRegion() OMG_NOEXCEPT {
        return m_aSaveRegion_;
    }

    const ::dds::core::array< uint8_t, 5L>& aSaveRegion() const OMG_NOEXCEPT {
        return m_aSaveRegion_;
    }

    void aSaveRegion(const ::dds::core::array< uint8_t, 5L>& value) {
        m_aSaveRegion_ = value;
    }

    void aSaveRegion(::dds::core::array< uint8_t, 5L>&& value) {
        m_aSaveRegion_ = std::move(value);
    }
    uint8_t& oOperSaveStatus() OMG_NOEXCEPT {
        return m_oOperSaveStatus_;
    }

    const uint8_t& oOperSaveStatus() const OMG_NOEXCEPT {
        return m_oOperSaveStatus_;
    }

    void oOperSaveStatus(uint8_t value) {
        m_oOperSaveStatus_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    ST_DATE_TIME& stStartTime() OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    const ST_DATE_TIME& stStartTime() const OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    void stStartTime(const ST_DATE_TIME& value) {
        m_stStartTime_ = value;
    }

    void stStartTime(ST_DATE_TIME&& value) {
        m_stStartTime_ = std::move(value);
    }
    uint32_t& ulElapsedTime() OMG_NOEXCEPT {
        return m_ulElapsedTime_;
    }

    const uint32_t& ulElapsedTime() const OMG_NOEXCEPT {
        return m_ulElapsedTime_;
    }

    void ulElapsedTime(uint32_t value) {
        m_ulElapsedTime_ = value;
    }

    float& fDataSize() OMG_NOEXCEPT {
        return m_fDataSize_;
    }

    const float& fDataSize() const OMG_NOEXCEPT {
        return m_fDataSize_;
    }

    void fDataSize(float value) {
        m_fDataSize_ = value;
    }

    bool operator == (const DATMGR_OPER_SAVE_STATUS_INFO& other_) const;
    bool operator != (const DATMGR_OPER_SAVE_STATUS_INFO& other_) const;

    void swap(DATMGR_OPER_SAVE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 5L> m_aSaveRegion_;
    uint8_t m_oOperSaveStatus_;
    uint8_t m_oDetailReason_;
    ST_DATE_TIME m_stStartTime_;
    uint32_t m_ulElapsedTime_;
    float m_fDataSize_;

};

inline void swap(DATMGR_OPER_SAVE_STATUS_INFO& a, DATMGR_OPER_SAVE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_OPER_SAVE_STATUS_INFO& sample);

class NDDSUSERDllExport DATMGR_RAWAUDIO_CONTROL_RESULT {
  public:
    DATMGR_RAWAUDIO_CONTROL_RESULT();

    DATMGR_RAWAUDIO_CONTROL_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint8_t oRequestResult,uint8_t oDetailReason);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_RAWAUDIO_CONTROL_RESULT (DATMGR_RAWAUDIO_CONTROL_RESULT&&) = default;
    DATMGR_RAWAUDIO_CONTROL_RESULT& operator=(DATMGR_RAWAUDIO_CONTROL_RESULT&&) = default;
    DATMGR_RAWAUDIO_CONTROL_RESULT& operator=(const DATMGR_RAWAUDIO_CONTROL_RESULT&) = default;
    DATMGR_RAWAUDIO_CONTROL_RESULT(const DATMGR_RAWAUDIO_CONTROL_RESULT&) = default;
    #else
    DATMGR_RAWAUDIO_CONTROL_RESULT(DATMGR_RAWAUDIO_CONTROL_RESULT&& other_) OMG_NOEXCEPT;  
    DATMGR_RAWAUDIO_CONTROL_RESULT& operator=(DATMGR_RAWAUDIO_CONTROL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint8_t& oRequestResult() OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    const uint8_t& oRequestResult() const OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    void oRequestResult(uint8_t value) {
        m_oRequestResult_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    bool operator == (const DATMGR_RAWAUDIO_CONTROL_RESULT& other_) const;
    bool operator != (const DATMGR_RAWAUDIO_CONTROL_RESULT& other_) const;

    void swap(DATMGR_RAWAUDIO_CONTROL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint8_t m_oRequestResult_;
    uint8_t m_oDetailReason_;

};

inline void swap(DATMGR_RAWAUDIO_CONTROL_RESULT& a, DATMGR_RAWAUDIO_CONTROL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_RAWAUDIO_CONTROL_RESULT& sample);

class NDDSUSERDllExport ST_RAWAUDIO_INFO {
  public:
    ST_RAWAUDIO_INFO();

    ST_RAWAUDIO_INFO(uint16_t usIndex,const ::dds::core::array< uint8_t, 256L>& szFileName,const ::dds::core::array< uint8_t, 100L>& szUserTag,uint32_t ulTotalTime,const ST_DATE_TIME& stSaveTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_RAWAUDIO_INFO (ST_RAWAUDIO_INFO&&) = default;
    ST_RAWAUDIO_INFO& operator=(ST_RAWAUDIO_INFO&&) = default;
    ST_RAWAUDIO_INFO& operator=(const ST_RAWAUDIO_INFO&) = default;
    ST_RAWAUDIO_INFO(const ST_RAWAUDIO_INFO&) = default;
    #else
    ST_RAWAUDIO_INFO(ST_RAWAUDIO_INFO&& other_) OMG_NOEXCEPT;  
    ST_RAWAUDIO_INFO& operator=(ST_RAWAUDIO_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usIndex() OMG_NOEXCEPT {
        return m_usIndex_;
    }

    const uint16_t& usIndex() const OMG_NOEXCEPT {
        return m_usIndex_;
    }

    void usIndex(uint16_t value) {
        m_usIndex_ = value;
    }

    ::dds::core::array< uint8_t, 256L>& szFileName() OMG_NOEXCEPT {
        return m_szFileName_;
    }

    const ::dds::core::array< uint8_t, 256L>& szFileName() const OMG_NOEXCEPT {
        return m_szFileName_;
    }

    void szFileName(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szFileName_ = value;
    }

    void szFileName(::dds::core::array< uint8_t, 256L>&& value) {
        m_szFileName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 100L>& szUserTag() OMG_NOEXCEPT {
        return m_szUserTag_;
    }

    const ::dds::core::array< uint8_t, 100L>& szUserTag() const OMG_NOEXCEPT {
        return m_szUserTag_;
    }

    void szUserTag(const ::dds::core::array< uint8_t, 100L>& value) {
        m_szUserTag_ = value;
    }

    void szUserTag(::dds::core::array< uint8_t, 100L>&& value) {
        m_szUserTag_ = std::move(value);
    }
    uint32_t& ulTotalTime() OMG_NOEXCEPT {
        return m_ulTotalTime_;
    }

    const uint32_t& ulTotalTime() const OMG_NOEXCEPT {
        return m_ulTotalTime_;
    }

    void ulTotalTime(uint32_t value) {
        m_ulTotalTime_ = value;
    }

    ST_DATE_TIME& stSaveTime() OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    const ST_DATE_TIME& stSaveTime() const OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    void stSaveTime(const ST_DATE_TIME& value) {
        m_stSaveTime_ = value;
    }

    void stSaveTime(ST_DATE_TIME&& value) {
        m_stSaveTime_ = std::move(value);
    }

    bool operator == (const ST_RAWAUDIO_INFO& other_) const;
    bool operator != (const ST_RAWAUDIO_INFO& other_) const;

    void swap(ST_RAWAUDIO_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usIndex_;
    ::dds::core::array< uint8_t, 256L> m_szFileName_;
    ::dds::core::array< uint8_t, 100L> m_szUserTag_;
    uint32_t m_ulTotalTime_;
    ST_DATE_TIME m_stSaveTime_;

};

inline void swap(ST_RAWAUDIO_INFO& a, ST_RAWAUDIO_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_RAWAUDIO_INFO& sample);

class NDDSUSERDllExport DATMGR_RAWAUDIO_LIST_INFO {
  public:
    DATMGR_RAWAUDIO_LIST_INFO();

    DATMGR_RAWAUDIO_LIST_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usTotalPageNum,uint32_t ulTotalDataNum,uint16_t usCurrentPageNum,uint16_t usDataNum,const ::dds::core::array< ST_RAWAUDIO_INFO, 100L>& stRawaudioInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_RAWAUDIO_LIST_INFO (DATMGR_RAWAUDIO_LIST_INFO&&) = default;
    DATMGR_RAWAUDIO_LIST_INFO& operator=(DATMGR_RAWAUDIO_LIST_INFO&&) = default;
    DATMGR_RAWAUDIO_LIST_INFO& operator=(const DATMGR_RAWAUDIO_LIST_INFO&) = default;
    DATMGR_RAWAUDIO_LIST_INFO(const DATMGR_RAWAUDIO_LIST_INFO&) = default;
    #else
    DATMGR_RAWAUDIO_LIST_INFO(DATMGR_RAWAUDIO_LIST_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_RAWAUDIO_LIST_INFO& operator=(DATMGR_RAWAUDIO_LIST_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usTotalPageNum() OMG_NOEXCEPT {
        return m_usTotalPageNum_;
    }

    const uint16_t& usTotalPageNum() const OMG_NOEXCEPT {
        return m_usTotalPageNum_;
    }

    void usTotalPageNum(uint16_t value) {
        m_usTotalPageNum_ = value;
    }

    uint32_t& ulTotalDataNum() OMG_NOEXCEPT {
        return m_ulTotalDataNum_;
    }

    const uint32_t& ulTotalDataNum() const OMG_NOEXCEPT {
        return m_ulTotalDataNum_;
    }

    void ulTotalDataNum(uint32_t value) {
        m_ulTotalDataNum_ = value;
    }

    uint16_t& usCurrentPageNum() OMG_NOEXCEPT {
        return m_usCurrentPageNum_;
    }

    const uint16_t& usCurrentPageNum() const OMG_NOEXCEPT {
        return m_usCurrentPageNum_;
    }

    void usCurrentPageNum(uint16_t value) {
        m_usCurrentPageNum_ = value;
    }

    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    ::dds::core::array< ST_RAWAUDIO_INFO, 100L>& stRawaudioInfo() OMG_NOEXCEPT {
        return m_stRawaudioInfo_;
    }

    const ::dds::core::array< ST_RAWAUDIO_INFO, 100L>& stRawaudioInfo() const OMG_NOEXCEPT {
        return m_stRawaudioInfo_;
    }

    void stRawaudioInfo(const ::dds::core::array< ST_RAWAUDIO_INFO, 100L>& value) {
        m_stRawaudioInfo_ = value;
    }

    void stRawaudioInfo(::dds::core::array< ST_RAWAUDIO_INFO, 100L>&& value) {
        m_stRawaudioInfo_ = std::move(value);
    }

    bool operator == (const DATMGR_RAWAUDIO_LIST_INFO& other_) const;
    bool operator != (const DATMGR_RAWAUDIO_LIST_INFO& other_) const;

    void swap(DATMGR_RAWAUDIO_LIST_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usTotalPageNum_;
    uint32_t m_ulTotalDataNum_;
    uint16_t m_usCurrentPageNum_;
    uint16_t m_usDataNum_;
    ::dds::core::array< ST_RAWAUDIO_INFO, 100L> m_stRawaudioInfo_;

};

inline void swap(DATMGR_RAWAUDIO_LIST_INFO& a, DATMGR_RAWAUDIO_LIST_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_RAWAUDIO_LIST_INFO& sample);

class NDDSUSERDllExport ST_SCREENSHOT_INFO {
  public:
    ST_SCREENSHOT_INFO();

    ST_SCREENSHOT_INFO(uint16_t unScreenShotIndex,uint8_t oScreenNum,const ::dds::core::array< uint8_t, 30L>& szUserID,const ST_DATE_TIME& stSaveTime,const ::dds::core::array< uint8_t, 256L>& szComment);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SCREENSHOT_INFO (ST_SCREENSHOT_INFO&&) = default;
    ST_SCREENSHOT_INFO& operator=(ST_SCREENSHOT_INFO&&) = default;
    ST_SCREENSHOT_INFO& operator=(const ST_SCREENSHOT_INFO&) = default;
    ST_SCREENSHOT_INFO(const ST_SCREENSHOT_INFO&) = default;
    #else
    ST_SCREENSHOT_INFO(ST_SCREENSHOT_INFO&& other_) OMG_NOEXCEPT;  
    ST_SCREENSHOT_INFO& operator=(ST_SCREENSHOT_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& unScreenShotIndex() OMG_NOEXCEPT {
        return m_unScreenShotIndex_;
    }

    const uint16_t& unScreenShotIndex() const OMG_NOEXCEPT {
        return m_unScreenShotIndex_;
    }

    void unScreenShotIndex(uint16_t value) {
        m_unScreenShotIndex_ = value;
    }

    uint8_t& oScreenNum() OMG_NOEXCEPT {
        return m_oScreenNum_;
    }

    const uint8_t& oScreenNum() const OMG_NOEXCEPT {
        return m_oScreenNum_;
    }

    void oScreenNum(uint8_t value) {
        m_oScreenNum_ = value;
    }

    ::dds::core::array< uint8_t, 30L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 30L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 30L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 30L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ST_DATE_TIME& stSaveTime() OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    const ST_DATE_TIME& stSaveTime() const OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    void stSaveTime(const ST_DATE_TIME& value) {
        m_stSaveTime_ = value;
    }

    void stSaveTime(ST_DATE_TIME&& value) {
        m_stSaveTime_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& szComment() OMG_NOEXCEPT {
        return m_szComment_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComment() const OMG_NOEXCEPT {
        return m_szComment_;
    }

    void szComment(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComment_ = value;
    }

    void szComment(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComment_ = std::move(value);
    }

    bool operator == (const ST_SCREENSHOT_INFO& other_) const;
    bool operator != (const ST_SCREENSHOT_INFO& other_) const;

    void swap(ST_SCREENSHOT_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_unScreenShotIndex_;
    uint8_t m_oScreenNum_;
    ::dds::core::array< uint8_t, 30L> m_szUserID_;
    ST_DATE_TIME m_stSaveTime_;
    ::dds::core::array< uint8_t, 256L> m_szComment_;

};

inline void swap(ST_SCREENSHOT_INFO& a, ST_SCREENSHOT_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SCREENSHOT_INFO& sample);

class NDDSUSERDllExport DATMGR_SAVED_SCREENSHOT_INFO {
  public:
    DATMGR_SAVED_SCREENSHOT_INFO();

    DATMGR_SAVED_SCREENSHOT_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_SCREENSHOT_INFO& stScreenShotInfo,const ::dds::core::array< uint8_t, 6220800L>& aScreenContents);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_SAVED_SCREENSHOT_INFO (DATMGR_SAVED_SCREENSHOT_INFO&&) = default;
    DATMGR_SAVED_SCREENSHOT_INFO& operator=(DATMGR_SAVED_SCREENSHOT_INFO&&) = default;
    DATMGR_SAVED_SCREENSHOT_INFO& operator=(const DATMGR_SAVED_SCREENSHOT_INFO&) = default;
    DATMGR_SAVED_SCREENSHOT_INFO(const DATMGR_SAVED_SCREENSHOT_INFO&) = default;
    #else
    DATMGR_SAVED_SCREENSHOT_INFO(DATMGR_SAVED_SCREENSHOT_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_SAVED_SCREENSHOT_INFO& operator=(DATMGR_SAVED_SCREENSHOT_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_SCREENSHOT_INFO& stScreenShotInfo() OMG_NOEXCEPT {
        return m_stScreenShotInfo_;
    }

    const ST_SCREENSHOT_INFO& stScreenShotInfo() const OMG_NOEXCEPT {
        return m_stScreenShotInfo_;
    }

    void stScreenShotInfo(const ST_SCREENSHOT_INFO& value) {
        m_stScreenShotInfo_ = value;
    }

    void stScreenShotInfo(ST_SCREENSHOT_INFO&& value) {
        m_stScreenShotInfo_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 6220800L>& aScreenContents() OMG_NOEXCEPT {
        return m_aScreenContents_;
    }

    const ::dds::core::array< uint8_t, 6220800L>& aScreenContents() const OMG_NOEXCEPT {
        return m_aScreenContents_;
    }

    void aScreenContents(const ::dds::core::array< uint8_t, 6220800L>& value) {
        m_aScreenContents_ = value;
    }

    void aScreenContents(::dds::core::array< uint8_t, 6220800L>&& value) {
        m_aScreenContents_ = std::move(value);
    }

    bool operator == (const DATMGR_SAVED_SCREENSHOT_INFO& other_) const;
    bool operator != (const DATMGR_SAVED_SCREENSHOT_INFO& other_) const;

    void swap(DATMGR_SAVED_SCREENSHOT_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_SCREENSHOT_INFO m_stScreenShotInfo_;
    ::dds::core::array< uint8_t, 6220800L> m_aScreenContents_;

};

inline void swap(DATMGR_SAVED_SCREENSHOT_INFO& a, DATMGR_SAVED_SCREENSHOT_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_SAVED_SCREENSHOT_INFO& sample);

class NDDSUSERDllExport DATMGR_SCREENSHOT_CONTROL_RESULT {
  public:
    DATMGR_SCREENSHOT_CONTROL_RESULT();

    DATMGR_SCREENSHOT_CONTROL_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint8_t oRequestResult,uint8_t oDetailReason);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_SCREENSHOT_CONTROL_RESULT (DATMGR_SCREENSHOT_CONTROL_RESULT&&) = default;
    DATMGR_SCREENSHOT_CONTROL_RESULT& operator=(DATMGR_SCREENSHOT_CONTROL_RESULT&&) = default;
    DATMGR_SCREENSHOT_CONTROL_RESULT& operator=(const DATMGR_SCREENSHOT_CONTROL_RESULT&) = default;
    DATMGR_SCREENSHOT_CONTROL_RESULT(const DATMGR_SCREENSHOT_CONTROL_RESULT&) = default;
    #else
    DATMGR_SCREENSHOT_CONTROL_RESULT(DATMGR_SCREENSHOT_CONTROL_RESULT&& other_) OMG_NOEXCEPT;  
    DATMGR_SCREENSHOT_CONTROL_RESULT& operator=(DATMGR_SCREENSHOT_CONTROL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint8_t& oRequestResult() OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    const uint8_t& oRequestResult() const OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    void oRequestResult(uint8_t value) {
        m_oRequestResult_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    bool operator == (const DATMGR_SCREENSHOT_CONTROL_RESULT& other_) const;
    bool operator != (const DATMGR_SCREENSHOT_CONTROL_RESULT& other_) const;

    void swap(DATMGR_SCREENSHOT_CONTROL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint8_t m_oRequestResult_;
    uint8_t m_oDetailReason_;

};

inline void swap(DATMGR_SCREENSHOT_CONTROL_RESULT& a, DATMGR_SCREENSHOT_CONTROL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_SCREENSHOT_CONTROL_RESULT& sample);

class NDDSUSERDllExport DATMGR_SCREENSHOT_LIST_INFO {
  public:
    DATMGR_SCREENSHOT_LIST_INFO();

    DATMGR_SCREENSHOT_LIST_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t unTotalPageNum,uint16_t unCurrentPageNum,uint16_t unDataNum,const ::dds::core::array< ST_SCREENSHOT_INFO, 30L>& stScreenShotInfoList);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_SCREENSHOT_LIST_INFO (DATMGR_SCREENSHOT_LIST_INFO&&) = default;
    DATMGR_SCREENSHOT_LIST_INFO& operator=(DATMGR_SCREENSHOT_LIST_INFO&&) = default;
    DATMGR_SCREENSHOT_LIST_INFO& operator=(const DATMGR_SCREENSHOT_LIST_INFO&) = default;
    DATMGR_SCREENSHOT_LIST_INFO(const DATMGR_SCREENSHOT_LIST_INFO&) = default;
    #else
    DATMGR_SCREENSHOT_LIST_INFO(DATMGR_SCREENSHOT_LIST_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_SCREENSHOT_LIST_INFO& operator=(DATMGR_SCREENSHOT_LIST_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unTotalPageNum() OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    const uint16_t& unTotalPageNum() const OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    void unTotalPageNum(uint16_t value) {
        m_unTotalPageNum_ = value;
    }

    uint16_t& unCurrentPageNum() OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    const uint16_t& unCurrentPageNum() const OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    void unCurrentPageNum(uint16_t value) {
        m_unCurrentPageNum_ = value;
    }

    uint16_t& unDataNum() OMG_NOEXCEPT {
        return m_unDataNum_;
    }

    const uint16_t& unDataNum() const OMG_NOEXCEPT {
        return m_unDataNum_;
    }

    void unDataNum(uint16_t value) {
        m_unDataNum_ = value;
    }

    ::dds::core::array< ST_SCREENSHOT_INFO, 30L>& stScreenShotInfoList() OMG_NOEXCEPT {
        return m_stScreenShotInfoList_;
    }

    const ::dds::core::array< ST_SCREENSHOT_INFO, 30L>& stScreenShotInfoList() const OMG_NOEXCEPT {
        return m_stScreenShotInfoList_;
    }

    void stScreenShotInfoList(const ::dds::core::array< ST_SCREENSHOT_INFO, 30L>& value) {
        m_stScreenShotInfoList_ = value;
    }

    void stScreenShotInfoList(::dds::core::array< ST_SCREENSHOT_INFO, 30L>&& value) {
        m_stScreenShotInfoList_ = std::move(value);
    }

    bool operator == (const DATMGR_SCREENSHOT_LIST_INFO& other_) const;
    bool operator != (const DATMGR_SCREENSHOT_LIST_INFO& other_) const;

    void swap(DATMGR_SCREENSHOT_LIST_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unTotalPageNum_;
    uint16_t m_unCurrentPageNum_;
    uint16_t m_unDataNum_;
    ::dds::core::array< ST_SCREENSHOT_INFO, 30L> m_stScreenShotInfoList_;

};

inline void swap(DATMGR_SCREENSHOT_LIST_INFO& a, DATMGR_SCREENSHOT_LIST_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_SCREENSHOT_LIST_INFO& sample);

class NDDSUSERDllExport ST_SENSOR_PROTECTION_AREA_INFO {
  public:
    ST_SENSOR_PROTECTION_AREA_INFO();

    ST_SENSOR_PROTECTION_AREA_INFO(uint16_t usRange,const ::dds::core::array< float, 3L>& aVelocity,uint32_t ulAnchoringDurationTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SENSOR_PROTECTION_AREA_INFO (ST_SENSOR_PROTECTION_AREA_INFO&&) = default;
    ST_SENSOR_PROTECTION_AREA_INFO& operator=(ST_SENSOR_PROTECTION_AREA_INFO&&) = default;
    ST_SENSOR_PROTECTION_AREA_INFO& operator=(const ST_SENSOR_PROTECTION_AREA_INFO&) = default;
    ST_SENSOR_PROTECTION_AREA_INFO(const ST_SENSOR_PROTECTION_AREA_INFO&) = default;
    #else
    ST_SENSOR_PROTECTION_AREA_INFO(ST_SENSOR_PROTECTION_AREA_INFO&& other_) OMG_NOEXCEPT;  
    ST_SENSOR_PROTECTION_AREA_INFO& operator=(ST_SENSOR_PROTECTION_AREA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usRange() OMG_NOEXCEPT {
        return m_usRange_;
    }

    const uint16_t& usRange() const OMG_NOEXCEPT {
        return m_usRange_;
    }

    void usRange(uint16_t value) {
        m_usRange_ = value;
    }

    ::dds::core::array< float, 3L>& aVelocity() OMG_NOEXCEPT {
        return m_aVelocity_;
    }

    const ::dds::core::array< float, 3L>& aVelocity() const OMG_NOEXCEPT {
        return m_aVelocity_;
    }

    void aVelocity(const ::dds::core::array< float, 3L>& value) {
        m_aVelocity_ = value;
    }

    void aVelocity(::dds::core::array< float, 3L>&& value) {
        m_aVelocity_ = std::move(value);
    }
    uint32_t& ulAnchoringDurationTime() OMG_NOEXCEPT {
        return m_ulAnchoringDurationTime_;
    }

    const uint32_t& ulAnchoringDurationTime() const OMG_NOEXCEPT {
        return m_ulAnchoringDurationTime_;
    }

    void ulAnchoringDurationTime(uint32_t value) {
        m_ulAnchoringDurationTime_ = value;
    }

    bool operator == (const ST_SENSOR_PROTECTION_AREA_INFO& other_) const;
    bool operator != (const ST_SENSOR_PROTECTION_AREA_INFO& other_) const;

    void swap(ST_SENSOR_PROTECTION_AREA_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usRange_;
    ::dds::core::array< float, 3L> m_aVelocity_;
    uint32_t m_ulAnchoringDurationTime_;

};

inline void swap(ST_SENSOR_PROTECTION_AREA_INFO& a, ST_SENSOR_PROTECTION_AREA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SENSOR_PROTECTION_AREA_INFO& sample);

class NDDSUSERDllExport DATMGR_SENSOR_PROTECTION_CONTROL_INFO {
  public:
    DATMGR_SENSOR_PROTECTION_CONTROL_INFO();

    DATMGR_SENSOR_PROTECTION_CONTROL_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oInfoType,const ST_SENSOR_PROTECTION_AREA_INFO& stSensorProtectionAreaInfo,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_SENSOR_PROTECTION_CONTROL_INFO (DATMGR_SENSOR_PROTECTION_CONTROL_INFO&&) = default;
    DATMGR_SENSOR_PROTECTION_CONTROL_INFO& operator=(DATMGR_SENSOR_PROTECTION_CONTROL_INFO&&) = default;
    DATMGR_SENSOR_PROTECTION_CONTROL_INFO& operator=(const DATMGR_SENSOR_PROTECTION_CONTROL_INFO&) = default;
    DATMGR_SENSOR_PROTECTION_CONTROL_INFO(const DATMGR_SENSOR_PROTECTION_CONTROL_INFO&) = default;
    #else
    DATMGR_SENSOR_PROTECTION_CONTROL_INFO(DATMGR_SENSOR_PROTECTION_CONTROL_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_SENSOR_PROTECTION_CONTROL_INFO& operator=(DATMGR_SENSOR_PROTECTION_CONTROL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oInfoType() OMG_NOEXCEPT {
        return m_oInfoType_;
    }

    const uint8_t& oInfoType() const OMG_NOEXCEPT {
        return m_oInfoType_;
    }

    void oInfoType(uint8_t value) {
        m_oInfoType_ = value;
    }

    ST_SENSOR_PROTECTION_AREA_INFO& stSensorProtectionAreaInfo() OMG_NOEXCEPT {
        return m_stSensorProtectionAreaInfo_;
    }

    const ST_SENSOR_PROTECTION_AREA_INFO& stSensorProtectionAreaInfo() const OMG_NOEXCEPT {
        return m_stSensorProtectionAreaInfo_;
    }

    void stSensorProtectionAreaInfo(const ST_SENSOR_PROTECTION_AREA_INFO& value) {
        m_stSensorProtectionAreaInfo_ = value;
    }

    void stSensorProtectionAreaInfo(ST_SENSOR_PROTECTION_AREA_INFO&& value) {
        m_stSensorProtectionAreaInfo_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const DATMGR_SENSOR_PROTECTION_CONTROL_INFO& other_) const;
    bool operator != (const DATMGR_SENSOR_PROTECTION_CONTROL_INFO& other_) const;

    void swap(DATMGR_SENSOR_PROTECTION_CONTROL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oInfoType_;
    ST_SENSOR_PROTECTION_AREA_INFO m_stSensorProtectionAreaInfo_;
    uint16_t m_usReserved_;

};

inline void swap(DATMGR_SENSOR_PROTECTION_CONTROL_INFO& a, DATMGR_SENSOR_PROTECTION_CONTROL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_SENSOR_PROTECTION_CONTROL_INFO& sample);

class NDDSUSERDllExport DATMGR_STABILIZED_GRAM_TARGET_INFO {
  public:
    DATMGR_STABILIZED_GRAM_TARGET_INFO();

    DATMGR_STABILIZED_GRAM_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usTargetNo,uint16_t usAxis,uint16_t usDataNum,const ::dds::core::array< uint32_t, 1800L>& ulFrameNo,const ::dds::core::array< uint16_t, 1800L>& usBeamNo,const ::dds::core::array< ST_DATE_TIME, 1800L>& stAcqusitionTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_STABILIZED_GRAM_TARGET_INFO (DATMGR_STABILIZED_GRAM_TARGET_INFO&&) = default;
    DATMGR_STABILIZED_GRAM_TARGET_INFO& operator=(DATMGR_STABILIZED_GRAM_TARGET_INFO&&) = default;
    DATMGR_STABILIZED_GRAM_TARGET_INFO& operator=(const DATMGR_STABILIZED_GRAM_TARGET_INFO&) = default;
    DATMGR_STABILIZED_GRAM_TARGET_INFO(const DATMGR_STABILIZED_GRAM_TARGET_INFO&) = default;
    #else
    DATMGR_STABILIZED_GRAM_TARGET_INFO(DATMGR_STABILIZED_GRAM_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_STABILIZED_GRAM_TARGET_INFO& operator=(DATMGR_STABILIZED_GRAM_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    uint16_t& usAxis() OMG_NOEXCEPT {
        return m_usAxis_;
    }

    const uint16_t& usAxis() const OMG_NOEXCEPT {
        return m_usAxis_;
    }

    void usAxis(uint16_t value) {
        m_usAxis_ = value;
    }

    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    ::dds::core::array< uint32_t, 1800L>& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const ::dds::core::array< uint32_t, 1800L>& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(const ::dds::core::array< uint32_t, 1800L>& value) {
        m_ulFrameNo_ = value;
    }

    void ulFrameNo(::dds::core::array< uint32_t, 1800L>&& value) {
        m_ulFrameNo_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 1800L>& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const ::dds::core::array< uint16_t, 1800L>& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(const ::dds::core::array< uint16_t, 1800L>& value) {
        m_usBeamNo_ = value;
    }

    void usBeamNo(::dds::core::array< uint16_t, 1800L>&& value) {
        m_usBeamNo_ = std::move(value);
    }
    ::dds::core::array< ST_DATE_TIME, 1800L>& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ::dds::core::array< ST_DATE_TIME, 1800L>& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ::dds::core::array< ST_DATE_TIME, 1800L>& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(::dds::core::array< ST_DATE_TIME, 1800L>&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }

    bool operator == (const DATMGR_STABILIZED_GRAM_TARGET_INFO& other_) const;
    bool operator != (const DATMGR_STABILIZED_GRAM_TARGET_INFO& other_) const;

    void swap(DATMGR_STABILIZED_GRAM_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usTargetNo_;
    uint16_t m_usAxis_;
    uint16_t m_usDataNum_;
    ::dds::core::array< uint32_t, 1800L> m_ulFrameNo_;
    ::dds::core::array< uint16_t, 1800L> m_usBeamNo_;
    ::dds::core::array< ST_DATE_TIME, 1800L> m_stAcqusitionTime_;

};

inline void swap(DATMGR_STABILIZED_GRAM_TARGET_INFO& a, DATMGR_STABILIZED_GRAM_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_STABILIZED_GRAM_TARGET_INFO& sample);

class NDDSUSERDllExport ST_STORAGE_STATUS_INFO {
  public:
    ST_STORAGE_STATUS_INFO();

    ST_STORAGE_STATUS_INFO(float fStorageUsageRate,uint32_t ulStrorageUsage,uint32_t ulStorageSpace,uint8_t oController1_Ctrl,const ::dds::core::array< uint8_t, 2L>& oController1_PSU,const ::dds::core::array< uint8_t, 3L>& oController1_Fan,uint8_t oController2_Ctrl,const ::dds::core::array< uint8_t, 2L>& oController2_PSU,const ::dds::core::array< uint8_t, 3L>& oController2_Fan,const ::dds::core::array< uint8_t, 60L>& oShelf1_Disk,const ::dds::core::array< uint8_t, 3L>& oShelf1_PSU,const ::dds::core::array< uint8_t, 3L>& oShelf1_Fan,const ::dds::core::array< uint8_t, 6L>& oShelf1_Comm,const ::dds::core::array< uint8_t, 60L>& oShelf2_Disk,const ::dds::core::array< uint8_t, 3L>& oShelf2_PSU,const ::dds::core::array< uint8_t, 3L>& oShelf2_Fan,const ::dds::core::array< uint8_t, 6L>& oShelf2_Comm);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_STORAGE_STATUS_INFO (ST_STORAGE_STATUS_INFO&&) = default;
    ST_STORAGE_STATUS_INFO& operator=(ST_STORAGE_STATUS_INFO&&) = default;
    ST_STORAGE_STATUS_INFO& operator=(const ST_STORAGE_STATUS_INFO&) = default;
    ST_STORAGE_STATUS_INFO(const ST_STORAGE_STATUS_INFO&) = default;
    #else
    ST_STORAGE_STATUS_INFO(ST_STORAGE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_STORAGE_STATUS_INFO& operator=(ST_STORAGE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    float& fStorageUsageRate() OMG_NOEXCEPT {
        return m_fStorageUsageRate_;
    }

    const float& fStorageUsageRate() const OMG_NOEXCEPT {
        return m_fStorageUsageRate_;
    }

    void fStorageUsageRate(float value) {
        m_fStorageUsageRate_ = value;
    }

    uint32_t& ulStrorageUsage() OMG_NOEXCEPT {
        return m_ulStrorageUsage_;
    }

    const uint32_t& ulStrorageUsage() const OMG_NOEXCEPT {
        return m_ulStrorageUsage_;
    }

    void ulStrorageUsage(uint32_t value) {
        m_ulStrorageUsage_ = value;
    }

    uint32_t& ulStorageSpace() OMG_NOEXCEPT {
        return m_ulStorageSpace_;
    }

    const uint32_t& ulStorageSpace() const OMG_NOEXCEPT {
        return m_ulStorageSpace_;
    }

    void ulStorageSpace(uint32_t value) {
        m_ulStorageSpace_ = value;
    }

    uint8_t& oController1_Ctrl() OMG_NOEXCEPT {
        return m_oController1_Ctrl_;
    }

    const uint8_t& oController1_Ctrl() const OMG_NOEXCEPT {
        return m_oController1_Ctrl_;
    }

    void oController1_Ctrl(uint8_t value) {
        m_oController1_Ctrl_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oController1_PSU() OMG_NOEXCEPT {
        return m_oController1_PSU_;
    }

    const ::dds::core::array< uint8_t, 2L>& oController1_PSU() const OMG_NOEXCEPT {
        return m_oController1_PSU_;
    }

    void oController1_PSU(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oController1_PSU_ = value;
    }

    void oController1_PSU(::dds::core::array< uint8_t, 2L>&& value) {
        m_oController1_PSU_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oController1_Fan() OMG_NOEXCEPT {
        return m_oController1_Fan_;
    }

    const ::dds::core::array< uint8_t, 3L>& oController1_Fan() const OMG_NOEXCEPT {
        return m_oController1_Fan_;
    }

    void oController1_Fan(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oController1_Fan_ = value;
    }

    void oController1_Fan(::dds::core::array< uint8_t, 3L>&& value) {
        m_oController1_Fan_ = std::move(value);
    }
    uint8_t& oController2_Ctrl() OMG_NOEXCEPT {
        return m_oController2_Ctrl_;
    }

    const uint8_t& oController2_Ctrl() const OMG_NOEXCEPT {
        return m_oController2_Ctrl_;
    }

    void oController2_Ctrl(uint8_t value) {
        m_oController2_Ctrl_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oController2_PSU() OMG_NOEXCEPT {
        return m_oController2_PSU_;
    }

    const ::dds::core::array< uint8_t, 2L>& oController2_PSU() const OMG_NOEXCEPT {
        return m_oController2_PSU_;
    }

    void oController2_PSU(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oController2_PSU_ = value;
    }

    void oController2_PSU(::dds::core::array< uint8_t, 2L>&& value) {
        m_oController2_PSU_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oController2_Fan() OMG_NOEXCEPT {
        return m_oController2_Fan_;
    }

    const ::dds::core::array< uint8_t, 3L>& oController2_Fan() const OMG_NOEXCEPT {
        return m_oController2_Fan_;
    }

    void oController2_Fan(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oController2_Fan_ = value;
    }

    void oController2_Fan(::dds::core::array< uint8_t, 3L>&& value) {
        m_oController2_Fan_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 60L>& oShelf1_Disk() OMG_NOEXCEPT {
        return m_oShelf1_Disk_;
    }

    const ::dds::core::array< uint8_t, 60L>& oShelf1_Disk() const OMG_NOEXCEPT {
        return m_oShelf1_Disk_;
    }

    void oShelf1_Disk(const ::dds::core::array< uint8_t, 60L>& value) {
        m_oShelf1_Disk_ = value;
    }

    void oShelf1_Disk(::dds::core::array< uint8_t, 60L>&& value) {
        m_oShelf1_Disk_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oShelf1_PSU() OMG_NOEXCEPT {
        return m_oShelf1_PSU_;
    }

    const ::dds::core::array< uint8_t, 3L>& oShelf1_PSU() const OMG_NOEXCEPT {
        return m_oShelf1_PSU_;
    }

    void oShelf1_PSU(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oShelf1_PSU_ = value;
    }

    void oShelf1_PSU(::dds::core::array< uint8_t, 3L>&& value) {
        m_oShelf1_PSU_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oShelf1_Fan() OMG_NOEXCEPT {
        return m_oShelf1_Fan_;
    }

    const ::dds::core::array< uint8_t, 3L>& oShelf1_Fan() const OMG_NOEXCEPT {
        return m_oShelf1_Fan_;
    }

    void oShelf1_Fan(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oShelf1_Fan_ = value;
    }

    void oShelf1_Fan(::dds::core::array< uint8_t, 3L>&& value) {
        m_oShelf1_Fan_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 6L>& oShelf1_Comm() OMG_NOEXCEPT {
        return m_oShelf1_Comm_;
    }

    const ::dds::core::array< uint8_t, 6L>& oShelf1_Comm() const OMG_NOEXCEPT {
        return m_oShelf1_Comm_;
    }

    void oShelf1_Comm(const ::dds::core::array< uint8_t, 6L>& value) {
        m_oShelf1_Comm_ = value;
    }

    void oShelf1_Comm(::dds::core::array< uint8_t, 6L>&& value) {
        m_oShelf1_Comm_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 60L>& oShelf2_Disk() OMG_NOEXCEPT {
        return m_oShelf2_Disk_;
    }

    const ::dds::core::array< uint8_t, 60L>& oShelf2_Disk() const OMG_NOEXCEPT {
        return m_oShelf2_Disk_;
    }

    void oShelf2_Disk(const ::dds::core::array< uint8_t, 60L>& value) {
        m_oShelf2_Disk_ = value;
    }

    void oShelf2_Disk(::dds::core::array< uint8_t, 60L>&& value) {
        m_oShelf2_Disk_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oShelf2_PSU() OMG_NOEXCEPT {
        return m_oShelf2_PSU_;
    }

    const ::dds::core::array< uint8_t, 3L>& oShelf2_PSU() const OMG_NOEXCEPT {
        return m_oShelf2_PSU_;
    }

    void oShelf2_PSU(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oShelf2_PSU_ = value;
    }

    void oShelf2_PSU(::dds::core::array< uint8_t, 3L>&& value) {
        m_oShelf2_PSU_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oShelf2_Fan() OMG_NOEXCEPT {
        return m_oShelf2_Fan_;
    }

    const ::dds::core::array< uint8_t, 3L>& oShelf2_Fan() const OMG_NOEXCEPT {
        return m_oShelf2_Fan_;
    }

    void oShelf2_Fan(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oShelf2_Fan_ = value;
    }

    void oShelf2_Fan(::dds::core::array< uint8_t, 3L>&& value) {
        m_oShelf2_Fan_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 6L>& oShelf2_Comm() OMG_NOEXCEPT {
        return m_oShelf2_Comm_;
    }

    const ::dds::core::array< uint8_t, 6L>& oShelf2_Comm() const OMG_NOEXCEPT {
        return m_oShelf2_Comm_;
    }

    void oShelf2_Comm(const ::dds::core::array< uint8_t, 6L>& value) {
        m_oShelf2_Comm_ = value;
    }

    void oShelf2_Comm(::dds::core::array< uint8_t, 6L>&& value) {
        m_oShelf2_Comm_ = std::move(value);
    }

    bool operator == (const ST_STORAGE_STATUS_INFO& other_) const;
    bool operator != (const ST_STORAGE_STATUS_INFO& other_) const;

    void swap(ST_STORAGE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    float m_fStorageUsageRate_;
    uint32_t m_ulStrorageUsage_;
    uint32_t m_ulStorageSpace_;
    uint8_t m_oController1_Ctrl_;
    ::dds::core::array< uint8_t, 2L> m_oController1_PSU_;
    ::dds::core::array< uint8_t, 3L> m_oController1_Fan_;
    uint8_t m_oController2_Ctrl_;
    ::dds::core::array< uint8_t, 2L> m_oController2_PSU_;
    ::dds::core::array< uint8_t, 3L> m_oController2_Fan_;
    ::dds::core::array< uint8_t, 60L> m_oShelf1_Disk_;
    ::dds::core::array< uint8_t, 3L> m_oShelf1_PSU_;
    ::dds::core::array< uint8_t, 3L> m_oShelf1_Fan_;
    ::dds::core::array< uint8_t, 6L> m_oShelf1_Comm_;
    ::dds::core::array< uint8_t, 60L> m_oShelf2_Disk_;
    ::dds::core::array< uint8_t, 3L> m_oShelf2_PSU_;
    ::dds::core::array< uint8_t, 3L> m_oShelf2_Fan_;
    ::dds::core::array< uint8_t, 6L> m_oShelf2_Comm_;

};

inline void swap(ST_STORAGE_STATUS_INFO& a, ST_STORAGE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_STORAGE_STATUS_INFO& sample);

class NDDSUSERDllExport DATMGR_STORAGE_STATUS_INFO {
  public:
    DATMGR_STORAGE_STATUS_INFO();

    DATMGR_STORAGE_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_STORAGE_STATUS_INFO& stStorageStatusInfo,float fEOTSUsageRate,uint32_t ulEOTSUsageSpace,uint32_t ulEOTSFreeSpace);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_STORAGE_STATUS_INFO (DATMGR_STORAGE_STATUS_INFO&&) = default;
    DATMGR_STORAGE_STATUS_INFO& operator=(DATMGR_STORAGE_STATUS_INFO&&) = default;
    DATMGR_STORAGE_STATUS_INFO& operator=(const DATMGR_STORAGE_STATUS_INFO&) = default;
    DATMGR_STORAGE_STATUS_INFO(const DATMGR_STORAGE_STATUS_INFO&) = default;
    #else
    DATMGR_STORAGE_STATUS_INFO(DATMGR_STORAGE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_STORAGE_STATUS_INFO& operator=(DATMGR_STORAGE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_STORAGE_STATUS_INFO& stStorageStatusInfo() OMG_NOEXCEPT {
        return m_stStorageStatusInfo_;
    }

    const ST_STORAGE_STATUS_INFO& stStorageStatusInfo() const OMG_NOEXCEPT {
        return m_stStorageStatusInfo_;
    }

    void stStorageStatusInfo(const ST_STORAGE_STATUS_INFO& value) {
        m_stStorageStatusInfo_ = value;
    }

    void stStorageStatusInfo(ST_STORAGE_STATUS_INFO&& value) {
        m_stStorageStatusInfo_ = std::move(value);
    }
    float& fEOTSUsageRate() OMG_NOEXCEPT {
        return m_fEOTSUsageRate_;
    }

    const float& fEOTSUsageRate() const OMG_NOEXCEPT {
        return m_fEOTSUsageRate_;
    }

    void fEOTSUsageRate(float value) {
        m_fEOTSUsageRate_ = value;
    }

    uint32_t& ulEOTSUsageSpace() OMG_NOEXCEPT {
        return m_ulEOTSUsageSpace_;
    }

    const uint32_t& ulEOTSUsageSpace() const OMG_NOEXCEPT {
        return m_ulEOTSUsageSpace_;
    }

    void ulEOTSUsageSpace(uint32_t value) {
        m_ulEOTSUsageSpace_ = value;
    }

    uint32_t& ulEOTSFreeSpace() OMG_NOEXCEPT {
        return m_ulEOTSFreeSpace_;
    }

    const uint32_t& ulEOTSFreeSpace() const OMG_NOEXCEPT {
        return m_ulEOTSFreeSpace_;
    }

    void ulEOTSFreeSpace(uint32_t value) {
        m_ulEOTSFreeSpace_ = value;
    }

    bool operator == (const DATMGR_STORAGE_STATUS_INFO& other_) const;
    bool operator != (const DATMGR_STORAGE_STATUS_INFO& other_) const;

    void swap(DATMGR_STORAGE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_STORAGE_STATUS_INFO m_stStorageStatusInfo_;
    float m_fEOTSUsageRate_;
    uint32_t m_ulEOTSUsageSpace_;
    uint32_t m_ulEOTSFreeSpace_;

};

inline void swap(DATMGR_STORAGE_STATUS_INFO& a, DATMGR_STORAGE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_STORAGE_STATUS_INFO& sample);

class NDDSUSERDllExport ST_SAVE_LAS_TIME_DM_DETECTION_DATA {
  public:
    ST_SAVE_LAS_TIME_DM_DETECTION_DATA();

    ST_SAVE_LAS_TIME_DM_DETECTION_DATA(uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisID,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBBIntegrationTime,uint16_t usNBIntegrationTime,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDEMONOutput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SAVE_LAS_TIME_DM_DETECTION_DATA (ST_SAVE_LAS_TIME_DM_DETECTION_DATA&&) = default;
    ST_SAVE_LAS_TIME_DM_DETECTION_DATA& operator=(ST_SAVE_LAS_TIME_DM_DETECTION_DATA&&) = default;
    ST_SAVE_LAS_TIME_DM_DETECTION_DATA& operator=(const ST_SAVE_LAS_TIME_DM_DETECTION_DATA&) = default;
    ST_SAVE_LAS_TIME_DM_DETECTION_DATA(const ST_SAVE_LAS_TIME_DM_DETECTION_DATA&) = default;
    #else
    ST_SAVE_LAS_TIME_DM_DETECTION_DATA(ST_SAVE_LAS_TIME_DM_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    ST_SAVE_LAS_TIME_DM_DETECTION_DATA& operator=(ST_SAVE_LAS_TIME_DM_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBBIntegrationTime() OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    const uint16_t& usBBIntegrationTime() const OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    void usBBIntegrationTime(uint16_t value) {
        m_usBBIntegrationTime_ = value;
    }

    uint16_t& usNBIntegrationTime() OMG_NOEXCEPT {
        return m_usNBIntegrationTime_;
    }

    const uint16_t& usNBIntegrationTime() const OMG_NOEXCEPT {
        return m_usNBIntegrationTime_;
    }

    void usNBIntegrationTime(uint16_t value) {
        m_usNBIntegrationTime_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDEMONOutput() OMG_NOEXCEPT {
        return m_aNormDEMONOutput_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDEMONOutput() const OMG_NOEXCEPT {
        return m_aNormDEMONOutput_;
    }

    void aNormDEMONOutput(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aNormDEMONOutput_ = value;
    }

    void aNormDEMONOutput(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aNormDEMONOutput_ = std::move(value);
    }

    bool operator == (const ST_SAVE_LAS_TIME_DM_DETECTION_DATA& other_) const;
    bool operator != (const ST_SAVE_LAS_TIME_DM_DETECTION_DATA& other_) const;

    void swap(ST_SAVE_LAS_TIME_DM_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisID_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBBIntegrationTime_;
    uint16_t m_usNBIntegrationTime_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aNormDEMONOutput_;

};

inline void swap(ST_SAVE_LAS_TIME_DM_DETECTION_DATA& a, ST_SAVE_LAS_TIME_DM_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SAVE_LAS_TIME_DM_DETECTION_DATA& sample);

class NDDSUSERDllExport ST_SAVE_LAS_FREQ_DM_DETECTION_DATA {
  public:
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA();

    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA(uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisID,uint16_t usBBIntegrationTime,uint16_t unNBIntegrationTime,uint16_t usReserved,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA (ST_SAVE_LAS_FREQ_DM_DETECTION_DATA&&) = default;
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& operator=(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA&&) = default;
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& operator=(const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA&) = default;
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA(const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA&) = default;
    #else
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& operator=(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisID() OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    const uint16_t& usAxisID() const OMG_NOEXCEPT {
        return m_usAxisID_;
    }

    void usAxisID(uint16_t value) {
        m_usAxisID_ = value;
    }

    uint16_t& usBBIntegrationTime() OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    const uint16_t& usBBIntegrationTime() const OMG_NOEXCEPT {
        return m_usBBIntegrationTime_;
    }

    void usBBIntegrationTime(uint16_t value) {
        m_usBBIntegrationTime_ = value;
    }

    uint16_t& unNBIntegrationTime() OMG_NOEXCEPT {
        return m_unNBIntegrationTime_;
    }

    const uint16_t& unNBIntegrationTime() const OMG_NOEXCEPT {
        return m_unNBIntegrationTime_;
    }

    void unNBIntegrationTime(uint16_t value) {
        m_unNBIntegrationTime_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }

    bool operator == (const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& other_) const;
    bool operator != (const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& other_) const;

    void swap(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisID_;
    uint16_t m_usBBIntegrationTime_;
    uint16_t m_unNBIntegrationTime_;
    uint16_t m_usReserved_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;

};

inline void swap(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& a, ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& sample);

class NDDSUSERDllExport ST_SAVE_LAS_DETECTION_DATA {
  public:
    ST_SAVE_LAS_DETECTION_DATA();

    ST_SAVE_LAS_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisFaultStatus,const ::dds::core::array< ST_SAVE_LAS_TIME_DM_DETECTION_DATA, 3L>& stTimeDmDetectionData,const ::dds::core::array< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA, 3L>& stFreqDmDetectionData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SAVE_LAS_DETECTION_DATA (ST_SAVE_LAS_DETECTION_DATA&&) = default;
    ST_SAVE_LAS_DETECTION_DATA& operator=(ST_SAVE_LAS_DETECTION_DATA&&) = default;
    ST_SAVE_LAS_DETECTION_DATA& operator=(const ST_SAVE_LAS_DETECTION_DATA&) = default;
    ST_SAVE_LAS_DETECTION_DATA(const ST_SAVE_LAS_DETECTION_DATA&) = default;
    #else
    ST_SAVE_LAS_DETECTION_DATA(ST_SAVE_LAS_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    ST_SAVE_LAS_DETECTION_DATA& operator=(ST_SAVE_LAS_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisFaultStatus() OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    const uint16_t& usAxisFaultStatus() const OMG_NOEXCEPT {
        return m_usAxisFaultStatus_;
    }

    void usAxisFaultStatus(uint16_t value) {
        m_usAxisFaultStatus_ = value;
    }

    ::dds::core::array< ST_SAVE_LAS_TIME_DM_DETECTION_DATA, 3L>& stTimeDmDetectionData() OMG_NOEXCEPT {
        return m_stTimeDmDetectionData_;
    }

    const ::dds::core::array< ST_SAVE_LAS_TIME_DM_DETECTION_DATA, 3L>& stTimeDmDetectionData() const OMG_NOEXCEPT {
        return m_stTimeDmDetectionData_;
    }

    void stTimeDmDetectionData(const ::dds::core::array< ST_SAVE_LAS_TIME_DM_DETECTION_DATA, 3L>& value) {
        m_stTimeDmDetectionData_ = value;
    }

    void stTimeDmDetectionData(::dds::core::array< ST_SAVE_LAS_TIME_DM_DETECTION_DATA, 3L>&& value) {
        m_stTimeDmDetectionData_ = std::move(value);
    }
    ::dds::core::array< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA, 3L>& stFreqDmDetectionData() OMG_NOEXCEPT {
        return m_stFreqDmDetectionData_;
    }

    const ::dds::core::array< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA, 3L>& stFreqDmDetectionData() const OMG_NOEXCEPT {
        return m_stFreqDmDetectionData_;
    }

    void stFreqDmDetectionData(const ::dds::core::array< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA, 3L>& value) {
        m_stFreqDmDetectionData_ = value;
    }

    void stFreqDmDetectionData(::dds::core::array< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA, 3L>&& value) {
        m_stFreqDmDetectionData_ = std::move(value);
    }

    bool operator == (const ST_SAVE_LAS_DETECTION_DATA& other_) const;
    bool operator != (const ST_SAVE_LAS_DETECTION_DATA& other_) const;

    void swap(ST_SAVE_LAS_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisFaultStatus_;
    ::dds::core::array< ST_SAVE_LAS_TIME_DM_DETECTION_DATA, 3L> m_stTimeDmDetectionData_;
    ::dds::core::array< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA, 3L> m_stFreqDmDetectionData_;

};

inline void swap(ST_SAVE_LAS_DETECTION_DATA& a, ST_SAVE_LAS_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SAVE_LAS_DETECTION_DATA& sample);

class NDDSUSERDllExport DATMGR_STRUCT_SAVE {
  public:
    DATMGR_STRUCT_SAVE();

    DATMGR_STRUCT_SAVE(const ST_SAVE_LAS_TIME_DM_DETECTION_DATA& stSaveLasTimeDmDetectionData,const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& stSaveLasFreqDmDetectionData,const ST_SAVE_LAS_DETECTION_DATA& stSaveLasDetectionData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_STRUCT_SAVE (DATMGR_STRUCT_SAVE&&) = default;
    DATMGR_STRUCT_SAVE& operator=(DATMGR_STRUCT_SAVE&&) = default;
    DATMGR_STRUCT_SAVE& operator=(const DATMGR_STRUCT_SAVE&) = default;
    DATMGR_STRUCT_SAVE(const DATMGR_STRUCT_SAVE&) = default;
    #else
    DATMGR_STRUCT_SAVE(DATMGR_STRUCT_SAVE&& other_) OMG_NOEXCEPT;  
    DATMGR_STRUCT_SAVE& operator=(DATMGR_STRUCT_SAVE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_SAVE_LAS_TIME_DM_DETECTION_DATA& stSaveLasTimeDmDetectionData() OMG_NOEXCEPT {
        return m_stSaveLasTimeDmDetectionData_;
    }

    const ST_SAVE_LAS_TIME_DM_DETECTION_DATA& stSaveLasTimeDmDetectionData() const OMG_NOEXCEPT {
        return m_stSaveLasTimeDmDetectionData_;
    }

    void stSaveLasTimeDmDetectionData(const ST_SAVE_LAS_TIME_DM_DETECTION_DATA& value) {
        m_stSaveLasTimeDmDetectionData_ = value;
    }

    void stSaveLasTimeDmDetectionData(ST_SAVE_LAS_TIME_DM_DETECTION_DATA&& value) {
        m_stSaveLasTimeDmDetectionData_ = std::move(value);
    }
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& stSaveLasFreqDmDetectionData() OMG_NOEXCEPT {
        return m_stSaveLasFreqDmDetectionData_;
    }

    const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& stSaveLasFreqDmDetectionData() const OMG_NOEXCEPT {
        return m_stSaveLasFreqDmDetectionData_;
    }

    void stSaveLasFreqDmDetectionData(const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& value) {
        m_stSaveLasFreqDmDetectionData_ = value;
    }

    void stSaveLasFreqDmDetectionData(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA&& value) {
        m_stSaveLasFreqDmDetectionData_ = std::move(value);
    }
    ST_SAVE_LAS_DETECTION_DATA& stSaveLasDetectionData() OMG_NOEXCEPT {
        return m_stSaveLasDetectionData_;
    }

    const ST_SAVE_LAS_DETECTION_DATA& stSaveLasDetectionData() const OMG_NOEXCEPT {
        return m_stSaveLasDetectionData_;
    }

    void stSaveLasDetectionData(const ST_SAVE_LAS_DETECTION_DATA& value) {
        m_stSaveLasDetectionData_ = value;
    }

    void stSaveLasDetectionData(ST_SAVE_LAS_DETECTION_DATA&& value) {
        m_stSaveLasDetectionData_ = std::move(value);
    }

    bool operator == (const DATMGR_STRUCT_SAVE& other_) const;
    bool operator != (const DATMGR_STRUCT_SAVE& other_) const;

    void swap(DATMGR_STRUCT_SAVE& other_) OMG_NOEXCEPT ;

  private:

    ST_SAVE_LAS_TIME_DM_DETECTION_DATA m_stSaveLasTimeDmDetectionData_;
    ST_SAVE_LAS_FREQ_DM_DETECTION_DATA m_stSaveLasFreqDmDetectionData_;
    ST_SAVE_LAS_DETECTION_DATA m_stSaveLasDetectionData_;

};

inline void swap(DATMGR_STRUCT_SAVE& a, DATMGR_STRUCT_SAVE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_STRUCT_SAVE& sample);

class NDDSUSERDllExport DATMGR_TACTICAL_AREA_CONTROL_RESULT {
  public:
    DATMGR_TACTICAL_AREA_CONTROL_RESULT();

    DATMGR_TACTICAL_AREA_CONTROL_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint8_t oRequestResult,uint8_t oDetailReason);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_TACTICAL_AREA_CONTROL_RESULT (DATMGR_TACTICAL_AREA_CONTROL_RESULT&&) = default;
    DATMGR_TACTICAL_AREA_CONTROL_RESULT& operator=(DATMGR_TACTICAL_AREA_CONTROL_RESULT&&) = default;
    DATMGR_TACTICAL_AREA_CONTROL_RESULT& operator=(const DATMGR_TACTICAL_AREA_CONTROL_RESULT&) = default;
    DATMGR_TACTICAL_AREA_CONTROL_RESULT(const DATMGR_TACTICAL_AREA_CONTROL_RESULT&) = default;
    #else
    DATMGR_TACTICAL_AREA_CONTROL_RESULT(DATMGR_TACTICAL_AREA_CONTROL_RESULT&& other_) OMG_NOEXCEPT;  
    DATMGR_TACTICAL_AREA_CONTROL_RESULT& operator=(DATMGR_TACTICAL_AREA_CONTROL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint8_t& oRequestResult() OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    const uint8_t& oRequestResult() const OMG_NOEXCEPT {
        return m_oRequestResult_;
    }

    void oRequestResult(uint8_t value) {
        m_oRequestResult_ = value;
    }

    uint8_t& oDetailReason() OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    const uint8_t& oDetailReason() const OMG_NOEXCEPT {
        return m_oDetailReason_;
    }

    void oDetailReason(uint8_t value) {
        m_oDetailReason_ = value;
    }

    bool operator == (const DATMGR_TACTICAL_AREA_CONTROL_RESULT& other_) const;
    bool operator != (const DATMGR_TACTICAL_AREA_CONTROL_RESULT& other_) const;

    void swap(DATMGR_TACTICAL_AREA_CONTROL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint8_t m_oRequestResult_;
    uint8_t m_oDetailReason_;

};

inline void swap(DATMGR_TACTICAL_AREA_CONTROL_RESULT& a, DATMGR_TACTICAL_AREA_CONTROL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_TACTICAL_AREA_CONTROL_RESULT& sample);

class NDDSUSERDllExport ST_DRAW_OBJ {
  public:
    ST_DRAW_OBJ();

    ST_DRAW_OBJ(const ::dds::core::array< uint8_t, 256L>& szObjName,uint8_t oDrawType,uint8_t oPointNum,const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& fPoint,uint8_t oDisplayFont,uint8_t oFontSize,uint8_t oFondBold,uint8_t oLineSize,uint8_t oLineColor,uint8_t oLineType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_DRAW_OBJ (ST_DRAW_OBJ&&) = default;
    ST_DRAW_OBJ& operator=(ST_DRAW_OBJ&&) = default;
    ST_DRAW_OBJ& operator=(const ST_DRAW_OBJ&) = default;
    ST_DRAW_OBJ(const ST_DRAW_OBJ&) = default;
    #else
    ST_DRAW_OBJ(ST_DRAW_OBJ&& other_) OMG_NOEXCEPT;  
    ST_DRAW_OBJ& operator=(ST_DRAW_OBJ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 256L>& szObjName() OMG_NOEXCEPT {
        return m_szObjName_;
    }

    const ::dds::core::array< uint8_t, 256L>& szObjName() const OMG_NOEXCEPT {
        return m_szObjName_;
    }

    void szObjName(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szObjName_ = value;
    }

    void szObjName(::dds::core::array< uint8_t, 256L>&& value) {
        m_szObjName_ = std::move(value);
    }
    uint8_t& oDrawType() OMG_NOEXCEPT {
        return m_oDrawType_;
    }

    const uint8_t& oDrawType() const OMG_NOEXCEPT {
        return m_oDrawType_;
    }

    void oDrawType(uint8_t value) {
        m_oDrawType_ = value;
    }

    uint8_t& oPointNum() OMG_NOEXCEPT {
        return m_oPointNum_;
    }

    const uint8_t& oPointNum() const OMG_NOEXCEPT {
        return m_oPointNum_;
    }

    void oPointNum(uint8_t value) {
        m_oPointNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& fPoint() OMG_NOEXCEPT {
        return m_fPoint_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& fPoint() const OMG_NOEXCEPT {
        return m_fPoint_;
    }

    void fPoint(const ::dds::core::array< ::dds::core::array< float, 2L>, 10L>& value) {
        m_fPoint_ = value;
    }

    void fPoint(::dds::core::array< ::dds::core::array< float, 2L>, 10L>&& value) {
        m_fPoint_ = std::move(value);
    }
    uint8_t& oDisplayFont() OMG_NOEXCEPT {
        return m_oDisplayFont_;
    }

    const uint8_t& oDisplayFont() const OMG_NOEXCEPT {
        return m_oDisplayFont_;
    }

    void oDisplayFont(uint8_t value) {
        m_oDisplayFont_ = value;
    }

    uint8_t& oFontSize() OMG_NOEXCEPT {
        return m_oFontSize_;
    }

    const uint8_t& oFontSize() const OMG_NOEXCEPT {
        return m_oFontSize_;
    }

    void oFontSize(uint8_t value) {
        m_oFontSize_ = value;
    }

    uint8_t& oFondBold() OMG_NOEXCEPT {
        return m_oFondBold_;
    }

    const uint8_t& oFondBold() const OMG_NOEXCEPT {
        return m_oFondBold_;
    }

    void oFondBold(uint8_t value) {
        m_oFondBold_ = value;
    }

    uint8_t& oLineSize() OMG_NOEXCEPT {
        return m_oLineSize_;
    }

    const uint8_t& oLineSize() const OMG_NOEXCEPT {
        return m_oLineSize_;
    }

    void oLineSize(uint8_t value) {
        m_oLineSize_ = value;
    }

    uint8_t& oLineColor() OMG_NOEXCEPT {
        return m_oLineColor_;
    }

    const uint8_t& oLineColor() const OMG_NOEXCEPT {
        return m_oLineColor_;
    }

    void oLineColor(uint8_t value) {
        m_oLineColor_ = value;
    }

    uint8_t& oLineType() OMG_NOEXCEPT {
        return m_oLineType_;
    }

    const uint8_t& oLineType() const OMG_NOEXCEPT {
        return m_oLineType_;
    }

    void oLineType(uint8_t value) {
        m_oLineType_ = value;
    }

    bool operator == (const ST_DRAW_OBJ& other_) const;
    bool operator != (const ST_DRAW_OBJ& other_) const;

    void swap(ST_DRAW_OBJ& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 256L> m_szObjName_;
    uint8_t m_oDrawType_;
    uint8_t m_oPointNum_;
    ::dds::core::array< ::dds::core::array< float, 2L>, 10L> m_fPoint_;
    uint8_t m_oDisplayFont_;
    uint8_t m_oFontSize_;
    uint8_t m_oFondBold_;
    uint8_t m_oLineSize_;
    uint8_t m_oLineColor_;
    uint8_t m_oLineType_;

};

inline void swap(ST_DRAW_OBJ& a, ST_DRAW_OBJ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_DRAW_OBJ& sample);

class NDDSUSERDllExport ST_TACTICAL_AREA {
  public:
    ST_TACTICAL_AREA();

    ST_TACTICAL_AREA(uint16_t usTacticalAreaIndex,const ::dds::core::array< uint8_t, 80L>& szTacticalAreaName,const ::dds::core::array< uint8_t, 30L>& szUserID,const ST_DATE_TIME& stSaveTime,uint8_t oDisplay,uint16_t usPriority,uint16_t usAreaType,uint8_t oDrawObjNum,const ::dds::core::array< ST_DRAW_OBJ, 30L>& stDrawObj);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TACTICAL_AREA (ST_TACTICAL_AREA&&) = default;
    ST_TACTICAL_AREA& operator=(ST_TACTICAL_AREA&&) = default;
    ST_TACTICAL_AREA& operator=(const ST_TACTICAL_AREA&) = default;
    ST_TACTICAL_AREA(const ST_TACTICAL_AREA&) = default;
    #else
    ST_TACTICAL_AREA(ST_TACTICAL_AREA&& other_) OMG_NOEXCEPT;  
    ST_TACTICAL_AREA& operator=(ST_TACTICAL_AREA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTacticalAreaIndex() OMG_NOEXCEPT {
        return m_usTacticalAreaIndex_;
    }

    const uint16_t& usTacticalAreaIndex() const OMG_NOEXCEPT {
        return m_usTacticalAreaIndex_;
    }

    void usTacticalAreaIndex(uint16_t value) {
        m_usTacticalAreaIndex_ = value;
    }

    ::dds::core::array< uint8_t, 80L>& szTacticalAreaName() OMG_NOEXCEPT {
        return m_szTacticalAreaName_;
    }

    const ::dds::core::array< uint8_t, 80L>& szTacticalAreaName() const OMG_NOEXCEPT {
        return m_szTacticalAreaName_;
    }

    void szTacticalAreaName(const ::dds::core::array< uint8_t, 80L>& value) {
        m_szTacticalAreaName_ = value;
    }

    void szTacticalAreaName(::dds::core::array< uint8_t, 80L>&& value) {
        m_szTacticalAreaName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 30L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 30L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 30L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 30L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ST_DATE_TIME& stSaveTime() OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    const ST_DATE_TIME& stSaveTime() const OMG_NOEXCEPT {
        return m_stSaveTime_;
    }

    void stSaveTime(const ST_DATE_TIME& value) {
        m_stSaveTime_ = value;
    }

    void stSaveTime(ST_DATE_TIME&& value) {
        m_stSaveTime_ = std::move(value);
    }
    uint8_t& oDisplay() OMG_NOEXCEPT {
        return m_oDisplay_;
    }

    const uint8_t& oDisplay() const OMG_NOEXCEPT {
        return m_oDisplay_;
    }

    void oDisplay(uint8_t value) {
        m_oDisplay_ = value;
    }

    uint16_t& usPriority() OMG_NOEXCEPT {
        return m_usPriority_;
    }

    const uint16_t& usPriority() const OMG_NOEXCEPT {
        return m_usPriority_;
    }

    void usPriority(uint16_t value) {
        m_usPriority_ = value;
    }

    uint16_t& usAreaType() OMG_NOEXCEPT {
        return m_usAreaType_;
    }

    const uint16_t& usAreaType() const OMG_NOEXCEPT {
        return m_usAreaType_;
    }

    void usAreaType(uint16_t value) {
        m_usAreaType_ = value;
    }

    uint8_t& oDrawObjNum() OMG_NOEXCEPT {
        return m_oDrawObjNum_;
    }

    const uint8_t& oDrawObjNum() const OMG_NOEXCEPT {
        return m_oDrawObjNum_;
    }

    void oDrawObjNum(uint8_t value) {
        m_oDrawObjNum_ = value;
    }

    ::dds::core::array< ST_DRAW_OBJ, 30L>& stDrawObj() OMG_NOEXCEPT {
        return m_stDrawObj_;
    }

    const ::dds::core::array< ST_DRAW_OBJ, 30L>& stDrawObj() const OMG_NOEXCEPT {
        return m_stDrawObj_;
    }

    void stDrawObj(const ::dds::core::array< ST_DRAW_OBJ, 30L>& value) {
        m_stDrawObj_ = value;
    }

    void stDrawObj(::dds::core::array< ST_DRAW_OBJ, 30L>&& value) {
        m_stDrawObj_ = std::move(value);
    }

    bool operator == (const ST_TACTICAL_AREA& other_) const;
    bool operator != (const ST_TACTICAL_AREA& other_) const;

    void swap(ST_TACTICAL_AREA& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTacticalAreaIndex_;
    ::dds::core::array< uint8_t, 80L> m_szTacticalAreaName_;
    ::dds::core::array< uint8_t, 30L> m_szUserID_;
    ST_DATE_TIME m_stSaveTime_;
    uint8_t m_oDisplay_;
    uint16_t m_usPriority_;
    uint16_t m_usAreaType_;
    uint8_t m_oDrawObjNum_;
    ::dds::core::array< ST_DRAW_OBJ, 30L> m_stDrawObj_;

};

inline void swap(ST_TACTICAL_AREA& a, ST_TACTICAL_AREA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TACTICAL_AREA& sample);

class NDDSUSERDllExport DATMGR_TACTICAL_AREA_INFO {
  public:
    DATMGR_TACTICAL_AREA_INFO();

    DATMGR_TACTICAL_AREA_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oTacticalAreaNum,const ::dds::core::array< ST_TACTICAL_AREA, 30L>& stTacticalAreaList);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_TACTICAL_AREA_INFO (DATMGR_TACTICAL_AREA_INFO&&) = default;
    DATMGR_TACTICAL_AREA_INFO& operator=(DATMGR_TACTICAL_AREA_INFO&&) = default;
    DATMGR_TACTICAL_AREA_INFO& operator=(const DATMGR_TACTICAL_AREA_INFO&) = default;
    DATMGR_TACTICAL_AREA_INFO(const DATMGR_TACTICAL_AREA_INFO&) = default;
    #else
    DATMGR_TACTICAL_AREA_INFO(DATMGR_TACTICAL_AREA_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_TACTICAL_AREA_INFO& operator=(DATMGR_TACTICAL_AREA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oTacticalAreaNum() OMG_NOEXCEPT {
        return m_oTacticalAreaNum_;
    }

    const uint8_t& oTacticalAreaNum() const OMG_NOEXCEPT {
        return m_oTacticalAreaNum_;
    }

    void oTacticalAreaNum(uint8_t value) {
        m_oTacticalAreaNum_ = value;
    }

    ::dds::core::array< ST_TACTICAL_AREA, 30L>& stTacticalAreaList() OMG_NOEXCEPT {
        return m_stTacticalAreaList_;
    }

    const ::dds::core::array< ST_TACTICAL_AREA, 30L>& stTacticalAreaList() const OMG_NOEXCEPT {
        return m_stTacticalAreaList_;
    }

    void stTacticalAreaList(const ::dds::core::array< ST_TACTICAL_AREA, 30L>& value) {
        m_stTacticalAreaList_ = value;
    }

    void stTacticalAreaList(::dds::core::array< ST_TACTICAL_AREA, 30L>&& value) {
        m_stTacticalAreaList_ = std::move(value);
    }

    bool operator == (const DATMGR_TACTICAL_AREA_INFO& other_) const;
    bool operator != (const DATMGR_TACTICAL_AREA_INFO& other_) const;

    void swap(DATMGR_TACTICAL_AREA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oTacticalAreaNum_;
    ::dds::core::array< ST_TACTICAL_AREA, 30L> m_stTacticalAreaList_;

};

inline void swap(DATMGR_TACTICAL_AREA_INFO& a, DATMGR_TACTICAL_AREA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_TACTICAL_AREA_INFO& sample);

class NDDSUSERDllExport ST_TARGET_DB_INFO {
  public:
    ST_TARGET_DB_INFO();

    ST_TARGET_DB_INFO(int32_t nCreationDateTime,const ::dds::core::array< uint8_t, 100L>& szName,float fSpeed,float fHeading,int32_t nBISStrengthMode,float fBISRepresentativeStrength,int32_t nBISDetailStrengthIncidenceCount,int32_t nBISDetailStrengthReflectionCount,int32_t nASStrengthMode,float fASRepresentativeStrength,int32_t nASDetailStrengthBearingCount,int32_t nASDetailStrengthFreqCount);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TARGET_DB_INFO (ST_TARGET_DB_INFO&&) = default;
    ST_TARGET_DB_INFO& operator=(ST_TARGET_DB_INFO&&) = default;
    ST_TARGET_DB_INFO& operator=(const ST_TARGET_DB_INFO&) = default;
    ST_TARGET_DB_INFO(const ST_TARGET_DB_INFO&) = default;
    #else
    ST_TARGET_DB_INFO(ST_TARGET_DB_INFO&& other_) OMG_NOEXCEPT;  
    ST_TARGET_DB_INFO& operator=(ST_TARGET_DB_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int32_t& nCreationDateTime() OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    const int32_t& nCreationDateTime() const OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    void nCreationDateTime(int32_t value) {
        m_nCreationDateTime_ = value;
    }

    ::dds::core::array< uint8_t, 100L>& szName() OMG_NOEXCEPT {
        return m_szName_;
    }

    const ::dds::core::array< uint8_t, 100L>& szName() const OMG_NOEXCEPT {
        return m_szName_;
    }

    void szName(const ::dds::core::array< uint8_t, 100L>& value) {
        m_szName_ = value;
    }

    void szName(::dds::core::array< uint8_t, 100L>&& value) {
        m_szName_ = std::move(value);
    }
    float& fSpeed() OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    const float& fSpeed() const OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    void fSpeed(float value) {
        m_fSpeed_ = value;
    }

    float& fHeading() OMG_NOEXCEPT {
        return m_fHeading_;
    }

    const float& fHeading() const OMG_NOEXCEPT {
        return m_fHeading_;
    }

    void fHeading(float value) {
        m_fHeading_ = value;
    }

    int32_t& nBISStrengthMode() OMG_NOEXCEPT {
        return m_nBISStrengthMode_;
    }

    const int32_t& nBISStrengthMode() const OMG_NOEXCEPT {
        return m_nBISStrengthMode_;
    }

    void nBISStrengthMode(int32_t value) {
        m_nBISStrengthMode_ = value;
    }

    float& fBISRepresentativeStrength() OMG_NOEXCEPT {
        return m_fBISRepresentativeStrength_;
    }

    const float& fBISRepresentativeStrength() const OMG_NOEXCEPT {
        return m_fBISRepresentativeStrength_;
    }

    void fBISRepresentativeStrength(float value) {
        m_fBISRepresentativeStrength_ = value;
    }

    int32_t& nBISDetailStrengthIncidenceCount() OMG_NOEXCEPT {
        return m_nBISDetailStrengthIncidenceCount_;
    }

    const int32_t& nBISDetailStrengthIncidenceCount() const OMG_NOEXCEPT {
        return m_nBISDetailStrengthIncidenceCount_;
    }

    void nBISDetailStrengthIncidenceCount(int32_t value) {
        m_nBISDetailStrengthIncidenceCount_ = value;
    }

    int32_t& nBISDetailStrengthReflectionCount() OMG_NOEXCEPT {
        return m_nBISDetailStrengthReflectionCount_;
    }

    const int32_t& nBISDetailStrengthReflectionCount() const OMG_NOEXCEPT {
        return m_nBISDetailStrengthReflectionCount_;
    }

    void nBISDetailStrengthReflectionCount(int32_t value) {
        m_nBISDetailStrengthReflectionCount_ = value;
    }

    int32_t& nASStrengthMode() OMG_NOEXCEPT {
        return m_nASStrengthMode_;
    }

    const int32_t& nASStrengthMode() const OMG_NOEXCEPT {
        return m_nASStrengthMode_;
    }

    void nASStrengthMode(int32_t value) {
        m_nASStrengthMode_ = value;
    }

    float& fASRepresentativeStrength() OMG_NOEXCEPT {
        return m_fASRepresentativeStrength_;
    }

    const float& fASRepresentativeStrength() const OMG_NOEXCEPT {
        return m_fASRepresentativeStrength_;
    }

    void fASRepresentativeStrength(float value) {
        m_fASRepresentativeStrength_ = value;
    }

    int32_t& nASDetailStrengthBearingCount() OMG_NOEXCEPT {
        return m_nASDetailStrengthBearingCount_;
    }

    const int32_t& nASDetailStrengthBearingCount() const OMG_NOEXCEPT {
        return m_nASDetailStrengthBearingCount_;
    }

    void nASDetailStrengthBearingCount(int32_t value) {
        m_nASDetailStrengthBearingCount_ = value;
    }

    int32_t& nASDetailStrengthFreqCount() OMG_NOEXCEPT {
        return m_nASDetailStrengthFreqCount_;
    }

    const int32_t& nASDetailStrengthFreqCount() const OMG_NOEXCEPT {
        return m_nASDetailStrengthFreqCount_;
    }

    void nASDetailStrengthFreqCount(int32_t value) {
        m_nASDetailStrengthFreqCount_ = value;
    }

    bool operator == (const ST_TARGET_DB_INFO& other_) const;
    bool operator != (const ST_TARGET_DB_INFO& other_) const;

    void swap(ST_TARGET_DB_INFO& other_) OMG_NOEXCEPT ;

  private:

    int32_t m_nCreationDateTime_;
    ::dds::core::array< uint8_t, 100L> m_szName_;
    float m_fSpeed_;
    float m_fHeading_;
    int32_t m_nBISStrengthMode_;
    float m_fBISRepresentativeStrength_;
    int32_t m_nBISDetailStrengthIncidenceCount_;
    int32_t m_nBISDetailStrengthReflectionCount_;
    int32_t m_nASStrengthMode_;
    float m_fASRepresentativeStrength_;
    int32_t m_nASDetailStrengthBearingCount_;
    int32_t m_nASDetailStrengthFreqCount_;

};

inline void swap(ST_TARGET_DB_INFO& a, ST_TARGET_DB_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TARGET_DB_INFO& sample);

class NDDSUSERDllExport ST_TARGET_DB_AS_STRENGTH {
  public:
    ST_TARGET_DB_AS_STRENGTH();

    ST_TARGET_DB_AS_STRENGTH(int32_t nCreationDateTime,float fBearing,float fFrequency,float fStrength);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TARGET_DB_AS_STRENGTH (ST_TARGET_DB_AS_STRENGTH&&) = default;
    ST_TARGET_DB_AS_STRENGTH& operator=(ST_TARGET_DB_AS_STRENGTH&&) = default;
    ST_TARGET_DB_AS_STRENGTH& operator=(const ST_TARGET_DB_AS_STRENGTH&) = default;
    ST_TARGET_DB_AS_STRENGTH(const ST_TARGET_DB_AS_STRENGTH&) = default;
    #else
    ST_TARGET_DB_AS_STRENGTH(ST_TARGET_DB_AS_STRENGTH&& other_) OMG_NOEXCEPT;  
    ST_TARGET_DB_AS_STRENGTH& operator=(ST_TARGET_DB_AS_STRENGTH&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int32_t& nCreationDateTime() OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    const int32_t& nCreationDateTime() const OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    void nCreationDateTime(int32_t value) {
        m_nCreationDateTime_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fFrequency() OMG_NOEXCEPT {
        return m_fFrequency_;
    }

    const float& fFrequency() const OMG_NOEXCEPT {
        return m_fFrequency_;
    }

    void fFrequency(float value) {
        m_fFrequency_ = value;
    }

    float& fStrength() OMG_NOEXCEPT {
        return m_fStrength_;
    }

    const float& fStrength() const OMG_NOEXCEPT {
        return m_fStrength_;
    }

    void fStrength(float value) {
        m_fStrength_ = value;
    }

    bool operator == (const ST_TARGET_DB_AS_STRENGTH& other_) const;
    bool operator != (const ST_TARGET_DB_AS_STRENGTH& other_) const;

    void swap(ST_TARGET_DB_AS_STRENGTH& other_) OMG_NOEXCEPT ;

  private:

    int32_t m_nCreationDateTime_;
    float m_fBearing_;
    float m_fFrequency_;
    float m_fStrength_;

};

inline void swap(ST_TARGET_DB_AS_STRENGTH& a, ST_TARGET_DB_AS_STRENGTH& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TARGET_DB_AS_STRENGTH& sample);

class NDDSUSERDllExport ST_TARGET_DB_BIS_STRENGTH {
  public:
    ST_TARGET_DB_BIS_STRENGTH();

    ST_TARGET_DB_BIS_STRENGTH(int32_t nCreationDateTime,float fIncidence,float fReflection,float fStrength);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TARGET_DB_BIS_STRENGTH (ST_TARGET_DB_BIS_STRENGTH&&) = default;
    ST_TARGET_DB_BIS_STRENGTH& operator=(ST_TARGET_DB_BIS_STRENGTH&&) = default;
    ST_TARGET_DB_BIS_STRENGTH& operator=(const ST_TARGET_DB_BIS_STRENGTH&) = default;
    ST_TARGET_DB_BIS_STRENGTH(const ST_TARGET_DB_BIS_STRENGTH&) = default;
    #else
    ST_TARGET_DB_BIS_STRENGTH(ST_TARGET_DB_BIS_STRENGTH&& other_) OMG_NOEXCEPT;  
    ST_TARGET_DB_BIS_STRENGTH& operator=(ST_TARGET_DB_BIS_STRENGTH&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int32_t& nCreationDateTime() OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    const int32_t& nCreationDateTime() const OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    void nCreationDateTime(int32_t value) {
        m_nCreationDateTime_ = value;
    }

    float& fIncidence() OMG_NOEXCEPT {
        return m_fIncidence_;
    }

    const float& fIncidence() const OMG_NOEXCEPT {
        return m_fIncidence_;
    }

    void fIncidence(float value) {
        m_fIncidence_ = value;
    }

    float& fReflection() OMG_NOEXCEPT {
        return m_fReflection_;
    }

    const float& fReflection() const OMG_NOEXCEPT {
        return m_fReflection_;
    }

    void fReflection(float value) {
        m_fReflection_ = value;
    }

    float& fStrength() OMG_NOEXCEPT {
        return m_fStrength_;
    }

    const float& fStrength() const OMG_NOEXCEPT {
        return m_fStrength_;
    }

    void fStrength(float value) {
        m_fStrength_ = value;
    }

    bool operator == (const ST_TARGET_DB_BIS_STRENGTH& other_) const;
    bool operator != (const ST_TARGET_DB_BIS_STRENGTH& other_) const;

    void swap(ST_TARGET_DB_BIS_STRENGTH& other_) OMG_NOEXCEPT ;

  private:

    int32_t m_nCreationDateTime_;
    float m_fIncidence_;
    float m_fReflection_;
    float m_fStrength_;

};

inline void swap(ST_TARGET_DB_BIS_STRENGTH& a, ST_TARGET_DB_BIS_STRENGTH& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TARGET_DB_BIS_STRENGTH& sample);

class NDDSUSERDllExport ST_TARGET_DB_BB_SOURCE_LEVEL {
  public:
    ST_TARGET_DB_BB_SOURCE_LEVEL();

    ST_TARGET_DB_BB_SOURCE_LEVEL(int32_t nCreationDateTime,const ::dds::core::array< uint8_t, 100L>& szFrequency,float fSourceLevel);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TARGET_DB_BB_SOURCE_LEVEL (ST_TARGET_DB_BB_SOURCE_LEVEL&&) = default;
    ST_TARGET_DB_BB_SOURCE_LEVEL& operator=(ST_TARGET_DB_BB_SOURCE_LEVEL&&) = default;
    ST_TARGET_DB_BB_SOURCE_LEVEL& operator=(const ST_TARGET_DB_BB_SOURCE_LEVEL&) = default;
    ST_TARGET_DB_BB_SOURCE_LEVEL(const ST_TARGET_DB_BB_SOURCE_LEVEL&) = default;
    #else
    ST_TARGET_DB_BB_SOURCE_LEVEL(ST_TARGET_DB_BB_SOURCE_LEVEL&& other_) OMG_NOEXCEPT;  
    ST_TARGET_DB_BB_SOURCE_LEVEL& operator=(ST_TARGET_DB_BB_SOURCE_LEVEL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int32_t& nCreationDateTime() OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    const int32_t& nCreationDateTime() const OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    void nCreationDateTime(int32_t value) {
        m_nCreationDateTime_ = value;
    }

    ::dds::core::array< uint8_t, 100L>& szFrequency() OMG_NOEXCEPT {
        return m_szFrequency_;
    }

    const ::dds::core::array< uint8_t, 100L>& szFrequency() const OMG_NOEXCEPT {
        return m_szFrequency_;
    }

    void szFrequency(const ::dds::core::array< uint8_t, 100L>& value) {
        m_szFrequency_ = value;
    }

    void szFrequency(::dds::core::array< uint8_t, 100L>&& value) {
        m_szFrequency_ = std::move(value);
    }
    float& fSourceLevel() OMG_NOEXCEPT {
        return m_fSourceLevel_;
    }

    const float& fSourceLevel() const OMG_NOEXCEPT {
        return m_fSourceLevel_;
    }

    void fSourceLevel(float value) {
        m_fSourceLevel_ = value;
    }

    bool operator == (const ST_TARGET_DB_BB_SOURCE_LEVEL& other_) const;
    bool operator != (const ST_TARGET_DB_BB_SOURCE_LEVEL& other_) const;

    void swap(ST_TARGET_DB_BB_SOURCE_LEVEL& other_) OMG_NOEXCEPT ;

  private:

    int32_t m_nCreationDateTime_;
    ::dds::core::array< uint8_t, 100L> m_szFrequency_;
    float m_fSourceLevel_;

};

inline void swap(ST_TARGET_DB_BB_SOURCE_LEVEL& a, ST_TARGET_DB_BB_SOURCE_LEVEL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TARGET_DB_BB_SOURCE_LEVEL& sample);

class NDDSUSERDllExport ST_TARGET_DB_NB_SOURCE_LEVEL {
  public:
    ST_TARGET_DB_NB_SOURCE_LEVEL();

    ST_TARGET_DB_NB_SOURCE_LEVEL(int32_t nCreationDateTime,float fFrequency,float fSourceLevel);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TARGET_DB_NB_SOURCE_LEVEL (ST_TARGET_DB_NB_SOURCE_LEVEL&&) = default;
    ST_TARGET_DB_NB_SOURCE_LEVEL& operator=(ST_TARGET_DB_NB_SOURCE_LEVEL&&) = default;
    ST_TARGET_DB_NB_SOURCE_LEVEL& operator=(const ST_TARGET_DB_NB_SOURCE_LEVEL&) = default;
    ST_TARGET_DB_NB_SOURCE_LEVEL(const ST_TARGET_DB_NB_SOURCE_LEVEL&) = default;
    #else
    ST_TARGET_DB_NB_SOURCE_LEVEL(ST_TARGET_DB_NB_SOURCE_LEVEL&& other_) OMG_NOEXCEPT;  
    ST_TARGET_DB_NB_SOURCE_LEVEL& operator=(ST_TARGET_DB_NB_SOURCE_LEVEL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int32_t& nCreationDateTime() OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    const int32_t& nCreationDateTime() const OMG_NOEXCEPT {
        return m_nCreationDateTime_;
    }

    void nCreationDateTime(int32_t value) {
        m_nCreationDateTime_ = value;
    }

    float& fFrequency() OMG_NOEXCEPT {
        return m_fFrequency_;
    }

    const float& fFrequency() const OMG_NOEXCEPT {
        return m_fFrequency_;
    }

    void fFrequency(float value) {
        m_fFrequency_ = value;
    }

    float& fSourceLevel() OMG_NOEXCEPT {
        return m_fSourceLevel_;
    }

    const float& fSourceLevel() const OMG_NOEXCEPT {
        return m_fSourceLevel_;
    }

    void fSourceLevel(float value) {
        m_fSourceLevel_ = value;
    }

    bool operator == (const ST_TARGET_DB_NB_SOURCE_LEVEL& other_) const;
    bool operator != (const ST_TARGET_DB_NB_SOURCE_LEVEL& other_) const;

    void swap(ST_TARGET_DB_NB_SOURCE_LEVEL& other_) OMG_NOEXCEPT ;

  private:

    int32_t m_nCreationDateTime_;
    float m_fFrequency_;
    float m_fSourceLevel_;

};

inline void swap(ST_TARGET_DB_NB_SOURCE_LEVEL& a, ST_TARGET_DB_NB_SOURCE_LEVEL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TARGET_DB_NB_SOURCE_LEVEL& sample);

class NDDSUSERDllExport DATMGR_TARGET_DB_INFO {
  public:
    DATMGR_TARGET_DB_INFO();

    DATMGR_TARGET_DB_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usTargetDBInfoCnt,const ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& stTargetDBInfo,uint16_t usTargetDBASStrengthCnt,const ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& stTargetDBASStrength,uint16_t usTargetDBBISStrengthCnt,const ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& stTargetDBBISStrength,uint16_t usTargetDBBBSourceLevelCnt,const ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& stTargetDBBBSourceLevel,uint16_t usTargetDBNBSourceLevelCnt,const ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& stTargetDBNBSourceLevel);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_TARGET_DB_INFO (DATMGR_TARGET_DB_INFO&&) = default;
    DATMGR_TARGET_DB_INFO& operator=(DATMGR_TARGET_DB_INFO&&) = default;
    DATMGR_TARGET_DB_INFO& operator=(const DATMGR_TARGET_DB_INFO&) = default;
    DATMGR_TARGET_DB_INFO(const DATMGR_TARGET_DB_INFO&) = default;
    #else
    DATMGR_TARGET_DB_INFO(DATMGR_TARGET_DB_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_TARGET_DB_INFO& operator=(DATMGR_TARGET_DB_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usTargetDBInfoCnt() OMG_NOEXCEPT {
        return m_usTargetDBInfoCnt_;
    }

    const uint16_t& usTargetDBInfoCnt() const OMG_NOEXCEPT {
        return m_usTargetDBInfoCnt_;
    }

    void usTargetDBInfoCnt(uint16_t value) {
        m_usTargetDBInfoCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& stTargetDBInfo() OMG_NOEXCEPT {
        return m_stTargetDBInfo_;
    }

    const ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& stTargetDBInfo() const OMG_NOEXCEPT {
        return m_stTargetDBInfo_;
    }

    void stTargetDBInfo(const ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& value) {
        m_stTargetDBInfo_ = value;
    }

    void stTargetDBInfo(::dds::core::array< ST_TARGET_DB_INFO, 1000L>&& value) {
        m_stTargetDBInfo_ = std::move(value);
    }
    uint16_t& usTargetDBASStrengthCnt() OMG_NOEXCEPT {
        return m_usTargetDBASStrengthCnt_;
    }

    const uint16_t& usTargetDBASStrengthCnt() const OMG_NOEXCEPT {
        return m_usTargetDBASStrengthCnt_;
    }

    void usTargetDBASStrengthCnt(uint16_t value) {
        m_usTargetDBASStrengthCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& stTargetDBASStrength() OMG_NOEXCEPT {
        return m_stTargetDBASStrength_;
    }

    const ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& stTargetDBASStrength() const OMG_NOEXCEPT {
        return m_stTargetDBASStrength_;
    }

    void stTargetDBASStrength(const ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& value) {
        m_stTargetDBASStrength_ = value;
    }

    void stTargetDBASStrength(::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>&& value) {
        m_stTargetDBASStrength_ = std::move(value);
    }
    uint16_t& usTargetDBBISStrengthCnt() OMG_NOEXCEPT {
        return m_usTargetDBBISStrengthCnt_;
    }

    const uint16_t& usTargetDBBISStrengthCnt() const OMG_NOEXCEPT {
        return m_usTargetDBBISStrengthCnt_;
    }

    void usTargetDBBISStrengthCnt(uint16_t value) {
        m_usTargetDBBISStrengthCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& stTargetDBBISStrength() OMG_NOEXCEPT {
        return m_stTargetDBBISStrength_;
    }

    const ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& stTargetDBBISStrength() const OMG_NOEXCEPT {
        return m_stTargetDBBISStrength_;
    }

    void stTargetDBBISStrength(const ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& value) {
        m_stTargetDBBISStrength_ = value;
    }

    void stTargetDBBISStrength(::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>&& value) {
        m_stTargetDBBISStrength_ = std::move(value);
    }
    uint16_t& usTargetDBBBSourceLevelCnt() OMG_NOEXCEPT {
        return m_usTargetDBBBSourceLevelCnt_;
    }

    const uint16_t& usTargetDBBBSourceLevelCnt() const OMG_NOEXCEPT {
        return m_usTargetDBBBSourceLevelCnt_;
    }

    void usTargetDBBBSourceLevelCnt(uint16_t value) {
        m_usTargetDBBBSourceLevelCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& stTargetDBBBSourceLevel() OMG_NOEXCEPT {
        return m_stTargetDBBBSourceLevel_;
    }

    const ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& stTargetDBBBSourceLevel() const OMG_NOEXCEPT {
        return m_stTargetDBBBSourceLevel_;
    }

    void stTargetDBBBSourceLevel(const ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& value) {
        m_stTargetDBBBSourceLevel_ = value;
    }

    void stTargetDBBBSourceLevel(::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>&& value) {
        m_stTargetDBBBSourceLevel_ = std::move(value);
    }
    uint16_t& usTargetDBNBSourceLevelCnt() OMG_NOEXCEPT {
        return m_usTargetDBNBSourceLevelCnt_;
    }

    const uint16_t& usTargetDBNBSourceLevelCnt() const OMG_NOEXCEPT {
        return m_usTargetDBNBSourceLevelCnt_;
    }

    void usTargetDBNBSourceLevelCnt(uint16_t value) {
        m_usTargetDBNBSourceLevelCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& stTargetDBNBSourceLevel() OMG_NOEXCEPT {
        return m_stTargetDBNBSourceLevel_;
    }

    const ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& stTargetDBNBSourceLevel() const OMG_NOEXCEPT {
        return m_stTargetDBNBSourceLevel_;
    }

    void stTargetDBNBSourceLevel(const ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& value) {
        m_stTargetDBNBSourceLevel_ = value;
    }

    void stTargetDBNBSourceLevel(::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>&& value) {
        m_stTargetDBNBSourceLevel_ = std::move(value);
    }

    bool operator == (const DATMGR_TARGET_DB_INFO& other_) const;
    bool operator != (const DATMGR_TARGET_DB_INFO& other_) const;

    void swap(DATMGR_TARGET_DB_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usTargetDBInfoCnt_;
    ::dds::core::array< ST_TARGET_DB_INFO, 1000L> m_stTargetDBInfo_;
    uint16_t m_usTargetDBASStrengthCnt_;
    ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L> m_stTargetDBASStrength_;
    uint16_t m_usTargetDBBISStrengthCnt_;
    ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L> m_stTargetDBBISStrength_;
    uint16_t m_usTargetDBBBSourceLevelCnt_;
    ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L> m_stTargetDBBBSourceLevel_;
    uint16_t m_usTargetDBNBSourceLevelCnt_;
    ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L> m_stTargetDBNBSourceLevel_;

};

inline void swap(DATMGR_TARGET_DB_INFO& a, DATMGR_TARGET_DB_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_TARGET_DB_INFO& sample);

class NDDSUSERDllExport ST_LAS_THRESH_INFO {
  public:
    ST_LAS_THRESH_INFO();

    ST_LAS_THRESH_INFO(float fLasCitBbdCbfThresh,float fLasCitBbdAbfThresh,float fLasCitLofarVlfCbfThresh,float fLasCitLofarVlfAbfThresh,float fLasCitLofarLfCbfThresh,float fLasCitLofarLfAbfThresh,float fLasCitLofarMfCbfThresh,float fLasCitLofarMfAbfThresh,float fLasCitLofarHfCbfThresh,float fLasCitLofarHfAbfThresh,float fLasCitDemonThresh,float fLasOitBbdCbfThresh,float fLasOitBbdAbfThresh,float fLasOitLofarCbfThresh,float fLasOitLofarAbfThresh,float fLasOitDemonThresh,const ::dds::core::array< float, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_THRESH_INFO (ST_LAS_THRESH_INFO&&) = default;
    ST_LAS_THRESH_INFO& operator=(ST_LAS_THRESH_INFO&&) = default;
    ST_LAS_THRESH_INFO& operator=(const ST_LAS_THRESH_INFO&) = default;
    ST_LAS_THRESH_INFO(const ST_LAS_THRESH_INFO&) = default;
    #else
    ST_LAS_THRESH_INFO(ST_LAS_THRESH_INFO&& other_) OMG_NOEXCEPT;  
    ST_LAS_THRESH_INFO& operator=(ST_LAS_THRESH_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    float& fLasCitBbdCbfThresh() OMG_NOEXCEPT {
        return m_fLasCitBbdCbfThresh_;
    }

    const float& fLasCitBbdCbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitBbdCbfThresh_;
    }

    void fLasCitBbdCbfThresh(float value) {
        m_fLasCitBbdCbfThresh_ = value;
    }

    float& fLasCitBbdAbfThresh() OMG_NOEXCEPT {
        return m_fLasCitBbdAbfThresh_;
    }

    const float& fLasCitBbdAbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitBbdAbfThresh_;
    }

    void fLasCitBbdAbfThresh(float value) {
        m_fLasCitBbdAbfThresh_ = value;
    }

    float& fLasCitLofarVlfCbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarVlfCbfThresh_;
    }

    const float& fLasCitLofarVlfCbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarVlfCbfThresh_;
    }

    void fLasCitLofarVlfCbfThresh(float value) {
        m_fLasCitLofarVlfCbfThresh_ = value;
    }

    float& fLasCitLofarVlfAbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarVlfAbfThresh_;
    }

    const float& fLasCitLofarVlfAbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarVlfAbfThresh_;
    }

    void fLasCitLofarVlfAbfThresh(float value) {
        m_fLasCitLofarVlfAbfThresh_ = value;
    }

    float& fLasCitLofarLfCbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarLfCbfThresh_;
    }

    const float& fLasCitLofarLfCbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarLfCbfThresh_;
    }

    void fLasCitLofarLfCbfThresh(float value) {
        m_fLasCitLofarLfCbfThresh_ = value;
    }

    float& fLasCitLofarLfAbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarLfAbfThresh_;
    }

    const float& fLasCitLofarLfAbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarLfAbfThresh_;
    }

    void fLasCitLofarLfAbfThresh(float value) {
        m_fLasCitLofarLfAbfThresh_ = value;
    }

    float& fLasCitLofarMfCbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarMfCbfThresh_;
    }

    const float& fLasCitLofarMfCbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarMfCbfThresh_;
    }

    void fLasCitLofarMfCbfThresh(float value) {
        m_fLasCitLofarMfCbfThresh_ = value;
    }

    float& fLasCitLofarMfAbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarMfAbfThresh_;
    }

    const float& fLasCitLofarMfAbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarMfAbfThresh_;
    }

    void fLasCitLofarMfAbfThresh(float value) {
        m_fLasCitLofarMfAbfThresh_ = value;
    }

    float& fLasCitLofarHfCbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarHfCbfThresh_;
    }

    const float& fLasCitLofarHfCbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarHfCbfThresh_;
    }

    void fLasCitLofarHfCbfThresh(float value) {
        m_fLasCitLofarHfCbfThresh_ = value;
    }

    float& fLasCitLofarHfAbfThresh() OMG_NOEXCEPT {
        return m_fLasCitLofarHfAbfThresh_;
    }

    const float& fLasCitLofarHfAbfThresh() const OMG_NOEXCEPT {
        return m_fLasCitLofarHfAbfThresh_;
    }

    void fLasCitLofarHfAbfThresh(float value) {
        m_fLasCitLofarHfAbfThresh_ = value;
    }

    float& fLasCitDemonThresh() OMG_NOEXCEPT {
        return m_fLasCitDemonThresh_;
    }

    const float& fLasCitDemonThresh() const OMG_NOEXCEPT {
        return m_fLasCitDemonThresh_;
    }

    void fLasCitDemonThresh(float value) {
        m_fLasCitDemonThresh_ = value;
    }

    float& fLasOitBbdCbfThresh() OMG_NOEXCEPT {
        return m_fLasOitBbdCbfThresh_;
    }

    const float& fLasOitBbdCbfThresh() const OMG_NOEXCEPT {
        return m_fLasOitBbdCbfThresh_;
    }

    void fLasOitBbdCbfThresh(float value) {
        m_fLasOitBbdCbfThresh_ = value;
    }

    float& fLasOitBbdAbfThresh() OMG_NOEXCEPT {
        return m_fLasOitBbdAbfThresh_;
    }

    const float& fLasOitBbdAbfThresh() const OMG_NOEXCEPT {
        return m_fLasOitBbdAbfThresh_;
    }

    void fLasOitBbdAbfThresh(float value) {
        m_fLasOitBbdAbfThresh_ = value;
    }

    float& fLasOitLofarCbfThresh() OMG_NOEXCEPT {
        return m_fLasOitLofarCbfThresh_;
    }

    const float& fLasOitLofarCbfThresh() const OMG_NOEXCEPT {
        return m_fLasOitLofarCbfThresh_;
    }

    void fLasOitLofarCbfThresh(float value) {
        m_fLasOitLofarCbfThresh_ = value;
    }

    float& fLasOitLofarAbfThresh() OMG_NOEXCEPT {
        return m_fLasOitLofarAbfThresh_;
    }

    const float& fLasOitLofarAbfThresh() const OMG_NOEXCEPT {
        return m_fLasOitLofarAbfThresh_;
    }

    void fLasOitLofarAbfThresh(float value) {
        m_fLasOitLofarAbfThresh_ = value;
    }

    float& fLasOitDemonThresh() OMG_NOEXCEPT {
        return m_fLasOitDemonThresh_;
    }

    const float& fLasOitDemonThresh() const OMG_NOEXCEPT {
        return m_fLasOitDemonThresh_;
    }

    void fLasOitDemonThresh(float value) {
        m_fLasOitDemonThresh_ = value;
    }

    ::dds::core::array< float, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< float, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< float, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< float, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_LAS_THRESH_INFO& other_) const;
    bool operator != (const ST_LAS_THRESH_INFO& other_) const;

    void swap(ST_LAS_THRESH_INFO& other_) OMG_NOEXCEPT ;

  private:

    float m_fLasCitBbdCbfThresh_;
    float m_fLasCitBbdAbfThresh_;
    float m_fLasCitLofarVlfCbfThresh_;
    float m_fLasCitLofarVlfAbfThresh_;
    float m_fLasCitLofarLfCbfThresh_;
    float m_fLasCitLofarLfAbfThresh_;
    float m_fLasCitLofarMfCbfThresh_;
    float m_fLasCitLofarMfAbfThresh_;
    float m_fLasCitLofarHfCbfThresh_;
    float m_fLasCitLofarHfAbfThresh_;
    float m_fLasCitDemonThresh_;
    float m_fLasOitBbdCbfThresh_;
    float m_fLasOitBbdAbfThresh_;
    float m_fLasOitLofarCbfThresh_;
    float m_fLasOitLofarAbfThresh_;
    float m_fLasOitDemonThresh_;
    ::dds::core::array< float, 4L> m_aReserved_;

};

inline void swap(ST_LAS_THRESH_INFO& a, ST_LAS_THRESH_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_THRESH_INFO& sample);

class NDDSUSERDllExport ST_BIS_THRESH_INFO {
  public:
    ST_BIS_THRESH_INFO();

    ST_BIS_THRESH_INFO(float fBisCitCwThresh,float fBisCitFmThresh,float fBisOitCwThresh,float fBisOitFmThresh,float fBisCwGrdThresh,float fBisFmGrdThresh,const ::dds::core::array< float, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_THRESH_INFO (ST_BIS_THRESH_INFO&&) = default;
    ST_BIS_THRESH_INFO& operator=(ST_BIS_THRESH_INFO&&) = default;
    ST_BIS_THRESH_INFO& operator=(const ST_BIS_THRESH_INFO&) = default;
    ST_BIS_THRESH_INFO(const ST_BIS_THRESH_INFO&) = default;
    #else
    ST_BIS_THRESH_INFO(ST_BIS_THRESH_INFO&& other_) OMG_NOEXCEPT;  
    ST_BIS_THRESH_INFO& operator=(ST_BIS_THRESH_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    float& fBisCitCwThresh() OMG_NOEXCEPT {
        return m_fBisCitCwThresh_;
    }

    const float& fBisCitCwThresh() const OMG_NOEXCEPT {
        return m_fBisCitCwThresh_;
    }

    void fBisCitCwThresh(float value) {
        m_fBisCitCwThresh_ = value;
    }

    float& fBisCitFmThresh() OMG_NOEXCEPT {
        return m_fBisCitFmThresh_;
    }

    const float& fBisCitFmThresh() const OMG_NOEXCEPT {
        return m_fBisCitFmThresh_;
    }

    void fBisCitFmThresh(float value) {
        m_fBisCitFmThresh_ = value;
    }

    float& fBisOitCwThresh() OMG_NOEXCEPT {
        return m_fBisOitCwThresh_;
    }

    const float& fBisOitCwThresh() const OMG_NOEXCEPT {
        return m_fBisOitCwThresh_;
    }

    void fBisOitCwThresh(float value) {
        m_fBisOitCwThresh_ = value;
    }

    float& fBisOitFmThresh() OMG_NOEXCEPT {
        return m_fBisOitFmThresh_;
    }

    const float& fBisOitFmThresh() const OMG_NOEXCEPT {
        return m_fBisOitFmThresh_;
    }

    void fBisOitFmThresh(float value) {
        m_fBisOitFmThresh_ = value;
    }

    float& fBisCwGrdThresh() OMG_NOEXCEPT {
        return m_fBisCwGrdThresh_;
    }

    const float& fBisCwGrdThresh() const OMG_NOEXCEPT {
        return m_fBisCwGrdThresh_;
    }

    void fBisCwGrdThresh(float value) {
        m_fBisCwGrdThresh_ = value;
    }

    float& fBisFmGrdThresh() OMG_NOEXCEPT {
        return m_fBisFmGrdThresh_;
    }

    const float& fBisFmGrdThresh() const OMG_NOEXCEPT {
        return m_fBisFmGrdThresh_;
    }

    void fBisFmGrdThresh(float value) {
        m_fBisFmGrdThresh_ = value;
    }

    ::dds::core::array< float, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< float, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< float, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< float, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_BIS_THRESH_INFO& other_) const;
    bool operator != (const ST_BIS_THRESH_INFO& other_) const;

    void swap(ST_BIS_THRESH_INFO& other_) OMG_NOEXCEPT ;

  private:

    float m_fBisCitCwThresh_;
    float m_fBisCitFmThresh_;
    float m_fBisOitCwThresh_;
    float m_fBisOitFmThresh_;
    float m_fBisCwGrdThresh_;
    float m_fBisFmGrdThresh_;
    ::dds::core::array< float, 4L> m_aReserved_;

};

inline void swap(ST_BIS_THRESH_INFO& a, ST_BIS_THRESH_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_THRESH_INFO& sample);

class NDDSUSERDllExport ST_MAS_THRESH_INFO {
  public:
    ST_MAS_THRESH_INFO();

    ST_MAS_THRESH_INFO(float fMasBbdThresh,float fMasNbdThresh,float fMasMagThresh,float fMasLofFreqThresh,float fMasDemFreqThresh,const ::dds::core::array< float, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_THRESH_INFO (ST_MAS_THRESH_INFO&&) = default;
    ST_MAS_THRESH_INFO& operator=(ST_MAS_THRESH_INFO&&) = default;
    ST_MAS_THRESH_INFO& operator=(const ST_MAS_THRESH_INFO&) = default;
    ST_MAS_THRESH_INFO(const ST_MAS_THRESH_INFO&) = default;
    #else
    ST_MAS_THRESH_INFO(ST_MAS_THRESH_INFO&& other_) OMG_NOEXCEPT;  
    ST_MAS_THRESH_INFO& operator=(ST_MAS_THRESH_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    float& fMasBbdThresh() OMG_NOEXCEPT {
        return m_fMasBbdThresh_;
    }

    const float& fMasBbdThresh() const OMG_NOEXCEPT {
        return m_fMasBbdThresh_;
    }

    void fMasBbdThresh(float value) {
        m_fMasBbdThresh_ = value;
    }

    float& fMasNbdThresh() OMG_NOEXCEPT {
        return m_fMasNbdThresh_;
    }

    const float& fMasNbdThresh() const OMG_NOEXCEPT {
        return m_fMasNbdThresh_;
    }

    void fMasNbdThresh(float value) {
        m_fMasNbdThresh_ = value;
    }

    float& fMasMagThresh() OMG_NOEXCEPT {
        return m_fMasMagThresh_;
    }

    const float& fMasMagThresh() const OMG_NOEXCEPT {
        return m_fMasMagThresh_;
    }

    void fMasMagThresh(float value) {
        m_fMasMagThresh_ = value;
    }

    float& fMasLofFreqThresh() OMG_NOEXCEPT {
        return m_fMasLofFreqThresh_;
    }

    const float& fMasLofFreqThresh() const OMG_NOEXCEPT {
        return m_fMasLofFreqThresh_;
    }

    void fMasLofFreqThresh(float value) {
        m_fMasLofFreqThresh_ = value;
    }

    float& fMasDemFreqThresh() OMG_NOEXCEPT {
        return m_fMasDemFreqThresh_;
    }

    const float& fMasDemFreqThresh() const OMG_NOEXCEPT {
        return m_fMasDemFreqThresh_;
    }

    void fMasDemFreqThresh(float value) {
        m_fMasDemFreqThresh_ = value;
    }

    ::dds::core::array< float, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< float, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< float, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< float, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_MAS_THRESH_INFO& other_) const;
    bool operator != (const ST_MAS_THRESH_INFO& other_) const;

    void swap(ST_MAS_THRESH_INFO& other_) OMG_NOEXCEPT ;

  private:

    float m_fMasBbdThresh_;
    float m_fMasNbdThresh_;
    float m_fMasMagThresh_;
    float m_fMasLofFreqThresh_;
    float m_fMasDemFreqThresh_;
    ::dds::core::array< float, 4L> m_aReserved_;

};

inline void swap(ST_MAS_THRESH_INFO& a, ST_MAS_THRESH_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_THRESH_INFO& sample);

class NDDSUSERDllExport DATMGR_TGTTRK_PARAM_INFO {
  public:
    DATMGR_TGTTRK_PARAM_INFO();

    DATMGR_TGTTRK_PARAM_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsLasCitThrshAuto,const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh,uint8_t oIsBisCitThrshAuto,const ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& stBisThresh,uint8_t oIsMasCitThrshAuto,const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasCitThresh,const ::dds::core::array< float, 24L>& aThreatFrequency,const ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& aExclusFrequency);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_TGTTRK_PARAM_INFO (DATMGR_TGTTRK_PARAM_INFO&&) = default;
    DATMGR_TGTTRK_PARAM_INFO& operator=(DATMGR_TGTTRK_PARAM_INFO&&) = default;
    DATMGR_TGTTRK_PARAM_INFO& operator=(const DATMGR_TGTTRK_PARAM_INFO&) = default;
    DATMGR_TGTTRK_PARAM_INFO(const DATMGR_TGTTRK_PARAM_INFO&) = default;
    #else
    DATMGR_TGTTRK_PARAM_INFO(DATMGR_TGTTRK_PARAM_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_TGTTRK_PARAM_INFO& operator=(DATMGR_TGTTRK_PARAM_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsLasCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsLasCitThrshAuto_;
    }

    const uint8_t& oIsLasCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsLasCitThrshAuto_;
    }

    void oIsLasCitThrshAuto(uint8_t value) {
        m_oIsLasCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh() OMG_NOEXCEPT {
        return m_stLasThresh_;
    }

    const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh() const OMG_NOEXCEPT {
        return m_stLasThresh_;
    }

    void stLasThresh(const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& value) {
        m_stLasThresh_ = value;
    }

    void stLasThresh(::dds::core::array< ST_LAS_THRESH_INFO, 3L>&& value) {
        m_stLasThresh_ = std::move(value);
    }
    uint8_t& oIsBisCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    const uint8_t& oIsBisCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    void oIsBisCitThrshAuto(uint8_t value) {
        m_oIsBisCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& stBisThresh() OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    const ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& stBisThresh() const OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    void stBisThresh(const ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& value) {
        m_stBisThresh_ = value;
    }

    void stBisThresh(::dds::core::array< ST_BIS_THRESH_INFO, 3L>&& value) {
        m_stBisThresh_ = std::move(value);
    }
    uint8_t& oIsMasCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsMasCitThrshAuto_;
    }

    const uint8_t& oIsMasCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsMasCitThrshAuto_;
    }

    void oIsMasCitThrshAuto(uint8_t value) {
        m_oIsMasCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasCitThresh() OMG_NOEXCEPT {
        return m_stMasCitThresh_;
    }

    const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasCitThresh() const OMG_NOEXCEPT {
        return m_stMasCitThresh_;
    }

    void stMasCitThresh(const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& value) {
        m_stMasCitThresh_ = value;
    }

    void stMasCitThresh(::dds::core::array< ST_MAS_THRESH_INFO, 2L>&& value) {
        m_stMasCitThresh_ = std::move(value);
    }
    ::dds::core::array< float, 24L>& aThreatFrequency() OMG_NOEXCEPT {
        return m_aThreatFrequency_;
    }

    const ::dds::core::array< float, 24L>& aThreatFrequency() const OMG_NOEXCEPT {
        return m_aThreatFrequency_;
    }

    void aThreatFrequency(const ::dds::core::array< float, 24L>& value) {
        m_aThreatFrequency_ = value;
    }

    void aThreatFrequency(::dds::core::array< float, 24L>&& value) {
        m_aThreatFrequency_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& aExclusFrequency() OMG_NOEXCEPT {
        return m_aExclusFrequency_;
    }

    const ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& aExclusFrequency() const OMG_NOEXCEPT {
        return m_aExclusFrequency_;
    }

    void aExclusFrequency(const ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& value) {
        m_aExclusFrequency_ = value;
    }

    void aExclusFrequency(::dds::core::array< ::dds::core::array< float, 24L>, 3L>&& value) {
        m_aExclusFrequency_ = std::move(value);
    }

    bool operator == (const DATMGR_TGTTRK_PARAM_INFO& other_) const;
    bool operator != (const DATMGR_TGTTRK_PARAM_INFO& other_) const;

    void swap(DATMGR_TGTTRK_PARAM_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsLasCitThrshAuto_;
    ::dds::core::array< ST_LAS_THRESH_INFO, 3L> m_stLasThresh_;
    uint8_t m_oIsBisCitThrshAuto_;
    ::dds::core::array< ST_BIS_THRESH_INFO, 3L> m_stBisThresh_;
    uint8_t m_oIsMasCitThrshAuto_;
    ::dds::core::array< ST_MAS_THRESH_INFO, 2L> m_stMasCitThresh_;
    ::dds::core::array< float, 24L> m_aThreatFrequency_;
    ::dds::core::array< ::dds::core::array< float, 24L>, 3L> m_aExclusFrequency_;

};

inline void swap(DATMGR_TGTTRK_PARAM_INFO& a, DATMGR_TGTTRK_PARAM_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_TGTTRK_PARAM_INFO& sample);

class NDDSUSERDllExport ST_THREAT_AREA {
  public:
    ST_THREAT_AREA();

    ST_THREAT_AREA(const ::dds::core::array< ::dds::core::array< float, 2L>, 2L>& fPoint,uint8_t oLineSize,uint8_t oLineColor,uint8_t oLineType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_THREAT_AREA (ST_THREAT_AREA&&) = default;
    ST_THREAT_AREA& operator=(ST_THREAT_AREA&&) = default;
    ST_THREAT_AREA& operator=(const ST_THREAT_AREA&) = default;
    ST_THREAT_AREA(const ST_THREAT_AREA&) = default;
    #else
    ST_THREAT_AREA(ST_THREAT_AREA&& other_) OMG_NOEXCEPT;  
    ST_THREAT_AREA& operator=(ST_THREAT_AREA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< ::dds::core::array< float, 2L>, 2L>& fPoint() OMG_NOEXCEPT {
        return m_fPoint_;
    }

    const ::dds::core::array< ::dds::core::array< float, 2L>, 2L>& fPoint() const OMG_NOEXCEPT {
        return m_fPoint_;
    }

    void fPoint(const ::dds::core::array< ::dds::core::array< float, 2L>, 2L>& value) {
        m_fPoint_ = value;
    }

    void fPoint(::dds::core::array< ::dds::core::array< float, 2L>, 2L>&& value) {
        m_fPoint_ = std::move(value);
    }
    uint8_t& oLineSize() OMG_NOEXCEPT {
        return m_oLineSize_;
    }

    const uint8_t& oLineSize() const OMG_NOEXCEPT {
        return m_oLineSize_;
    }

    void oLineSize(uint8_t value) {
        m_oLineSize_ = value;
    }

    uint8_t& oLineColor() OMG_NOEXCEPT {
        return m_oLineColor_;
    }

    const uint8_t& oLineColor() const OMG_NOEXCEPT {
        return m_oLineColor_;
    }

    void oLineColor(uint8_t value) {
        m_oLineColor_ = value;
    }

    uint8_t& oLineType() OMG_NOEXCEPT {
        return m_oLineType_;
    }

    const uint8_t& oLineType() const OMG_NOEXCEPT {
        return m_oLineType_;
    }

    void oLineType(uint8_t value) {
        m_oLineType_ = value;
    }

    bool operator == (const ST_THREAT_AREA& other_) const;
    bool operator != (const ST_THREAT_AREA& other_) const;

    void swap(ST_THREAT_AREA& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< ::dds::core::array< float, 2L>, 2L> m_fPoint_;
    uint8_t m_oLineSize_;
    uint8_t m_oLineColor_;
    uint8_t m_oLineType_;

};

inline void swap(ST_THREAT_AREA& a, ST_THREAT_AREA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_THREAT_AREA& sample);

class NDDSUSERDllExport DATMGR_THREAT_AREA_INFO {
  public:
    DATMGR_THREAT_AREA_INFO();

    DATMGR_THREAT_AREA_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oInfoType,const ST_THREAT_AREA& stThreatArea1,const ST_THREAT_AREA& stThreatArea2,const ST_THREAT_AREA& stThreatArea3);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_THREAT_AREA_INFO (DATMGR_THREAT_AREA_INFO&&) = default;
    DATMGR_THREAT_AREA_INFO& operator=(DATMGR_THREAT_AREA_INFO&&) = default;
    DATMGR_THREAT_AREA_INFO& operator=(const DATMGR_THREAT_AREA_INFO&) = default;
    DATMGR_THREAT_AREA_INFO(const DATMGR_THREAT_AREA_INFO&) = default;
    #else
    DATMGR_THREAT_AREA_INFO(DATMGR_THREAT_AREA_INFO&& other_) OMG_NOEXCEPT;  
    DATMGR_THREAT_AREA_INFO& operator=(DATMGR_THREAT_AREA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oInfoType() OMG_NOEXCEPT {
        return m_oInfoType_;
    }

    const uint8_t& oInfoType() const OMG_NOEXCEPT {
        return m_oInfoType_;
    }

    void oInfoType(uint8_t value) {
        m_oInfoType_ = value;
    }

    ST_THREAT_AREA& stThreatArea1() OMG_NOEXCEPT {
        return m_stThreatArea1_;
    }

    const ST_THREAT_AREA& stThreatArea1() const OMG_NOEXCEPT {
        return m_stThreatArea1_;
    }

    void stThreatArea1(const ST_THREAT_AREA& value) {
        m_stThreatArea1_ = value;
    }

    void stThreatArea1(ST_THREAT_AREA&& value) {
        m_stThreatArea1_ = std::move(value);
    }
    ST_THREAT_AREA& stThreatArea2() OMG_NOEXCEPT {
        return m_stThreatArea2_;
    }

    const ST_THREAT_AREA& stThreatArea2() const OMG_NOEXCEPT {
        return m_stThreatArea2_;
    }

    void stThreatArea2(const ST_THREAT_AREA& value) {
        m_stThreatArea2_ = value;
    }

    void stThreatArea2(ST_THREAT_AREA&& value) {
        m_stThreatArea2_ = std::move(value);
    }
    ST_THREAT_AREA& stThreatArea3() OMG_NOEXCEPT {
        return m_stThreatArea3_;
    }

    const ST_THREAT_AREA& stThreatArea3() const OMG_NOEXCEPT {
        return m_stThreatArea3_;
    }

    void stThreatArea3(const ST_THREAT_AREA& value) {
        m_stThreatArea3_ = value;
    }

    void stThreatArea3(ST_THREAT_AREA&& value) {
        m_stThreatArea3_ = std::move(value);
    }

    bool operator == (const DATMGR_THREAT_AREA_INFO& other_) const;
    bool operator != (const DATMGR_THREAT_AREA_INFO& other_) const;

    void swap(DATMGR_THREAT_AREA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oInfoType_;
    ST_THREAT_AREA m_stThreatArea1_;
    ST_THREAT_AREA m_stThreatArea2_;
    ST_THREAT_AREA m_stThreatArea3_;

};

inline void swap(DATMGR_THREAT_AREA_INFO& a, DATMGR_THREAT_AREA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_THREAT_AREA_INFO& sample);

class NDDSUSERDllExport DATMGR_USER_LOGIN_INFO_REQUEST {
  public:
    DATMGR_USER_LOGIN_INFO_REQUEST();

    DATMGR_USER_LOGIN_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    DATMGR_USER_LOGIN_INFO_REQUEST (DATMGR_USER_LOGIN_INFO_REQUEST&&) = default;
    DATMGR_USER_LOGIN_INFO_REQUEST& operator=(DATMGR_USER_LOGIN_INFO_REQUEST&&) = default;
    DATMGR_USER_LOGIN_INFO_REQUEST& operator=(const DATMGR_USER_LOGIN_INFO_REQUEST&) = default;
    DATMGR_USER_LOGIN_INFO_REQUEST(const DATMGR_USER_LOGIN_INFO_REQUEST&) = default;
    #else
    DATMGR_USER_LOGIN_INFO_REQUEST(DATMGR_USER_LOGIN_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    DATMGR_USER_LOGIN_INFO_REQUEST& operator=(DATMGR_USER_LOGIN_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    bool operator == (const DATMGR_USER_LOGIN_INFO_REQUEST& other_) const;
    bool operator != (const DATMGR_USER_LOGIN_INFO_REQUEST& other_) const;

    void swap(DATMGR_USER_LOGIN_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;

};

inline void swap(DATMGR_USER_LOGIN_INFO_REQUEST& a, DATMGR_USER_LOGIN_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const DATMGR_USER_LOGIN_INFO_REQUEST& sample);

class NDDSUSERDllExport ST_SEN_DET_CHK {
  public:
    ST_SEN_DET_CHK();

    ST_SEN_DET_CHK(const ::dds::core::array< bool, 3L>& bLAS,const ::dds::core::array< bool, 3L>& bBIS,const ::dds::core::array< uint8_t, 4L>& oMAS,const ::dds::core::array< bool, 3L>& bASE,const ::dds::core::array< bool, 2L>& bEOT,const ::dds::core::array< bool, 2L>& bRDR,bool bKNT);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SEN_DET_CHK (ST_SEN_DET_CHK&&) = default;
    ST_SEN_DET_CHK& operator=(ST_SEN_DET_CHK&&) = default;
    ST_SEN_DET_CHK& operator=(const ST_SEN_DET_CHK&) = default;
    ST_SEN_DET_CHK(const ST_SEN_DET_CHK&) = default;
    #else
    ST_SEN_DET_CHK(ST_SEN_DET_CHK&& other_) OMG_NOEXCEPT;  
    ST_SEN_DET_CHK& operator=(ST_SEN_DET_CHK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< bool, 3L>& bLAS() OMG_NOEXCEPT {
        return m_bLAS_;
    }

    const ::dds::core::array< bool, 3L>& bLAS() const OMG_NOEXCEPT {
        return m_bLAS_;
    }

    void bLAS(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_ = value;
    }

    void bLAS(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bBIS() OMG_NOEXCEPT {
        return m_bBIS_;
    }

    const ::dds::core::array< bool, 3L>& bBIS() const OMG_NOEXCEPT {
        return m_bBIS_;
    }

    void bBIS(const ::dds::core::array< bool, 3L>& value) {
        m_bBIS_ = value;
    }

    void bBIS(::dds::core::array< bool, 3L>&& value) {
        m_bBIS_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 4L>& oMAS() OMG_NOEXCEPT {
        return m_oMAS_;
    }

    const ::dds::core::array< uint8_t, 4L>& oMAS() const OMG_NOEXCEPT {
        return m_oMAS_;
    }

    void oMAS(const ::dds::core::array< uint8_t, 4L>& value) {
        m_oMAS_ = value;
    }

    void oMAS(::dds::core::array< uint8_t, 4L>&& value) {
        m_oMAS_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bASE() OMG_NOEXCEPT {
        return m_bASE_;
    }

    const ::dds::core::array< bool, 3L>& bASE() const OMG_NOEXCEPT {
        return m_bASE_;
    }

    void bASE(const ::dds::core::array< bool, 3L>& value) {
        m_bASE_ = value;
    }

    void bASE(::dds::core::array< bool, 3L>&& value) {
        m_bASE_ = std::move(value);
    }
    ::dds::core::array< bool, 2L>& bEOT() OMG_NOEXCEPT {
        return m_bEOT_;
    }

    const ::dds::core::array< bool, 2L>& bEOT() const OMG_NOEXCEPT {
        return m_bEOT_;
    }

    void bEOT(const ::dds::core::array< bool, 2L>& value) {
        m_bEOT_ = value;
    }

    void bEOT(::dds::core::array< bool, 2L>&& value) {
        m_bEOT_ = std::move(value);
    }
    ::dds::core::array< bool, 2L>& bRDR() OMG_NOEXCEPT {
        return m_bRDR_;
    }

    const ::dds::core::array< bool, 2L>& bRDR() const OMG_NOEXCEPT {
        return m_bRDR_;
    }

    void bRDR(const ::dds::core::array< bool, 2L>& value) {
        m_bRDR_ = value;
    }

    void bRDR(::dds::core::array< bool, 2L>&& value) {
        m_bRDR_ = std::move(value);
    }
    bool& bKNT() OMG_NOEXCEPT {
        return m_bKNT_;
    }

    const bool& bKNT() const OMG_NOEXCEPT {
        return m_bKNT_;
    }

    void bKNT(bool value) {
        m_bKNT_ = value;
    }

    bool operator == (const ST_SEN_DET_CHK& other_) const;
    bool operator != (const ST_SEN_DET_CHK& other_) const;

    void swap(ST_SEN_DET_CHK& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< bool, 3L> m_bLAS_;
    ::dds::core::array< bool, 3L> m_bBIS_;
    ::dds::core::array< uint8_t, 4L> m_oMAS_;
    ::dds::core::array< bool, 3L> m_bASE_;
    ::dds::core::array< bool, 2L> m_bEOT_;
    ::dds::core::array< bool, 2L> m_bRDR_;
    bool m_bKNT_;

};

inline void swap(ST_SEN_DET_CHK& a, ST_SEN_DET_CHK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SEN_DET_CHK& sample);

class NDDSUSERDllExport ST_SEN_DET_SEL {
  public:
    ST_SEN_DET_SEL();

    ST_SEN_DET_SEL(const ::dds::core::array< bool, 3L>& bLAS_CIT_BBD_CBF,const ::dds::core::array< bool, 3L>& bLAS_CIT_BBD_ABF,const ::dds::core::array< bool, 3L>& bLAS_CIT_LOFAR_CBF,const ::dds::core::array< bool, 3L>& bLAS_CIT_LOFAR_ABF,const ::dds::core::array< bool, 3L>& bLAS_CIT_DEMON,const ::dds::core::array< bool, 3L>& bLAS_OIT_BBD_CBF,const ::dds::core::array< bool, 3L>& bLAS_OIT_BBD_ABF,const ::dds::core::array< bool, 3L>& bLAS_OIT_LOFAR_CBF,const ::dds::core::array< bool, 3L>& bLAS_OIT_LOFAR_ABF,const ::dds::core::array< bool, 3L>& bLAS_OIT_DEMON,const ::dds::core::array< bool, 3L>& bBIS_CW_CIT,const ::dds::core::array< bool, 3L>& bBIS_CW_OIT,const ::dds::core::array< bool, 3L>& bBIS_FM_CIT,const ::dds::core::array< bool, 3L>& bBIS_FM_OIT,const ::dds::core::array< bool, 2L>& bMAS_MAG,const ::dds::core::array< bool, 2L>& bMAS_ACO_BBD,const ::dds::core::array< bool, 2L>& bMAS_ACO_NBD,const ::dds::core::array< bool, 3L>& bASE_CIT,const ::dds::core::array< bool, 3L>& bASE_OIT,const ::dds::core::array< bool, 2L>& bEOT,const ::dds::core::array< bool, 2L>& bRDR,bool bKNT);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SEN_DET_SEL (ST_SEN_DET_SEL&&) = default;
    ST_SEN_DET_SEL& operator=(ST_SEN_DET_SEL&&) = default;
    ST_SEN_DET_SEL& operator=(const ST_SEN_DET_SEL&) = default;
    ST_SEN_DET_SEL(const ST_SEN_DET_SEL&) = default;
    #else
    ST_SEN_DET_SEL(ST_SEN_DET_SEL&& other_) OMG_NOEXCEPT;  
    ST_SEN_DET_SEL& operator=(ST_SEN_DET_SEL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< bool, 3L>& bLAS_CIT_BBD_CBF() OMG_NOEXCEPT {
        return m_bLAS_CIT_BBD_CBF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_CIT_BBD_CBF() const OMG_NOEXCEPT {
        return m_bLAS_CIT_BBD_CBF_;
    }

    void bLAS_CIT_BBD_CBF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_CIT_BBD_CBF_ = value;
    }

    void bLAS_CIT_BBD_CBF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_CIT_BBD_CBF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_CIT_BBD_ABF() OMG_NOEXCEPT {
        return m_bLAS_CIT_BBD_ABF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_CIT_BBD_ABF() const OMG_NOEXCEPT {
        return m_bLAS_CIT_BBD_ABF_;
    }

    void bLAS_CIT_BBD_ABF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_CIT_BBD_ABF_ = value;
    }

    void bLAS_CIT_BBD_ABF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_CIT_BBD_ABF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_CIT_LOFAR_CBF() OMG_NOEXCEPT {
        return m_bLAS_CIT_LOFAR_CBF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_CIT_LOFAR_CBF() const OMG_NOEXCEPT {
        return m_bLAS_CIT_LOFAR_CBF_;
    }

    void bLAS_CIT_LOFAR_CBF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_CIT_LOFAR_CBF_ = value;
    }

    void bLAS_CIT_LOFAR_CBF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_CIT_LOFAR_CBF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_CIT_LOFAR_ABF() OMG_NOEXCEPT {
        return m_bLAS_CIT_LOFAR_ABF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_CIT_LOFAR_ABF() const OMG_NOEXCEPT {
        return m_bLAS_CIT_LOFAR_ABF_;
    }

    void bLAS_CIT_LOFAR_ABF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_CIT_LOFAR_ABF_ = value;
    }

    void bLAS_CIT_LOFAR_ABF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_CIT_LOFAR_ABF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_CIT_DEMON() OMG_NOEXCEPT {
        return m_bLAS_CIT_DEMON_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_CIT_DEMON() const OMG_NOEXCEPT {
        return m_bLAS_CIT_DEMON_;
    }

    void bLAS_CIT_DEMON(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_CIT_DEMON_ = value;
    }

    void bLAS_CIT_DEMON(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_CIT_DEMON_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_OIT_BBD_CBF() OMG_NOEXCEPT {
        return m_bLAS_OIT_BBD_CBF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_OIT_BBD_CBF() const OMG_NOEXCEPT {
        return m_bLAS_OIT_BBD_CBF_;
    }

    void bLAS_OIT_BBD_CBF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_OIT_BBD_CBF_ = value;
    }

    void bLAS_OIT_BBD_CBF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_OIT_BBD_CBF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_OIT_BBD_ABF() OMG_NOEXCEPT {
        return m_bLAS_OIT_BBD_ABF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_OIT_BBD_ABF() const OMG_NOEXCEPT {
        return m_bLAS_OIT_BBD_ABF_;
    }

    void bLAS_OIT_BBD_ABF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_OIT_BBD_ABF_ = value;
    }

    void bLAS_OIT_BBD_ABF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_OIT_BBD_ABF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_OIT_LOFAR_CBF() OMG_NOEXCEPT {
        return m_bLAS_OIT_LOFAR_CBF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_OIT_LOFAR_CBF() const OMG_NOEXCEPT {
        return m_bLAS_OIT_LOFAR_CBF_;
    }

    void bLAS_OIT_LOFAR_CBF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_OIT_LOFAR_CBF_ = value;
    }

    void bLAS_OIT_LOFAR_CBF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_OIT_LOFAR_CBF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_OIT_LOFAR_ABF() OMG_NOEXCEPT {
        return m_bLAS_OIT_LOFAR_ABF_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_OIT_LOFAR_ABF() const OMG_NOEXCEPT {
        return m_bLAS_OIT_LOFAR_ABF_;
    }

    void bLAS_OIT_LOFAR_ABF(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_OIT_LOFAR_ABF_ = value;
    }

    void bLAS_OIT_LOFAR_ABF(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_OIT_LOFAR_ABF_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bLAS_OIT_DEMON() OMG_NOEXCEPT {
        return m_bLAS_OIT_DEMON_;
    }

    const ::dds::core::array< bool, 3L>& bLAS_OIT_DEMON() const OMG_NOEXCEPT {
        return m_bLAS_OIT_DEMON_;
    }

    void bLAS_OIT_DEMON(const ::dds::core::array< bool, 3L>& value) {
        m_bLAS_OIT_DEMON_ = value;
    }

    void bLAS_OIT_DEMON(::dds::core::array< bool, 3L>&& value) {
        m_bLAS_OIT_DEMON_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bBIS_CW_CIT() OMG_NOEXCEPT {
        return m_bBIS_CW_CIT_;
    }

    const ::dds::core::array< bool, 3L>& bBIS_CW_CIT() const OMG_NOEXCEPT {
        return m_bBIS_CW_CIT_;
    }

    void bBIS_CW_CIT(const ::dds::core::array< bool, 3L>& value) {
        m_bBIS_CW_CIT_ = value;
    }

    void bBIS_CW_CIT(::dds::core::array< bool, 3L>&& value) {
        m_bBIS_CW_CIT_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bBIS_CW_OIT() OMG_NOEXCEPT {
        return m_bBIS_CW_OIT_;
    }

    const ::dds::core::array< bool, 3L>& bBIS_CW_OIT() const OMG_NOEXCEPT {
        return m_bBIS_CW_OIT_;
    }

    void bBIS_CW_OIT(const ::dds::core::array< bool, 3L>& value) {
        m_bBIS_CW_OIT_ = value;
    }

    void bBIS_CW_OIT(::dds::core::array< bool, 3L>&& value) {
        m_bBIS_CW_OIT_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bBIS_FM_CIT() OMG_NOEXCEPT {
        return m_bBIS_FM_CIT_;
    }

    const ::dds::core::array< bool, 3L>& bBIS_FM_CIT() const OMG_NOEXCEPT {
        return m_bBIS_FM_CIT_;
    }

    void bBIS_FM_CIT(const ::dds::core::array< bool, 3L>& value) {
        m_bBIS_FM_CIT_ = value;
    }

    void bBIS_FM_CIT(::dds::core::array< bool, 3L>&& value) {
        m_bBIS_FM_CIT_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bBIS_FM_OIT() OMG_NOEXCEPT {
        return m_bBIS_FM_OIT_;
    }

    const ::dds::core::array< bool, 3L>& bBIS_FM_OIT() const OMG_NOEXCEPT {
        return m_bBIS_FM_OIT_;
    }

    void bBIS_FM_OIT(const ::dds::core::array< bool, 3L>& value) {
        m_bBIS_FM_OIT_ = value;
    }

    void bBIS_FM_OIT(::dds::core::array< bool, 3L>&& value) {
        m_bBIS_FM_OIT_ = std::move(value);
    }
    ::dds::core::array< bool, 2L>& bMAS_MAG() OMG_NOEXCEPT {
        return m_bMAS_MAG_;
    }

    const ::dds::core::array< bool, 2L>& bMAS_MAG() const OMG_NOEXCEPT {
        return m_bMAS_MAG_;
    }

    void bMAS_MAG(const ::dds::core::array< bool, 2L>& value) {
        m_bMAS_MAG_ = value;
    }

    void bMAS_MAG(::dds::core::array< bool, 2L>&& value) {
        m_bMAS_MAG_ = std::move(value);
    }
    ::dds::core::array< bool, 2L>& bMAS_ACO_BBD() OMG_NOEXCEPT {
        return m_bMAS_ACO_BBD_;
    }

    const ::dds::core::array< bool, 2L>& bMAS_ACO_BBD() const OMG_NOEXCEPT {
        return m_bMAS_ACO_BBD_;
    }

    void bMAS_ACO_BBD(const ::dds::core::array< bool, 2L>& value) {
        m_bMAS_ACO_BBD_ = value;
    }

    void bMAS_ACO_BBD(::dds::core::array< bool, 2L>&& value) {
        m_bMAS_ACO_BBD_ = std::move(value);
    }
    ::dds::core::array< bool, 2L>& bMAS_ACO_NBD() OMG_NOEXCEPT {
        return m_bMAS_ACO_NBD_;
    }

    const ::dds::core::array< bool, 2L>& bMAS_ACO_NBD() const OMG_NOEXCEPT {
        return m_bMAS_ACO_NBD_;
    }

    void bMAS_ACO_NBD(const ::dds::core::array< bool, 2L>& value) {
        m_bMAS_ACO_NBD_ = value;
    }

    void bMAS_ACO_NBD(::dds::core::array< bool, 2L>&& value) {
        m_bMAS_ACO_NBD_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bASE_CIT() OMG_NOEXCEPT {
        return m_bASE_CIT_;
    }

    const ::dds::core::array< bool, 3L>& bASE_CIT() const OMG_NOEXCEPT {
        return m_bASE_CIT_;
    }

    void bASE_CIT(const ::dds::core::array< bool, 3L>& value) {
        m_bASE_CIT_ = value;
    }

    void bASE_CIT(::dds::core::array< bool, 3L>&& value) {
        m_bASE_CIT_ = std::move(value);
    }
    ::dds::core::array< bool, 3L>& bASE_OIT() OMG_NOEXCEPT {
        return m_bASE_OIT_;
    }

    const ::dds::core::array< bool, 3L>& bASE_OIT() const OMG_NOEXCEPT {
        return m_bASE_OIT_;
    }

    void bASE_OIT(const ::dds::core::array< bool, 3L>& value) {
        m_bASE_OIT_ = value;
    }

    void bASE_OIT(::dds::core::array< bool, 3L>&& value) {
        m_bASE_OIT_ = std::move(value);
    }
    ::dds::core::array< bool, 2L>& bEOT() OMG_NOEXCEPT {
        return m_bEOT_;
    }

    const ::dds::core::array< bool, 2L>& bEOT() const OMG_NOEXCEPT {
        return m_bEOT_;
    }

    void bEOT(const ::dds::core::array< bool, 2L>& value) {
        m_bEOT_ = value;
    }

    void bEOT(::dds::core::array< bool, 2L>&& value) {
        m_bEOT_ = std::move(value);
    }
    ::dds::core::array< bool, 2L>& bRDR() OMG_NOEXCEPT {
        return m_bRDR_;
    }

    const ::dds::core::array< bool, 2L>& bRDR() const OMG_NOEXCEPT {
        return m_bRDR_;
    }

    void bRDR(const ::dds::core::array< bool, 2L>& value) {
        m_bRDR_ = value;
    }

    void bRDR(::dds::core::array< bool, 2L>&& value) {
        m_bRDR_ = std::move(value);
    }
    bool& bKNT() OMG_NOEXCEPT {
        return m_bKNT_;
    }

    const bool& bKNT() const OMG_NOEXCEPT {
        return m_bKNT_;
    }

    void bKNT(bool value) {
        m_bKNT_ = value;
    }

    bool operator == (const ST_SEN_DET_SEL& other_) const;
    bool operator != (const ST_SEN_DET_SEL& other_) const;

    void swap(ST_SEN_DET_SEL& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< bool, 3L> m_bLAS_CIT_BBD_CBF_;
    ::dds::core::array< bool, 3L> m_bLAS_CIT_BBD_ABF_;
    ::dds::core::array< bool, 3L> m_bLAS_CIT_LOFAR_CBF_;
    ::dds::core::array< bool, 3L> m_bLAS_CIT_LOFAR_ABF_;
    ::dds::core::array< bool, 3L> m_bLAS_CIT_DEMON_;
    ::dds::core::array< bool, 3L> m_bLAS_OIT_BBD_CBF_;
    ::dds::core::array< bool, 3L> m_bLAS_OIT_BBD_ABF_;
    ::dds::core::array< bool, 3L> m_bLAS_OIT_LOFAR_CBF_;
    ::dds::core::array< bool, 3L> m_bLAS_OIT_LOFAR_ABF_;
    ::dds::core::array< bool, 3L> m_bLAS_OIT_DEMON_;
    ::dds::core::array< bool, 3L> m_bBIS_CW_CIT_;
    ::dds::core::array< bool, 3L> m_bBIS_CW_OIT_;
    ::dds::core::array< bool, 3L> m_bBIS_FM_CIT_;
    ::dds::core::array< bool, 3L> m_bBIS_FM_OIT_;
    ::dds::core::array< bool, 2L> m_bMAS_MAG_;
    ::dds::core::array< bool, 2L> m_bMAS_ACO_BBD_;
    ::dds::core::array< bool, 2L> m_bMAS_ACO_NBD_;
    ::dds::core::array< bool, 3L> m_bASE_CIT_;
    ::dds::core::array< bool, 3L> m_bASE_OIT_;
    ::dds::core::array< bool, 2L> m_bEOT_;
    ::dds::core::array< bool, 2L> m_bRDR_;
    bool m_bKNT_;

};

inline void swap(ST_SEN_DET_SEL& a, ST_SEN_DET_SEL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SEN_DET_SEL& sample);

class NDDSUSERDllExport ST_SEN_DISTANCE {
  public:
    ST_SEN_DISTANCE();

    ST_SEN_DISTANCE(const ::dds::core::array< float, 3L>& fLAS,const ::dds::core::array< float, 3L>& fBIS,const ::dds::core::array< float, 4L>& fMAS,const ::dds::core::array< float, 3L>& fASE,const ::dds::core::array< float, 2L>& fEOT,const ::dds::core::array< float, 2L>& fRDR,float fKNT);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SEN_DISTANCE (ST_SEN_DISTANCE&&) = default;
    ST_SEN_DISTANCE& operator=(ST_SEN_DISTANCE&&) = default;
    ST_SEN_DISTANCE& operator=(const ST_SEN_DISTANCE&) = default;
    ST_SEN_DISTANCE(const ST_SEN_DISTANCE&) = default;
    #else
    ST_SEN_DISTANCE(ST_SEN_DISTANCE&& other_) OMG_NOEXCEPT;  
    ST_SEN_DISTANCE& operator=(ST_SEN_DISTANCE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< float, 3L>& fLAS() OMG_NOEXCEPT {
        return m_fLAS_;
    }

    const ::dds::core::array< float, 3L>& fLAS() const OMG_NOEXCEPT {
        return m_fLAS_;
    }

    void fLAS(const ::dds::core::array< float, 3L>& value) {
        m_fLAS_ = value;
    }

    void fLAS(::dds::core::array< float, 3L>&& value) {
        m_fLAS_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& fBIS() OMG_NOEXCEPT {
        return m_fBIS_;
    }

    const ::dds::core::array< float, 3L>& fBIS() const OMG_NOEXCEPT {
        return m_fBIS_;
    }

    void fBIS(const ::dds::core::array< float, 3L>& value) {
        m_fBIS_ = value;
    }

    void fBIS(::dds::core::array< float, 3L>&& value) {
        m_fBIS_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fMAS() OMG_NOEXCEPT {
        return m_fMAS_;
    }

    const ::dds::core::array< float, 4L>& fMAS() const OMG_NOEXCEPT {
        return m_fMAS_;
    }

    void fMAS(const ::dds::core::array< float, 4L>& value) {
        m_fMAS_ = value;
    }

    void fMAS(::dds::core::array< float, 4L>&& value) {
        m_fMAS_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& fASE() OMG_NOEXCEPT {
        return m_fASE_;
    }

    const ::dds::core::array< float, 3L>& fASE() const OMG_NOEXCEPT {
        return m_fASE_;
    }

    void fASE(const ::dds::core::array< float, 3L>& value) {
        m_fASE_ = value;
    }

    void fASE(::dds::core::array< float, 3L>&& value) {
        m_fASE_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fEOT() OMG_NOEXCEPT {
        return m_fEOT_;
    }

    const ::dds::core::array< float, 2L>& fEOT() const OMG_NOEXCEPT {
        return m_fEOT_;
    }

    void fEOT(const ::dds::core::array< float, 2L>& value) {
        m_fEOT_ = value;
    }

    void fEOT(::dds::core::array< float, 2L>&& value) {
        m_fEOT_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fRDR() OMG_NOEXCEPT {
        return m_fRDR_;
    }

    const ::dds::core::array< float, 2L>& fRDR() const OMG_NOEXCEPT {
        return m_fRDR_;
    }

    void fRDR(const ::dds::core::array< float, 2L>& value) {
        m_fRDR_ = value;
    }

    void fRDR(::dds::core::array< float, 2L>&& value) {
        m_fRDR_ = std::move(value);
    }
    float& fKNT() OMG_NOEXCEPT {
        return m_fKNT_;
    }

    const float& fKNT() const OMG_NOEXCEPT {
        return m_fKNT_;
    }

    void fKNT(float value) {
        m_fKNT_ = value;
    }

    bool operator == (const ST_SEN_DISTANCE& other_) const;
    bool operator != (const ST_SEN_DISTANCE& other_) const;

    void swap(ST_SEN_DISTANCE& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< float, 3L> m_fLAS_;
    ::dds::core::array< float, 3L> m_fBIS_;
    ::dds::core::array< float, 4L> m_fMAS_;
    ::dds::core::array< float, 3L> m_fASE_;
    ::dds::core::array< float, 2L> m_fEOT_;
    ::dds::core::array< float, 2L> m_fRDR_;
    float m_fKNT_;

};

inline void swap(ST_SEN_DISTANCE& a, ST_SEN_DISTANCE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SEN_DISTANCE& sample);

class NDDSUSERDllExport ST_SEN_BEARING {
  public:
    ST_SEN_BEARING();

    ST_SEN_BEARING(const ::dds::core::array< float, 3L>& fLAS,const ::dds::core::array< float, 3L>& fBIS,const ::dds::core::array< float, 4L>& fMAS,const ::dds::core::array< float, 3L>& fASE,const ::dds::core::array< float, 2L>& fEOT,const ::dds::core::array< float, 2L>& fRDR,float fKNT);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SEN_BEARING (ST_SEN_BEARING&&) = default;
    ST_SEN_BEARING& operator=(ST_SEN_BEARING&&) = default;
    ST_SEN_BEARING& operator=(const ST_SEN_BEARING&) = default;
    ST_SEN_BEARING(const ST_SEN_BEARING&) = default;
    #else
    ST_SEN_BEARING(ST_SEN_BEARING&& other_) OMG_NOEXCEPT;  
    ST_SEN_BEARING& operator=(ST_SEN_BEARING&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< float, 3L>& fLAS() OMG_NOEXCEPT {
        return m_fLAS_;
    }

    const ::dds::core::array< float, 3L>& fLAS() const OMG_NOEXCEPT {
        return m_fLAS_;
    }

    void fLAS(const ::dds::core::array< float, 3L>& value) {
        m_fLAS_ = value;
    }

    void fLAS(::dds::core::array< float, 3L>&& value) {
        m_fLAS_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& fBIS() OMG_NOEXCEPT {
        return m_fBIS_;
    }

    const ::dds::core::array< float, 3L>& fBIS() const OMG_NOEXCEPT {
        return m_fBIS_;
    }

    void fBIS(const ::dds::core::array< float, 3L>& value) {
        m_fBIS_ = value;
    }

    void fBIS(::dds::core::array< float, 3L>&& value) {
        m_fBIS_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fMAS() OMG_NOEXCEPT {
        return m_fMAS_;
    }

    const ::dds::core::array< float, 4L>& fMAS() const OMG_NOEXCEPT {
        return m_fMAS_;
    }

    void fMAS(const ::dds::core::array< float, 4L>& value) {
        m_fMAS_ = value;
    }

    void fMAS(::dds::core::array< float, 4L>&& value) {
        m_fMAS_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& fASE() OMG_NOEXCEPT {
        return m_fASE_;
    }

    const ::dds::core::array< float, 3L>& fASE() const OMG_NOEXCEPT {
        return m_fASE_;
    }

    void fASE(const ::dds::core::array< float, 3L>& value) {
        m_fASE_ = value;
    }

    void fASE(::dds::core::array< float, 3L>&& value) {
        m_fASE_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fEOT() OMG_NOEXCEPT {
        return m_fEOT_;
    }

    const ::dds::core::array< float, 2L>& fEOT() const OMG_NOEXCEPT {
        return m_fEOT_;
    }

    void fEOT(const ::dds::core::array< float, 2L>& value) {
        m_fEOT_ = value;
    }

    void fEOT(::dds::core::array< float, 2L>&& value) {
        m_fEOT_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fRDR() OMG_NOEXCEPT {
        return m_fRDR_;
    }

    const ::dds::core::array< float, 2L>& fRDR() const OMG_NOEXCEPT {
        return m_fRDR_;
    }

    void fRDR(const ::dds::core::array< float, 2L>& value) {
        m_fRDR_ = value;
    }

    void fRDR(::dds::core::array< float, 2L>&& value) {
        m_fRDR_ = std::move(value);
    }
    float& fKNT() OMG_NOEXCEPT {
        return m_fKNT_;
    }

    const float& fKNT() const OMG_NOEXCEPT {
        return m_fKNT_;
    }

    void fKNT(float value) {
        m_fKNT_ = value;
    }

    bool operator == (const ST_SEN_BEARING& other_) const;
    bool operator != (const ST_SEN_BEARING& other_) const;

    void swap(ST_SEN_BEARING& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< float, 3L> m_fLAS_;
    ::dds::core::array< float, 3L> m_fBIS_;
    ::dds::core::array< float, 4L> m_fMAS_;
    ::dds::core::array< float, 3L> m_fASE_;
    ::dds::core::array< float, 2L> m_fEOT_;
    ::dds::core::array< float, 2L> m_fRDR_;
    float m_fKNT_;

};

inline void swap(ST_SEN_BEARING& a, ST_SEN_BEARING& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SEN_BEARING& sample);

class NDDSUSERDllExport ST_BIS_TARGET_POS {
  public:
    ST_BIS_TARGET_POS();

    ST_BIS_TARGET_POS(const ::dds::core::array< float, 3L>& fPosX,const ::dds::core::array< float, 3L>& fPosY);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_TARGET_POS (ST_BIS_TARGET_POS&&) = default;
    ST_BIS_TARGET_POS& operator=(ST_BIS_TARGET_POS&&) = default;
    ST_BIS_TARGET_POS& operator=(const ST_BIS_TARGET_POS&) = default;
    ST_BIS_TARGET_POS(const ST_BIS_TARGET_POS&) = default;
    #else
    ST_BIS_TARGET_POS(ST_BIS_TARGET_POS&& other_) OMG_NOEXCEPT;  
    ST_BIS_TARGET_POS& operator=(ST_BIS_TARGET_POS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< float, 3L>& fPosX() OMG_NOEXCEPT {
        return m_fPosX_;
    }

    const ::dds::core::array< float, 3L>& fPosX() const OMG_NOEXCEPT {
        return m_fPosX_;
    }

    void fPosX(const ::dds::core::array< float, 3L>& value) {
        m_fPosX_ = value;
    }

    void fPosX(::dds::core::array< float, 3L>&& value) {
        m_fPosX_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& fPosY() OMG_NOEXCEPT {
        return m_fPosY_;
    }

    const ::dds::core::array< float, 3L>& fPosY() const OMG_NOEXCEPT {
        return m_fPosY_;
    }

    void fPosY(const ::dds::core::array< float, 3L>& value) {
        m_fPosY_ = value;
    }

    void fPosY(::dds::core::array< float, 3L>&& value) {
        m_fPosY_ = std::move(value);
    }

    bool operator == (const ST_BIS_TARGET_POS& other_) const;
    bool operator != (const ST_BIS_TARGET_POS& other_) const;

    void swap(ST_BIS_TARGET_POS& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< float, 3L> m_fPosX_;
    ::dds::core::array< float, 3L> m_fPosY_;

};

inline void swap(ST_BIS_TARGET_POS& a, ST_BIS_TARGET_POS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_TARGET_POS& sample);

class NDDSUSERDllExport ST_HIS_FREQ_INFO {
  public:
    ST_HIS_FREQ_INFO();

    ST_HIS_FREQ_INFO(float fLofar,uint8_t oSNR,bool bThreatFreqChk);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HIS_FREQ_INFO (ST_HIS_FREQ_INFO&&) = default;
    ST_HIS_FREQ_INFO& operator=(ST_HIS_FREQ_INFO&&) = default;
    ST_HIS_FREQ_INFO& operator=(const ST_HIS_FREQ_INFO&) = default;
    ST_HIS_FREQ_INFO(const ST_HIS_FREQ_INFO&) = default;
    #else
    ST_HIS_FREQ_INFO(ST_HIS_FREQ_INFO&& other_) OMG_NOEXCEPT;  
    ST_HIS_FREQ_INFO& operator=(ST_HIS_FREQ_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    float& fLofar() OMG_NOEXCEPT {
        return m_fLofar_;
    }

    const float& fLofar() const OMG_NOEXCEPT {
        return m_fLofar_;
    }

    void fLofar(float value) {
        m_fLofar_ = value;
    }

    uint8_t& oSNR() OMG_NOEXCEPT {
        return m_oSNR_;
    }

    const uint8_t& oSNR() const OMG_NOEXCEPT {
        return m_oSNR_;
    }

    void oSNR(uint8_t value) {
        m_oSNR_ = value;
    }

    bool& bThreatFreqChk() OMG_NOEXCEPT {
        return m_bThreatFreqChk_;
    }

    const bool& bThreatFreqChk() const OMG_NOEXCEPT {
        return m_bThreatFreqChk_;
    }

    void bThreatFreqChk(bool value) {
        m_bThreatFreqChk_ = value;
    }

    bool operator == (const ST_HIS_FREQ_INFO& other_) const;
    bool operator != (const ST_HIS_FREQ_INFO& other_) const;

    void swap(ST_HIS_FREQ_INFO& other_) OMG_NOEXCEPT ;

  private:

    float m_fLofar_;
    uint8_t m_oSNR_;
    bool m_bThreatFreqChk_;

};

inline void swap(ST_HIS_FREQ_INFO& a, ST_HIS_FREQ_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HIS_FREQ_INFO& sample);

class NDDSUSERDllExport ST_SCENARIO_TARGET_INFO {
  public:
    ST_SCENARIO_TARGET_INFO();

    ST_SCENARIO_TARGET_INFO(uint16_t unTargetNum,double dLat,double dLon,float fCourse,float fSpeed,const ST_SEN_DET_CHK& stSenDetChk,const ST_SEN_DET_SEL& stSenDetSel,const ST_SEN_DISTANCE& stSenDistance,const ST_SEN_BEARING& stSenBearing,const ST_BIS_TARGET_POS& stBisTargetPos,const ::dds::core::array< ST_HIS_FREQ_INFO, 2L>& stHisLofarFreqInfo,const ST_HIS_FREQ_INFO& stHisDemonFreqInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SCENARIO_TARGET_INFO (ST_SCENARIO_TARGET_INFO&&) = default;
    ST_SCENARIO_TARGET_INFO& operator=(ST_SCENARIO_TARGET_INFO&&) = default;
    ST_SCENARIO_TARGET_INFO& operator=(const ST_SCENARIO_TARGET_INFO&) = default;
    ST_SCENARIO_TARGET_INFO(const ST_SCENARIO_TARGET_INFO&) = default;
    #else
    ST_SCENARIO_TARGET_INFO(ST_SCENARIO_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    ST_SCENARIO_TARGET_INFO& operator=(ST_SCENARIO_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& unTargetNum() OMG_NOEXCEPT {
        return m_unTargetNum_;
    }

    const uint16_t& unTargetNum() const OMG_NOEXCEPT {
        return m_unTargetNum_;
    }

    void unTargetNum(uint16_t value) {
        m_unTargetNum_ = value;
    }

    double& dLat() OMG_NOEXCEPT {
        return m_dLat_;
    }

    const double& dLat() const OMG_NOEXCEPT {
        return m_dLat_;
    }

    void dLat(double value) {
        m_dLat_ = value;
    }

    double& dLon() OMG_NOEXCEPT {
        return m_dLon_;
    }

    const double& dLon() const OMG_NOEXCEPT {
        return m_dLon_;
    }

    void dLon(double value) {
        m_dLon_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fSpeed() OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    const float& fSpeed() const OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    void fSpeed(float value) {
        m_fSpeed_ = value;
    }

    ST_SEN_DET_CHK& stSenDetChk() OMG_NOEXCEPT {
        return m_stSenDetChk_;
    }

    const ST_SEN_DET_CHK& stSenDetChk() const OMG_NOEXCEPT {
        return m_stSenDetChk_;
    }

    void stSenDetChk(const ST_SEN_DET_CHK& value) {
        m_stSenDetChk_ = value;
    }

    void stSenDetChk(ST_SEN_DET_CHK&& value) {
        m_stSenDetChk_ = std::move(value);
    }
    ST_SEN_DET_SEL& stSenDetSel() OMG_NOEXCEPT {
        return m_stSenDetSel_;
    }

    const ST_SEN_DET_SEL& stSenDetSel() const OMG_NOEXCEPT {
        return m_stSenDetSel_;
    }

    void stSenDetSel(const ST_SEN_DET_SEL& value) {
        m_stSenDetSel_ = value;
    }

    void stSenDetSel(ST_SEN_DET_SEL&& value) {
        m_stSenDetSel_ = std::move(value);
    }
    ST_SEN_DISTANCE& stSenDistance() OMG_NOEXCEPT {
        return m_stSenDistance_;
    }

    const ST_SEN_DISTANCE& stSenDistance() const OMG_NOEXCEPT {
        return m_stSenDistance_;
    }

    void stSenDistance(const ST_SEN_DISTANCE& value) {
        m_stSenDistance_ = value;
    }

    void stSenDistance(ST_SEN_DISTANCE&& value) {
        m_stSenDistance_ = std::move(value);
    }
    ST_SEN_BEARING& stSenBearing() OMG_NOEXCEPT {
        return m_stSenBearing_;
    }

    const ST_SEN_BEARING& stSenBearing() const OMG_NOEXCEPT {
        return m_stSenBearing_;
    }

    void stSenBearing(const ST_SEN_BEARING& value) {
        m_stSenBearing_ = value;
    }

    void stSenBearing(ST_SEN_BEARING&& value) {
        m_stSenBearing_ = std::move(value);
    }
    ST_BIS_TARGET_POS& stBisTargetPos() OMG_NOEXCEPT {
        return m_stBisTargetPos_;
    }

    const ST_BIS_TARGET_POS& stBisTargetPos() const OMG_NOEXCEPT {
        return m_stBisTargetPos_;
    }

    void stBisTargetPos(const ST_BIS_TARGET_POS& value) {
        m_stBisTargetPos_ = value;
    }

    void stBisTargetPos(ST_BIS_TARGET_POS&& value) {
        m_stBisTargetPos_ = std::move(value);
    }
    ::dds::core::array< ST_HIS_FREQ_INFO, 2L>& stHisLofarFreqInfo() OMG_NOEXCEPT {
        return m_stHisLofarFreqInfo_;
    }

    const ::dds::core::array< ST_HIS_FREQ_INFO, 2L>& stHisLofarFreqInfo() const OMG_NOEXCEPT {
        return m_stHisLofarFreqInfo_;
    }

    void stHisLofarFreqInfo(const ::dds::core::array< ST_HIS_FREQ_INFO, 2L>& value) {
        m_stHisLofarFreqInfo_ = value;
    }

    void stHisLofarFreqInfo(::dds::core::array< ST_HIS_FREQ_INFO, 2L>&& value) {
        m_stHisLofarFreqInfo_ = std::move(value);
    }
    ST_HIS_FREQ_INFO& stHisDemonFreqInfo() OMG_NOEXCEPT {
        return m_stHisDemonFreqInfo_;
    }

    const ST_HIS_FREQ_INFO& stHisDemonFreqInfo() const OMG_NOEXCEPT {
        return m_stHisDemonFreqInfo_;
    }

    void stHisDemonFreqInfo(const ST_HIS_FREQ_INFO& value) {
        m_stHisDemonFreqInfo_ = value;
    }

    void stHisDemonFreqInfo(ST_HIS_FREQ_INFO&& value) {
        m_stHisDemonFreqInfo_ = std::move(value);
    }

    bool operator == (const ST_SCENARIO_TARGET_INFO& other_) const;
    bool operator != (const ST_SCENARIO_TARGET_INFO& other_) const;

    void swap(ST_SCENARIO_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_unTargetNum_;
    double m_dLat_;
    double m_dLon_;
    float m_fCourse_;
    float m_fSpeed_;
    ST_SEN_DET_CHK m_stSenDetChk_;
    ST_SEN_DET_SEL m_stSenDetSel_;
    ST_SEN_DISTANCE m_stSenDistance_;
    ST_SEN_BEARING m_stSenBearing_;
    ST_BIS_TARGET_POS m_stBisTargetPos_;
    ::dds::core::array< ST_HIS_FREQ_INFO, 2L> m_stHisLofarFreqInfo_;
    ST_HIS_FREQ_INFO m_stHisDemonFreqInfo_;

};

inline void swap(ST_SCENARIO_TARGET_INFO& a, ST_SCENARIO_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SCENARIO_TARGET_INFO& sample);

class NDDSUSERDllExport HUSSIS_SCENARIO_TARGET_INFO {
  public:
    HUSSIS_SCENARIO_TARGET_INFO();

    HUSSIS_SCENARIO_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usTargetNum,const ::dds::core::array< ST_SCENARIO_TARGET_INFO, 30L>& stScenarioTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    HUSSIS_SCENARIO_TARGET_INFO (HUSSIS_SCENARIO_TARGET_INFO&&) = default;
    HUSSIS_SCENARIO_TARGET_INFO& operator=(HUSSIS_SCENARIO_TARGET_INFO&&) = default;
    HUSSIS_SCENARIO_TARGET_INFO& operator=(const HUSSIS_SCENARIO_TARGET_INFO&) = default;
    HUSSIS_SCENARIO_TARGET_INFO(const HUSSIS_SCENARIO_TARGET_INFO&) = default;
    #else
    HUSSIS_SCENARIO_TARGET_INFO(HUSSIS_SCENARIO_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    HUSSIS_SCENARIO_TARGET_INFO& operator=(HUSSIS_SCENARIO_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usTargetNum() OMG_NOEXCEPT {
        return m_usTargetNum_;
    }

    const uint16_t& usTargetNum() const OMG_NOEXCEPT {
        return m_usTargetNum_;
    }

    void usTargetNum(uint16_t value) {
        m_usTargetNum_ = value;
    }

    ::dds::core::array< ST_SCENARIO_TARGET_INFO, 30L>& stScenarioTargetInfo() OMG_NOEXCEPT {
        return m_stScenarioTargetInfo_;
    }

    const ::dds::core::array< ST_SCENARIO_TARGET_INFO, 30L>& stScenarioTargetInfo() const OMG_NOEXCEPT {
        return m_stScenarioTargetInfo_;
    }

    void stScenarioTargetInfo(const ::dds::core::array< ST_SCENARIO_TARGET_INFO, 30L>& value) {
        m_stScenarioTargetInfo_ = value;
    }

    void stScenarioTargetInfo(::dds::core::array< ST_SCENARIO_TARGET_INFO, 30L>&& value) {
        m_stScenarioTargetInfo_ = std::move(value);
    }

    bool operator == (const HUSSIS_SCENARIO_TARGET_INFO& other_) const;
    bool operator != (const HUSSIS_SCENARIO_TARGET_INFO& other_) const;

    void swap(HUSSIS_SCENARIO_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usTargetNum_;
    ::dds::core::array< ST_SCENARIO_TARGET_INFO, 30L> m_stScenarioTargetInfo_;

};

inline void swap(HUSSIS_SCENARIO_TARGET_INFO& a, HUSSIS_SCENARIO_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const HUSSIS_SCENARIO_TARGET_INFO& sample);

class NDDSUSERDllExport ST_HIS_TARGET_INFORMATION {
  public:
    ST_HIS_TARGET_INFORMATION();

    ST_HIS_TARGET_INFORMATION(double dLat,double dLon,int16_t sNumLofar,const ::dds::core::array< int32_t, 960L>& lLofarFreq,int16_t sNumSing,const ::dds::core::array< int32_t, 5L>& lSingFreq);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HIS_TARGET_INFORMATION (ST_HIS_TARGET_INFORMATION&&) = default;
    ST_HIS_TARGET_INFORMATION& operator=(ST_HIS_TARGET_INFORMATION&&) = default;
    ST_HIS_TARGET_INFORMATION& operator=(const ST_HIS_TARGET_INFORMATION&) = default;
    ST_HIS_TARGET_INFORMATION(const ST_HIS_TARGET_INFORMATION&) = default;
    #else
    ST_HIS_TARGET_INFORMATION(ST_HIS_TARGET_INFORMATION&& other_) OMG_NOEXCEPT;  
    ST_HIS_TARGET_INFORMATION& operator=(ST_HIS_TARGET_INFORMATION&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    double& dLat() OMG_NOEXCEPT {
        return m_dLat_;
    }

    const double& dLat() const OMG_NOEXCEPT {
        return m_dLat_;
    }

    void dLat(double value) {
        m_dLat_ = value;
    }

    double& dLon() OMG_NOEXCEPT {
        return m_dLon_;
    }

    const double& dLon() const OMG_NOEXCEPT {
        return m_dLon_;
    }

    void dLon(double value) {
        m_dLon_ = value;
    }

    int16_t& sNumLofar() OMG_NOEXCEPT {
        return m_sNumLofar_;
    }

    const int16_t& sNumLofar() const OMG_NOEXCEPT {
        return m_sNumLofar_;
    }

    void sNumLofar(int16_t value) {
        m_sNumLofar_ = value;
    }

    ::dds::core::array< int32_t, 960L>& lLofarFreq() OMG_NOEXCEPT {
        return m_lLofarFreq_;
    }

    const ::dds::core::array< int32_t, 960L>& lLofarFreq() const OMG_NOEXCEPT {
        return m_lLofarFreq_;
    }

    void lLofarFreq(const ::dds::core::array< int32_t, 960L>& value) {
        m_lLofarFreq_ = value;
    }

    void lLofarFreq(::dds::core::array< int32_t, 960L>&& value) {
        m_lLofarFreq_ = std::move(value);
    }
    int16_t& sNumSing() OMG_NOEXCEPT {
        return m_sNumSing_;
    }

    const int16_t& sNumSing() const OMG_NOEXCEPT {
        return m_sNumSing_;
    }

    void sNumSing(int16_t value) {
        m_sNumSing_ = value;
    }

    ::dds::core::array< int32_t, 5L>& lSingFreq() OMG_NOEXCEPT {
        return m_lSingFreq_;
    }

    const ::dds::core::array< int32_t, 5L>& lSingFreq() const OMG_NOEXCEPT {
        return m_lSingFreq_;
    }

    void lSingFreq(const ::dds::core::array< int32_t, 5L>& value) {
        m_lSingFreq_ = value;
    }

    void lSingFreq(::dds::core::array< int32_t, 5L>&& value) {
        m_lSingFreq_ = std::move(value);
    }

    bool operator == (const ST_HIS_TARGET_INFORMATION& other_) const;
    bool operator != (const ST_HIS_TARGET_INFORMATION& other_) const;

    void swap(ST_HIS_TARGET_INFORMATION& other_) OMG_NOEXCEPT ;

  private:

    double m_dLat_;
    double m_dLon_;
    int16_t m_sNumLofar_;
    ::dds::core::array< int32_t, 960L> m_lLofarFreq_;
    int16_t m_sNumSing_;
    ::dds::core::array< int32_t, 5L> m_lSingFreq_;

};

inline void swap(ST_HIS_TARGET_INFORMATION& a, ST_HIS_TARGET_INFORMATION& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HIS_TARGET_INFORMATION& sample);

class NDDSUSERDllExport HUSSIS_TARGET_INFORMATION {
  public:
    HUSSIS_TARGET_INFORMATION();

    HUSSIS_TARGET_INFORMATION(const ST_MSG_HEADER& stMsgHeader,int16_t sTargetNum,const ::dds::core::array< ST_HIS_TARGET_INFORMATION, 50L>& stTargetInformation);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    HUSSIS_TARGET_INFORMATION (HUSSIS_TARGET_INFORMATION&&) = default;
    HUSSIS_TARGET_INFORMATION& operator=(HUSSIS_TARGET_INFORMATION&&) = default;
    HUSSIS_TARGET_INFORMATION& operator=(const HUSSIS_TARGET_INFORMATION&) = default;
    HUSSIS_TARGET_INFORMATION(const HUSSIS_TARGET_INFORMATION&) = default;
    #else
    HUSSIS_TARGET_INFORMATION(HUSSIS_TARGET_INFORMATION&& other_) OMG_NOEXCEPT;  
    HUSSIS_TARGET_INFORMATION& operator=(HUSSIS_TARGET_INFORMATION&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int16_t& sTargetNum() OMG_NOEXCEPT {
        return m_sTargetNum_;
    }

    const int16_t& sTargetNum() const OMG_NOEXCEPT {
        return m_sTargetNum_;
    }

    void sTargetNum(int16_t value) {
        m_sTargetNum_ = value;
    }

    ::dds::core::array< ST_HIS_TARGET_INFORMATION, 50L>& stTargetInformation() OMG_NOEXCEPT {
        return m_stTargetInformation_;
    }

    const ::dds::core::array< ST_HIS_TARGET_INFORMATION, 50L>& stTargetInformation() const OMG_NOEXCEPT {
        return m_stTargetInformation_;
    }

    void stTargetInformation(const ::dds::core::array< ST_HIS_TARGET_INFORMATION, 50L>& value) {
        m_stTargetInformation_ = value;
    }

    void stTargetInformation(::dds::core::array< ST_HIS_TARGET_INFORMATION, 50L>&& value) {
        m_stTargetInformation_ = std::move(value);
    }

    bool operator == (const HUSSIS_TARGET_INFORMATION& other_) const;
    bool operator != (const HUSSIS_TARGET_INFORMATION& other_) const;

    void swap(HUSSIS_TARGET_INFORMATION& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int16_t m_sTargetNum_;
    ::dds::core::array< ST_HIS_TARGET_INFORMATION, 50L> m_stTargetInformation_;

};

inline void swap(HUSSIS_TARGET_INFORMATION& a, HUSSIS_TARGET_INFORMATION& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const HUSSIS_TARGET_INFORMATION& sample);

class NDDSUSERDllExport HUSS_CSCI_COM_MSG {
  public:
    HUSS_CSCI_COM_MSG();

    HUSS_CSCI_COM_MSG(const ST_MSG_HEADER& stMsgHeader,uint32_t ulComMSGID,uint32_t ulCSCIID,const ::dds::core::array< uint8_t, 1500L>& oData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    HUSS_CSCI_COM_MSG (HUSS_CSCI_COM_MSG&&) = default;
    HUSS_CSCI_COM_MSG& operator=(HUSS_CSCI_COM_MSG&&) = default;
    HUSS_CSCI_COM_MSG& operator=(const HUSS_CSCI_COM_MSG&) = default;
    HUSS_CSCI_COM_MSG(const HUSS_CSCI_COM_MSG&) = default;
    #else
    HUSS_CSCI_COM_MSG(HUSS_CSCI_COM_MSG&& other_) OMG_NOEXCEPT;  
    HUSS_CSCI_COM_MSG& operator=(HUSS_CSCI_COM_MSG&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulComMSGID() OMG_NOEXCEPT {
        return m_ulComMSGID_;
    }

    const uint32_t& ulComMSGID() const OMG_NOEXCEPT {
        return m_ulComMSGID_;
    }

    void ulComMSGID(uint32_t value) {
        m_ulComMSGID_ = value;
    }

    uint32_t& ulCSCIID() OMG_NOEXCEPT {
        return m_ulCSCIID_;
    }

    const uint32_t& ulCSCIID() const OMG_NOEXCEPT {
        return m_ulCSCIID_;
    }

    void ulCSCIID(uint32_t value) {
        m_ulCSCIID_ = value;
    }

    ::dds::core::array< uint8_t, 1500L>& oData() OMG_NOEXCEPT {
        return m_oData_;
    }

    const ::dds::core::array< uint8_t, 1500L>& oData() const OMG_NOEXCEPT {
        return m_oData_;
    }

    void oData(const ::dds::core::array< uint8_t, 1500L>& value) {
        m_oData_ = value;
    }

    void oData(::dds::core::array< uint8_t, 1500L>&& value) {
        m_oData_ = std::move(value);
    }

    bool operator == (const HUSS_CSCI_COM_MSG& other_) const;
    bool operator != (const HUSS_CSCI_COM_MSG& other_) const;

    void swap(HUSS_CSCI_COM_MSG& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulComMSGID_;
    uint32_t m_ulCSCIID_;
    ::dds::core::array< uint8_t, 1500L> m_oData_;

};

inline void swap(HUSS_CSCI_COM_MSG& a, HUSS_CSCI_COM_MSG& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const HUSS_CSCI_COM_MSG& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_CHANNEL_INFO {
  public:
    IFCCTR_ACTIVESONAR_CHANNEL_INFO();

    IFCCTR_ACTIVESONAR_CHANNEL_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,uint32_t ulFaultSensorNum,const ::dds::core::array< uint8_t, 120L>& oFaultSensorInfo,float fReferenceValue,const ::dds::core::array< float, 120L>& fEnergyError,int32_t lAGC,const ST_DATE_TIME& stDateTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_CHANNEL_INFO (IFCCTR_ACTIVESONAR_CHANNEL_INFO&&) = default;
    IFCCTR_ACTIVESONAR_CHANNEL_INFO& operator=(IFCCTR_ACTIVESONAR_CHANNEL_INFO&&) = default;
    IFCCTR_ACTIVESONAR_CHANNEL_INFO& operator=(const IFCCTR_ACTIVESONAR_CHANNEL_INFO&) = default;
    IFCCTR_ACTIVESONAR_CHANNEL_INFO(const IFCCTR_ACTIVESONAR_CHANNEL_INFO&) = default;
    #else
    IFCCTR_ACTIVESONAR_CHANNEL_INFO(IFCCTR_ACTIVESONAR_CHANNEL_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_CHANNEL_INFO& operator=(IFCCTR_ACTIVESONAR_CHANNEL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    uint32_t& ulFaultSensorNum() OMG_NOEXCEPT {
        return m_ulFaultSensorNum_;
    }

    const uint32_t& ulFaultSensorNum() const OMG_NOEXCEPT {
        return m_ulFaultSensorNum_;
    }

    void ulFaultSensorNum(uint32_t value) {
        m_ulFaultSensorNum_ = value;
    }

    ::dds::core::array< uint8_t, 120L>& oFaultSensorInfo() OMG_NOEXCEPT {
        return m_oFaultSensorInfo_;
    }

    const ::dds::core::array< uint8_t, 120L>& oFaultSensorInfo() const OMG_NOEXCEPT {
        return m_oFaultSensorInfo_;
    }

    void oFaultSensorInfo(const ::dds::core::array< uint8_t, 120L>& value) {
        m_oFaultSensorInfo_ = value;
    }

    void oFaultSensorInfo(::dds::core::array< uint8_t, 120L>&& value) {
        m_oFaultSensorInfo_ = std::move(value);
    }
    float& fReferenceValue() OMG_NOEXCEPT {
        return m_fReferenceValue_;
    }

    const float& fReferenceValue() const OMG_NOEXCEPT {
        return m_fReferenceValue_;
    }

    void fReferenceValue(float value) {
        m_fReferenceValue_ = value;
    }

    ::dds::core::array< float, 120L>& fEnergyError() OMG_NOEXCEPT {
        return m_fEnergyError_;
    }

    const ::dds::core::array< float, 120L>& fEnergyError() const OMG_NOEXCEPT {
        return m_fEnergyError_;
    }

    void fEnergyError(const ::dds::core::array< float, 120L>& value) {
        m_fEnergyError_ = value;
    }

    void fEnergyError(::dds::core::array< float, 120L>&& value) {
        m_fEnergyError_ = std::move(value);
    }
    int32_t& lAGC() OMG_NOEXCEPT {
        return m_lAGC_;
    }

    const int32_t& lAGC() const OMG_NOEXCEPT {
        return m_lAGC_;
    }

    void lAGC(int32_t value) {
        m_lAGC_ = value;
    }

    ST_DATE_TIME& stDateTime() OMG_NOEXCEPT {
        return m_stDateTime_;
    }

    const ST_DATE_TIME& stDateTime() const OMG_NOEXCEPT {
        return m_stDateTime_;
    }

    void stDateTime(const ST_DATE_TIME& value) {
        m_stDateTime_ = value;
    }

    void stDateTime(ST_DATE_TIME&& value) {
        m_stDateTime_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_CHANNEL_INFO& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_CHANNEL_INFO& other_) const;

    void swap(IFCCTR_ACTIVESONAR_CHANNEL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    uint32_t m_ulFaultSensorNum_;
    ::dds::core::array< uint8_t, 120L> m_oFaultSensorInfo_;
    float m_fReferenceValue_;
    ::dds::core::array< float, 120L> m_fEnergyError_;
    int32_t m_lAGC_;
    ST_DATE_TIME m_stDateTime_;

};

inline void swap(IFCCTR_ACTIVESONAR_CHANNEL_INFO& a, IFCCTR_ACTIVESONAR_CHANNEL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_CHANNEL_INFO& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO {
  public:
    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO();

    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& ClutterMapInfo,const ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& SonarImageInfo,const ST_DATE_TIME& stUpdateTime,uint32_t ulPingCount);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO (IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO&&) = default;
    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& operator=(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO&&) = default;
    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& operator=(const IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO&) = default;
    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO(const IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO&) = default;
    #else
    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& operator=(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& ClutterMapInfo() OMG_NOEXCEPT {
        return m_ClutterMapInfo_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& ClutterMapInfo() const OMG_NOEXCEPT {
        return m_ClutterMapInfo_;
    }

    void ClutterMapInfo(const ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& value) {
        m_ClutterMapInfo_ = value;
    }

    void ClutterMapInfo(::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>&& value) {
        m_ClutterMapInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& SonarImageInfo() OMG_NOEXCEPT {
        return m_SonarImageInfo_;
    }

    const ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& SonarImageInfo() const OMG_NOEXCEPT {
        return m_SonarImageInfo_;
    }

    void SonarImageInfo(const ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>& value) {
        m_SonarImageInfo_ = value;
    }

    void SonarImageInfo(::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L>&& value) {
        m_SonarImageInfo_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint32_t& ulPingCount() OMG_NOEXCEPT {
        return m_ulPingCount_;
    }

    const uint32_t& ulPingCount() const OMG_NOEXCEPT {
        return m_ulPingCount_;
    }

    void ulPingCount(uint32_t value) {
        m_ulPingCount_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& other_) const;

    void swap(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L> m_ClutterMapInfo_;
    ::dds::core::array< ::dds::core::array< int32_t, 1458L>, 240L> m_SonarImageInfo_;
    ST_DATE_TIME m_stUpdateTime_;
    uint32_t m_ulPingCount_;

};

inline void swap(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& a, IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& sample);

class NDDSUSERDllExport ST_TX_INFO {
  public:
    ST_TX_INFO();

    ST_TX_INFO(uint32_t ulStartFreq,uint32_t ulEndFreq,uint16_t usPeriodFreq,uint16_t usMinDeep,uint8_t oPulseType,uint8_t oPulseLength,uint8_t oShading,uint8_t oTransAgc,uint8_t oAttAgc1,uint8_t oAttAgc2,uint8_t oAttAgc3,uint8_t oAttAgc4,uint8_t oAttAgc5,uint8_t oAttAgc6,uint8_t oTransArea,const ::dds::core::array< uint8_t, 37L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TX_INFO (ST_TX_INFO&&) = default;
    ST_TX_INFO& operator=(ST_TX_INFO&&) = default;
    ST_TX_INFO& operator=(const ST_TX_INFO&) = default;
    ST_TX_INFO(const ST_TX_INFO&) = default;
    #else
    ST_TX_INFO(ST_TX_INFO&& other_) OMG_NOEXCEPT;  
    ST_TX_INFO& operator=(ST_TX_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulStartFreq() OMG_NOEXCEPT {
        return m_ulStartFreq_;
    }

    const uint32_t& ulStartFreq() const OMG_NOEXCEPT {
        return m_ulStartFreq_;
    }

    void ulStartFreq(uint32_t value) {
        m_ulStartFreq_ = value;
    }

    uint32_t& ulEndFreq() OMG_NOEXCEPT {
        return m_ulEndFreq_;
    }

    const uint32_t& ulEndFreq() const OMG_NOEXCEPT {
        return m_ulEndFreq_;
    }

    void ulEndFreq(uint32_t value) {
        m_ulEndFreq_ = value;
    }

    uint16_t& usPeriodFreq() OMG_NOEXCEPT {
        return m_usPeriodFreq_;
    }

    const uint16_t& usPeriodFreq() const OMG_NOEXCEPT {
        return m_usPeriodFreq_;
    }

    void usPeriodFreq(uint16_t value) {
        m_usPeriodFreq_ = value;
    }

    uint16_t& usMinDeep() OMG_NOEXCEPT {
        return m_usMinDeep_;
    }

    const uint16_t& usMinDeep() const OMG_NOEXCEPT {
        return m_usMinDeep_;
    }

    void usMinDeep(uint16_t value) {
        m_usMinDeep_ = value;
    }

    uint8_t& oPulseType() OMG_NOEXCEPT {
        return m_oPulseType_;
    }

    const uint8_t& oPulseType() const OMG_NOEXCEPT {
        return m_oPulseType_;
    }

    void oPulseType(uint8_t value) {
        m_oPulseType_ = value;
    }

    uint8_t& oPulseLength() OMG_NOEXCEPT {
        return m_oPulseLength_;
    }

    const uint8_t& oPulseLength() const OMG_NOEXCEPT {
        return m_oPulseLength_;
    }

    void oPulseLength(uint8_t value) {
        m_oPulseLength_ = value;
    }

    uint8_t& oShading() OMG_NOEXCEPT {
        return m_oShading_;
    }

    const uint8_t& oShading() const OMG_NOEXCEPT {
        return m_oShading_;
    }

    void oShading(uint8_t value) {
        m_oShading_ = value;
    }

    uint8_t& oTransAgc() OMG_NOEXCEPT {
        return m_oTransAgc_;
    }

    const uint8_t& oTransAgc() const OMG_NOEXCEPT {
        return m_oTransAgc_;
    }

    void oTransAgc(uint8_t value) {
        m_oTransAgc_ = value;
    }

    uint8_t& oAttAgc1() OMG_NOEXCEPT {
        return m_oAttAgc1_;
    }

    const uint8_t& oAttAgc1() const OMG_NOEXCEPT {
        return m_oAttAgc1_;
    }

    void oAttAgc1(uint8_t value) {
        m_oAttAgc1_ = value;
    }

    uint8_t& oAttAgc2() OMG_NOEXCEPT {
        return m_oAttAgc2_;
    }

    const uint8_t& oAttAgc2() const OMG_NOEXCEPT {
        return m_oAttAgc2_;
    }

    void oAttAgc2(uint8_t value) {
        m_oAttAgc2_ = value;
    }

    uint8_t& oAttAgc3() OMG_NOEXCEPT {
        return m_oAttAgc3_;
    }

    const uint8_t& oAttAgc3() const OMG_NOEXCEPT {
        return m_oAttAgc3_;
    }

    void oAttAgc3(uint8_t value) {
        m_oAttAgc3_ = value;
    }

    uint8_t& oAttAgc4() OMG_NOEXCEPT {
        return m_oAttAgc4_;
    }

    const uint8_t& oAttAgc4() const OMG_NOEXCEPT {
        return m_oAttAgc4_;
    }

    void oAttAgc4(uint8_t value) {
        m_oAttAgc4_ = value;
    }

    uint8_t& oAttAgc5() OMG_NOEXCEPT {
        return m_oAttAgc5_;
    }

    const uint8_t& oAttAgc5() const OMG_NOEXCEPT {
        return m_oAttAgc5_;
    }

    void oAttAgc5(uint8_t value) {
        m_oAttAgc5_ = value;
    }

    uint8_t& oAttAgc6() OMG_NOEXCEPT {
        return m_oAttAgc6_;
    }

    const uint8_t& oAttAgc6() const OMG_NOEXCEPT {
        return m_oAttAgc6_;
    }

    void oAttAgc6(uint8_t value) {
        m_oAttAgc6_ = value;
    }

    uint8_t& oTransArea() OMG_NOEXCEPT {
        return m_oTransArea_;
    }

    const uint8_t& oTransArea() const OMG_NOEXCEPT {
        return m_oTransArea_;
    }

    void oTransArea(uint8_t value) {
        m_oTransArea_ = value;
    }

    ::dds::core::array< uint8_t, 37L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 37L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 37L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 37L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const ST_TX_INFO& other_) const;
    bool operator != (const ST_TX_INFO& other_) const;

    void swap(ST_TX_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulStartFreq_;
    uint32_t m_ulEndFreq_;
    uint16_t m_usPeriodFreq_;
    uint16_t m_usMinDeep_;
    uint8_t m_oPulseType_;
    uint8_t m_oPulseLength_;
    uint8_t m_oShading_;
    uint8_t m_oTransAgc_;
    uint8_t m_oAttAgc1_;
    uint8_t m_oAttAgc2_;
    uint8_t m_oAttAgc3_;
    uint8_t m_oAttAgc4_;
    uint8_t m_oAttAgc5_;
    uint8_t m_oAttAgc6_;
    uint8_t m_oTransArea_;
    ::dds::core::array< uint8_t, 37L> m_oRes_;

};

inline void swap(ST_TX_INFO& a, ST_TX_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TX_INFO& sample);

class NDDSUSERDllExport ST_MEAS_INFO {
  public:
    ST_MEAS_INFO();

    ST_MEAS_INFO(int16_t sID,int16_t sX,int16_t sY,uint16_t usDistance,uint16_t usDegree,int16_t sEnergy,int16_t sStrength,int16_t sClusterId);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MEAS_INFO (ST_MEAS_INFO&&) = default;
    ST_MEAS_INFO& operator=(ST_MEAS_INFO&&) = default;
    ST_MEAS_INFO& operator=(const ST_MEAS_INFO&) = default;
    ST_MEAS_INFO(const ST_MEAS_INFO&) = default;
    #else
    ST_MEAS_INFO(ST_MEAS_INFO&& other_) OMG_NOEXCEPT;  
    ST_MEAS_INFO& operator=(ST_MEAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int16_t& sID() OMG_NOEXCEPT {
        return m_sID_;
    }

    const int16_t& sID() const OMG_NOEXCEPT {
        return m_sID_;
    }

    void sID(int16_t value) {
        m_sID_ = value;
    }

    int16_t& sX() OMG_NOEXCEPT {
        return m_sX_;
    }

    const int16_t& sX() const OMG_NOEXCEPT {
        return m_sX_;
    }

    void sX(int16_t value) {
        m_sX_ = value;
    }

    int16_t& sY() OMG_NOEXCEPT {
        return m_sY_;
    }

    const int16_t& sY() const OMG_NOEXCEPT {
        return m_sY_;
    }

    void sY(int16_t value) {
        m_sY_ = value;
    }

    uint16_t& usDistance() OMG_NOEXCEPT {
        return m_usDistance_;
    }

    const uint16_t& usDistance() const OMG_NOEXCEPT {
        return m_usDistance_;
    }

    void usDistance(uint16_t value) {
        m_usDistance_ = value;
    }

    uint16_t& usDegree() OMG_NOEXCEPT {
        return m_usDegree_;
    }

    const uint16_t& usDegree() const OMG_NOEXCEPT {
        return m_usDegree_;
    }

    void usDegree(uint16_t value) {
        m_usDegree_ = value;
    }

    int16_t& sEnergy() OMG_NOEXCEPT {
        return m_sEnergy_;
    }

    const int16_t& sEnergy() const OMG_NOEXCEPT {
        return m_sEnergy_;
    }

    void sEnergy(int16_t value) {
        m_sEnergy_ = value;
    }

    int16_t& sStrength() OMG_NOEXCEPT {
        return m_sStrength_;
    }

    const int16_t& sStrength() const OMG_NOEXCEPT {
        return m_sStrength_;
    }

    void sStrength(int16_t value) {
        m_sStrength_ = value;
    }

    int16_t& sClusterId() OMG_NOEXCEPT {
        return m_sClusterId_;
    }

    const int16_t& sClusterId() const OMG_NOEXCEPT {
        return m_sClusterId_;
    }

    void sClusterId(int16_t value) {
        m_sClusterId_ = value;
    }

    bool operator == (const ST_MEAS_INFO& other_) const;
    bool operator != (const ST_MEAS_INFO& other_) const;

    void swap(ST_MEAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    int16_t m_sID_;
    int16_t m_sX_;
    int16_t m_sY_;
    uint16_t m_usDistance_;
    uint16_t m_usDegree_;
    int16_t m_sEnergy_;
    int16_t m_sStrength_;
    int16_t m_sClusterId_;

};

inline void swap(ST_MEAS_INFO& a, ST_MEAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MEAS_INFO& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_DETECT_DATA {
  public:
    IFCCTR_ACTIVESONAR_DETECT_DATA();

    IFCCTR_ACTIVESONAR_DETECT_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ::dds::core::array< ST_MEAS_INFO, 3000L>& stTMeasInfo,const ST_TX_INFO& stTTxInfo,const ST_DATE_TIME& stDateTime,uint32_t ulPingCount);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_DETECT_DATA (IFCCTR_ACTIVESONAR_DETECT_DATA&&) = default;
    IFCCTR_ACTIVESONAR_DETECT_DATA& operator=(IFCCTR_ACTIVESONAR_DETECT_DATA&&) = default;
    IFCCTR_ACTIVESONAR_DETECT_DATA& operator=(const IFCCTR_ACTIVESONAR_DETECT_DATA&) = default;
    IFCCTR_ACTIVESONAR_DETECT_DATA(const IFCCTR_ACTIVESONAR_DETECT_DATA&) = default;
    #else
    IFCCTR_ACTIVESONAR_DETECT_DATA(IFCCTR_ACTIVESONAR_DETECT_DATA&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_DETECT_DATA& operator=(IFCCTR_ACTIVESONAR_DETECT_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ::dds::core::array< ST_MEAS_INFO, 3000L>& stTMeasInfo() OMG_NOEXCEPT {
        return m_stTMeasInfo_;
    }

    const ::dds::core::array< ST_MEAS_INFO, 3000L>& stTMeasInfo() const OMG_NOEXCEPT {
        return m_stTMeasInfo_;
    }

    void stTMeasInfo(const ::dds::core::array< ST_MEAS_INFO, 3000L>& value) {
        m_stTMeasInfo_ = value;
    }

    void stTMeasInfo(::dds::core::array< ST_MEAS_INFO, 3000L>&& value) {
        m_stTMeasInfo_ = std::move(value);
    }
    ST_TX_INFO& stTTxInfo() OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    const ST_TX_INFO& stTTxInfo() const OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    void stTTxInfo(const ST_TX_INFO& value) {
        m_stTTxInfo_ = value;
    }

    void stTTxInfo(ST_TX_INFO&& value) {
        m_stTTxInfo_ = std::move(value);
    }
    ST_DATE_TIME& stDateTime() OMG_NOEXCEPT {
        return m_stDateTime_;
    }

    const ST_DATE_TIME& stDateTime() const OMG_NOEXCEPT {
        return m_stDateTime_;
    }

    void stDateTime(const ST_DATE_TIME& value) {
        m_stDateTime_ = value;
    }

    void stDateTime(ST_DATE_TIME&& value) {
        m_stDateTime_ = std::move(value);
    }
    uint32_t& ulPingCount() OMG_NOEXCEPT {
        return m_ulPingCount_;
    }

    const uint32_t& ulPingCount() const OMG_NOEXCEPT {
        return m_ulPingCount_;
    }

    void ulPingCount(uint32_t value) {
        m_ulPingCount_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_DETECT_DATA& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_DETECT_DATA& other_) const;

    void swap(IFCCTR_ACTIVESONAR_DETECT_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ::dds::core::array< ST_MEAS_INFO, 3000L> m_stTMeasInfo_;
    ST_TX_INFO m_stTTxInfo_;
    ST_DATE_TIME m_stDateTime_;
    uint32_t m_ulPingCount_;

};

inline void swap(IFCCTR_ACTIVESONAR_DETECT_DATA& a, IFCCTR_ACTIVESONAR_DETECT_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_DETECT_DATA& sample);

class NDDSUSERDllExport ST_TH_INFO {
  public:
    ST_TH_INFO();

    explicit ST_TH_INFO(const ::dds::core::array< int16_t, 6L>& sDt);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TH_INFO (ST_TH_INFO&&) = default;
    ST_TH_INFO& operator=(ST_TH_INFO&&) = default;
    ST_TH_INFO& operator=(const ST_TH_INFO&) = default;
    ST_TH_INFO(const ST_TH_INFO&) = default;
    #else
    ST_TH_INFO(ST_TH_INFO&& other_) OMG_NOEXCEPT;  
    ST_TH_INFO& operator=(ST_TH_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< int16_t, 6L>& sDt() OMG_NOEXCEPT {
        return m_sDt_;
    }

    const ::dds::core::array< int16_t, 6L>& sDt() const OMG_NOEXCEPT {
        return m_sDt_;
    }

    void sDt(const ::dds::core::array< int16_t, 6L>& value) {
        m_sDt_ = value;
    }

    void sDt(::dds::core::array< int16_t, 6L>&& value) {
        m_sDt_ = std::move(value);
    }

    bool operator == (const ST_TH_INFO& other_) const;
    bool operator != (const ST_TH_INFO& other_) const;

    void swap(ST_TH_INFO& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< int16_t, 6L> m_sDt_;

};

inline void swap(ST_TH_INFO& a, ST_TH_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TH_INFO& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE();

    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ST_TH_INFO& stTThInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE (IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& operator=(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE(const IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& operator=(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ST_TH_INFO& stTThInfo() OMG_NOEXCEPT {
        return m_stTThInfo_;
    }

    const ST_TH_INFO& stTThInfo() const OMG_NOEXCEPT {
        return m_stTThInfo_;
    }

    void stTThInfo(const ST_TH_INFO& value) {
        m_stTThInfo_ = value;
    }

    void stTThInfo(ST_TH_INFO&& value) {
        m_stTThInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ST_TH_INFO m_stTThInfo_;

};

inline void swap(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& a, IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_ENE_DATA {
  public:
    IFCCTR_ACTIVESONAR_ENE_DATA();

    IFCCTR_ACTIVESONAR_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ST_TX_INFO& stTxInfo,const ::dds::core::array< float, 24L>& fENEData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_ENE_DATA (IFCCTR_ACTIVESONAR_ENE_DATA&&) = default;
    IFCCTR_ACTIVESONAR_ENE_DATA& operator=(IFCCTR_ACTIVESONAR_ENE_DATA&&) = default;
    IFCCTR_ACTIVESONAR_ENE_DATA& operator=(const IFCCTR_ACTIVESONAR_ENE_DATA&) = default;
    IFCCTR_ACTIVESONAR_ENE_DATA(const IFCCTR_ACTIVESONAR_ENE_DATA&) = default;
    #else
    IFCCTR_ACTIVESONAR_ENE_DATA(IFCCTR_ACTIVESONAR_ENE_DATA&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_ENE_DATA& operator=(IFCCTR_ACTIVESONAR_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ST_TX_INFO& stTxInfo() OMG_NOEXCEPT {
        return m_stTxInfo_;
    }

    const ST_TX_INFO& stTxInfo() const OMG_NOEXCEPT {
        return m_stTxInfo_;
    }

    void stTxInfo(const ST_TX_INFO& value) {
        m_stTxInfo_ = value;
    }

    void stTxInfo(ST_TX_INFO&& value) {
        m_stTxInfo_ = std::move(value);
    }
    ::dds::core::array< float, 24L>& fENEData() OMG_NOEXCEPT {
        return m_fENEData_;
    }

    const ::dds::core::array< float, 24L>& fENEData() const OMG_NOEXCEPT {
        return m_fENEData_;
    }

    void fENEData(const ::dds::core::array< float, 24L>& value) {
        m_fENEData_ = value;
    }

    void fENEData(::dds::core::array< float, 24L>&& value) {
        m_fENEData_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_ENE_DATA& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_ENE_DATA& other_) const;

    void swap(IFCCTR_ACTIVESONAR_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ST_TX_INFO m_stTxInfo_;
    ::dds::core::array< float, 24L> m_fENEData_;

};

inline void swap(IFCCTR_ACTIVESONAR_ENE_DATA& a, IFCCTR_ACTIVESONAR_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_ENE_DATA& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE();

    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oFishSup,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE (IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& operator=(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE(const IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& operator=(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oFishSup() OMG_NOEXCEPT {
        return m_oFishSup_;
    }

    const uint8_t& oFishSup() const OMG_NOEXCEPT {
        return m_oFishSup_;
    }

    void oFishSup(uint8_t value) {
        m_oFishSup_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oFishSup_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& a, IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE();

    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oFlowSup,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE (IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& operator=(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE(const IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& operator=(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oFlowSup() OMG_NOEXCEPT {
        return m_oFlowSup_;
    }

    const uint8_t& oFlowSup() const OMG_NOEXCEPT {
        return m_oFlowSup_;
    }

    void oFlowSup(uint8_t value) {
        m_oFlowSup_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oFlowSup_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& a, IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& sample);

class NDDSUSERDllExport ST_AS_TARGET {
  public:
    ST_AS_TARGET();

    ST_AS_TARGET(uint16_t usTargetID,uint8_t oTrackStatus,uint8_t oRelation,uint16_t usDistance,int16_t sBearing,int16_t sCourse,uint16_t usVelocity,int16_t sSignalPower,uint16_t usTrackPingcnt,uint16_t usTrackAge,uint16_t usTrackReliability,uint16_t usIdentify,uint16_t usCorrection,const ST_DATE_TIME& stTrackConfirmTime,const ST_DATE_TIME& stTrackStartTime,const ST_DATE_TIME& stTrackRefreshTime,const ::dds::core::array< float, 4L>& aStateVector,const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aPositionCovArry,uint8_t oTranning,uint8_t oTrackInitType,const ::dds::core::array< uint8_t, 2L>& oReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_TARGET (ST_AS_TARGET&&) = default;
    ST_AS_TARGET& operator=(ST_AS_TARGET&&) = default;
    ST_AS_TARGET& operator=(const ST_AS_TARGET&) = default;
    ST_AS_TARGET(const ST_AS_TARGET&) = default;
    #else
    ST_AS_TARGET(ST_AS_TARGET&& other_) OMG_NOEXCEPT;  
    ST_AS_TARGET& operator=(ST_AS_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTargetID() OMG_NOEXCEPT {
        return m_usTargetID_;
    }

    const uint16_t& usTargetID() const OMG_NOEXCEPT {
        return m_usTargetID_;
    }

    void usTargetID(uint16_t value) {
        m_usTargetID_ = value;
    }

    uint8_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint8_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint8_t value) {
        m_oTrackStatus_ = value;
    }

    uint8_t& oRelation() OMG_NOEXCEPT {
        return m_oRelation_;
    }

    const uint8_t& oRelation() const OMG_NOEXCEPT {
        return m_oRelation_;
    }

    void oRelation(uint8_t value) {
        m_oRelation_ = value;
    }

    uint16_t& usDistance() OMG_NOEXCEPT {
        return m_usDistance_;
    }

    const uint16_t& usDistance() const OMG_NOEXCEPT {
        return m_usDistance_;
    }

    void usDistance(uint16_t value) {
        m_usDistance_ = value;
    }

    int16_t& sBearing() OMG_NOEXCEPT {
        return m_sBearing_;
    }

    const int16_t& sBearing() const OMG_NOEXCEPT {
        return m_sBearing_;
    }

    void sBearing(int16_t value) {
        m_sBearing_ = value;
    }

    int16_t& sCourse() OMG_NOEXCEPT {
        return m_sCourse_;
    }

    const int16_t& sCourse() const OMG_NOEXCEPT {
        return m_sCourse_;
    }

    void sCourse(int16_t value) {
        m_sCourse_ = value;
    }

    uint16_t& usVelocity() OMG_NOEXCEPT {
        return m_usVelocity_;
    }

    const uint16_t& usVelocity() const OMG_NOEXCEPT {
        return m_usVelocity_;
    }

    void usVelocity(uint16_t value) {
        m_usVelocity_ = value;
    }

    int16_t& sSignalPower() OMG_NOEXCEPT {
        return m_sSignalPower_;
    }

    const int16_t& sSignalPower() const OMG_NOEXCEPT {
        return m_sSignalPower_;
    }

    void sSignalPower(int16_t value) {
        m_sSignalPower_ = value;
    }

    uint16_t& usTrackPingcnt() OMG_NOEXCEPT {
        return m_usTrackPingcnt_;
    }

    const uint16_t& usTrackPingcnt() const OMG_NOEXCEPT {
        return m_usTrackPingcnt_;
    }

    void usTrackPingcnt(uint16_t value) {
        m_usTrackPingcnt_ = value;
    }

    uint16_t& usTrackAge() OMG_NOEXCEPT {
        return m_usTrackAge_;
    }

    const uint16_t& usTrackAge() const OMG_NOEXCEPT {
        return m_usTrackAge_;
    }

    void usTrackAge(uint16_t value) {
        m_usTrackAge_ = value;
    }

    uint16_t& usTrackReliability() OMG_NOEXCEPT {
        return m_usTrackReliability_;
    }

    const uint16_t& usTrackReliability() const OMG_NOEXCEPT {
        return m_usTrackReliability_;
    }

    void usTrackReliability(uint16_t value) {
        m_usTrackReliability_ = value;
    }

    uint16_t& usIdentify() OMG_NOEXCEPT {
        return m_usIdentify_;
    }

    const uint16_t& usIdentify() const OMG_NOEXCEPT {
        return m_usIdentify_;
    }

    void usIdentify(uint16_t value) {
        m_usIdentify_ = value;
    }

    uint16_t& usCorrection() OMG_NOEXCEPT {
        return m_usCorrection_;
    }

    const uint16_t& usCorrection() const OMG_NOEXCEPT {
        return m_usCorrection_;
    }

    void usCorrection(uint16_t value) {
        m_usCorrection_ = value;
    }

    ST_DATE_TIME& stTrackConfirmTime() OMG_NOEXCEPT {
        return m_stTrackConfirmTime_;
    }

    const ST_DATE_TIME& stTrackConfirmTime() const OMG_NOEXCEPT {
        return m_stTrackConfirmTime_;
    }

    void stTrackConfirmTime(const ST_DATE_TIME& value) {
        m_stTrackConfirmTime_ = value;
    }

    void stTrackConfirmTime(ST_DATE_TIME&& value) {
        m_stTrackConfirmTime_ = std::move(value);
    }
    ST_DATE_TIME& stTrackStartTime() OMG_NOEXCEPT {
        return m_stTrackStartTime_;
    }

    const ST_DATE_TIME& stTrackStartTime() const OMG_NOEXCEPT {
        return m_stTrackStartTime_;
    }

    void stTrackStartTime(const ST_DATE_TIME& value) {
        m_stTrackStartTime_ = value;
    }

    void stTrackStartTime(ST_DATE_TIME&& value) {
        m_stTrackStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stTrackRefreshTime() OMG_NOEXCEPT {
        return m_stTrackRefreshTime_;
    }

    const ST_DATE_TIME& stTrackRefreshTime() const OMG_NOEXCEPT {
        return m_stTrackRefreshTime_;
    }

    void stTrackRefreshTime(const ST_DATE_TIME& value) {
        m_stTrackRefreshTime_ = value;
    }

    void stTrackRefreshTime(ST_DATE_TIME&& value) {
        m_stTrackRefreshTime_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& aStateVector() OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    const ::dds::core::array< float, 4L>& aStateVector() const OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    void aStateVector(const ::dds::core::array< float, 4L>& value) {
        m_aStateVector_ = value;
    }

    void aStateVector(::dds::core::array< float, 4L>&& value) {
        m_aStateVector_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aPositionCovArry() OMG_NOEXCEPT {
        return m_aPositionCovArry_;
    }

    const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aPositionCovArry() const OMG_NOEXCEPT {
        return m_aPositionCovArry_;
    }

    void aPositionCovArry(const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& value) {
        m_aPositionCovArry_ = value;
    }

    void aPositionCovArry(::dds::core::array< ::dds::core::array< float, 4L>, 4L>&& value) {
        m_aPositionCovArry_ = std::move(value);
    }
    uint8_t& oTranning() OMG_NOEXCEPT {
        return m_oTranning_;
    }

    const uint8_t& oTranning() const OMG_NOEXCEPT {
        return m_oTranning_;
    }

    void oTranning(uint8_t value) {
        m_oTranning_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oReserved() OMG_NOEXCEPT {
        return m_oReserved_;
    }

    const ::dds::core::array< uint8_t, 2L>& oReserved() const OMG_NOEXCEPT {
        return m_oReserved_;
    }

    void oReserved(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oReserved_ = value;
    }

    void oReserved(::dds::core::array< uint8_t, 2L>&& value) {
        m_oReserved_ = std::move(value);
    }

    bool operator == (const ST_AS_TARGET& other_) const;
    bool operator != (const ST_AS_TARGET& other_) const;

    void swap(ST_AS_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTargetID_;
    uint8_t m_oTrackStatus_;
    uint8_t m_oRelation_;
    uint16_t m_usDistance_;
    int16_t m_sBearing_;
    int16_t m_sCourse_;
    uint16_t m_usVelocity_;
    int16_t m_sSignalPower_;
    uint16_t m_usTrackPingcnt_;
    uint16_t m_usTrackAge_;
    uint16_t m_usTrackReliability_;
    uint16_t m_usIdentify_;
    uint16_t m_usCorrection_;
    ST_DATE_TIME m_stTrackConfirmTime_;
    ST_DATE_TIME m_stTrackStartTime_;
    ST_DATE_TIME m_stTrackRefreshTime_;
    ::dds::core::array< float, 4L> m_aStateVector_;
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L> m_aPositionCovArry_;
    uint8_t m_oTranning_;
    uint8_t m_oTrackInitType_;
    ::dds::core::array< uint8_t, 2L> m_oReserved_;

};

inline void swap(ST_AS_TARGET& a, ST_AS_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_TARGET& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO {
  public:
    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO();

    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,uint32_t ulCitCount,uint32_t ulOitCount,const ::dds::core::array< ST_AS_TARGET, 2000L>& stAsTarget,const ST_TX_INFO& stTTxInfo,uint32_t ulPingCount);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO (IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO&&) = default;
    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& operator=(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO&&) = default;
    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& operator=(const IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO&) = default;
    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO(const IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO&) = default;
    #else
    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& operator=(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    uint32_t& ulCitCount() OMG_NOEXCEPT {
        return m_ulCitCount_;
    }

    const uint32_t& ulCitCount() const OMG_NOEXCEPT {
        return m_ulCitCount_;
    }

    void ulCitCount(uint32_t value) {
        m_ulCitCount_ = value;
    }

    uint32_t& ulOitCount() OMG_NOEXCEPT {
        return m_ulOitCount_;
    }

    const uint32_t& ulOitCount() const OMG_NOEXCEPT {
        return m_ulOitCount_;
    }

    void ulOitCount(uint32_t value) {
        m_ulOitCount_ = value;
    }

    ::dds::core::array< ST_AS_TARGET, 2000L>& stAsTarget() OMG_NOEXCEPT {
        return m_stAsTarget_;
    }

    const ::dds::core::array< ST_AS_TARGET, 2000L>& stAsTarget() const OMG_NOEXCEPT {
        return m_stAsTarget_;
    }

    void stAsTarget(const ::dds::core::array< ST_AS_TARGET, 2000L>& value) {
        m_stAsTarget_ = value;
    }

    void stAsTarget(::dds::core::array< ST_AS_TARGET, 2000L>&& value) {
        m_stAsTarget_ = std::move(value);
    }
    ST_TX_INFO& stTTxInfo() OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    const ST_TX_INFO& stTTxInfo() const OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    void stTTxInfo(const ST_TX_INFO& value) {
        m_stTTxInfo_ = value;
    }

    void stTTxInfo(ST_TX_INFO&& value) {
        m_stTTxInfo_ = std::move(value);
    }
    uint32_t& ulPingCount() OMG_NOEXCEPT {
        return m_ulPingCount_;
    }

    const uint32_t& ulPingCount() const OMG_NOEXCEPT {
        return m_ulPingCount_;
    }

    void ulPingCount(uint32_t value) {
        m_ulPingCount_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& other_) const;

    void swap(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    uint32_t m_ulCitCount_;
    uint32_t m_ulOitCount_;
    ::dds::core::array< ST_AS_TARGET, 2000L> m_stAsTarget_;
    ST_TX_INFO m_stTTxInfo_;
    uint32_t m_ulPingCount_;

};

inline void swap(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& a, IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE();

    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE (IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE(const IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lResult_;

};

inline void swap(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& a, IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE();

    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,uint32_t ulMaxRange);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE (IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE(const IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    uint32_t& ulMaxRange() OMG_NOEXCEPT {
        return m_ulMaxRange_;
    }

    const uint32_t& ulMaxRange() const OMG_NOEXCEPT {
        return m_ulMaxRange_;
    }

    void ulMaxRange(uint32_t value) {
        m_ulMaxRange_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    uint32_t m_ulMaxRange_;

};

inline void swap(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& a, IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE();

    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oSpeed,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE (IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE(const IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oSpeed() OMG_NOEXCEPT {
        return m_oSpeed_;
    }

    const uint8_t& oSpeed() const OMG_NOEXCEPT {
        return m_oSpeed_;
    }

    void oSpeed(uint8_t value) {
        m_oSpeed_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oSpeed_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& a, IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_MODE_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_MODE_RESPONSE();

    IFCCTR_ACTIVESONAR_MODE_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oMode,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_MODE_RESPONSE (IFCCTR_ACTIVESONAR_MODE_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MODE_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MODE_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_MODE_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_MODE_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_MODE_RESPONSE(const IFCCTR_ACTIVESONAR_MODE_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_MODE_RESPONSE(IFCCTR_ACTIVESONAR_MODE_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_MODE_RESPONSE& operator=(IFCCTR_ACTIVESONAR_MODE_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oMode() OMG_NOEXCEPT {
        return m_oMode_;
    }

    const uint8_t& oMode() const OMG_NOEXCEPT {
        return m_oMode_;
    }

    void oMode(uint8_t value) {
        m_oMode_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_MODE_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_MODE_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_MODE_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oMode_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_MODE_RESPONSE& a, IFCCTR_ACTIVESONAR_MODE_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_MODE_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE();

    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE (IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& operator=(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE(const IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& operator=(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lResult_;

};

inline void swap(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& a, IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_REV_DATA {
  public:
    IFCCTR_ACTIVESONAR_REV_DATA();

    IFCCTR_ACTIVESONAR_REV_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ST_TX_INFO& stTxInfo,uint32_t ulDataCountNum,const ::dds::core::array< ::dds::core::array< float, 24L>, 32L>& fREVData);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_REV_DATA (IFCCTR_ACTIVESONAR_REV_DATA&&) = default;
    IFCCTR_ACTIVESONAR_REV_DATA& operator=(IFCCTR_ACTIVESONAR_REV_DATA&&) = default;
    IFCCTR_ACTIVESONAR_REV_DATA& operator=(const IFCCTR_ACTIVESONAR_REV_DATA&) = default;
    IFCCTR_ACTIVESONAR_REV_DATA(const IFCCTR_ACTIVESONAR_REV_DATA&) = default;
    #else
    IFCCTR_ACTIVESONAR_REV_DATA(IFCCTR_ACTIVESONAR_REV_DATA&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_REV_DATA& operator=(IFCCTR_ACTIVESONAR_REV_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ST_TX_INFO& stTxInfo() OMG_NOEXCEPT {
        return m_stTxInfo_;
    }

    const ST_TX_INFO& stTxInfo() const OMG_NOEXCEPT {
        return m_stTxInfo_;
    }

    void stTxInfo(const ST_TX_INFO& value) {
        m_stTxInfo_ = value;
    }

    void stTxInfo(ST_TX_INFO&& value) {
        m_stTxInfo_ = std::move(value);
    }
    uint32_t& ulDataCountNum() OMG_NOEXCEPT {
        return m_ulDataCountNum_;
    }

    const uint32_t& ulDataCountNum() const OMG_NOEXCEPT {
        return m_ulDataCountNum_;
    }

    void ulDataCountNum(uint32_t value) {
        m_ulDataCountNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 24L>, 32L>& fREVData() OMG_NOEXCEPT {
        return m_fREVData_;
    }

    const ::dds::core::array< ::dds::core::array< float, 24L>, 32L>& fREVData() const OMG_NOEXCEPT {
        return m_fREVData_;
    }

    void fREVData(const ::dds::core::array< ::dds::core::array< float, 24L>, 32L>& value) {
        m_fREVData_ = value;
    }

    void fREVData(::dds::core::array< ::dds::core::array< float, 24L>, 32L>&& value) {
        m_fREVData_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_REV_DATA& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_REV_DATA& other_) const;

    void swap(IFCCTR_ACTIVESONAR_REV_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ST_TX_INFO m_stTxInfo_;
    uint32_t m_ulDataCountNum_;
    ::dds::core::array< ::dds::core::array< float, 24L>, 32L> m_fREVData_;

};

inline void swap(IFCCTR_ACTIVESONAR_REV_DATA& a, IFCCTR_ACTIVESONAR_REV_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_REV_DATA& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE();

    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE (IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& operator=(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE(const IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& operator=(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lResult_;

};

inline void swap(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& a, IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE();

    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE (IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& operator=(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE(const IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& operator=(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lResult_;

};

inline void swap(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& a, IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& sample);

class NDDSUSERDllExport ST_TM_STATUS_T {
  public:
    ST_TM_STATUS_T();

    ST_TM_STATUS_T(uint8_t oStatus,uint8_t oValue);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TM_STATUS_T (ST_TM_STATUS_T&&) = default;
    ST_TM_STATUS_T& operator=(ST_TM_STATUS_T&&) = default;
    ST_TM_STATUS_T& operator=(const ST_TM_STATUS_T&) = default;
    ST_TM_STATUS_T(const ST_TM_STATUS_T&) = default;
    #else
    ST_TM_STATUS_T(ST_TM_STATUS_T&& other_) OMG_NOEXCEPT;  
    ST_TM_STATUS_T& operator=(ST_TM_STATUS_T&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    uint8_t& oValue() OMG_NOEXCEPT {
        return m_oValue_;
    }

    const uint8_t& oValue() const OMG_NOEXCEPT {
        return m_oValue_;
    }

    void oValue(uint8_t value) {
        m_oValue_ = value;
    }

    bool operator == (const ST_TM_STATUS_T& other_) const;
    bool operator != (const ST_TM_STATUS_T& other_) const;

    void swap(ST_TM_STATUS_T& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oStatus_;
    uint8_t m_oValue_;

};

inline void swap(ST_TM_STATUS_T& a, ST_TM_STATUS_T& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TM_STATUS_T& sample);

class NDDSUSERDllExport ST_PS_STATUS_T {
  public:
    ST_PS_STATUS_T();

    ST_PS_STATUS_T(uint8_t oStatus,uint8_t oValue);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_PS_STATUS_T (ST_PS_STATUS_T&&) = default;
    ST_PS_STATUS_T& operator=(ST_PS_STATUS_T&&) = default;
    ST_PS_STATUS_T& operator=(const ST_PS_STATUS_T&) = default;
    ST_PS_STATUS_T(const ST_PS_STATUS_T&) = default;
    #else
    ST_PS_STATUS_T(ST_PS_STATUS_T&& other_) OMG_NOEXCEPT;  
    ST_PS_STATUS_T& operator=(ST_PS_STATUS_T&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    uint8_t& oValue() OMG_NOEXCEPT {
        return m_oValue_;
    }

    const uint8_t& oValue() const OMG_NOEXCEPT {
        return m_oValue_;
    }

    void oValue(uint8_t value) {
        m_oValue_ = value;
    }

    bool operator == (const ST_PS_STATUS_T& other_) const;
    bool operator != (const ST_PS_STATUS_T& other_) const;

    void swap(ST_PS_STATUS_T& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oStatus_;
    uint8_t m_oValue_;

};

inline void swap(ST_PS_STATUS_T& a, ST_PS_STATUS_T& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_PS_STATUS_T& sample);

class NDDSUSERDllExport ST_PS_STATUS_F {
  public:
    ST_PS_STATUS_F();

    ST_PS_STATUS_F(uint16_t usPowerStatus,int16_t sPowerValue,uint16_t usCurrentStatus,int16_t sCurrentValue);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_PS_STATUS_F (ST_PS_STATUS_F&&) = default;
    ST_PS_STATUS_F& operator=(ST_PS_STATUS_F&&) = default;
    ST_PS_STATUS_F& operator=(const ST_PS_STATUS_F&) = default;
    ST_PS_STATUS_F(const ST_PS_STATUS_F&) = default;
    #else
    ST_PS_STATUS_F(ST_PS_STATUS_F&& other_) OMG_NOEXCEPT;  
    ST_PS_STATUS_F& operator=(ST_PS_STATUS_F&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usPowerStatus() OMG_NOEXCEPT {
        return m_usPowerStatus_;
    }

    const uint16_t& usPowerStatus() const OMG_NOEXCEPT {
        return m_usPowerStatus_;
    }

    void usPowerStatus(uint16_t value) {
        m_usPowerStatus_ = value;
    }

    int16_t& sPowerValue() OMG_NOEXCEPT {
        return m_sPowerValue_;
    }

    const int16_t& sPowerValue() const OMG_NOEXCEPT {
        return m_sPowerValue_;
    }

    void sPowerValue(int16_t value) {
        m_sPowerValue_ = value;
    }

    uint16_t& usCurrentStatus() OMG_NOEXCEPT {
        return m_usCurrentStatus_;
    }

    const uint16_t& usCurrentStatus() const OMG_NOEXCEPT {
        return m_usCurrentStatus_;
    }

    void usCurrentStatus(uint16_t value) {
        m_usCurrentStatus_ = value;
    }

    int16_t& sCurrentValue() OMG_NOEXCEPT {
        return m_sCurrentValue_;
    }

    const int16_t& sCurrentValue() const OMG_NOEXCEPT {
        return m_sCurrentValue_;
    }

    void sCurrentValue(int16_t value) {
        m_sCurrentValue_ = value;
    }

    bool operator == (const ST_PS_STATUS_F& other_) const;
    bool operator != (const ST_PS_STATUS_F& other_) const;

    void swap(ST_PS_STATUS_F& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usPowerStatus_;
    int16_t m_sPowerValue_;
    uint16_t m_usCurrentStatus_;
    int16_t m_sCurrentValue_;

};

inline void swap(ST_PS_STATUS_F& a, ST_PS_STATUS_F& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_PS_STATUS_F& sample);

class NDDSUSERDllExport ST_AS_NIC_CONF {
  public:
    ST_AS_NIC_CONF();

    ST_AS_NIC_CONF(uint8_t oIPAClass,uint8_t oIPBClass,uint8_t oIPCClass,uint8_t oIPDClass,uint16_t usPortNumControl,uint16_t usPortNumSensor);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_NIC_CONF (ST_AS_NIC_CONF&&) = default;
    ST_AS_NIC_CONF& operator=(ST_AS_NIC_CONF&&) = default;
    ST_AS_NIC_CONF& operator=(const ST_AS_NIC_CONF&) = default;
    ST_AS_NIC_CONF(const ST_AS_NIC_CONF&) = default;
    #else
    ST_AS_NIC_CONF(ST_AS_NIC_CONF&& other_) OMG_NOEXCEPT;  
    ST_AS_NIC_CONF& operator=(ST_AS_NIC_CONF&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oIPAClass() OMG_NOEXCEPT {
        return m_oIPAClass_;
    }

    const uint8_t& oIPAClass() const OMG_NOEXCEPT {
        return m_oIPAClass_;
    }

    void oIPAClass(uint8_t value) {
        m_oIPAClass_ = value;
    }

    uint8_t& oIPBClass() OMG_NOEXCEPT {
        return m_oIPBClass_;
    }

    const uint8_t& oIPBClass() const OMG_NOEXCEPT {
        return m_oIPBClass_;
    }

    void oIPBClass(uint8_t value) {
        m_oIPBClass_ = value;
    }

    uint8_t& oIPCClass() OMG_NOEXCEPT {
        return m_oIPCClass_;
    }

    const uint8_t& oIPCClass() const OMG_NOEXCEPT {
        return m_oIPCClass_;
    }

    void oIPCClass(uint8_t value) {
        m_oIPCClass_ = value;
    }

    uint8_t& oIPDClass() OMG_NOEXCEPT {
        return m_oIPDClass_;
    }

    const uint8_t& oIPDClass() const OMG_NOEXCEPT {
        return m_oIPDClass_;
    }

    void oIPDClass(uint8_t value) {
        m_oIPDClass_ = value;
    }

    uint16_t& usPortNumControl() OMG_NOEXCEPT {
        return m_usPortNumControl_;
    }

    const uint16_t& usPortNumControl() const OMG_NOEXCEPT {
        return m_usPortNumControl_;
    }

    void usPortNumControl(uint16_t value) {
        m_usPortNumControl_ = value;
    }

    uint16_t& usPortNumSensor() OMG_NOEXCEPT {
        return m_usPortNumSensor_;
    }

    const uint16_t& usPortNumSensor() const OMG_NOEXCEPT {
        return m_usPortNumSensor_;
    }

    void usPortNumSensor(uint16_t value) {
        m_usPortNumSensor_ = value;
    }

    bool operator == (const ST_AS_NIC_CONF& other_) const;
    bool operator != (const ST_AS_NIC_CONF& other_) const;

    void swap(ST_AS_NIC_CONF& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oIPAClass_;
    uint8_t m_oIPBClass_;
    uint8_t m_oIPCClass_;
    uint8_t m_oIPDClass_;
    uint16_t m_usPortNumControl_;
    uint16_t m_usPortNumSensor_;

};

inline void swap(ST_AS_NIC_CONF& a, ST_AS_NIC_CONF& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_NIC_CONF& sample);

class NDDSUSERDllExport ST_AS_TILT_SENSOR {
  public:
    ST_AS_TILT_SENSOR();

    ST_AS_TILT_SENSOR(int16_t usRoll,int16_t usPitch,int16_t usYaw,int16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_TILT_SENSOR (ST_AS_TILT_SENSOR&&) = default;
    ST_AS_TILT_SENSOR& operator=(ST_AS_TILT_SENSOR&&) = default;
    ST_AS_TILT_SENSOR& operator=(const ST_AS_TILT_SENSOR&) = default;
    ST_AS_TILT_SENSOR(const ST_AS_TILT_SENSOR&) = default;
    #else
    ST_AS_TILT_SENSOR(ST_AS_TILT_SENSOR&& other_) OMG_NOEXCEPT;  
    ST_AS_TILT_SENSOR& operator=(ST_AS_TILT_SENSOR&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int16_t& usRoll() OMG_NOEXCEPT {
        return m_usRoll_;
    }

    const int16_t& usRoll() const OMG_NOEXCEPT {
        return m_usRoll_;
    }

    void usRoll(int16_t value) {
        m_usRoll_ = value;
    }

    int16_t& usPitch() OMG_NOEXCEPT {
        return m_usPitch_;
    }

    const int16_t& usPitch() const OMG_NOEXCEPT {
        return m_usPitch_;
    }

    void usPitch(int16_t value) {
        m_usPitch_ = value;
    }

    int16_t& usYaw() OMG_NOEXCEPT {
        return m_usYaw_;
    }

    const int16_t& usYaw() const OMG_NOEXCEPT {
        return m_usYaw_;
    }

    void usYaw(int16_t value) {
        m_usYaw_ = value;
    }

    int16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const int16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(int16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const ST_AS_TILT_SENSOR& other_) const;
    bool operator != (const ST_AS_TILT_SENSOR& other_) const;

    void swap(ST_AS_TILT_SENSOR& other_) OMG_NOEXCEPT ;

  private:

    int16_t m_usRoll_;
    int16_t m_usPitch_;
    int16_t m_usYaw_;
    int16_t m_usReserved_;

};

inline void swap(ST_AS_TILT_SENSOR& a, ST_AS_TILT_SENSOR& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_TILT_SENSOR& sample);

class NDDSUSERDllExport ST_AS_AUX_SENSOR {
  public:
    ST_AS_AUX_SENSOR();

    ST_AS_AUX_SENSOR(const ST_AS_TILT_SENSOR& stTiltSensor,uint32_t ulPressureSensor,uint32_t ulTempSensor,uint32_t ulReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_AUX_SENSOR (ST_AS_AUX_SENSOR&&) = default;
    ST_AS_AUX_SENSOR& operator=(ST_AS_AUX_SENSOR&&) = default;
    ST_AS_AUX_SENSOR& operator=(const ST_AS_AUX_SENSOR&) = default;
    ST_AS_AUX_SENSOR(const ST_AS_AUX_SENSOR&) = default;
    #else
    ST_AS_AUX_SENSOR(ST_AS_AUX_SENSOR&& other_) OMG_NOEXCEPT;  
    ST_AS_AUX_SENSOR& operator=(ST_AS_AUX_SENSOR&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_AS_TILT_SENSOR& stTiltSensor() OMG_NOEXCEPT {
        return m_stTiltSensor_;
    }

    const ST_AS_TILT_SENSOR& stTiltSensor() const OMG_NOEXCEPT {
        return m_stTiltSensor_;
    }

    void stTiltSensor(const ST_AS_TILT_SENSOR& value) {
        m_stTiltSensor_ = value;
    }

    void stTiltSensor(ST_AS_TILT_SENSOR&& value) {
        m_stTiltSensor_ = std::move(value);
    }
    uint32_t& ulPressureSensor() OMG_NOEXCEPT {
        return m_ulPressureSensor_;
    }

    const uint32_t& ulPressureSensor() const OMG_NOEXCEPT {
        return m_ulPressureSensor_;
    }

    void ulPressureSensor(uint32_t value) {
        m_ulPressureSensor_ = value;
    }

    uint32_t& ulTempSensor() OMG_NOEXCEPT {
        return m_ulTempSensor_;
    }

    const uint32_t& ulTempSensor() const OMG_NOEXCEPT {
        return m_ulTempSensor_;
    }

    void ulTempSensor(uint32_t value) {
        m_ulTempSensor_ = value;
    }

    uint32_t& ulReserved() OMG_NOEXCEPT {
        return m_ulReserved_;
    }

    const uint32_t& ulReserved() const OMG_NOEXCEPT {
        return m_ulReserved_;
    }

    void ulReserved(uint32_t value) {
        m_ulReserved_ = value;
    }

    bool operator == (const ST_AS_AUX_SENSOR& other_) const;
    bool operator != (const ST_AS_AUX_SENSOR& other_) const;

    void swap(ST_AS_AUX_SENSOR& other_) OMG_NOEXCEPT ;

  private:

    ST_AS_TILT_SENSOR m_stTiltSensor_;
    uint32_t m_ulPressureSensor_;
    uint32_t m_ulTempSensor_;
    uint32_t m_ulReserved_;

};

inline void swap(ST_AS_AUX_SENSOR& a, ST_AS_AUX_SENSOR& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_AUX_SENSOR& sample);

class NDDSUSERDllExport ST_AS_PSU_STATUS {
  public:
    ST_AS_PSU_STATUS();

    ST_AS_PSU_STATUS(uint16_t usPowerStatus,uint16_t usPSUStatus,uint16_t usElectricity,uint16_t usCurrent,uint16_t usVoltage,const ::dds::core::array< uint16_t, 3L>& usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_PSU_STATUS (ST_AS_PSU_STATUS&&) = default;
    ST_AS_PSU_STATUS& operator=(ST_AS_PSU_STATUS&&) = default;
    ST_AS_PSU_STATUS& operator=(const ST_AS_PSU_STATUS&) = default;
    ST_AS_PSU_STATUS(const ST_AS_PSU_STATUS&) = default;
    #else
    ST_AS_PSU_STATUS(ST_AS_PSU_STATUS&& other_) OMG_NOEXCEPT;  
    ST_AS_PSU_STATUS& operator=(ST_AS_PSU_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usPowerStatus() OMG_NOEXCEPT {
        return m_usPowerStatus_;
    }

    const uint16_t& usPowerStatus() const OMG_NOEXCEPT {
        return m_usPowerStatus_;
    }

    void usPowerStatus(uint16_t value) {
        m_usPowerStatus_ = value;
    }

    uint16_t& usPSUStatus() OMG_NOEXCEPT {
        return m_usPSUStatus_;
    }

    const uint16_t& usPSUStatus() const OMG_NOEXCEPT {
        return m_usPSUStatus_;
    }

    void usPSUStatus(uint16_t value) {
        m_usPSUStatus_ = value;
    }

    uint16_t& usElectricity() OMG_NOEXCEPT {
        return m_usElectricity_;
    }

    const uint16_t& usElectricity() const OMG_NOEXCEPT {
        return m_usElectricity_;
    }

    void usElectricity(uint16_t value) {
        m_usElectricity_ = value;
    }

    uint16_t& usCurrent() OMG_NOEXCEPT {
        return m_usCurrent_;
    }

    const uint16_t& usCurrent() const OMG_NOEXCEPT {
        return m_usCurrent_;
    }

    void usCurrent(uint16_t value) {
        m_usCurrent_ = value;
    }

    uint16_t& usVoltage() OMG_NOEXCEPT {
        return m_usVoltage_;
    }

    const uint16_t& usVoltage() const OMG_NOEXCEPT {
        return m_usVoltage_;
    }

    void usVoltage(uint16_t value) {
        m_usVoltage_ = value;
    }

    ::dds::core::array< uint16_t, 3L>& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const ::dds::core::array< uint16_t, 3L>& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(const ::dds::core::array< uint16_t, 3L>& value) {
        m_usReserved_ = value;
    }

    void usReserved(::dds::core::array< uint16_t, 3L>&& value) {
        m_usReserved_ = std::move(value);
    }

    bool operator == (const ST_AS_PSU_STATUS& other_) const;
    bool operator != (const ST_AS_PSU_STATUS& other_) const;

    void swap(ST_AS_PSU_STATUS& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usPowerStatus_;
    uint16_t m_usPSUStatus_;
    uint16_t m_usElectricity_;
    uint16_t m_usCurrent_;
    uint16_t m_usVoltage_;
    ::dds::core::array< uint16_t, 3L> m_usReserved_;

};

inline void swap(ST_AS_PSU_STATUS& a, ST_AS_PSU_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_PSU_STATUS& sample);

class NDDSUSERDllExport ST_ASE_STATUS_INFO {
  public:
    ST_ASE_STATUS_INFO();

    ST_ASE_STATUS_INFO(uint32_t ulASID,const ::dds::core::array< uint8_t, 6L>& oReceiveAmpBoardStatus,const ::dds::core::array< uint8_t, 6L>& oTransmitAmpBoardStatus,const ST_TM_STATUS_T& stFpgaTmStatusT,const ::dds::core::array< ST_PS_STATUS_T, 2L>& oPowerStatus10,const ST_TM_STATUS_T& stTmTmStatusT,const ::dds::core::array< ST_PS_STATUS_T, 6L>& stTmStatus,const ::dds::core::array< ST_PS_STATUS_F, 5L>& stPsStatus,const ::dds::core::array< ST_TM_STATUS_T, 8L>& stTmStatusT,const ST_AS_NIC_CONF& stNICConf,const ST_AS_AUX_SENSOR& stAuxSensor,const ST_AS_PSU_STATUS& stPsuStatus,uint8_t oSenIFCStatus,uint8_t oPSUIFCStatus,uint8_t oAGCOffSet,uint8_t oTVG,char cTxSteering,const ::dds::core::array< uint8_t, 11L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_ASE_STATUS_INFO (ST_ASE_STATUS_INFO&&) = default;
    ST_ASE_STATUS_INFO& operator=(ST_ASE_STATUS_INFO&&) = default;
    ST_ASE_STATUS_INFO& operator=(const ST_ASE_STATUS_INFO&) = default;
    ST_ASE_STATUS_INFO(const ST_ASE_STATUS_INFO&) = default;
    #else
    ST_ASE_STATUS_INFO(ST_ASE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_ASE_STATUS_INFO& operator=(ST_ASE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ::dds::core::array< uint8_t, 6L>& oReceiveAmpBoardStatus() OMG_NOEXCEPT {
        return m_oReceiveAmpBoardStatus_;
    }

    const ::dds::core::array< uint8_t, 6L>& oReceiveAmpBoardStatus() const OMG_NOEXCEPT {
        return m_oReceiveAmpBoardStatus_;
    }

    void oReceiveAmpBoardStatus(const ::dds::core::array< uint8_t, 6L>& value) {
        m_oReceiveAmpBoardStatus_ = value;
    }

    void oReceiveAmpBoardStatus(::dds::core::array< uint8_t, 6L>&& value) {
        m_oReceiveAmpBoardStatus_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 6L>& oTransmitAmpBoardStatus() OMG_NOEXCEPT {
        return m_oTransmitAmpBoardStatus_;
    }

    const ::dds::core::array< uint8_t, 6L>& oTransmitAmpBoardStatus() const OMG_NOEXCEPT {
        return m_oTransmitAmpBoardStatus_;
    }

    void oTransmitAmpBoardStatus(const ::dds::core::array< uint8_t, 6L>& value) {
        m_oTransmitAmpBoardStatus_ = value;
    }

    void oTransmitAmpBoardStatus(::dds::core::array< uint8_t, 6L>&& value) {
        m_oTransmitAmpBoardStatus_ = std::move(value);
    }
    ST_TM_STATUS_T& stFpgaTmStatusT() OMG_NOEXCEPT {
        return m_stFpgaTmStatusT_;
    }

    const ST_TM_STATUS_T& stFpgaTmStatusT() const OMG_NOEXCEPT {
        return m_stFpgaTmStatusT_;
    }

    void stFpgaTmStatusT(const ST_TM_STATUS_T& value) {
        m_stFpgaTmStatusT_ = value;
    }

    void stFpgaTmStatusT(ST_TM_STATUS_T&& value) {
        m_stFpgaTmStatusT_ = std::move(value);
    }
    ::dds::core::array< ST_PS_STATUS_T, 2L>& oPowerStatus10() OMG_NOEXCEPT {
        return m_oPowerStatus10_;
    }

    const ::dds::core::array< ST_PS_STATUS_T, 2L>& oPowerStatus10() const OMG_NOEXCEPT {
        return m_oPowerStatus10_;
    }

    void oPowerStatus10(const ::dds::core::array< ST_PS_STATUS_T, 2L>& value) {
        m_oPowerStatus10_ = value;
    }

    void oPowerStatus10(::dds::core::array< ST_PS_STATUS_T, 2L>&& value) {
        m_oPowerStatus10_ = std::move(value);
    }
    ST_TM_STATUS_T& stTmTmStatusT() OMG_NOEXCEPT {
        return m_stTmTmStatusT_;
    }

    const ST_TM_STATUS_T& stTmTmStatusT() const OMG_NOEXCEPT {
        return m_stTmTmStatusT_;
    }

    void stTmTmStatusT(const ST_TM_STATUS_T& value) {
        m_stTmTmStatusT_ = value;
    }

    void stTmTmStatusT(ST_TM_STATUS_T&& value) {
        m_stTmTmStatusT_ = std::move(value);
    }
    ::dds::core::array< ST_PS_STATUS_T, 6L>& stTmStatus() OMG_NOEXCEPT {
        return m_stTmStatus_;
    }

    const ::dds::core::array< ST_PS_STATUS_T, 6L>& stTmStatus() const OMG_NOEXCEPT {
        return m_stTmStatus_;
    }

    void stTmStatus(const ::dds::core::array< ST_PS_STATUS_T, 6L>& value) {
        m_stTmStatus_ = value;
    }

    void stTmStatus(::dds::core::array< ST_PS_STATUS_T, 6L>&& value) {
        m_stTmStatus_ = std::move(value);
    }
    ::dds::core::array< ST_PS_STATUS_F, 5L>& stPsStatus() OMG_NOEXCEPT {
        return m_stPsStatus_;
    }

    const ::dds::core::array< ST_PS_STATUS_F, 5L>& stPsStatus() const OMG_NOEXCEPT {
        return m_stPsStatus_;
    }

    void stPsStatus(const ::dds::core::array< ST_PS_STATUS_F, 5L>& value) {
        m_stPsStatus_ = value;
    }

    void stPsStatus(::dds::core::array< ST_PS_STATUS_F, 5L>&& value) {
        m_stPsStatus_ = std::move(value);
    }
    ::dds::core::array< ST_TM_STATUS_T, 8L>& stTmStatusT() OMG_NOEXCEPT {
        return m_stTmStatusT_;
    }

    const ::dds::core::array< ST_TM_STATUS_T, 8L>& stTmStatusT() const OMG_NOEXCEPT {
        return m_stTmStatusT_;
    }

    void stTmStatusT(const ::dds::core::array< ST_TM_STATUS_T, 8L>& value) {
        m_stTmStatusT_ = value;
    }

    void stTmStatusT(::dds::core::array< ST_TM_STATUS_T, 8L>&& value) {
        m_stTmStatusT_ = std::move(value);
    }
    ST_AS_NIC_CONF& stNICConf() OMG_NOEXCEPT {
        return m_stNICConf_;
    }

    const ST_AS_NIC_CONF& stNICConf() const OMG_NOEXCEPT {
        return m_stNICConf_;
    }

    void stNICConf(const ST_AS_NIC_CONF& value) {
        m_stNICConf_ = value;
    }

    void stNICConf(ST_AS_NIC_CONF&& value) {
        m_stNICConf_ = std::move(value);
    }
    ST_AS_AUX_SENSOR& stAuxSensor() OMG_NOEXCEPT {
        return m_stAuxSensor_;
    }

    const ST_AS_AUX_SENSOR& stAuxSensor() const OMG_NOEXCEPT {
        return m_stAuxSensor_;
    }

    void stAuxSensor(const ST_AS_AUX_SENSOR& value) {
        m_stAuxSensor_ = value;
    }

    void stAuxSensor(ST_AS_AUX_SENSOR&& value) {
        m_stAuxSensor_ = std::move(value);
    }
    ST_AS_PSU_STATUS& stPsuStatus() OMG_NOEXCEPT {
        return m_stPsuStatus_;
    }

    const ST_AS_PSU_STATUS& stPsuStatus() const OMG_NOEXCEPT {
        return m_stPsuStatus_;
    }

    void stPsuStatus(const ST_AS_PSU_STATUS& value) {
        m_stPsuStatus_ = value;
    }

    void stPsuStatus(ST_AS_PSU_STATUS&& value) {
        m_stPsuStatus_ = std::move(value);
    }
    uint8_t& oSenIFCStatus() OMG_NOEXCEPT {
        return m_oSenIFCStatus_;
    }

    const uint8_t& oSenIFCStatus() const OMG_NOEXCEPT {
        return m_oSenIFCStatus_;
    }

    void oSenIFCStatus(uint8_t value) {
        m_oSenIFCStatus_ = value;
    }

    uint8_t& oPSUIFCStatus() OMG_NOEXCEPT {
        return m_oPSUIFCStatus_;
    }

    const uint8_t& oPSUIFCStatus() const OMG_NOEXCEPT {
        return m_oPSUIFCStatus_;
    }

    void oPSUIFCStatus(uint8_t value) {
        m_oPSUIFCStatus_ = value;
    }

    uint8_t& oAGCOffSet() OMG_NOEXCEPT {
        return m_oAGCOffSet_;
    }

    const uint8_t& oAGCOffSet() const OMG_NOEXCEPT {
        return m_oAGCOffSet_;
    }

    void oAGCOffSet(uint8_t value) {
        m_oAGCOffSet_ = value;
    }

    uint8_t& oTVG() OMG_NOEXCEPT {
        return m_oTVG_;
    }

    const uint8_t& oTVG() const OMG_NOEXCEPT {
        return m_oTVG_;
    }

    void oTVG(uint8_t value) {
        m_oTVG_ = value;
    }

    char& cTxSteering() OMG_NOEXCEPT {
        return m_cTxSteering_;
    }

    const char& cTxSteering() const OMG_NOEXCEPT {
        return m_cTxSteering_;
    }

    void cTxSteering(char value) {
        m_cTxSteering_ = value;
    }

    ::dds::core::array< uint8_t, 11L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 11L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 11L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 11L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const ST_ASE_STATUS_INFO& other_) const;
    bool operator != (const ST_ASE_STATUS_INFO& other_) const;

    void swap(ST_ASE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulASID_;
    ::dds::core::array< uint8_t, 6L> m_oReceiveAmpBoardStatus_;
    ::dds::core::array< uint8_t, 6L> m_oTransmitAmpBoardStatus_;
    ST_TM_STATUS_T m_stFpgaTmStatusT_;
    ::dds::core::array< ST_PS_STATUS_T, 2L> m_oPowerStatus10_;
    ST_TM_STATUS_T m_stTmTmStatusT_;
    ::dds::core::array< ST_PS_STATUS_T, 6L> m_stTmStatus_;
    ::dds::core::array< ST_PS_STATUS_F, 5L> m_stPsStatus_;
    ::dds::core::array< ST_TM_STATUS_T, 8L> m_stTmStatusT_;
    ST_AS_NIC_CONF m_stNICConf_;
    ST_AS_AUX_SENSOR m_stAuxSensor_;
    ST_AS_PSU_STATUS m_stPsuStatus_;
    uint8_t m_oSenIFCStatus_;
    uint8_t m_oPSUIFCStatus_;
    uint8_t m_oAGCOffSet_;
    uint8_t m_oTVG_;
    char m_cTxSteering_;
    ::dds::core::array< uint8_t, 11L> m_oRes_;

};

inline void swap(ST_ASE_STATUS_INFO& a, ST_ASE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_ASE_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_SENSOR_STATUS {
  public:
    IFCCTR_ACTIVESONAR_SENSOR_STATUS();

    IFCCTR_ACTIVESONAR_SENSOR_STATUS(const ST_MSG_HEADER& stMsgHeader,const ST_ASE_STATUS_INFO& stAseStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_SENSOR_STATUS (IFCCTR_ACTIVESONAR_SENSOR_STATUS&&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_STATUS& operator=(IFCCTR_ACTIVESONAR_SENSOR_STATUS&&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_STATUS& operator=(const IFCCTR_ACTIVESONAR_SENSOR_STATUS&) = default;
    IFCCTR_ACTIVESONAR_SENSOR_STATUS(const IFCCTR_ACTIVESONAR_SENSOR_STATUS&) = default;
    #else
    IFCCTR_ACTIVESONAR_SENSOR_STATUS(IFCCTR_ACTIVESONAR_SENSOR_STATUS&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_SENSOR_STATUS& operator=(IFCCTR_ACTIVESONAR_SENSOR_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_ASE_STATUS_INFO& stAseStatusInfo() OMG_NOEXCEPT {
        return m_stAseStatusInfo_;
    }

    const ST_ASE_STATUS_INFO& stAseStatusInfo() const OMG_NOEXCEPT {
        return m_stAseStatusInfo_;
    }

    void stAseStatusInfo(const ST_ASE_STATUS_INFO& value) {
        m_stAseStatusInfo_ = value;
    }

    void stAseStatusInfo(ST_ASE_STATUS_INFO&& value) {
        m_stAseStatusInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_SENSOR_STATUS& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_SENSOR_STATUS& other_) const;

    void swap(IFCCTR_ACTIVESONAR_SENSOR_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_ASE_STATUS_INFO m_stAseStatusInfo_;

};

inline void swap(IFCCTR_ACTIVESONAR_SENSOR_STATUS& a, IFCCTR_ACTIVESONAR_SENSOR_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_SENSOR_STATUS& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE();

    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lWaterSpeed);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE (IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& operator=(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE(const IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& operator=(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lWaterSpeed() OMG_NOEXCEPT {
        return m_lWaterSpeed_;
    }

    const int32_t& lWaterSpeed() const OMG_NOEXCEPT {
        return m_lWaterSpeed_;
    }

    void lWaterSpeed(int32_t value) {
        m_lWaterSpeed_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lWaterSpeed_;

};

inline void swap(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& a, IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES {
  public:
    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES();

    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oStayTarget,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES (IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES&&) = default;
    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& operator=(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES&&) = default;
    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& operator=(const IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES&) = default;
    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES(const IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES&) = default;
    #else
    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& operator=(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oStayTarget() OMG_NOEXCEPT {
        return m_oStayTarget_;
    }

    const uint8_t& oStayTarget() const OMG_NOEXCEPT {
        return m_oStayTarget_;
    }

    void oStayTarget(uint8_t value) {
        m_oStayTarget_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& other_) const;

    void swap(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oStayTarget_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& a, IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_STEERING_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_STEERING_RESPONSE();

    IFCCTR_ACTIVESONAR_STEERING_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_STEERING_RESPONSE (IFCCTR_ACTIVESONAR_STEERING_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_STEERING_RESPONSE& operator=(IFCCTR_ACTIVESONAR_STEERING_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_STEERING_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_STEERING_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_STEERING_RESPONSE(const IFCCTR_ACTIVESONAR_STEERING_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_STEERING_RESPONSE(IFCCTR_ACTIVESONAR_STEERING_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_STEERING_RESPONSE& operator=(IFCCTR_ACTIVESONAR_STEERING_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    bool operator == (const IFCCTR_ACTIVESONAR_STEERING_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_STEERING_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_STEERING_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lResult_;

};

inline void swap(IFCCTR_ACTIVESONAR_STEERING_RESPONSE& a, IFCCTR_ACTIVESONAR_STEERING_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_STEERING_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE();

    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oActivation,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE (IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& operator=(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE(const IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& operator=(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oActivation() OMG_NOEXCEPT {
        return m_oActivation_;
    }

    const uint8_t& oActivation() const OMG_NOEXCEPT {
        return m_oActivation_;
    }

    void oActivation(uint8_t value) {
        m_oActivation_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oActivation_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& a, IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE();

    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lResult,const ST_TX_INFO& stTTxInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE (IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& operator=(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE(const IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& operator=(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    ST_TX_INFO& stTTxInfo() OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    const ST_TX_INFO& stTTxInfo() const OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    void stTTxInfo(const ST_TX_INFO& value) {
        m_stTTxInfo_ = value;
    }

    void stTTxInfo(ST_TX_INFO&& value) {
        m_stTTxInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lResult_;
    ST_TX_INFO m_stTTxInfo_;

};

inline void swap(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& a, IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE();

    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oSenstive,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE (IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& operator=(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE(const IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& operator=(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oSenstive() OMG_NOEXCEPT {
        return m_oSenstive_;
    }

    const uint8_t& oSenstive() const OMG_NOEXCEPT {
        return m_oSenstive_;
    }

    void oSenstive(uint8_t value) {
        m_oSenstive_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oSenstive_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& a, IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE {
  public:
    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE();

    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oWakeSup,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE (IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& operator=(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE&&) = default;
    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& operator=(const IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE&) = default;
    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE(const IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE&) = default;
    #else
    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& operator=(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oWakeSup() OMG_NOEXCEPT {
        return m_oWakeSup_;
    }

    const uint8_t& oWakeSup() const OMG_NOEXCEPT {
        return m_oWakeSup_;
    }

    void oWakeSup(uint8_t value) {
        m_oWakeSup_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& other_) const;
    bool operator != (const IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& other_) const;

    void swap(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oWakeSup_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& a, IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_AIS_STATUS_INFO {
  public:
    IFCCTR_AIS_STATUS_INFO();

    IFCCTR_AIS_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,int32_t lAISStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_AIS_STATUS_INFO (IFCCTR_AIS_STATUS_INFO&&) = default;
    IFCCTR_AIS_STATUS_INFO& operator=(IFCCTR_AIS_STATUS_INFO&&) = default;
    IFCCTR_AIS_STATUS_INFO& operator=(const IFCCTR_AIS_STATUS_INFO&) = default;
    IFCCTR_AIS_STATUS_INFO(const IFCCTR_AIS_STATUS_INFO&) = default;
    #else
    IFCCTR_AIS_STATUS_INFO(IFCCTR_AIS_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_AIS_STATUS_INFO& operator=(IFCCTR_AIS_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int32_t& lAISStatus() OMG_NOEXCEPT {
        return m_lAISStatus_;
    }

    const int32_t& lAISStatus() const OMG_NOEXCEPT {
        return m_lAISStatus_;
    }

    void lAISStatus(int32_t value) {
        m_lAISStatus_ = value;
    }

    bool operator == (const IFCCTR_AIS_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_AIS_STATUS_INFO& other_) const;

    void swap(IFCCTR_AIS_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int32_t m_lAISStatus_;

};

inline void swap(IFCCTR_AIS_STATUS_INFO& a, IFCCTR_AIS_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_AIS_STATUS_INFO& sample);

class NDDSUSERDllExport ST_AIS_TARGET {
  public:
    ST_AIS_TARGET();

    ST_AIS_TARGET(uint32_t ulTrackNo,uint32_t ulMMSI,uint32_t ulLatitude_Int,uint32_t ulLatitude_Dec,uint32_t ulLongitude_Int,uint32_t ulLongitude_Dec,float fSpeed,float fCourse,const ::dds::core::array< uint8_t, 20L>& aAISShipName,const ST_DATE_TIME& stTimeDetectTime,const ::dds::core::array< uint8_t, 8L>& oCallSign,uint16_t usShipCargoType,uint32_t ulNavigationStatus,const ::dds::core::array< uint8_t, 20L>& oDestination,float fCOG,const ::dds::core::array< uint8_t, 40L>& oNationality,float fRateOfTurn,float fMaximumDraught,float fDimensionToBow,float fDimensionToStern,float fDimensionToPort,float fDimensionToStarboard,const ST_DATE_TIME& stTimeETA);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AIS_TARGET (ST_AIS_TARGET&&) = default;
    ST_AIS_TARGET& operator=(ST_AIS_TARGET&&) = default;
    ST_AIS_TARGET& operator=(const ST_AIS_TARGET&) = default;
    ST_AIS_TARGET(const ST_AIS_TARGET&) = default;
    #else
    ST_AIS_TARGET(ST_AIS_TARGET&& other_) OMG_NOEXCEPT;  
    ST_AIS_TARGET& operator=(ST_AIS_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulTrackNo() OMG_NOEXCEPT {
        return m_ulTrackNo_;
    }

    const uint32_t& ulTrackNo() const OMG_NOEXCEPT {
        return m_ulTrackNo_;
    }

    void ulTrackNo(uint32_t value) {
        m_ulTrackNo_ = value;
    }

    uint32_t& ulMMSI() OMG_NOEXCEPT {
        return m_ulMMSI_;
    }

    const uint32_t& ulMMSI() const OMG_NOEXCEPT {
        return m_ulMMSI_;
    }

    void ulMMSI(uint32_t value) {
        m_ulMMSI_ = value;
    }

    uint32_t& ulLatitude_Int() OMG_NOEXCEPT {
        return m_ulLatitude_Int_;
    }

    const uint32_t& ulLatitude_Int() const OMG_NOEXCEPT {
        return m_ulLatitude_Int_;
    }

    void ulLatitude_Int(uint32_t value) {
        m_ulLatitude_Int_ = value;
    }

    uint32_t& ulLatitude_Dec() OMG_NOEXCEPT {
        return m_ulLatitude_Dec_;
    }

    const uint32_t& ulLatitude_Dec() const OMG_NOEXCEPT {
        return m_ulLatitude_Dec_;
    }

    void ulLatitude_Dec(uint32_t value) {
        m_ulLatitude_Dec_ = value;
    }

    uint32_t& ulLongitude_Int() OMG_NOEXCEPT {
        return m_ulLongitude_Int_;
    }

    const uint32_t& ulLongitude_Int() const OMG_NOEXCEPT {
        return m_ulLongitude_Int_;
    }

    void ulLongitude_Int(uint32_t value) {
        m_ulLongitude_Int_ = value;
    }

    uint32_t& ulLongitude_Dec() OMG_NOEXCEPT {
        return m_ulLongitude_Dec_;
    }

    const uint32_t& ulLongitude_Dec() const OMG_NOEXCEPT {
        return m_ulLongitude_Dec_;
    }

    void ulLongitude_Dec(uint32_t value) {
        m_ulLongitude_Dec_ = value;
    }

    float& fSpeed() OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    const float& fSpeed() const OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    void fSpeed(float value) {
        m_fSpeed_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& aAISShipName() OMG_NOEXCEPT {
        return m_aAISShipName_;
    }

    const ::dds::core::array< uint8_t, 20L>& aAISShipName() const OMG_NOEXCEPT {
        return m_aAISShipName_;
    }

    void aAISShipName(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aAISShipName_ = value;
    }

    void aAISShipName(::dds::core::array< uint8_t, 20L>&& value) {
        m_aAISShipName_ = std::move(value);
    }
    ST_DATE_TIME& stTimeDetectTime() OMG_NOEXCEPT {
        return m_stTimeDetectTime_;
    }

    const ST_DATE_TIME& stTimeDetectTime() const OMG_NOEXCEPT {
        return m_stTimeDetectTime_;
    }

    void stTimeDetectTime(const ST_DATE_TIME& value) {
        m_stTimeDetectTime_ = value;
    }

    void stTimeDetectTime(ST_DATE_TIME&& value) {
        m_stTimeDetectTime_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 8L>& oCallSign() OMG_NOEXCEPT {
        return m_oCallSign_;
    }

    const ::dds::core::array< uint8_t, 8L>& oCallSign() const OMG_NOEXCEPT {
        return m_oCallSign_;
    }

    void oCallSign(const ::dds::core::array< uint8_t, 8L>& value) {
        m_oCallSign_ = value;
    }

    void oCallSign(::dds::core::array< uint8_t, 8L>&& value) {
        m_oCallSign_ = std::move(value);
    }
    uint16_t& usShipCargoType() OMG_NOEXCEPT {
        return m_usShipCargoType_;
    }

    const uint16_t& usShipCargoType() const OMG_NOEXCEPT {
        return m_usShipCargoType_;
    }

    void usShipCargoType(uint16_t value) {
        m_usShipCargoType_ = value;
    }

    uint32_t& ulNavigationStatus() OMG_NOEXCEPT {
        return m_ulNavigationStatus_;
    }

    const uint32_t& ulNavigationStatus() const OMG_NOEXCEPT {
        return m_ulNavigationStatus_;
    }

    void ulNavigationStatus(uint32_t value) {
        m_ulNavigationStatus_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& oDestination() OMG_NOEXCEPT {
        return m_oDestination_;
    }

    const ::dds::core::array< uint8_t, 20L>& oDestination() const OMG_NOEXCEPT {
        return m_oDestination_;
    }

    void oDestination(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oDestination_ = value;
    }

    void oDestination(::dds::core::array< uint8_t, 20L>&& value) {
        m_oDestination_ = std::move(value);
    }
    float& fCOG() OMG_NOEXCEPT {
        return m_fCOG_;
    }

    const float& fCOG() const OMG_NOEXCEPT {
        return m_fCOG_;
    }

    void fCOG(float value) {
        m_fCOG_ = value;
    }

    ::dds::core::array< uint8_t, 40L>& oNationality() OMG_NOEXCEPT {
        return m_oNationality_;
    }

    const ::dds::core::array< uint8_t, 40L>& oNationality() const OMG_NOEXCEPT {
        return m_oNationality_;
    }

    void oNationality(const ::dds::core::array< uint8_t, 40L>& value) {
        m_oNationality_ = value;
    }

    void oNationality(::dds::core::array< uint8_t, 40L>&& value) {
        m_oNationality_ = std::move(value);
    }
    float& fRateOfTurn() OMG_NOEXCEPT {
        return m_fRateOfTurn_;
    }

    const float& fRateOfTurn() const OMG_NOEXCEPT {
        return m_fRateOfTurn_;
    }

    void fRateOfTurn(float value) {
        m_fRateOfTurn_ = value;
    }

    float& fMaximumDraught() OMG_NOEXCEPT {
        return m_fMaximumDraught_;
    }

    const float& fMaximumDraught() const OMG_NOEXCEPT {
        return m_fMaximumDraught_;
    }

    void fMaximumDraught(float value) {
        m_fMaximumDraught_ = value;
    }

    float& fDimensionToBow() OMG_NOEXCEPT {
        return m_fDimensionToBow_;
    }

    const float& fDimensionToBow() const OMG_NOEXCEPT {
        return m_fDimensionToBow_;
    }

    void fDimensionToBow(float value) {
        m_fDimensionToBow_ = value;
    }

    float& fDimensionToStern() OMG_NOEXCEPT {
        return m_fDimensionToStern_;
    }

    const float& fDimensionToStern() const OMG_NOEXCEPT {
        return m_fDimensionToStern_;
    }

    void fDimensionToStern(float value) {
        m_fDimensionToStern_ = value;
    }

    float& fDimensionToPort() OMG_NOEXCEPT {
        return m_fDimensionToPort_;
    }

    const float& fDimensionToPort() const OMG_NOEXCEPT {
        return m_fDimensionToPort_;
    }

    void fDimensionToPort(float value) {
        m_fDimensionToPort_ = value;
    }

    float& fDimensionToStarboard() OMG_NOEXCEPT {
        return m_fDimensionToStarboard_;
    }

    const float& fDimensionToStarboard() const OMG_NOEXCEPT {
        return m_fDimensionToStarboard_;
    }

    void fDimensionToStarboard(float value) {
        m_fDimensionToStarboard_ = value;
    }

    ST_DATE_TIME& stTimeETA() OMG_NOEXCEPT {
        return m_stTimeETA_;
    }

    const ST_DATE_TIME& stTimeETA() const OMG_NOEXCEPT {
        return m_stTimeETA_;
    }

    void stTimeETA(const ST_DATE_TIME& value) {
        m_stTimeETA_ = value;
    }

    void stTimeETA(ST_DATE_TIME&& value) {
        m_stTimeETA_ = std::move(value);
    }

    bool operator == (const ST_AIS_TARGET& other_) const;
    bool operator != (const ST_AIS_TARGET& other_) const;

    void swap(ST_AIS_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulTrackNo_;
    uint32_t m_ulMMSI_;
    uint32_t m_ulLatitude_Int_;
    uint32_t m_ulLatitude_Dec_;
    uint32_t m_ulLongitude_Int_;
    uint32_t m_ulLongitude_Dec_;
    float m_fSpeed_;
    float m_fCourse_;
    ::dds::core::array< uint8_t, 20L> m_aAISShipName_;
    ST_DATE_TIME m_stTimeDetectTime_;
    ::dds::core::array< uint8_t, 8L> m_oCallSign_;
    uint16_t m_usShipCargoType_;
    uint32_t m_ulNavigationStatus_;
    ::dds::core::array< uint8_t, 20L> m_oDestination_;
    float m_fCOG_;
    ::dds::core::array< uint8_t, 40L> m_oNationality_;
    float m_fRateOfTurn_;
    float m_fMaximumDraught_;
    float m_fDimensionToBow_;
    float m_fDimensionToStern_;
    float m_fDimensionToPort_;
    float m_fDimensionToStarboard_;
    ST_DATE_TIME m_stTimeETA_;

};

inline void swap(ST_AIS_TARGET& a, ST_AIS_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AIS_TARGET& sample);

class NDDSUSERDllExport IFCCTR_AIS_TARGET_DATA_INFO {
  public:
    IFCCTR_AIS_TARGET_DATA_INFO();

    IFCCTR_AIS_TARGET_DATA_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNoOfTgts,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_AIS_TARGET, 1000L>& stAISTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_AIS_TARGET_DATA_INFO (IFCCTR_AIS_TARGET_DATA_INFO&&) = default;
    IFCCTR_AIS_TARGET_DATA_INFO& operator=(IFCCTR_AIS_TARGET_DATA_INFO&&) = default;
    IFCCTR_AIS_TARGET_DATA_INFO& operator=(const IFCCTR_AIS_TARGET_DATA_INFO&) = default;
    IFCCTR_AIS_TARGET_DATA_INFO(const IFCCTR_AIS_TARGET_DATA_INFO&) = default;
    #else
    IFCCTR_AIS_TARGET_DATA_INFO(IFCCTR_AIS_TARGET_DATA_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_AIS_TARGET_DATA_INFO& operator=(IFCCTR_AIS_TARGET_DATA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const uint16_t& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(uint16_t value) {
        m_usNoOfTgts_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_AIS_TARGET, 1000L>& stAISTargetInfo() OMG_NOEXCEPT {
        return m_stAISTargetInfo_;
    }

    const ::dds::core::array< ST_AIS_TARGET, 1000L>& stAISTargetInfo() const OMG_NOEXCEPT {
        return m_stAISTargetInfo_;
    }

    void stAISTargetInfo(const ::dds::core::array< ST_AIS_TARGET, 1000L>& value) {
        m_stAISTargetInfo_ = value;
    }

    void stAISTargetInfo(::dds::core::array< ST_AIS_TARGET, 1000L>&& value) {
        m_stAISTargetInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_AIS_TARGET_DATA_INFO& other_) const;
    bool operator != (const IFCCTR_AIS_TARGET_DATA_INFO& other_) const;

    void swap(IFCCTR_AIS_TARGET_DATA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNoOfTgts_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_AIS_TARGET, 1000L> m_stAISTargetInfo_;

};

inline void swap(IFCCTR_AIS_TARGET_DATA_INFO& a, IFCCTR_AIS_TARGET_DATA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_AIS_TARGET_DATA_INFO& sample);

class NDDSUSERDllExport IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE {
  public:
    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE();

    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint8_t oIRCameraCalInfo,uint8_t oTopdownAck,int16_t sTrueNorthValueAngle,uint16_t usEO_CenterPixel_X,uint16_t usEO_CenterPixel_Y,uint16_t usIR_CenterPixel_X,uint16_t usIR_CenterPixel_Y);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE (IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& operator=(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& operator=(const IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE&) = default;
    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE(const IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& operator=(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint8_t& oIRCameraCalInfo() OMG_NOEXCEPT {
        return m_oIRCameraCalInfo_;
    }

    const uint8_t& oIRCameraCalInfo() const OMG_NOEXCEPT {
        return m_oIRCameraCalInfo_;
    }

    void oIRCameraCalInfo(uint8_t value) {
        m_oIRCameraCalInfo_ = value;
    }

    uint8_t& oTopdownAck() OMG_NOEXCEPT {
        return m_oTopdownAck_;
    }

    const uint8_t& oTopdownAck() const OMG_NOEXCEPT {
        return m_oTopdownAck_;
    }

    void oTopdownAck(uint8_t value) {
        m_oTopdownAck_ = value;
    }

    int16_t& sTrueNorthValueAngle() OMG_NOEXCEPT {
        return m_sTrueNorthValueAngle_;
    }

    const int16_t& sTrueNorthValueAngle() const OMG_NOEXCEPT {
        return m_sTrueNorthValueAngle_;
    }

    void sTrueNorthValueAngle(int16_t value) {
        m_sTrueNorthValueAngle_ = value;
    }

    uint16_t& usEO_CenterPixel_X() OMG_NOEXCEPT {
        return m_usEO_CenterPixel_X_;
    }

    const uint16_t& usEO_CenterPixel_X() const OMG_NOEXCEPT {
        return m_usEO_CenterPixel_X_;
    }

    void usEO_CenterPixel_X(uint16_t value) {
        m_usEO_CenterPixel_X_ = value;
    }

    uint16_t& usEO_CenterPixel_Y() OMG_NOEXCEPT {
        return m_usEO_CenterPixel_Y_;
    }

    const uint16_t& usEO_CenterPixel_Y() const OMG_NOEXCEPT {
        return m_usEO_CenterPixel_Y_;
    }

    void usEO_CenterPixel_Y(uint16_t value) {
        m_usEO_CenterPixel_Y_ = value;
    }

    uint16_t& usIR_CenterPixel_X() OMG_NOEXCEPT {
        return m_usIR_CenterPixel_X_;
    }

    const uint16_t& usIR_CenterPixel_X() const OMG_NOEXCEPT {
        return m_usIR_CenterPixel_X_;
    }

    void usIR_CenterPixel_X(uint16_t value) {
        m_usIR_CenterPixel_X_ = value;
    }

    uint16_t& usIR_CenterPixel_Y() OMG_NOEXCEPT {
        return m_usIR_CenterPixel_Y_;
    }

    const uint16_t& usIR_CenterPixel_Y() const OMG_NOEXCEPT {
        return m_usIR_CenterPixel_Y_;
    }

    void usIR_CenterPixel_Y(uint16_t value) {
        m_usIR_CenterPixel_Y_ = value;
    }

    bool operator == (const IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint8_t m_oIRCameraCalInfo_;
    uint8_t m_oTopdownAck_;
    int16_t m_sTrueNorthValueAngle_;
    uint16_t m_usEO_CenterPixel_X_;
    uint16_t m_usEO_CenterPixel_Y_;
    uint16_t m_usIR_CenterPixel_X_;
    uint16_t m_usIR_CenterPixel_Y_;

};

inline void swap(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& a, IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_AUTH_CONTROL_RESPONSE {
  public:
    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE();

    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usAuthoritySettingAck);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE (IFCCTR_EOTE_AUTH_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& operator=(const IFCCTR_EOTE_AUTH_CONTROL_RESPONSE&) = default;
    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE(const IFCCTR_EOTE_AUTH_CONTROL_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usAuthoritySettingAck() OMG_NOEXCEPT {
        return m_usAuthoritySettingAck_;
    }

    const uint16_t& usAuthoritySettingAck() const OMG_NOEXCEPT {
        return m_usAuthoritySettingAck_;
    }

    void usAuthoritySettingAck(uint16_t value) {
        m_usAuthoritySettingAck_ = value;
    }

    bool operator == (const IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usAuthoritySettingAck_;

};

inline void swap(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& a, IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_AUTH_FAIL_RESPONSE {
  public:
    IFCCTR_EOTE_AUTH_FAIL_RESPONSE();

    IFCCTR_EOTE_AUTH_FAIL_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usAuthorityFailureInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_AUTH_FAIL_RESPONSE (IFCCTR_EOTE_AUTH_FAIL_RESPONSE&&) = default;
    IFCCTR_EOTE_AUTH_FAIL_RESPONSE& operator=(IFCCTR_EOTE_AUTH_FAIL_RESPONSE&&) = default;
    IFCCTR_EOTE_AUTH_FAIL_RESPONSE& operator=(const IFCCTR_EOTE_AUTH_FAIL_RESPONSE&) = default;
    IFCCTR_EOTE_AUTH_FAIL_RESPONSE(const IFCCTR_EOTE_AUTH_FAIL_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_AUTH_FAIL_RESPONSE(IFCCTR_EOTE_AUTH_FAIL_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_AUTH_FAIL_RESPONSE& operator=(IFCCTR_EOTE_AUTH_FAIL_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usAuthorityFailureInfo() OMG_NOEXCEPT {
        return m_usAuthorityFailureInfo_;
    }

    const uint16_t& usAuthorityFailureInfo() const OMG_NOEXCEPT {
        return m_usAuthorityFailureInfo_;
    }

    void usAuthorityFailureInfo(uint16_t value) {
        m_usAuthorityFailureInfo_ = value;
    }

    bool operator == (const IFCCTR_EOTE_AUTH_FAIL_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_AUTH_FAIL_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_AUTH_FAIL_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usAuthorityFailureInfo_;

};

inline void swap(IFCCTR_EOTE_AUTH_FAIL_RESPONSE& a, IFCCTR_EOTE_AUTH_FAIL_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_AUTH_FAIL_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_AUTH_INFO_RESPONSE {
  public:
    IFCCTR_EOTE_AUTH_INFO_RESPONSE();

    IFCCTR_EOTE_AUTH_INFO_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usAuthoritySettingInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_AUTH_INFO_RESPONSE (IFCCTR_EOTE_AUTH_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_AUTH_INFO_RESPONSE& operator=(IFCCTR_EOTE_AUTH_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_AUTH_INFO_RESPONSE& operator=(const IFCCTR_EOTE_AUTH_INFO_RESPONSE&) = default;
    IFCCTR_EOTE_AUTH_INFO_RESPONSE(const IFCCTR_EOTE_AUTH_INFO_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_AUTH_INFO_RESPONSE(IFCCTR_EOTE_AUTH_INFO_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_AUTH_INFO_RESPONSE& operator=(IFCCTR_EOTE_AUTH_INFO_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usAuthoritySettingInfo() OMG_NOEXCEPT {
        return m_usAuthoritySettingInfo_;
    }

    const uint16_t& usAuthoritySettingInfo() const OMG_NOEXCEPT {
        return m_usAuthoritySettingInfo_;
    }

    void usAuthoritySettingInfo(uint16_t value) {
        m_usAuthoritySettingInfo_ = value;
    }

    bool operator == (const IFCCTR_EOTE_AUTH_INFO_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_AUTH_INFO_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_AUTH_INFO_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usAuthoritySettingInfo_;

};

inline void swap(IFCCTR_EOTE_AUTH_INFO_RESPONSE& a, IFCCTR_EOTE_AUTH_INFO_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_AUTH_INFO_RESPONSE& sample);

class NDDSUSERDllExport ST_EOTE_STATUS_INFO {
  public:
    ST_EOTE_STATUS_INFO();

    ST_EOTE_STATUS_INFO(uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint8_t oStabilizationBoardBIT,uint8_t oCameraBoardBIT,uint8_t oTrackingBoardBIT,uint8_t oLaserRangeFinderBIT,uint8_t oEOCameraBIT,uint8_t oIRCameraBIT,uint8_t oPitchMotorBIT,uint8_t oYawMotorBIT,uint16_t usIRUsedTimeDAY,uint16_t usIRUsedTimeHour,uint32_t usLaserMeasureCount);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EOTE_STATUS_INFO (ST_EOTE_STATUS_INFO&&) = default;
    ST_EOTE_STATUS_INFO& operator=(ST_EOTE_STATUS_INFO&&) = default;
    ST_EOTE_STATUS_INFO& operator=(const ST_EOTE_STATUS_INFO&) = default;
    ST_EOTE_STATUS_INFO(const ST_EOTE_STATUS_INFO&) = default;
    #else
    ST_EOTE_STATUS_INFO(ST_EOTE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_EOTE_STATUS_INFO& operator=(ST_EOTE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint8_t& oStabilizationBoardBIT() OMG_NOEXCEPT {
        return m_oStabilizationBoardBIT_;
    }

    const uint8_t& oStabilizationBoardBIT() const OMG_NOEXCEPT {
        return m_oStabilizationBoardBIT_;
    }

    void oStabilizationBoardBIT(uint8_t value) {
        m_oStabilizationBoardBIT_ = value;
    }

    uint8_t& oCameraBoardBIT() OMG_NOEXCEPT {
        return m_oCameraBoardBIT_;
    }

    const uint8_t& oCameraBoardBIT() const OMG_NOEXCEPT {
        return m_oCameraBoardBIT_;
    }

    void oCameraBoardBIT(uint8_t value) {
        m_oCameraBoardBIT_ = value;
    }

    uint8_t& oTrackingBoardBIT() OMG_NOEXCEPT {
        return m_oTrackingBoardBIT_;
    }

    const uint8_t& oTrackingBoardBIT() const OMG_NOEXCEPT {
        return m_oTrackingBoardBIT_;
    }

    void oTrackingBoardBIT(uint8_t value) {
        m_oTrackingBoardBIT_ = value;
    }

    uint8_t& oLaserRangeFinderBIT() OMG_NOEXCEPT {
        return m_oLaserRangeFinderBIT_;
    }

    const uint8_t& oLaserRangeFinderBIT() const OMG_NOEXCEPT {
        return m_oLaserRangeFinderBIT_;
    }

    void oLaserRangeFinderBIT(uint8_t value) {
        m_oLaserRangeFinderBIT_ = value;
    }

    uint8_t& oEOCameraBIT() OMG_NOEXCEPT {
        return m_oEOCameraBIT_;
    }

    const uint8_t& oEOCameraBIT() const OMG_NOEXCEPT {
        return m_oEOCameraBIT_;
    }

    void oEOCameraBIT(uint8_t value) {
        m_oEOCameraBIT_ = value;
    }

    uint8_t& oIRCameraBIT() OMG_NOEXCEPT {
        return m_oIRCameraBIT_;
    }

    const uint8_t& oIRCameraBIT() const OMG_NOEXCEPT {
        return m_oIRCameraBIT_;
    }

    void oIRCameraBIT(uint8_t value) {
        m_oIRCameraBIT_ = value;
    }

    uint8_t& oPitchMotorBIT() OMG_NOEXCEPT {
        return m_oPitchMotorBIT_;
    }

    const uint8_t& oPitchMotorBIT() const OMG_NOEXCEPT {
        return m_oPitchMotorBIT_;
    }

    void oPitchMotorBIT(uint8_t value) {
        m_oPitchMotorBIT_ = value;
    }

    uint8_t& oYawMotorBIT() OMG_NOEXCEPT {
        return m_oYawMotorBIT_;
    }

    const uint8_t& oYawMotorBIT() const OMG_NOEXCEPT {
        return m_oYawMotorBIT_;
    }

    void oYawMotorBIT(uint8_t value) {
        m_oYawMotorBIT_ = value;
    }

    uint16_t& usIRUsedTimeDAY() OMG_NOEXCEPT {
        return m_usIRUsedTimeDAY_;
    }

    const uint16_t& usIRUsedTimeDAY() const OMG_NOEXCEPT {
        return m_usIRUsedTimeDAY_;
    }

    void usIRUsedTimeDAY(uint16_t value) {
        m_usIRUsedTimeDAY_ = value;
    }

    uint16_t& usIRUsedTimeHour() OMG_NOEXCEPT {
        return m_usIRUsedTimeHour_;
    }

    const uint16_t& usIRUsedTimeHour() const OMG_NOEXCEPT {
        return m_usIRUsedTimeHour_;
    }

    void usIRUsedTimeHour(uint16_t value) {
        m_usIRUsedTimeHour_ = value;
    }

    uint32_t& usLaserMeasureCount() OMG_NOEXCEPT {
        return m_usLaserMeasureCount_;
    }

    const uint32_t& usLaserMeasureCount() const OMG_NOEXCEPT {
        return m_usLaserMeasureCount_;
    }

    void usLaserMeasureCount(uint32_t value) {
        m_usLaserMeasureCount_ = value;
    }

    bool operator == (const ST_EOTE_STATUS_INFO& other_) const;
    bool operator != (const ST_EOTE_STATUS_INFO& other_) const;

    void swap(ST_EOTE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint8_t m_oStabilizationBoardBIT_;
    uint8_t m_oCameraBoardBIT_;
    uint8_t m_oTrackingBoardBIT_;
    uint8_t m_oLaserRangeFinderBIT_;
    uint8_t m_oEOCameraBIT_;
    uint8_t m_oIRCameraBIT_;
    uint8_t m_oPitchMotorBIT_;
    uint8_t m_oYawMotorBIT_;
    uint16_t m_usIRUsedTimeDAY_;
    uint16_t m_usIRUsedTimeHour_;
    uint32_t m_usLaserMeasureCount_;

};

inline void swap(ST_EOTE_STATUS_INFO& a, ST_EOTE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EOTE_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_EOTE_BIT_RESPONSE {
  public:
    IFCCTR_EOTE_BIT_RESPONSE();

    IFCCTR_EOTE_BIT_RESPONSE(const ST_MSG_HEADER& stMsgHeader,const ST_EOTE_STATUS_INFO& stEoteStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_BIT_RESPONSE (IFCCTR_EOTE_BIT_RESPONSE&&) = default;
    IFCCTR_EOTE_BIT_RESPONSE& operator=(IFCCTR_EOTE_BIT_RESPONSE&&) = default;
    IFCCTR_EOTE_BIT_RESPONSE& operator=(const IFCCTR_EOTE_BIT_RESPONSE&) = default;
    IFCCTR_EOTE_BIT_RESPONSE(const IFCCTR_EOTE_BIT_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_BIT_RESPONSE(IFCCTR_EOTE_BIT_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_BIT_RESPONSE& operator=(IFCCTR_EOTE_BIT_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_EOTE_STATUS_INFO& stEoteStatusInfo() OMG_NOEXCEPT {
        return m_stEoteStatusInfo_;
    }

    const ST_EOTE_STATUS_INFO& stEoteStatusInfo() const OMG_NOEXCEPT {
        return m_stEoteStatusInfo_;
    }

    void stEoteStatusInfo(const ST_EOTE_STATUS_INFO& value) {
        m_stEoteStatusInfo_ = value;
    }

    void stEoteStatusInfo(ST_EOTE_STATUS_INFO&& value) {
        m_stEoteStatusInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_EOTE_BIT_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_BIT_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_BIT_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_EOTE_STATUS_INFO m_stEoteStatusInfo_;

};

inline void swap(IFCCTR_EOTE_BIT_RESPONSE& a, IFCCTR_EOTE_BIT_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_BIT_RESPONSE& sample);

class NDDSUSERDllExport ST_EOTE_RESTIRCT_DISTRICT {
  public:
    ST_EOTE_RESTIRCT_DISTRICT();

    ST_EOTE_RESTIRCT_DISTRICT(int16_t sDistrictStartAzimuth,int16_t sDistrictEndAzimuth,int16_t sDistrictStartElevation,int16_t sDistrictEndElevation);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EOTE_RESTIRCT_DISTRICT (ST_EOTE_RESTIRCT_DISTRICT&&) = default;
    ST_EOTE_RESTIRCT_DISTRICT& operator=(ST_EOTE_RESTIRCT_DISTRICT&&) = default;
    ST_EOTE_RESTIRCT_DISTRICT& operator=(const ST_EOTE_RESTIRCT_DISTRICT&) = default;
    ST_EOTE_RESTIRCT_DISTRICT(const ST_EOTE_RESTIRCT_DISTRICT&) = default;
    #else
    ST_EOTE_RESTIRCT_DISTRICT(ST_EOTE_RESTIRCT_DISTRICT&& other_) OMG_NOEXCEPT;  
    ST_EOTE_RESTIRCT_DISTRICT& operator=(ST_EOTE_RESTIRCT_DISTRICT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int16_t& sDistrictStartAzimuth() OMG_NOEXCEPT {
        return m_sDistrictStartAzimuth_;
    }

    const int16_t& sDistrictStartAzimuth() const OMG_NOEXCEPT {
        return m_sDistrictStartAzimuth_;
    }

    void sDistrictStartAzimuth(int16_t value) {
        m_sDistrictStartAzimuth_ = value;
    }

    int16_t& sDistrictEndAzimuth() OMG_NOEXCEPT {
        return m_sDistrictEndAzimuth_;
    }

    const int16_t& sDistrictEndAzimuth() const OMG_NOEXCEPT {
        return m_sDistrictEndAzimuth_;
    }

    void sDistrictEndAzimuth(int16_t value) {
        m_sDistrictEndAzimuth_ = value;
    }

    int16_t& sDistrictStartElevation() OMG_NOEXCEPT {
        return m_sDistrictStartElevation_;
    }

    const int16_t& sDistrictStartElevation() const OMG_NOEXCEPT {
        return m_sDistrictStartElevation_;
    }

    void sDistrictStartElevation(int16_t value) {
        m_sDistrictStartElevation_ = value;
    }

    int16_t& sDistrictEndElevation() OMG_NOEXCEPT {
        return m_sDistrictEndElevation_;
    }

    const int16_t& sDistrictEndElevation() const OMG_NOEXCEPT {
        return m_sDistrictEndElevation_;
    }

    void sDistrictEndElevation(int16_t value) {
        m_sDistrictEndElevation_ = value;
    }

    bool operator == (const ST_EOTE_RESTIRCT_DISTRICT& other_) const;
    bool operator != (const ST_EOTE_RESTIRCT_DISTRICT& other_) const;

    void swap(ST_EOTE_RESTIRCT_DISTRICT& other_) OMG_NOEXCEPT ;

  private:

    int16_t m_sDistrictStartAzimuth_;
    int16_t m_sDistrictEndAzimuth_;
    int16_t m_sDistrictStartElevation_;
    int16_t m_sDistrictEndElevation_;

};

inline void swap(ST_EOTE_RESTIRCT_DISTRICT& a, ST_EOTE_RESTIRCT_DISTRICT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EOTE_RESTIRCT_DISTRICT& sample);

class NDDSUSERDllExport IFCCTR_EOTE_BLOCK_INFO_RESPONSE {
  public:
    IFCCTR_EOTE_BLOCK_INFO_RESPONSE();

    IFCCTR_EOTE_BLOCK_INFO_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,const ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& stRestrictedResion);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_BLOCK_INFO_RESPONSE (IFCCTR_EOTE_BLOCK_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_BLOCK_INFO_RESPONSE& operator=(IFCCTR_EOTE_BLOCK_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_BLOCK_INFO_RESPONSE& operator=(const IFCCTR_EOTE_BLOCK_INFO_RESPONSE&) = default;
    IFCCTR_EOTE_BLOCK_INFO_RESPONSE(const IFCCTR_EOTE_BLOCK_INFO_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_BLOCK_INFO_RESPONSE(IFCCTR_EOTE_BLOCK_INFO_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_BLOCK_INFO_RESPONSE& operator=(IFCCTR_EOTE_BLOCK_INFO_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& stRestrictedResion() OMG_NOEXCEPT {
        return m_stRestrictedResion_;
    }

    const ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& stRestrictedResion() const OMG_NOEXCEPT {
        return m_stRestrictedResion_;
    }

    void stRestrictedResion(const ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& value) {
        m_stRestrictedResion_ = value;
    }

    void stRestrictedResion(::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>&& value) {
        m_stRestrictedResion_ = std::move(value);
    }

    bool operator == (const IFCCTR_EOTE_BLOCK_INFO_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_BLOCK_INFO_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_BLOCK_INFO_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L> m_stRestrictedResion_;

};

inline void swap(IFCCTR_EOTE_BLOCK_INFO_RESPONSE& a, IFCCTR_EOTE_BLOCK_INFO_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_BLOCK_INFO_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_BLOCK_SET_RESPONSE {
  public:
    IFCCTR_EOTE_BLOCK_SET_RESPONSE();

    IFCCTR_EOTE_BLOCK_SET_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usRestrictDistrictAck,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_BLOCK_SET_RESPONSE (IFCCTR_EOTE_BLOCK_SET_RESPONSE&&) = default;
    IFCCTR_EOTE_BLOCK_SET_RESPONSE& operator=(IFCCTR_EOTE_BLOCK_SET_RESPONSE&&) = default;
    IFCCTR_EOTE_BLOCK_SET_RESPONSE& operator=(const IFCCTR_EOTE_BLOCK_SET_RESPONSE&) = default;
    IFCCTR_EOTE_BLOCK_SET_RESPONSE(const IFCCTR_EOTE_BLOCK_SET_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_BLOCK_SET_RESPONSE(IFCCTR_EOTE_BLOCK_SET_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_BLOCK_SET_RESPONSE& operator=(IFCCTR_EOTE_BLOCK_SET_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usRestrictDistrictAck() OMG_NOEXCEPT {
        return m_usRestrictDistrictAck_;
    }

    const uint16_t& usRestrictDistrictAck() const OMG_NOEXCEPT {
        return m_usRestrictDistrictAck_;
    }

    void usRestrictDistrictAck(uint16_t value) {
        m_usRestrictDistrictAck_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const IFCCTR_EOTE_BLOCK_SET_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_BLOCK_SET_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_BLOCK_SET_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usRestrictDistrictAck_;
    uint16_t m_usReserved2_;

};

inline void swap(IFCCTR_EOTE_BLOCK_SET_RESPONSE& a, IFCCTR_EOTE_BLOCK_SET_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_BLOCK_SET_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE {
  public:
    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE();

    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint8_t oIRInverseOnOffStatus,uint8_t oIRSharpnessStatus,uint8_t oFogRevisionStatus,uint8_t oReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE (IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& operator=(const IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE&) = default;
    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE(const IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint8_t& oIRInverseOnOffStatus() OMG_NOEXCEPT {
        return m_oIRInverseOnOffStatus_;
    }

    const uint8_t& oIRInverseOnOffStatus() const OMG_NOEXCEPT {
        return m_oIRInverseOnOffStatus_;
    }

    void oIRInverseOnOffStatus(uint8_t value) {
        m_oIRInverseOnOffStatus_ = value;
    }

    uint8_t& oIRSharpnessStatus() OMG_NOEXCEPT {
        return m_oIRSharpnessStatus_;
    }

    const uint8_t& oIRSharpnessStatus() const OMG_NOEXCEPT {
        return m_oIRSharpnessStatus_;
    }

    void oIRSharpnessStatus(uint8_t value) {
        m_oIRSharpnessStatus_ = value;
    }

    uint8_t& oFogRevisionStatus() OMG_NOEXCEPT {
        return m_oFogRevisionStatus_;
    }

    const uint8_t& oFogRevisionStatus() const OMG_NOEXCEPT {
        return m_oFogRevisionStatus_;
    }

    void oFogRevisionStatus(uint8_t value) {
        m_oFogRevisionStatus_ = value;
    }

    uint8_t& oReserved2() OMG_NOEXCEPT {
        return m_oReserved2_;
    }

    const uint8_t& oReserved2() const OMG_NOEXCEPT {
        return m_oReserved2_;
    }

    void oReserved2(uint8_t value) {
        m_oReserved2_ = value;
    }

    bool operator == (const IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint8_t m_oIRInverseOnOffStatus_;
    uint8_t m_oIRSharpnessStatus_;
    uint8_t m_oFogRevisionStatus_;
    uint8_t m_oReserved2_;

};

inline void swap(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& a, IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_LASER_CONTROL_RESPONSE {
  public:
    IFCCTR_EOTE_LASER_CONTROL_RESPONSE();

    IFCCTR_EOTE_LASER_CONTROL_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usDistanceInfo,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_LASER_CONTROL_RESPONSE (IFCCTR_EOTE_LASER_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_LASER_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_LASER_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_LASER_CONTROL_RESPONSE& operator=(const IFCCTR_EOTE_LASER_CONTROL_RESPONSE&) = default;
    IFCCTR_EOTE_LASER_CONTROL_RESPONSE(const IFCCTR_EOTE_LASER_CONTROL_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_LASER_CONTROL_RESPONSE(IFCCTR_EOTE_LASER_CONTROL_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_LASER_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_LASER_CONTROL_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usDistanceInfo() OMG_NOEXCEPT {
        return m_usDistanceInfo_;
    }

    const uint16_t& usDistanceInfo() const OMG_NOEXCEPT {
        return m_usDistanceInfo_;
    }

    void usDistanceInfo(uint16_t value) {
        m_usDistanceInfo_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const IFCCTR_EOTE_LASER_CONTROL_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_LASER_CONTROL_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_LASER_CONTROL_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usDistanceInfo_;
    uint16_t m_usReserved2_;

};

inline void swap(IFCCTR_EOTE_LASER_CONTROL_RESPONSE& a, IFCCTR_EOTE_LASER_CONTROL_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_LASER_CONTROL_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_MOVE_CONTROL_RESPONSE {
  public:
    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE();

    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint8_t usMovingTrackingAck,uint8_t oMovingSearchingDistrict,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE (IFCCTR_EOTE_MOVE_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& operator=(const IFCCTR_EOTE_MOVE_CONTROL_RESPONSE&) = default;
    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE(const IFCCTR_EOTE_MOVE_CONTROL_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint8_t& usMovingTrackingAck() OMG_NOEXCEPT {
        return m_usMovingTrackingAck_;
    }

    const uint8_t& usMovingTrackingAck() const OMG_NOEXCEPT {
        return m_usMovingTrackingAck_;
    }

    void usMovingTrackingAck(uint8_t value) {
        m_usMovingTrackingAck_ = value;
    }

    uint8_t& oMovingSearchingDistrict() OMG_NOEXCEPT {
        return m_oMovingSearchingDistrict_;
    }

    const uint8_t& oMovingSearchingDistrict() const OMG_NOEXCEPT {
        return m_oMovingSearchingDistrict_;
    }

    void oMovingSearchingDistrict(uint8_t value) {
        m_oMovingSearchingDistrict_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint8_t m_usMovingTrackingAck_;
    uint8_t m_oMovingSearchingDistrict_;
    uint16_t m_usReserved2_;

};

inline void swap(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& a, IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& sample);

class NDDSUSERDllExport ST_EOTE_MOVING_SEARCHING_INFO {
  public:
    ST_EOTE_MOVING_SEARCHING_INFO();

    ST_EOTE_MOVING_SEARCHING_INFO(int16_t sPointAzimuth,int16_t sPointElevation,uint16_t usPointViewAngle,uint8_t oPointMovingTime,uint8_t oPointStayTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EOTE_MOVING_SEARCHING_INFO (ST_EOTE_MOVING_SEARCHING_INFO&&) = default;
    ST_EOTE_MOVING_SEARCHING_INFO& operator=(ST_EOTE_MOVING_SEARCHING_INFO&&) = default;
    ST_EOTE_MOVING_SEARCHING_INFO& operator=(const ST_EOTE_MOVING_SEARCHING_INFO&) = default;
    ST_EOTE_MOVING_SEARCHING_INFO(const ST_EOTE_MOVING_SEARCHING_INFO&) = default;
    #else
    ST_EOTE_MOVING_SEARCHING_INFO(ST_EOTE_MOVING_SEARCHING_INFO&& other_) OMG_NOEXCEPT;  
    ST_EOTE_MOVING_SEARCHING_INFO& operator=(ST_EOTE_MOVING_SEARCHING_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int16_t& sPointAzimuth() OMG_NOEXCEPT {
        return m_sPointAzimuth_;
    }

    const int16_t& sPointAzimuth() const OMG_NOEXCEPT {
        return m_sPointAzimuth_;
    }

    void sPointAzimuth(int16_t value) {
        m_sPointAzimuth_ = value;
    }

    int16_t& sPointElevation() OMG_NOEXCEPT {
        return m_sPointElevation_;
    }

    const int16_t& sPointElevation() const OMG_NOEXCEPT {
        return m_sPointElevation_;
    }

    void sPointElevation(int16_t value) {
        m_sPointElevation_ = value;
    }

    uint16_t& usPointViewAngle() OMG_NOEXCEPT {
        return m_usPointViewAngle_;
    }

    const uint16_t& usPointViewAngle() const OMG_NOEXCEPT {
        return m_usPointViewAngle_;
    }

    void usPointViewAngle(uint16_t value) {
        m_usPointViewAngle_ = value;
    }

    uint8_t& oPointMovingTime() OMG_NOEXCEPT {
        return m_oPointMovingTime_;
    }

    const uint8_t& oPointMovingTime() const OMG_NOEXCEPT {
        return m_oPointMovingTime_;
    }

    void oPointMovingTime(uint8_t value) {
        m_oPointMovingTime_ = value;
    }

    uint8_t& oPointStayTime() OMG_NOEXCEPT {
        return m_oPointStayTime_;
    }

    const uint8_t& oPointStayTime() const OMG_NOEXCEPT {
        return m_oPointStayTime_;
    }

    void oPointStayTime(uint8_t value) {
        m_oPointStayTime_ = value;
    }

    bool operator == (const ST_EOTE_MOVING_SEARCHING_INFO& other_) const;
    bool operator != (const ST_EOTE_MOVING_SEARCHING_INFO& other_) const;

    void swap(ST_EOTE_MOVING_SEARCHING_INFO& other_) OMG_NOEXCEPT ;

  private:

    int16_t m_sPointAzimuth_;
    int16_t m_sPointElevation_;
    uint16_t m_usPointViewAngle_;
    uint8_t m_oPointMovingTime_;
    uint8_t m_oPointStayTime_;

};

inline void swap(ST_EOTE_MOVING_SEARCHING_INFO& a, ST_EOTE_MOVING_SEARCHING_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EOTE_MOVING_SEARCHING_INFO& sample);

class NDDSUSERDllExport IFCCTR_EOTE_MOVE_INFO_RESPONSE {
  public:
    IFCCTR_EOTE_MOVE_INFO_RESPONSE();

    IFCCTR_EOTE_MOVE_INFO_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usDistrictNumber,uint16_t usReserved2,const ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& stPointInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_MOVE_INFO_RESPONSE (IFCCTR_EOTE_MOVE_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_MOVE_INFO_RESPONSE& operator=(IFCCTR_EOTE_MOVE_INFO_RESPONSE&&) = default;
    IFCCTR_EOTE_MOVE_INFO_RESPONSE& operator=(const IFCCTR_EOTE_MOVE_INFO_RESPONSE&) = default;
    IFCCTR_EOTE_MOVE_INFO_RESPONSE(const IFCCTR_EOTE_MOVE_INFO_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_MOVE_INFO_RESPONSE(IFCCTR_EOTE_MOVE_INFO_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_MOVE_INFO_RESPONSE& operator=(IFCCTR_EOTE_MOVE_INFO_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usDistrictNumber() OMG_NOEXCEPT {
        return m_usDistrictNumber_;
    }

    const uint16_t& usDistrictNumber() const OMG_NOEXCEPT {
        return m_usDistrictNumber_;
    }

    void usDistrictNumber(uint16_t value) {
        m_usDistrictNumber_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& stPointInfo() OMG_NOEXCEPT {
        return m_stPointInfo_;
    }

    const ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& stPointInfo() const OMG_NOEXCEPT {
        return m_stPointInfo_;
    }

    void stPointInfo(const ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& value) {
        m_stPointInfo_ = value;
    }

    void stPointInfo(::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>&& value) {
        m_stPointInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_EOTE_MOVE_INFO_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_MOVE_INFO_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_MOVE_INFO_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usDistrictNumber_;
    uint16_t m_usReserved2_;
    ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L> m_stPointInfo_;

};

inline void swap(IFCCTR_EOTE_MOVE_INFO_RESPONSE& a, IFCCTR_EOTE_MOVE_INFO_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_MOVE_INFO_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_MOVE_SET_RESPONSE {
  public:
    IFCCTR_EOTE_MOVE_SET_RESPONSE();

    IFCCTR_EOTE_MOVE_SET_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usMovingSearchingDistrictAck,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_MOVE_SET_RESPONSE (IFCCTR_EOTE_MOVE_SET_RESPONSE&&) = default;
    IFCCTR_EOTE_MOVE_SET_RESPONSE& operator=(IFCCTR_EOTE_MOVE_SET_RESPONSE&&) = default;
    IFCCTR_EOTE_MOVE_SET_RESPONSE& operator=(const IFCCTR_EOTE_MOVE_SET_RESPONSE&) = default;
    IFCCTR_EOTE_MOVE_SET_RESPONSE(const IFCCTR_EOTE_MOVE_SET_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_MOVE_SET_RESPONSE(IFCCTR_EOTE_MOVE_SET_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_MOVE_SET_RESPONSE& operator=(IFCCTR_EOTE_MOVE_SET_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usMovingSearchingDistrictAck() OMG_NOEXCEPT {
        return m_usMovingSearchingDistrictAck_;
    }

    const uint16_t& usMovingSearchingDistrictAck() const OMG_NOEXCEPT {
        return m_usMovingSearchingDistrictAck_;
    }

    void usMovingSearchingDistrictAck(uint16_t value) {
        m_usMovingSearchingDistrictAck_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const IFCCTR_EOTE_MOVE_SET_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_MOVE_SET_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_MOVE_SET_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usMovingSearchingDistrictAck_;
    uint16_t m_usReserved2_;

};

inline void swap(IFCCTR_EOTE_MOVE_SET_RESPONSE& a, IFCCTR_EOTE_MOVE_SET_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_MOVE_SET_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_SENSOR_CONTROL_INFO {
  public:
    IFCCTR_EOTE_SENSOR_CONTROL_INFO();

    IFCCTR_EOTE_SENSOR_CONTROL_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,int16_t sAzimuth,int16_t sElevation,uint16_t usEOZoom,uint16_t usIRZoom,uint16_t usEOFocus,uint16_t usIRFocus,uint16_t usRangeFinderPoss,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_SENSOR_CONTROL_INFO (IFCCTR_EOTE_SENSOR_CONTROL_INFO&&) = default;
    IFCCTR_EOTE_SENSOR_CONTROL_INFO& operator=(IFCCTR_EOTE_SENSOR_CONTROL_INFO&&) = default;
    IFCCTR_EOTE_SENSOR_CONTROL_INFO& operator=(const IFCCTR_EOTE_SENSOR_CONTROL_INFO&) = default;
    IFCCTR_EOTE_SENSOR_CONTROL_INFO(const IFCCTR_EOTE_SENSOR_CONTROL_INFO&) = default;
    #else
    IFCCTR_EOTE_SENSOR_CONTROL_INFO(IFCCTR_EOTE_SENSOR_CONTROL_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_SENSOR_CONTROL_INFO& operator=(IFCCTR_EOTE_SENSOR_CONTROL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    int16_t& sAzimuth() OMG_NOEXCEPT {
        return m_sAzimuth_;
    }

    const int16_t& sAzimuth() const OMG_NOEXCEPT {
        return m_sAzimuth_;
    }

    void sAzimuth(int16_t value) {
        m_sAzimuth_ = value;
    }

    int16_t& sElevation() OMG_NOEXCEPT {
        return m_sElevation_;
    }

    const int16_t& sElevation() const OMG_NOEXCEPT {
        return m_sElevation_;
    }

    void sElevation(int16_t value) {
        m_sElevation_ = value;
    }

    uint16_t& usEOZoom() OMG_NOEXCEPT {
        return m_usEOZoom_;
    }

    const uint16_t& usEOZoom() const OMG_NOEXCEPT {
        return m_usEOZoom_;
    }

    void usEOZoom(uint16_t value) {
        m_usEOZoom_ = value;
    }

    uint16_t& usIRZoom() OMG_NOEXCEPT {
        return m_usIRZoom_;
    }

    const uint16_t& usIRZoom() const OMG_NOEXCEPT {
        return m_usIRZoom_;
    }

    void usIRZoom(uint16_t value) {
        m_usIRZoom_ = value;
    }

    uint16_t& usEOFocus() OMG_NOEXCEPT {
        return m_usEOFocus_;
    }

    const uint16_t& usEOFocus() const OMG_NOEXCEPT {
        return m_usEOFocus_;
    }

    void usEOFocus(uint16_t value) {
        m_usEOFocus_ = value;
    }

    uint16_t& usIRFocus() OMG_NOEXCEPT {
        return m_usIRFocus_;
    }

    const uint16_t& usIRFocus() const OMG_NOEXCEPT {
        return m_usIRFocus_;
    }

    void usIRFocus(uint16_t value) {
        m_usIRFocus_ = value;
    }

    uint16_t& usRangeFinderPoss() OMG_NOEXCEPT {
        return m_usRangeFinderPoss_;
    }

    const uint16_t& usRangeFinderPoss() const OMG_NOEXCEPT {
        return m_usRangeFinderPoss_;
    }

    void usRangeFinderPoss(uint16_t value) {
        m_usRangeFinderPoss_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const IFCCTR_EOTE_SENSOR_CONTROL_INFO& other_) const;
    bool operator != (const IFCCTR_EOTE_SENSOR_CONTROL_INFO& other_) const;

    void swap(IFCCTR_EOTE_SENSOR_CONTROL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    int16_t m_sAzimuth_;
    int16_t m_sElevation_;
    uint16_t m_usEOZoom_;
    uint16_t m_usIRZoom_;
    uint16_t m_usEOFocus_;
    uint16_t m_usIRFocus_;
    uint16_t m_usRangeFinderPoss_;
    uint16_t m_usReserved2_;

};

inline void swap(IFCCTR_EOTE_SENSOR_CONTROL_INFO& a, IFCCTR_EOTE_SENSOR_CONTROL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_SENSOR_CONTROL_INFO& sample);

class NDDSUSERDllExport IFCCTR_EOTE_STATUS_INFO {
  public:
    IFCCTR_EOTE_STATUS_INFO();

    IFCCTR_EOTE_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint8_t oEOPowerStatus,uint8_t oIRPowerStatus,uint8_t oLaserPowerStatus,uint8_t oFanPowerStatus,uint8_t oHeaterPowerStatus,uint8_t oReserved2,uint16_t usReserved3);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_STATUS_INFO (IFCCTR_EOTE_STATUS_INFO&&) = default;
    IFCCTR_EOTE_STATUS_INFO& operator=(IFCCTR_EOTE_STATUS_INFO&&) = default;
    IFCCTR_EOTE_STATUS_INFO& operator=(const IFCCTR_EOTE_STATUS_INFO&) = default;
    IFCCTR_EOTE_STATUS_INFO(const IFCCTR_EOTE_STATUS_INFO&) = default;
    #else
    IFCCTR_EOTE_STATUS_INFO(IFCCTR_EOTE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_STATUS_INFO& operator=(IFCCTR_EOTE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint8_t& oEOPowerStatus() OMG_NOEXCEPT {
        return m_oEOPowerStatus_;
    }

    const uint8_t& oEOPowerStatus() const OMG_NOEXCEPT {
        return m_oEOPowerStatus_;
    }

    void oEOPowerStatus(uint8_t value) {
        m_oEOPowerStatus_ = value;
    }

    uint8_t& oIRPowerStatus() OMG_NOEXCEPT {
        return m_oIRPowerStatus_;
    }

    const uint8_t& oIRPowerStatus() const OMG_NOEXCEPT {
        return m_oIRPowerStatus_;
    }

    void oIRPowerStatus(uint8_t value) {
        m_oIRPowerStatus_ = value;
    }

    uint8_t& oLaserPowerStatus() OMG_NOEXCEPT {
        return m_oLaserPowerStatus_;
    }

    const uint8_t& oLaserPowerStatus() const OMG_NOEXCEPT {
        return m_oLaserPowerStatus_;
    }

    void oLaserPowerStatus(uint8_t value) {
        m_oLaserPowerStatus_ = value;
    }

    uint8_t& oFanPowerStatus() OMG_NOEXCEPT {
        return m_oFanPowerStatus_;
    }

    const uint8_t& oFanPowerStatus() const OMG_NOEXCEPT {
        return m_oFanPowerStatus_;
    }

    void oFanPowerStatus(uint8_t value) {
        m_oFanPowerStatus_ = value;
    }

    uint8_t& oHeaterPowerStatus() OMG_NOEXCEPT {
        return m_oHeaterPowerStatus_;
    }

    const uint8_t& oHeaterPowerStatus() const OMG_NOEXCEPT {
        return m_oHeaterPowerStatus_;
    }

    void oHeaterPowerStatus(uint8_t value) {
        m_oHeaterPowerStatus_ = value;
    }

    uint8_t& oReserved2() OMG_NOEXCEPT {
        return m_oReserved2_;
    }

    const uint8_t& oReserved2() const OMG_NOEXCEPT {
        return m_oReserved2_;
    }

    void oReserved2(uint8_t value) {
        m_oReserved2_ = value;
    }

    uint16_t& usReserved3() OMG_NOEXCEPT {
        return m_usReserved3_;
    }

    const uint16_t& usReserved3() const OMG_NOEXCEPT {
        return m_usReserved3_;
    }

    void usReserved3(uint16_t value) {
        m_usReserved3_ = value;
    }

    bool operator == (const IFCCTR_EOTE_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_EOTE_STATUS_INFO& other_) const;

    void swap(IFCCTR_EOTE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint8_t m_oEOPowerStatus_;
    uint8_t m_oIRPowerStatus_;
    uint8_t m_oLaserPowerStatus_;
    uint8_t m_oFanPowerStatus_;
    uint8_t m_oHeaterPowerStatus_;
    uint8_t m_oReserved2_;
    uint16_t m_usReserved3_;

};

inline void swap(IFCCTR_EOTE_STATUS_INFO& a, IFCCTR_EOTE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_EOTE_TARGET_INFO {
  public:
    IFCCTR_EOTE_TARGET_INFO();

    IFCCTR_EOTE_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usTargetTrackStatus,int16_t sTargetBearing,uint16_t usTargetDistance,int16_t sTargetElevation);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_TARGET_INFO (IFCCTR_EOTE_TARGET_INFO&&) = default;
    IFCCTR_EOTE_TARGET_INFO& operator=(IFCCTR_EOTE_TARGET_INFO&&) = default;
    IFCCTR_EOTE_TARGET_INFO& operator=(const IFCCTR_EOTE_TARGET_INFO&) = default;
    IFCCTR_EOTE_TARGET_INFO(const IFCCTR_EOTE_TARGET_INFO&) = default;
    #else
    IFCCTR_EOTE_TARGET_INFO(IFCCTR_EOTE_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_TARGET_INFO& operator=(IFCCTR_EOTE_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usTargetTrackStatus() OMG_NOEXCEPT {
        return m_usTargetTrackStatus_;
    }

    const uint16_t& usTargetTrackStatus() const OMG_NOEXCEPT {
        return m_usTargetTrackStatus_;
    }

    void usTargetTrackStatus(uint16_t value) {
        m_usTargetTrackStatus_ = value;
    }

    int16_t& sTargetBearing() OMG_NOEXCEPT {
        return m_sTargetBearing_;
    }

    const int16_t& sTargetBearing() const OMG_NOEXCEPT {
        return m_sTargetBearing_;
    }

    void sTargetBearing(int16_t value) {
        m_sTargetBearing_ = value;
    }

    uint16_t& usTargetDistance() OMG_NOEXCEPT {
        return m_usTargetDistance_;
    }

    const uint16_t& usTargetDistance() const OMG_NOEXCEPT {
        return m_usTargetDistance_;
    }

    void usTargetDistance(uint16_t value) {
        m_usTargetDistance_ = value;
    }

    int16_t& sTargetElevation() OMG_NOEXCEPT {
        return m_sTargetElevation_;
    }

    const int16_t& sTargetElevation() const OMG_NOEXCEPT {
        return m_sTargetElevation_;
    }

    void sTargetElevation(int16_t value) {
        m_sTargetElevation_ = value;
    }

    bool operator == (const IFCCTR_EOTE_TARGET_INFO& other_) const;
    bool operator != (const IFCCTR_EOTE_TARGET_INFO& other_) const;

    void swap(IFCCTR_EOTE_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usTargetTrackStatus_;
    int16_t m_sTargetBearing_;
    uint16_t m_usTargetDistance_;
    int16_t m_sTargetElevation_;

};

inline void swap(IFCCTR_EOTE_TARGET_INFO& a, IFCCTR_EOTE_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_TARGET_INFO& sample);

class NDDSUSERDllExport IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE {
  public:
    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE();

    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usTrackValueAck);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE (IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE&&) = default;
    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& operator=(const IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE&) = default;
    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE(const IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE&) = default;
    #else
    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& operator=(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usTrackValueAck() OMG_NOEXCEPT {
        return m_usTrackValueAck_;
    }

    const uint16_t& usTrackValueAck() const OMG_NOEXCEPT {
        return m_usTrackValueAck_;
    }

    void usTrackValueAck(uint16_t value) {
        m_usTrackValueAck_ = value;
    }

    bool operator == (const IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& other_) const;
    bool operator != (const IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& other_) const;

    void swap(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usTrackValueAck_;

};

inline void swap(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& a, IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& sample);

class NDDSUSERDllExport IFCCTR_EOTE_TRACK_INFO {
  public:
    IFCCTR_EOTE_TRACK_INFO();

    IFCCTR_EOTE_TRACK_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,int16_t usTargetBearing,uint16_t usTargetDistance,uint16_t usTargetTrackStatus,uint16_t usTrackingImage,uint16_t usTrackLeftPoint,uint16_t usTrackTopPoint,uint16_t usTrackHorizontalSize,uint16_t usTrackVerticalSize,int16_t sTargetElevation,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_EOTE_TRACK_INFO (IFCCTR_EOTE_TRACK_INFO&&) = default;
    IFCCTR_EOTE_TRACK_INFO& operator=(IFCCTR_EOTE_TRACK_INFO&&) = default;
    IFCCTR_EOTE_TRACK_INFO& operator=(const IFCCTR_EOTE_TRACK_INFO&) = default;
    IFCCTR_EOTE_TRACK_INFO(const IFCCTR_EOTE_TRACK_INFO&) = default;
    #else
    IFCCTR_EOTE_TRACK_INFO(IFCCTR_EOTE_TRACK_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_EOTE_TRACK_INFO& operator=(IFCCTR_EOTE_TRACK_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    int16_t& usTargetBearing() OMG_NOEXCEPT {
        return m_usTargetBearing_;
    }

    const int16_t& usTargetBearing() const OMG_NOEXCEPT {
        return m_usTargetBearing_;
    }

    void usTargetBearing(int16_t value) {
        m_usTargetBearing_ = value;
    }

    uint16_t& usTargetDistance() OMG_NOEXCEPT {
        return m_usTargetDistance_;
    }

    const uint16_t& usTargetDistance() const OMG_NOEXCEPT {
        return m_usTargetDistance_;
    }

    void usTargetDistance(uint16_t value) {
        m_usTargetDistance_ = value;
    }

    uint16_t& usTargetTrackStatus() OMG_NOEXCEPT {
        return m_usTargetTrackStatus_;
    }

    const uint16_t& usTargetTrackStatus() const OMG_NOEXCEPT {
        return m_usTargetTrackStatus_;
    }

    void usTargetTrackStatus(uint16_t value) {
        m_usTargetTrackStatus_ = value;
    }

    uint16_t& usTrackingImage() OMG_NOEXCEPT {
        return m_usTrackingImage_;
    }

    const uint16_t& usTrackingImage() const OMG_NOEXCEPT {
        return m_usTrackingImage_;
    }

    void usTrackingImage(uint16_t value) {
        m_usTrackingImage_ = value;
    }

    uint16_t& usTrackLeftPoint() OMG_NOEXCEPT {
        return m_usTrackLeftPoint_;
    }

    const uint16_t& usTrackLeftPoint() const OMG_NOEXCEPT {
        return m_usTrackLeftPoint_;
    }

    void usTrackLeftPoint(uint16_t value) {
        m_usTrackLeftPoint_ = value;
    }

    uint16_t& usTrackTopPoint() OMG_NOEXCEPT {
        return m_usTrackTopPoint_;
    }

    const uint16_t& usTrackTopPoint() const OMG_NOEXCEPT {
        return m_usTrackTopPoint_;
    }

    void usTrackTopPoint(uint16_t value) {
        m_usTrackTopPoint_ = value;
    }

    uint16_t& usTrackHorizontalSize() OMG_NOEXCEPT {
        return m_usTrackHorizontalSize_;
    }

    const uint16_t& usTrackHorizontalSize() const OMG_NOEXCEPT {
        return m_usTrackHorizontalSize_;
    }

    void usTrackHorizontalSize(uint16_t value) {
        m_usTrackHorizontalSize_ = value;
    }

    uint16_t& usTrackVerticalSize() OMG_NOEXCEPT {
        return m_usTrackVerticalSize_;
    }

    const uint16_t& usTrackVerticalSize() const OMG_NOEXCEPT {
        return m_usTrackVerticalSize_;
    }

    void usTrackVerticalSize(uint16_t value) {
        m_usTrackVerticalSize_ = value;
    }

    int16_t& sTargetElevation() OMG_NOEXCEPT {
        return m_sTargetElevation_;
    }

    const int16_t& sTargetElevation() const OMG_NOEXCEPT {
        return m_sTargetElevation_;
    }

    void sTargetElevation(int16_t value) {
        m_sTargetElevation_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const IFCCTR_EOTE_TRACK_INFO& other_) const;
    bool operator != (const IFCCTR_EOTE_TRACK_INFO& other_) const;

    void swap(IFCCTR_EOTE_TRACK_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    int16_t m_usTargetBearing_;
    uint16_t m_usTargetDistance_;
    uint16_t m_usTargetTrackStatus_;
    uint16_t m_usTrackingImage_;
    uint16_t m_usTrackLeftPoint_;
    uint16_t m_usTrackTopPoint_;
    uint16_t m_usTrackHorizontalSize_;
    uint16_t m_usTrackVerticalSize_;
    int16_t m_sTargetElevation_;
    uint16_t m_usReserved2_;

};

inline void swap(IFCCTR_EOTE_TRACK_INFO& a, IFCCTR_EOTE_TRACK_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_EOTE_TRACK_INFO& sample);

class NDDSUSERDllExport IFCCTR_KNTDS_STATUS_INFO {
  public:
    IFCCTR_KNTDS_STATUS_INFO();

    IFCCTR_KNTDS_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,int32_t lKNTStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_KNTDS_STATUS_INFO (IFCCTR_KNTDS_STATUS_INFO&&) = default;
    IFCCTR_KNTDS_STATUS_INFO& operator=(IFCCTR_KNTDS_STATUS_INFO&&) = default;
    IFCCTR_KNTDS_STATUS_INFO& operator=(const IFCCTR_KNTDS_STATUS_INFO&) = default;
    IFCCTR_KNTDS_STATUS_INFO(const IFCCTR_KNTDS_STATUS_INFO&) = default;
    #else
    IFCCTR_KNTDS_STATUS_INFO(IFCCTR_KNTDS_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_KNTDS_STATUS_INFO& operator=(IFCCTR_KNTDS_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int32_t& lKNTStatus() OMG_NOEXCEPT {
        return m_lKNTStatus_;
    }

    const int32_t& lKNTStatus() const OMG_NOEXCEPT {
        return m_lKNTStatus_;
    }

    void lKNTStatus(int32_t value) {
        m_lKNTStatus_ = value;
    }

    bool operator == (const IFCCTR_KNTDS_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_KNTDS_STATUS_INFO& other_) const;

    void swap(IFCCTR_KNTDS_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int32_t m_lKNTStatus_;

};

inline void swap(IFCCTR_KNTDS_STATUS_INFO& a, IFCCTR_KNTDS_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_KNTDS_STATUS_INFO& sample);

class NDDSUSERDllExport ST_KNTDS_TARGET {
  public:
    ST_KNTDS_TARGET();

    ST_KNTDS_TARGET(uint32_t ulTrackNo,double dLatitude,double dLongitude,float fVelocity_X,float fVelocity_Y,uint8_t ucTrackStat,uint8_t ucTrackQuality,uint8_t ucTrackSize,uint8_t ucKind,uint8_t ucClass,uint8_t ucCategory,uint8_t ucIdentify,const ST_DATE_TIME& stTimeDetectTime,const ST_DATE_TIME& stTimeRegisterTime,const ST_DATE_TIME& stMaintainTime,uint8_t ucGTRegistrated,const ::dds::core::array< uint8_t, 6L>& ucTag);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_KNTDS_TARGET (ST_KNTDS_TARGET&&) = default;
    ST_KNTDS_TARGET& operator=(ST_KNTDS_TARGET&&) = default;
    ST_KNTDS_TARGET& operator=(const ST_KNTDS_TARGET&) = default;
    ST_KNTDS_TARGET(const ST_KNTDS_TARGET&) = default;
    #else
    ST_KNTDS_TARGET(ST_KNTDS_TARGET&& other_) OMG_NOEXCEPT;  
    ST_KNTDS_TARGET& operator=(ST_KNTDS_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulTrackNo() OMG_NOEXCEPT {
        return m_ulTrackNo_;
    }

    const uint32_t& ulTrackNo() const OMG_NOEXCEPT {
        return m_ulTrackNo_;
    }

    void ulTrackNo(uint32_t value) {
        m_ulTrackNo_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fVelocity_X() OMG_NOEXCEPT {
        return m_fVelocity_X_;
    }

    const float& fVelocity_X() const OMG_NOEXCEPT {
        return m_fVelocity_X_;
    }

    void fVelocity_X(float value) {
        m_fVelocity_X_ = value;
    }

    float& fVelocity_Y() OMG_NOEXCEPT {
        return m_fVelocity_Y_;
    }

    const float& fVelocity_Y() const OMG_NOEXCEPT {
        return m_fVelocity_Y_;
    }

    void fVelocity_Y(float value) {
        m_fVelocity_Y_ = value;
    }

    uint8_t& ucTrackStat() OMG_NOEXCEPT {
        return m_ucTrackStat_;
    }

    const uint8_t& ucTrackStat() const OMG_NOEXCEPT {
        return m_ucTrackStat_;
    }

    void ucTrackStat(uint8_t value) {
        m_ucTrackStat_ = value;
    }

    uint8_t& ucTrackQuality() OMG_NOEXCEPT {
        return m_ucTrackQuality_;
    }

    const uint8_t& ucTrackQuality() const OMG_NOEXCEPT {
        return m_ucTrackQuality_;
    }

    void ucTrackQuality(uint8_t value) {
        m_ucTrackQuality_ = value;
    }

    uint8_t& ucTrackSize() OMG_NOEXCEPT {
        return m_ucTrackSize_;
    }

    const uint8_t& ucTrackSize() const OMG_NOEXCEPT {
        return m_ucTrackSize_;
    }

    void ucTrackSize(uint8_t value) {
        m_ucTrackSize_ = value;
    }

    uint8_t& ucKind() OMG_NOEXCEPT {
        return m_ucKind_;
    }

    const uint8_t& ucKind() const OMG_NOEXCEPT {
        return m_ucKind_;
    }

    void ucKind(uint8_t value) {
        m_ucKind_ = value;
    }

    uint8_t& ucClass() OMG_NOEXCEPT {
        return m_ucClass_;
    }

    const uint8_t& ucClass() const OMG_NOEXCEPT {
        return m_ucClass_;
    }

    void ucClass(uint8_t value) {
        m_ucClass_ = value;
    }

    uint8_t& ucCategory() OMG_NOEXCEPT {
        return m_ucCategory_;
    }

    const uint8_t& ucCategory() const OMG_NOEXCEPT {
        return m_ucCategory_;
    }

    void ucCategory(uint8_t value) {
        m_ucCategory_ = value;
    }

    uint8_t& ucIdentify() OMG_NOEXCEPT {
        return m_ucIdentify_;
    }

    const uint8_t& ucIdentify() const OMG_NOEXCEPT {
        return m_ucIdentify_;
    }

    void ucIdentify(uint8_t value) {
        m_ucIdentify_ = value;
    }

    ST_DATE_TIME& stTimeDetectTime() OMG_NOEXCEPT {
        return m_stTimeDetectTime_;
    }

    const ST_DATE_TIME& stTimeDetectTime() const OMG_NOEXCEPT {
        return m_stTimeDetectTime_;
    }

    void stTimeDetectTime(const ST_DATE_TIME& value) {
        m_stTimeDetectTime_ = value;
    }

    void stTimeDetectTime(ST_DATE_TIME&& value) {
        m_stTimeDetectTime_ = std::move(value);
    }
    ST_DATE_TIME& stTimeRegisterTime() OMG_NOEXCEPT {
        return m_stTimeRegisterTime_;
    }

    const ST_DATE_TIME& stTimeRegisterTime() const OMG_NOEXCEPT {
        return m_stTimeRegisterTime_;
    }

    void stTimeRegisterTime(const ST_DATE_TIME& value) {
        m_stTimeRegisterTime_ = value;
    }

    void stTimeRegisterTime(ST_DATE_TIME&& value) {
        m_stTimeRegisterTime_ = std::move(value);
    }
    ST_DATE_TIME& stMaintainTime() OMG_NOEXCEPT {
        return m_stMaintainTime_;
    }

    const ST_DATE_TIME& stMaintainTime() const OMG_NOEXCEPT {
        return m_stMaintainTime_;
    }

    void stMaintainTime(const ST_DATE_TIME& value) {
        m_stMaintainTime_ = value;
    }

    void stMaintainTime(ST_DATE_TIME&& value) {
        m_stMaintainTime_ = std::move(value);
    }
    uint8_t& ucGTRegistrated() OMG_NOEXCEPT {
        return m_ucGTRegistrated_;
    }

    const uint8_t& ucGTRegistrated() const OMG_NOEXCEPT {
        return m_ucGTRegistrated_;
    }

    void ucGTRegistrated(uint8_t value) {
        m_ucGTRegistrated_ = value;
    }

    ::dds::core::array< uint8_t, 6L>& ucTag() OMG_NOEXCEPT {
        return m_ucTag_;
    }

    const ::dds::core::array< uint8_t, 6L>& ucTag() const OMG_NOEXCEPT {
        return m_ucTag_;
    }

    void ucTag(const ::dds::core::array< uint8_t, 6L>& value) {
        m_ucTag_ = value;
    }

    void ucTag(::dds::core::array< uint8_t, 6L>&& value) {
        m_ucTag_ = std::move(value);
    }

    bool operator == (const ST_KNTDS_TARGET& other_) const;
    bool operator != (const ST_KNTDS_TARGET& other_) const;

    void swap(ST_KNTDS_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulTrackNo_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fVelocity_X_;
    float m_fVelocity_Y_;
    uint8_t m_ucTrackStat_;
    uint8_t m_ucTrackQuality_;
    uint8_t m_ucTrackSize_;
    uint8_t m_ucKind_;
    uint8_t m_ucClass_;
    uint8_t m_ucCategory_;
    uint8_t m_ucIdentify_;
    ST_DATE_TIME m_stTimeDetectTime_;
    ST_DATE_TIME m_stTimeRegisterTime_;
    ST_DATE_TIME m_stMaintainTime_;
    uint8_t m_ucGTRegistrated_;
    ::dds::core::array< uint8_t, 6L> m_ucTag_;

};

inline void swap(ST_KNTDS_TARGET& a, ST_KNTDS_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_KNTDS_TARGET& sample);

class NDDSUSERDllExport IFCCTR_KNTDS_TARGET_DATA_INFO {
  public:
    IFCCTR_KNTDS_TARGET_DATA_INFO();

    IFCCTR_KNTDS_TARGET_DATA_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulKNTDSTargetNumber,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_KNTDS_TARGET, 1000L>& stKNTDSTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_KNTDS_TARGET_DATA_INFO (IFCCTR_KNTDS_TARGET_DATA_INFO&&) = default;
    IFCCTR_KNTDS_TARGET_DATA_INFO& operator=(IFCCTR_KNTDS_TARGET_DATA_INFO&&) = default;
    IFCCTR_KNTDS_TARGET_DATA_INFO& operator=(const IFCCTR_KNTDS_TARGET_DATA_INFO&) = default;
    IFCCTR_KNTDS_TARGET_DATA_INFO(const IFCCTR_KNTDS_TARGET_DATA_INFO&) = default;
    #else
    IFCCTR_KNTDS_TARGET_DATA_INFO(IFCCTR_KNTDS_TARGET_DATA_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_KNTDS_TARGET_DATA_INFO& operator=(IFCCTR_KNTDS_TARGET_DATA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulKNTDSTargetNumber() OMG_NOEXCEPT {
        return m_ulKNTDSTargetNumber_;
    }

    const uint32_t& ulKNTDSTargetNumber() const OMG_NOEXCEPT {
        return m_ulKNTDSTargetNumber_;
    }

    void ulKNTDSTargetNumber(uint32_t value) {
        m_ulKNTDSTargetNumber_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_KNTDS_TARGET, 1000L>& stKNTDSTargetInfo() OMG_NOEXCEPT {
        return m_stKNTDSTargetInfo_;
    }

    const ::dds::core::array< ST_KNTDS_TARGET, 1000L>& stKNTDSTargetInfo() const OMG_NOEXCEPT {
        return m_stKNTDSTargetInfo_;
    }

    void stKNTDSTargetInfo(const ::dds::core::array< ST_KNTDS_TARGET, 1000L>& value) {
        m_stKNTDSTargetInfo_ = value;
    }

    void stKNTDSTargetInfo(::dds::core::array< ST_KNTDS_TARGET, 1000L>&& value) {
        m_stKNTDSTargetInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_KNTDS_TARGET_DATA_INFO& other_) const;
    bool operator != (const IFCCTR_KNTDS_TARGET_DATA_INFO& other_) const;

    void swap(IFCCTR_KNTDS_TARGET_DATA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulKNTDSTargetNumber_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_KNTDS_TARGET, 1000L> m_stKNTDSTargetInfo_;

};

inline void swap(IFCCTR_KNTDS_TARGET_DATA_INFO& a, IFCCTR_KNTDS_TARGET_DATA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_KNTDS_TARGET_DATA_INFO& sample);

class NDDSUSERDllExport ST_RD_IMAGE {
  public:
    ST_RD_IMAGE();

    ST_RD_IMAGE(uint32_t ulRadarNum,uint8_t ucFTC,uint8_t ucSTC,uint8_t unCACFAR,uint8_t ucReserved,uint16_t usReserved,uint16_t usDispalyArea,const ST_DATE_TIME& stTimeGetTime,float fLeftUpperRange,float fLeftUpperAzimuth,float fRightLowerRange,float fRightLowerAzimuth,uint32_t ulSizeOfCompressedRDImage,const ::dds::core::array< uint8_t, 259200L>& ucCompressedRDImage,uint32_t ulSizeOfCenterCompressedRDImage,const ::dds::core::array< uint8_t, 259200L>& ucCenterCompressedRDImage);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_RD_IMAGE (ST_RD_IMAGE&&) = default;
    ST_RD_IMAGE& operator=(ST_RD_IMAGE&&) = default;
    ST_RD_IMAGE& operator=(const ST_RD_IMAGE&) = default;
    ST_RD_IMAGE(const ST_RD_IMAGE&) = default;
    #else
    ST_RD_IMAGE(ST_RD_IMAGE&& other_) OMG_NOEXCEPT;  
    ST_RD_IMAGE& operator=(ST_RD_IMAGE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulRadarNum() OMG_NOEXCEPT {
        return m_ulRadarNum_;
    }

    const uint32_t& ulRadarNum() const OMG_NOEXCEPT {
        return m_ulRadarNum_;
    }

    void ulRadarNum(uint32_t value) {
        m_ulRadarNum_ = value;
    }

    uint8_t& ucFTC() OMG_NOEXCEPT {
        return m_ucFTC_;
    }

    const uint8_t& ucFTC() const OMG_NOEXCEPT {
        return m_ucFTC_;
    }

    void ucFTC(uint8_t value) {
        m_ucFTC_ = value;
    }

    uint8_t& ucSTC() OMG_NOEXCEPT {
        return m_ucSTC_;
    }

    const uint8_t& ucSTC() const OMG_NOEXCEPT {
        return m_ucSTC_;
    }

    void ucSTC(uint8_t value) {
        m_ucSTC_ = value;
    }

    uint8_t& unCACFAR() OMG_NOEXCEPT {
        return m_unCACFAR_;
    }

    const uint8_t& unCACFAR() const OMG_NOEXCEPT {
        return m_unCACFAR_;
    }

    void unCACFAR(uint8_t value) {
        m_unCACFAR_ = value;
    }

    uint8_t& ucReserved() OMG_NOEXCEPT {
        return m_ucReserved_;
    }

    const uint8_t& ucReserved() const OMG_NOEXCEPT {
        return m_ucReserved_;
    }

    void ucReserved(uint8_t value) {
        m_ucReserved_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usDispalyArea() OMG_NOEXCEPT {
        return m_usDispalyArea_;
    }

    const uint16_t& usDispalyArea() const OMG_NOEXCEPT {
        return m_usDispalyArea_;
    }

    void usDispalyArea(uint16_t value) {
        m_usDispalyArea_ = value;
    }

    ST_DATE_TIME& stTimeGetTime() OMG_NOEXCEPT {
        return m_stTimeGetTime_;
    }

    const ST_DATE_TIME& stTimeGetTime() const OMG_NOEXCEPT {
        return m_stTimeGetTime_;
    }

    void stTimeGetTime(const ST_DATE_TIME& value) {
        m_stTimeGetTime_ = value;
    }

    void stTimeGetTime(ST_DATE_TIME&& value) {
        m_stTimeGetTime_ = std::move(value);
    }
    float& fLeftUpperRange() OMG_NOEXCEPT {
        return m_fLeftUpperRange_;
    }

    const float& fLeftUpperRange() const OMG_NOEXCEPT {
        return m_fLeftUpperRange_;
    }

    void fLeftUpperRange(float value) {
        m_fLeftUpperRange_ = value;
    }

    float& fLeftUpperAzimuth() OMG_NOEXCEPT {
        return m_fLeftUpperAzimuth_;
    }

    const float& fLeftUpperAzimuth() const OMG_NOEXCEPT {
        return m_fLeftUpperAzimuth_;
    }

    void fLeftUpperAzimuth(float value) {
        m_fLeftUpperAzimuth_ = value;
    }

    float& fRightLowerRange() OMG_NOEXCEPT {
        return m_fRightLowerRange_;
    }

    const float& fRightLowerRange() const OMG_NOEXCEPT {
        return m_fRightLowerRange_;
    }

    void fRightLowerRange(float value) {
        m_fRightLowerRange_ = value;
    }

    float& fRightLowerAzimuth() OMG_NOEXCEPT {
        return m_fRightLowerAzimuth_;
    }

    const float& fRightLowerAzimuth() const OMG_NOEXCEPT {
        return m_fRightLowerAzimuth_;
    }

    void fRightLowerAzimuth(float value) {
        m_fRightLowerAzimuth_ = value;
    }

    uint32_t& ulSizeOfCompressedRDImage() OMG_NOEXCEPT {
        return m_ulSizeOfCompressedRDImage_;
    }

    const uint32_t& ulSizeOfCompressedRDImage() const OMG_NOEXCEPT {
        return m_ulSizeOfCompressedRDImage_;
    }

    void ulSizeOfCompressedRDImage(uint32_t value) {
        m_ulSizeOfCompressedRDImage_ = value;
    }

    ::dds::core::array< uint8_t, 259200L>& ucCompressedRDImage() OMG_NOEXCEPT {
        return m_ucCompressedRDImage_;
    }

    const ::dds::core::array< uint8_t, 259200L>& ucCompressedRDImage() const OMG_NOEXCEPT {
        return m_ucCompressedRDImage_;
    }

    void ucCompressedRDImage(const ::dds::core::array< uint8_t, 259200L>& value) {
        m_ucCompressedRDImage_ = value;
    }

    void ucCompressedRDImage(::dds::core::array< uint8_t, 259200L>&& value) {
        m_ucCompressedRDImage_ = std::move(value);
    }
    uint32_t& ulSizeOfCenterCompressedRDImage() OMG_NOEXCEPT {
        return m_ulSizeOfCenterCompressedRDImage_;
    }

    const uint32_t& ulSizeOfCenterCompressedRDImage() const OMG_NOEXCEPT {
        return m_ulSizeOfCenterCompressedRDImage_;
    }

    void ulSizeOfCenterCompressedRDImage(uint32_t value) {
        m_ulSizeOfCenterCompressedRDImage_ = value;
    }

    ::dds::core::array< uint8_t, 259200L>& ucCenterCompressedRDImage() OMG_NOEXCEPT {
        return m_ucCenterCompressedRDImage_;
    }

    const ::dds::core::array< uint8_t, 259200L>& ucCenterCompressedRDImage() const OMG_NOEXCEPT {
        return m_ucCenterCompressedRDImage_;
    }

    void ucCenterCompressedRDImage(const ::dds::core::array< uint8_t, 259200L>& value) {
        m_ucCenterCompressedRDImage_ = value;
    }

    void ucCenterCompressedRDImage(::dds::core::array< uint8_t, 259200L>&& value) {
        m_ucCenterCompressedRDImage_ = std::move(value);
    }

    bool operator == (const ST_RD_IMAGE& other_) const;
    bool operator != (const ST_RD_IMAGE& other_) const;

    void swap(ST_RD_IMAGE& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulRadarNum_;
    uint8_t m_ucFTC_;
    uint8_t m_ucSTC_;
    uint8_t m_unCACFAR_;
    uint8_t m_ucReserved_;
    uint16_t m_usReserved_;
    uint16_t m_usDispalyArea_;
    ST_DATE_TIME m_stTimeGetTime_;
    float m_fLeftUpperRange_;
    float m_fLeftUpperAzimuth_;
    float m_fRightLowerRange_;
    float m_fRightLowerAzimuth_;
    uint32_t m_ulSizeOfCompressedRDImage_;
    ::dds::core::array< uint8_t, 259200L> m_ucCompressedRDImage_;
    uint32_t m_ulSizeOfCenterCompressedRDImage_;
    ::dds::core::array< uint8_t, 259200L> m_ucCenterCompressedRDImage_;

};

inline void swap(ST_RD_IMAGE& a, ST_RD_IMAGE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_RD_IMAGE& sample);

class NDDSUSERDllExport IFCCTR_RD_IMAGE_DATA_INFO {
  public:
    IFCCTR_RD_IMAGE_DATA_INFO();

    IFCCTR_RD_IMAGE_DATA_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_RD_IMAGE& stRadarImageInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_RD_IMAGE_DATA_INFO (IFCCTR_RD_IMAGE_DATA_INFO&&) = default;
    IFCCTR_RD_IMAGE_DATA_INFO& operator=(IFCCTR_RD_IMAGE_DATA_INFO&&) = default;
    IFCCTR_RD_IMAGE_DATA_INFO& operator=(const IFCCTR_RD_IMAGE_DATA_INFO&) = default;
    IFCCTR_RD_IMAGE_DATA_INFO(const IFCCTR_RD_IMAGE_DATA_INFO&) = default;
    #else
    IFCCTR_RD_IMAGE_DATA_INFO(IFCCTR_RD_IMAGE_DATA_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_RD_IMAGE_DATA_INFO& operator=(IFCCTR_RD_IMAGE_DATA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_RD_IMAGE& stRadarImageInfo() OMG_NOEXCEPT {
        return m_stRadarImageInfo_;
    }

    const ST_RD_IMAGE& stRadarImageInfo() const OMG_NOEXCEPT {
        return m_stRadarImageInfo_;
    }

    void stRadarImageInfo(const ST_RD_IMAGE& value) {
        m_stRadarImageInfo_ = value;
    }

    void stRadarImageInfo(ST_RD_IMAGE&& value) {
        m_stRadarImageInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_RD_IMAGE_DATA_INFO& other_) const;
    bool operator != (const IFCCTR_RD_IMAGE_DATA_INFO& other_) const;

    void swap(IFCCTR_RD_IMAGE_DATA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_RD_IMAGE m_stRadarImageInfo_;

};

inline void swap(IFCCTR_RD_IMAGE_DATA_INFO& a, IFCCTR_RD_IMAGE_DATA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_RD_IMAGE_DATA_INFO& sample);

class NDDSUSERDllExport IFCCTR_RD_OPERATION_STATUS_INFO {
  public:
    IFCCTR_RD_OPERATION_STATUS_INFO();

    IFCCTR_RD_OPERATION_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulRadarID,uint8_t ucRadarIFCBitResult,uint8_t ucImageConverterBitResult,uint8_t ucTrackProcCardBitResult,uint8_t ucSignalCardBitResult,uint8_t ucFTC,uint8_t ucSTC,uint8_t ucCACFAR,uint8_t ucReserved,uint8_t ucImageGain,uint8_t ucPulseMode,uint8_t ucDetectRange,uint8_t ucRadarChannel,uint8_t ucAutoDetectCount,uint8_t ucAutoLowSpeed,uint8_t ucAutoHighSpeed,uint8_t ucTrackingCancelCnt,uint8_t ucSemiAutoDetectCount,uint8_t ucSemiAutoLowSpeed,uint8_t ucSemiAutoHighSpeed,uint8_t ucReserved1,const ST_DATE_TIME& stDetectionTime,uint16_t usTargetMode,uint16_t usNoOfTgts);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_RD_OPERATION_STATUS_INFO (IFCCTR_RD_OPERATION_STATUS_INFO&&) = default;
    IFCCTR_RD_OPERATION_STATUS_INFO& operator=(IFCCTR_RD_OPERATION_STATUS_INFO&&) = default;
    IFCCTR_RD_OPERATION_STATUS_INFO& operator=(const IFCCTR_RD_OPERATION_STATUS_INFO&) = default;
    IFCCTR_RD_OPERATION_STATUS_INFO(const IFCCTR_RD_OPERATION_STATUS_INFO&) = default;
    #else
    IFCCTR_RD_OPERATION_STATUS_INFO(IFCCTR_RD_OPERATION_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_RD_OPERATION_STATUS_INFO& operator=(IFCCTR_RD_OPERATION_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulRadarID() OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    const uint32_t& ulRadarID() const OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    void ulRadarID(uint32_t value) {
        m_ulRadarID_ = value;
    }

    uint8_t& ucRadarIFCBitResult() OMG_NOEXCEPT {
        return m_ucRadarIFCBitResult_;
    }

    const uint8_t& ucRadarIFCBitResult() const OMG_NOEXCEPT {
        return m_ucRadarIFCBitResult_;
    }

    void ucRadarIFCBitResult(uint8_t value) {
        m_ucRadarIFCBitResult_ = value;
    }

    uint8_t& ucImageConverterBitResult() OMG_NOEXCEPT {
        return m_ucImageConverterBitResult_;
    }

    const uint8_t& ucImageConverterBitResult() const OMG_NOEXCEPT {
        return m_ucImageConverterBitResult_;
    }

    void ucImageConverterBitResult(uint8_t value) {
        m_ucImageConverterBitResult_ = value;
    }

    uint8_t& ucTrackProcCardBitResult() OMG_NOEXCEPT {
        return m_ucTrackProcCardBitResult_;
    }

    const uint8_t& ucTrackProcCardBitResult() const OMG_NOEXCEPT {
        return m_ucTrackProcCardBitResult_;
    }

    void ucTrackProcCardBitResult(uint8_t value) {
        m_ucTrackProcCardBitResult_ = value;
    }

    uint8_t& ucSignalCardBitResult() OMG_NOEXCEPT {
        return m_ucSignalCardBitResult_;
    }

    const uint8_t& ucSignalCardBitResult() const OMG_NOEXCEPT {
        return m_ucSignalCardBitResult_;
    }

    void ucSignalCardBitResult(uint8_t value) {
        m_ucSignalCardBitResult_ = value;
    }

    uint8_t& ucFTC() OMG_NOEXCEPT {
        return m_ucFTC_;
    }

    const uint8_t& ucFTC() const OMG_NOEXCEPT {
        return m_ucFTC_;
    }

    void ucFTC(uint8_t value) {
        m_ucFTC_ = value;
    }

    uint8_t& ucSTC() OMG_NOEXCEPT {
        return m_ucSTC_;
    }

    const uint8_t& ucSTC() const OMG_NOEXCEPT {
        return m_ucSTC_;
    }

    void ucSTC(uint8_t value) {
        m_ucSTC_ = value;
    }

    uint8_t& ucCACFAR() OMG_NOEXCEPT {
        return m_ucCACFAR_;
    }

    const uint8_t& ucCACFAR() const OMG_NOEXCEPT {
        return m_ucCACFAR_;
    }

    void ucCACFAR(uint8_t value) {
        m_ucCACFAR_ = value;
    }

    uint8_t& ucReserved() OMG_NOEXCEPT {
        return m_ucReserved_;
    }

    const uint8_t& ucReserved() const OMG_NOEXCEPT {
        return m_ucReserved_;
    }

    void ucReserved(uint8_t value) {
        m_ucReserved_ = value;
    }

    uint8_t& ucImageGain() OMG_NOEXCEPT {
        return m_ucImageGain_;
    }

    const uint8_t& ucImageGain() const OMG_NOEXCEPT {
        return m_ucImageGain_;
    }

    void ucImageGain(uint8_t value) {
        m_ucImageGain_ = value;
    }

    uint8_t& ucPulseMode() OMG_NOEXCEPT {
        return m_ucPulseMode_;
    }

    const uint8_t& ucPulseMode() const OMG_NOEXCEPT {
        return m_ucPulseMode_;
    }

    void ucPulseMode(uint8_t value) {
        m_ucPulseMode_ = value;
    }

    uint8_t& ucDetectRange() OMG_NOEXCEPT {
        return m_ucDetectRange_;
    }

    const uint8_t& ucDetectRange() const OMG_NOEXCEPT {
        return m_ucDetectRange_;
    }

    void ucDetectRange(uint8_t value) {
        m_ucDetectRange_ = value;
    }

    uint8_t& ucRadarChannel() OMG_NOEXCEPT {
        return m_ucRadarChannel_;
    }

    const uint8_t& ucRadarChannel() const OMG_NOEXCEPT {
        return m_ucRadarChannel_;
    }

    void ucRadarChannel(uint8_t value) {
        m_ucRadarChannel_ = value;
    }

    uint8_t& ucAutoDetectCount() OMG_NOEXCEPT {
        return m_ucAutoDetectCount_;
    }

    const uint8_t& ucAutoDetectCount() const OMG_NOEXCEPT {
        return m_ucAutoDetectCount_;
    }

    void ucAutoDetectCount(uint8_t value) {
        m_ucAutoDetectCount_ = value;
    }

    uint8_t& ucAutoLowSpeed() OMG_NOEXCEPT {
        return m_ucAutoLowSpeed_;
    }

    const uint8_t& ucAutoLowSpeed() const OMG_NOEXCEPT {
        return m_ucAutoLowSpeed_;
    }

    void ucAutoLowSpeed(uint8_t value) {
        m_ucAutoLowSpeed_ = value;
    }

    uint8_t& ucAutoHighSpeed() OMG_NOEXCEPT {
        return m_ucAutoHighSpeed_;
    }

    const uint8_t& ucAutoHighSpeed() const OMG_NOEXCEPT {
        return m_ucAutoHighSpeed_;
    }

    void ucAutoHighSpeed(uint8_t value) {
        m_ucAutoHighSpeed_ = value;
    }

    uint8_t& ucTrackingCancelCnt() OMG_NOEXCEPT {
        return m_ucTrackingCancelCnt_;
    }

    const uint8_t& ucTrackingCancelCnt() const OMG_NOEXCEPT {
        return m_ucTrackingCancelCnt_;
    }

    void ucTrackingCancelCnt(uint8_t value) {
        m_ucTrackingCancelCnt_ = value;
    }

    uint8_t& ucSemiAutoDetectCount() OMG_NOEXCEPT {
        return m_ucSemiAutoDetectCount_;
    }

    const uint8_t& ucSemiAutoDetectCount() const OMG_NOEXCEPT {
        return m_ucSemiAutoDetectCount_;
    }

    void ucSemiAutoDetectCount(uint8_t value) {
        m_ucSemiAutoDetectCount_ = value;
    }

    uint8_t& ucSemiAutoLowSpeed() OMG_NOEXCEPT {
        return m_ucSemiAutoLowSpeed_;
    }

    const uint8_t& ucSemiAutoLowSpeed() const OMG_NOEXCEPT {
        return m_ucSemiAutoLowSpeed_;
    }

    void ucSemiAutoLowSpeed(uint8_t value) {
        m_ucSemiAutoLowSpeed_ = value;
    }

    uint8_t& ucSemiAutoHighSpeed() OMG_NOEXCEPT {
        return m_ucSemiAutoHighSpeed_;
    }

    const uint8_t& ucSemiAutoHighSpeed() const OMG_NOEXCEPT {
        return m_ucSemiAutoHighSpeed_;
    }

    void ucSemiAutoHighSpeed(uint8_t value) {
        m_ucSemiAutoHighSpeed_ = value;
    }

    uint8_t& ucReserved1() OMG_NOEXCEPT {
        return m_ucReserved1_;
    }

    const uint8_t& ucReserved1() const OMG_NOEXCEPT {
        return m_ucReserved1_;
    }

    void ucReserved1(uint8_t value) {
        m_ucReserved1_ = value;
    }

    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& usTargetMode() OMG_NOEXCEPT {
        return m_usTargetMode_;
    }

    const uint16_t& usTargetMode() const OMG_NOEXCEPT {
        return m_usTargetMode_;
    }

    void usTargetMode(uint16_t value) {
        m_usTargetMode_ = value;
    }

    uint16_t& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const uint16_t& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(uint16_t value) {
        m_usNoOfTgts_ = value;
    }

    bool operator == (const IFCCTR_RD_OPERATION_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_RD_OPERATION_STATUS_INFO& other_) const;

    void swap(IFCCTR_RD_OPERATION_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulRadarID_;
    uint8_t m_ucRadarIFCBitResult_;
    uint8_t m_ucImageConverterBitResult_;
    uint8_t m_ucTrackProcCardBitResult_;
    uint8_t m_ucSignalCardBitResult_;
    uint8_t m_ucFTC_;
    uint8_t m_ucSTC_;
    uint8_t m_ucCACFAR_;
    uint8_t m_ucReserved_;
    uint8_t m_ucImageGain_;
    uint8_t m_ucPulseMode_;
    uint8_t m_ucDetectRange_;
    uint8_t m_ucRadarChannel_;
    uint8_t m_ucAutoDetectCount_;
    uint8_t m_ucAutoLowSpeed_;
    uint8_t m_ucAutoHighSpeed_;
    uint8_t m_ucTrackingCancelCnt_;
    uint8_t m_ucSemiAutoDetectCount_;
    uint8_t m_ucSemiAutoLowSpeed_;
    uint8_t m_ucSemiAutoHighSpeed_;
    uint8_t m_ucReserved1_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_usTargetMode_;
    uint16_t m_usNoOfTgts_;

};

inline void swap(IFCCTR_RD_OPERATION_STATUS_INFO& a, IFCCTR_RD_OPERATION_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_RD_OPERATION_STATUS_INFO& sample);

class NDDSUSERDllExport ST_RD_STATUS_INFO {
  public:
    ST_RD_STATUS_INFO();

    ST_RD_STATUS_INFO(uint32_t ulRadarID,uint8_t ucRadarIFCBitResult,uint8_t ucImageConverterBitResult,uint8_t ucTrackProcCardBitResult,uint8_t ucSignalCardBitResult,uint8_t ucFanBlowerBitResult,uint8_t ucRadarIFCFanBitResult,uint16_t usReserved1,uint32_t ulReserved2,uint8_t ucCH1,uint8_t ucCH2,uint16_t usUsedDiskRate);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_RD_STATUS_INFO (ST_RD_STATUS_INFO&&) = default;
    ST_RD_STATUS_INFO& operator=(ST_RD_STATUS_INFO&&) = default;
    ST_RD_STATUS_INFO& operator=(const ST_RD_STATUS_INFO&) = default;
    ST_RD_STATUS_INFO(const ST_RD_STATUS_INFO&) = default;
    #else
    ST_RD_STATUS_INFO(ST_RD_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_RD_STATUS_INFO& operator=(ST_RD_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulRadarID() OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    const uint32_t& ulRadarID() const OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    void ulRadarID(uint32_t value) {
        m_ulRadarID_ = value;
    }

    uint8_t& ucRadarIFCBitResult() OMG_NOEXCEPT {
        return m_ucRadarIFCBitResult_;
    }

    const uint8_t& ucRadarIFCBitResult() const OMG_NOEXCEPT {
        return m_ucRadarIFCBitResult_;
    }

    void ucRadarIFCBitResult(uint8_t value) {
        m_ucRadarIFCBitResult_ = value;
    }

    uint8_t& ucImageConverterBitResult() OMG_NOEXCEPT {
        return m_ucImageConverterBitResult_;
    }

    const uint8_t& ucImageConverterBitResult() const OMG_NOEXCEPT {
        return m_ucImageConverterBitResult_;
    }

    void ucImageConverterBitResult(uint8_t value) {
        m_ucImageConverterBitResult_ = value;
    }

    uint8_t& ucTrackProcCardBitResult() OMG_NOEXCEPT {
        return m_ucTrackProcCardBitResult_;
    }

    const uint8_t& ucTrackProcCardBitResult() const OMG_NOEXCEPT {
        return m_ucTrackProcCardBitResult_;
    }

    void ucTrackProcCardBitResult(uint8_t value) {
        m_ucTrackProcCardBitResult_ = value;
    }

    uint8_t& ucSignalCardBitResult() OMG_NOEXCEPT {
        return m_ucSignalCardBitResult_;
    }

    const uint8_t& ucSignalCardBitResult() const OMG_NOEXCEPT {
        return m_ucSignalCardBitResult_;
    }

    void ucSignalCardBitResult(uint8_t value) {
        m_ucSignalCardBitResult_ = value;
    }

    uint8_t& ucFanBlowerBitResult() OMG_NOEXCEPT {
        return m_ucFanBlowerBitResult_;
    }

    const uint8_t& ucFanBlowerBitResult() const OMG_NOEXCEPT {
        return m_ucFanBlowerBitResult_;
    }

    void ucFanBlowerBitResult(uint8_t value) {
        m_ucFanBlowerBitResult_ = value;
    }

    uint8_t& ucRadarIFCFanBitResult() OMG_NOEXCEPT {
        return m_ucRadarIFCFanBitResult_;
    }

    const uint8_t& ucRadarIFCFanBitResult() const OMG_NOEXCEPT {
        return m_ucRadarIFCFanBitResult_;
    }

    void ucRadarIFCFanBitResult(uint8_t value) {
        m_ucRadarIFCFanBitResult_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint32_t& ulReserved2() OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    const uint32_t& ulReserved2() const OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    void ulReserved2(uint32_t value) {
        m_ulReserved2_ = value;
    }

    uint8_t& ucCH1() OMG_NOEXCEPT {
        return m_ucCH1_;
    }

    const uint8_t& ucCH1() const OMG_NOEXCEPT {
        return m_ucCH1_;
    }

    void ucCH1(uint8_t value) {
        m_ucCH1_ = value;
    }

    uint8_t& ucCH2() OMG_NOEXCEPT {
        return m_ucCH2_;
    }

    const uint8_t& ucCH2() const OMG_NOEXCEPT {
        return m_ucCH2_;
    }

    void ucCH2(uint8_t value) {
        m_ucCH2_ = value;
    }

    uint16_t& usUsedDiskRate() OMG_NOEXCEPT {
        return m_usUsedDiskRate_;
    }

    const uint16_t& usUsedDiskRate() const OMG_NOEXCEPT {
        return m_usUsedDiskRate_;
    }

    void usUsedDiskRate(uint16_t value) {
        m_usUsedDiskRate_ = value;
    }

    bool operator == (const ST_RD_STATUS_INFO& other_) const;
    bool operator != (const ST_RD_STATUS_INFO& other_) const;

    void swap(ST_RD_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulRadarID_;
    uint8_t m_ucRadarIFCBitResult_;
    uint8_t m_ucImageConverterBitResult_;
    uint8_t m_ucTrackProcCardBitResult_;
    uint8_t m_ucSignalCardBitResult_;
    uint8_t m_ucFanBlowerBitResult_;
    uint8_t m_ucRadarIFCFanBitResult_;
    uint16_t m_usReserved1_;
    uint32_t m_ulReserved2_;
    uint8_t m_ucCH1_;
    uint8_t m_ucCH2_;
    uint16_t m_usUsedDiskRate_;

};

inline void swap(ST_RD_STATUS_INFO& a, ST_RD_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_RD_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_RD_STATUS_INFO {
  public:
    IFCCTR_RD_STATUS_INFO();

    IFCCTR_RD_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_RD_STATUS_INFO& stRdStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_RD_STATUS_INFO (IFCCTR_RD_STATUS_INFO&&) = default;
    IFCCTR_RD_STATUS_INFO& operator=(IFCCTR_RD_STATUS_INFO&&) = default;
    IFCCTR_RD_STATUS_INFO& operator=(const IFCCTR_RD_STATUS_INFO&) = default;
    IFCCTR_RD_STATUS_INFO(const IFCCTR_RD_STATUS_INFO&) = default;
    #else
    IFCCTR_RD_STATUS_INFO(IFCCTR_RD_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_RD_STATUS_INFO& operator=(IFCCTR_RD_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_RD_STATUS_INFO& stRdStatusInfo() OMG_NOEXCEPT {
        return m_stRdStatusInfo_;
    }

    const ST_RD_STATUS_INFO& stRdStatusInfo() const OMG_NOEXCEPT {
        return m_stRdStatusInfo_;
    }

    void stRdStatusInfo(const ST_RD_STATUS_INFO& value) {
        m_stRdStatusInfo_ = value;
    }

    void stRdStatusInfo(ST_RD_STATUS_INFO&& value) {
        m_stRdStatusInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_RD_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_RD_STATUS_INFO& other_) const;

    void swap(IFCCTR_RD_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_RD_STATUS_INFO m_stRdStatusInfo_;

};

inline void swap(IFCCTR_RD_STATUS_INFO& a, IFCCTR_RD_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_RD_STATUS_INFO& sample);

class NDDSUSERDllExport ST_RD_TARGET {
  public:
    ST_RD_TARGET();

    ST_RD_TARGET(uint32_t ulTargetNumber,uint8_t ucReserved,uint8_t ucUserSeperation,const ::dds::core::array< uint8_t, 2L>& ucTrackReliability,uint32_t ulTrackState,uint32_t ulAutoOrSemi,float fDistance,float fBearing,float fCourse,float fSpeed,const ST_DATE_TIME& stTargetRegistrationTime,const ST_DATE_TIME& stTargetUpdateTime,const ST_DATE_TIME& stTargetHoldingTime,int32_t lTargetPositionXVector,int32_t lTargetPositionYVector,float fTargetSpeedXVector,float fTargetSpeedYVector,const ::dds::core::array< float, 4L>& fTargetPositionCovariance);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_RD_TARGET (ST_RD_TARGET&&) = default;
    ST_RD_TARGET& operator=(ST_RD_TARGET&&) = default;
    ST_RD_TARGET& operator=(const ST_RD_TARGET&) = default;
    ST_RD_TARGET(const ST_RD_TARGET&) = default;
    #else
    ST_RD_TARGET(ST_RD_TARGET&& other_) OMG_NOEXCEPT;  
    ST_RD_TARGET& operator=(ST_RD_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulTargetNumber() OMG_NOEXCEPT {
        return m_ulTargetNumber_;
    }

    const uint32_t& ulTargetNumber() const OMG_NOEXCEPT {
        return m_ulTargetNumber_;
    }

    void ulTargetNumber(uint32_t value) {
        m_ulTargetNumber_ = value;
    }

    uint8_t& ucReserved() OMG_NOEXCEPT {
        return m_ucReserved_;
    }

    const uint8_t& ucReserved() const OMG_NOEXCEPT {
        return m_ucReserved_;
    }

    void ucReserved(uint8_t value) {
        m_ucReserved_ = value;
    }

    uint8_t& ucUserSeperation() OMG_NOEXCEPT {
        return m_ucUserSeperation_;
    }

    const uint8_t& ucUserSeperation() const OMG_NOEXCEPT {
        return m_ucUserSeperation_;
    }

    void ucUserSeperation(uint8_t value) {
        m_ucUserSeperation_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& ucTrackReliability() OMG_NOEXCEPT {
        return m_ucTrackReliability_;
    }

    const ::dds::core::array< uint8_t, 2L>& ucTrackReliability() const OMG_NOEXCEPT {
        return m_ucTrackReliability_;
    }

    void ucTrackReliability(const ::dds::core::array< uint8_t, 2L>& value) {
        m_ucTrackReliability_ = value;
    }

    void ucTrackReliability(::dds::core::array< uint8_t, 2L>&& value) {
        m_ucTrackReliability_ = std::move(value);
    }
    uint32_t& ulTrackState() OMG_NOEXCEPT {
        return m_ulTrackState_;
    }

    const uint32_t& ulTrackState() const OMG_NOEXCEPT {
        return m_ulTrackState_;
    }

    void ulTrackState(uint32_t value) {
        m_ulTrackState_ = value;
    }

    uint32_t& ulAutoOrSemi() OMG_NOEXCEPT {
        return m_ulAutoOrSemi_;
    }

    const uint32_t& ulAutoOrSemi() const OMG_NOEXCEPT {
        return m_ulAutoOrSemi_;
    }

    void ulAutoOrSemi(uint32_t value) {
        m_ulAutoOrSemi_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fSpeed() OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    const float& fSpeed() const OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    void fSpeed(float value) {
        m_fSpeed_ = value;
    }

    ST_DATE_TIME& stTargetRegistrationTime() OMG_NOEXCEPT {
        return m_stTargetRegistrationTime_;
    }

    const ST_DATE_TIME& stTargetRegistrationTime() const OMG_NOEXCEPT {
        return m_stTargetRegistrationTime_;
    }

    void stTargetRegistrationTime(const ST_DATE_TIME& value) {
        m_stTargetRegistrationTime_ = value;
    }

    void stTargetRegistrationTime(ST_DATE_TIME&& value) {
        m_stTargetRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stTargetUpdateTime() OMG_NOEXCEPT {
        return m_stTargetUpdateTime_;
    }

    const ST_DATE_TIME& stTargetUpdateTime() const OMG_NOEXCEPT {
        return m_stTargetUpdateTime_;
    }

    void stTargetUpdateTime(const ST_DATE_TIME& value) {
        m_stTargetUpdateTime_ = value;
    }

    void stTargetUpdateTime(ST_DATE_TIME&& value) {
        m_stTargetUpdateTime_ = std::move(value);
    }
    ST_DATE_TIME& stTargetHoldingTime() OMG_NOEXCEPT {
        return m_stTargetHoldingTime_;
    }

    const ST_DATE_TIME& stTargetHoldingTime() const OMG_NOEXCEPT {
        return m_stTargetHoldingTime_;
    }

    void stTargetHoldingTime(const ST_DATE_TIME& value) {
        m_stTargetHoldingTime_ = value;
    }

    void stTargetHoldingTime(ST_DATE_TIME&& value) {
        m_stTargetHoldingTime_ = std::move(value);
    }
    int32_t& lTargetPositionXVector() OMG_NOEXCEPT {
        return m_lTargetPositionXVector_;
    }

    const int32_t& lTargetPositionXVector() const OMG_NOEXCEPT {
        return m_lTargetPositionXVector_;
    }

    void lTargetPositionXVector(int32_t value) {
        m_lTargetPositionXVector_ = value;
    }

    int32_t& lTargetPositionYVector() OMG_NOEXCEPT {
        return m_lTargetPositionYVector_;
    }

    const int32_t& lTargetPositionYVector() const OMG_NOEXCEPT {
        return m_lTargetPositionYVector_;
    }

    void lTargetPositionYVector(int32_t value) {
        m_lTargetPositionYVector_ = value;
    }

    float& fTargetSpeedXVector() OMG_NOEXCEPT {
        return m_fTargetSpeedXVector_;
    }

    const float& fTargetSpeedXVector() const OMG_NOEXCEPT {
        return m_fTargetSpeedXVector_;
    }

    void fTargetSpeedXVector(float value) {
        m_fTargetSpeedXVector_ = value;
    }

    float& fTargetSpeedYVector() OMG_NOEXCEPT {
        return m_fTargetSpeedYVector_;
    }

    const float& fTargetSpeedYVector() const OMG_NOEXCEPT {
        return m_fTargetSpeedYVector_;
    }

    void fTargetSpeedYVector(float value) {
        m_fTargetSpeedYVector_ = value;
    }

    ::dds::core::array< float, 4L>& fTargetPositionCovariance() OMG_NOEXCEPT {
        return m_fTargetPositionCovariance_;
    }

    const ::dds::core::array< float, 4L>& fTargetPositionCovariance() const OMG_NOEXCEPT {
        return m_fTargetPositionCovariance_;
    }

    void fTargetPositionCovariance(const ::dds::core::array< float, 4L>& value) {
        m_fTargetPositionCovariance_ = value;
    }

    void fTargetPositionCovariance(::dds::core::array< float, 4L>&& value) {
        m_fTargetPositionCovariance_ = std::move(value);
    }

    bool operator == (const ST_RD_TARGET& other_) const;
    bool operator != (const ST_RD_TARGET& other_) const;

    void swap(ST_RD_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulTargetNumber_;
    uint8_t m_ucReserved_;
    uint8_t m_ucUserSeperation_;
    ::dds::core::array< uint8_t, 2L> m_ucTrackReliability_;
    uint32_t m_ulTrackState_;
    uint32_t m_ulAutoOrSemi_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fCourse_;
    float m_fSpeed_;
    ST_DATE_TIME m_stTargetRegistrationTime_;
    ST_DATE_TIME m_stTargetUpdateTime_;
    ST_DATE_TIME m_stTargetHoldingTime_;
    int32_t m_lTargetPositionXVector_;
    int32_t m_lTargetPositionYVector_;
    float m_fTargetSpeedXVector_;
    float m_fTargetSpeedYVector_;
    ::dds::core::array< float, 4L> m_fTargetPositionCovariance_;

};

inline void swap(ST_RD_TARGET& a, ST_RD_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_RD_TARGET& sample);

class NDDSUSERDllExport IFCCTR_RD_TARGET_DATA_INFO {
  public:
    IFCCTR_RD_TARGET_DATA_INFO();

    IFCCTR_RD_TARGET_DATA_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulRadarID,uint8_t ucRadarIFCBitResult,uint8_t ucImageConverterBitResult,uint8_t ucTrackProcCardBitResult,uint8_t ucSignalCardBitResult,uint8_t ucRadarChannel,uint8_t ucTrackingMode,uint16_t usReserved,const ST_DATE_TIME& stDetectionTime,uint16_t usNoOfTgts,uint16_t usReserved2,const ::dds::core::array< ST_RD_TARGET, 1000L>& stRadarTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_RD_TARGET_DATA_INFO (IFCCTR_RD_TARGET_DATA_INFO&&) = default;
    IFCCTR_RD_TARGET_DATA_INFO& operator=(IFCCTR_RD_TARGET_DATA_INFO&&) = default;
    IFCCTR_RD_TARGET_DATA_INFO& operator=(const IFCCTR_RD_TARGET_DATA_INFO&) = default;
    IFCCTR_RD_TARGET_DATA_INFO(const IFCCTR_RD_TARGET_DATA_INFO&) = default;
    #else
    IFCCTR_RD_TARGET_DATA_INFO(IFCCTR_RD_TARGET_DATA_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_RD_TARGET_DATA_INFO& operator=(IFCCTR_RD_TARGET_DATA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulRadarID() OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    const uint32_t& ulRadarID() const OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    void ulRadarID(uint32_t value) {
        m_ulRadarID_ = value;
    }

    uint8_t& ucRadarIFCBitResult() OMG_NOEXCEPT {
        return m_ucRadarIFCBitResult_;
    }

    const uint8_t& ucRadarIFCBitResult() const OMG_NOEXCEPT {
        return m_ucRadarIFCBitResult_;
    }

    void ucRadarIFCBitResult(uint8_t value) {
        m_ucRadarIFCBitResult_ = value;
    }

    uint8_t& ucImageConverterBitResult() OMG_NOEXCEPT {
        return m_ucImageConverterBitResult_;
    }

    const uint8_t& ucImageConverterBitResult() const OMG_NOEXCEPT {
        return m_ucImageConverterBitResult_;
    }

    void ucImageConverterBitResult(uint8_t value) {
        m_ucImageConverterBitResult_ = value;
    }

    uint8_t& ucTrackProcCardBitResult() OMG_NOEXCEPT {
        return m_ucTrackProcCardBitResult_;
    }

    const uint8_t& ucTrackProcCardBitResult() const OMG_NOEXCEPT {
        return m_ucTrackProcCardBitResult_;
    }

    void ucTrackProcCardBitResult(uint8_t value) {
        m_ucTrackProcCardBitResult_ = value;
    }

    uint8_t& ucSignalCardBitResult() OMG_NOEXCEPT {
        return m_ucSignalCardBitResult_;
    }

    const uint8_t& ucSignalCardBitResult() const OMG_NOEXCEPT {
        return m_ucSignalCardBitResult_;
    }

    void ucSignalCardBitResult(uint8_t value) {
        m_ucSignalCardBitResult_ = value;
    }

    uint8_t& ucRadarChannel() OMG_NOEXCEPT {
        return m_ucRadarChannel_;
    }

    const uint8_t& ucRadarChannel() const OMG_NOEXCEPT {
        return m_ucRadarChannel_;
    }

    void ucRadarChannel(uint8_t value) {
        m_ucRadarChannel_ = value;
    }

    uint8_t& ucTrackingMode() OMG_NOEXCEPT {
        return m_ucTrackingMode_;
    }

    const uint8_t& ucTrackingMode() const OMG_NOEXCEPT {
        return m_ucTrackingMode_;
    }

    void ucTrackingMode(uint8_t value) {
        m_ucTrackingMode_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const uint16_t& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(uint16_t value) {
        m_usNoOfTgts_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    ::dds::core::array< ST_RD_TARGET, 1000L>& stRadarTargetInfo() OMG_NOEXCEPT {
        return m_stRadarTargetInfo_;
    }

    const ::dds::core::array< ST_RD_TARGET, 1000L>& stRadarTargetInfo() const OMG_NOEXCEPT {
        return m_stRadarTargetInfo_;
    }

    void stRadarTargetInfo(const ::dds::core::array< ST_RD_TARGET, 1000L>& value) {
        m_stRadarTargetInfo_ = value;
    }

    void stRadarTargetInfo(::dds::core::array< ST_RD_TARGET, 1000L>&& value) {
        m_stRadarTargetInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_RD_TARGET_DATA_INFO& other_) const;
    bool operator != (const IFCCTR_RD_TARGET_DATA_INFO& other_) const;

    void swap(IFCCTR_RD_TARGET_DATA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulRadarID_;
    uint8_t m_ucRadarIFCBitResult_;
    uint8_t m_ucImageConverterBitResult_;
    uint8_t m_ucTrackProcCardBitResult_;
    uint8_t m_ucSignalCardBitResult_;
    uint8_t m_ucRadarChannel_;
    uint8_t m_ucTrackingMode_;
    uint16_t m_usReserved_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_usNoOfTgts_;
    uint16_t m_usReserved2_;
    ::dds::core::array< ST_RD_TARGET, 1000L> m_stRadarTargetInfo_;

};

inline void swap(IFCCTR_RD_TARGET_DATA_INFO& a, IFCCTR_RD_TARGET_DATA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_RD_TARGET_DATA_INFO& sample);

class NDDSUSERDllExport ST_EA_INTERWORKING_STATUS_INFO {
  public:
    ST_EA_INTERWORKING_STATUS_INFO();

    ST_EA_INTERWORKING_STATUS_INFO(uint16_t usDeviceID,uint16_t usDeviceStatus,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EA_INTERWORKING_STATUS_INFO (ST_EA_INTERWORKING_STATUS_INFO&&) = default;
    ST_EA_INTERWORKING_STATUS_INFO& operator=(ST_EA_INTERWORKING_STATUS_INFO&&) = default;
    ST_EA_INTERWORKING_STATUS_INFO& operator=(const ST_EA_INTERWORKING_STATUS_INFO&) = default;
    ST_EA_INTERWORKING_STATUS_INFO(const ST_EA_INTERWORKING_STATUS_INFO&) = default;
    #else
    ST_EA_INTERWORKING_STATUS_INFO(ST_EA_INTERWORKING_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_EA_INTERWORKING_STATUS_INFO& operator=(ST_EA_INTERWORKING_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usDeviceID() OMG_NOEXCEPT {
        return m_usDeviceID_;
    }

    const uint16_t& usDeviceID() const OMG_NOEXCEPT {
        return m_usDeviceID_;
    }

    void usDeviceID(uint16_t value) {
        m_usDeviceID_ = value;
    }

    uint16_t& usDeviceStatus() OMG_NOEXCEPT {
        return m_usDeviceStatus_;
    }

    const uint16_t& usDeviceStatus() const OMG_NOEXCEPT {
        return m_usDeviceStatus_;
    }

    void usDeviceStatus(uint16_t value) {
        m_usDeviceStatus_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const ST_EA_INTERWORKING_STATUS_INFO& other_) const;
    bool operator != (const ST_EA_INTERWORKING_STATUS_INFO& other_) const;

    void swap(ST_EA_INTERWORKING_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usDeviceID_;
    uint16_t m_usDeviceStatus_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(ST_EA_INTERWORKING_STATUS_INFO& a, ST_EA_INTERWORKING_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EA_INTERWORKING_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO {
  public:
    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO();

    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_EA_INTERWORKING_STATUS_INFO& stEaInterworkingStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO (IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO&&) = default;
    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& operator=(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO&&) = default;
    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& operator=(const IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO&) = default;
    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO(const IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO&) = default;
    #else
    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& operator=(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_EA_INTERWORKING_STATUS_INFO& stEaInterworkingStatusInfo() OMG_NOEXCEPT {
        return m_stEaInterworkingStatusInfo_;
    }

    const ST_EA_INTERWORKING_STATUS_INFO& stEaInterworkingStatusInfo() const OMG_NOEXCEPT {
        return m_stEaInterworkingStatusInfo_;
    }

    void stEaInterworkingStatusInfo(const ST_EA_INTERWORKING_STATUS_INFO& value) {
        m_stEaInterworkingStatusInfo_ = value;
    }

    void stEaInterworkingStatusInfo(ST_EA_INTERWORKING_STATUS_INFO&& value) {
        m_stEaInterworkingStatusInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& other_) const;

    void swap(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_EA_INTERWORKING_STATUS_INFO m_stEaInterworkingStatusInfo_;

};

inline void swap(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& a, IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& sample);

class NDDSUSERDllExport ST_INTERCHANGE_DEVICE_STATUS_INFO {
  public:
    ST_INTERCHANGE_DEVICE_STATUS_INFO();

    ST_INTERCHANGE_DEVICE_STATUS_INFO(uint16_t usDeviceID,uint16_t usDeviceStatus,uint16_t usMainModuleStatus,uint16_t usMainModuleStatus2,uint16_t usIOModule1Status,uint16_t usIOModule2Status,uint16_t usIOModule3Status,uint16_t usIOModule4Status,uint16_t usPowerModuleStatus,uint16_t usPowerModuleStatus2,uint16_t usFanModuleStatus,uint16_t usReserved3);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_INTERCHANGE_DEVICE_STATUS_INFO (ST_INTERCHANGE_DEVICE_STATUS_INFO&&) = default;
    ST_INTERCHANGE_DEVICE_STATUS_INFO& operator=(ST_INTERCHANGE_DEVICE_STATUS_INFO&&) = default;
    ST_INTERCHANGE_DEVICE_STATUS_INFO& operator=(const ST_INTERCHANGE_DEVICE_STATUS_INFO&) = default;
    ST_INTERCHANGE_DEVICE_STATUS_INFO(const ST_INTERCHANGE_DEVICE_STATUS_INFO&) = default;
    #else
    ST_INTERCHANGE_DEVICE_STATUS_INFO(ST_INTERCHANGE_DEVICE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_INTERCHANGE_DEVICE_STATUS_INFO& operator=(ST_INTERCHANGE_DEVICE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usDeviceID() OMG_NOEXCEPT {
        return m_usDeviceID_;
    }

    const uint16_t& usDeviceID() const OMG_NOEXCEPT {
        return m_usDeviceID_;
    }

    void usDeviceID(uint16_t value) {
        m_usDeviceID_ = value;
    }

    uint16_t& usDeviceStatus() OMG_NOEXCEPT {
        return m_usDeviceStatus_;
    }

    const uint16_t& usDeviceStatus() const OMG_NOEXCEPT {
        return m_usDeviceStatus_;
    }

    void usDeviceStatus(uint16_t value) {
        m_usDeviceStatus_ = value;
    }

    uint16_t& usMainModuleStatus() OMG_NOEXCEPT {
        return m_usMainModuleStatus_;
    }

    const uint16_t& usMainModuleStatus() const OMG_NOEXCEPT {
        return m_usMainModuleStatus_;
    }

    void usMainModuleStatus(uint16_t value) {
        m_usMainModuleStatus_ = value;
    }

    uint16_t& usMainModuleStatus2() OMG_NOEXCEPT {
        return m_usMainModuleStatus2_;
    }

    const uint16_t& usMainModuleStatus2() const OMG_NOEXCEPT {
        return m_usMainModuleStatus2_;
    }

    void usMainModuleStatus2(uint16_t value) {
        m_usMainModuleStatus2_ = value;
    }

    uint16_t& usIOModule1Status() OMG_NOEXCEPT {
        return m_usIOModule1Status_;
    }

    const uint16_t& usIOModule1Status() const OMG_NOEXCEPT {
        return m_usIOModule1Status_;
    }

    void usIOModule1Status(uint16_t value) {
        m_usIOModule1Status_ = value;
    }

    uint16_t& usIOModule2Status() OMG_NOEXCEPT {
        return m_usIOModule2Status_;
    }

    const uint16_t& usIOModule2Status() const OMG_NOEXCEPT {
        return m_usIOModule2Status_;
    }

    void usIOModule2Status(uint16_t value) {
        m_usIOModule2Status_ = value;
    }

    uint16_t& usIOModule3Status() OMG_NOEXCEPT {
        return m_usIOModule3Status_;
    }

    const uint16_t& usIOModule3Status() const OMG_NOEXCEPT {
        return m_usIOModule3Status_;
    }

    void usIOModule3Status(uint16_t value) {
        m_usIOModule3Status_ = value;
    }

    uint16_t& usIOModule4Status() OMG_NOEXCEPT {
        return m_usIOModule4Status_;
    }

    const uint16_t& usIOModule4Status() const OMG_NOEXCEPT {
        return m_usIOModule4Status_;
    }

    void usIOModule4Status(uint16_t value) {
        m_usIOModule4Status_ = value;
    }

    uint16_t& usPowerModuleStatus() OMG_NOEXCEPT {
        return m_usPowerModuleStatus_;
    }

    const uint16_t& usPowerModuleStatus() const OMG_NOEXCEPT {
        return m_usPowerModuleStatus_;
    }

    void usPowerModuleStatus(uint16_t value) {
        m_usPowerModuleStatus_ = value;
    }

    uint16_t& usPowerModuleStatus2() OMG_NOEXCEPT {
        return m_usPowerModuleStatus2_;
    }

    const uint16_t& usPowerModuleStatus2() const OMG_NOEXCEPT {
        return m_usPowerModuleStatus2_;
    }

    void usPowerModuleStatus2(uint16_t value) {
        m_usPowerModuleStatus2_ = value;
    }

    uint16_t& usFanModuleStatus() OMG_NOEXCEPT {
        return m_usFanModuleStatus_;
    }

    const uint16_t& usFanModuleStatus() const OMG_NOEXCEPT {
        return m_usFanModuleStatus_;
    }

    void usFanModuleStatus(uint16_t value) {
        m_usFanModuleStatus_ = value;
    }

    uint16_t& usReserved3() OMG_NOEXCEPT {
        return m_usReserved3_;
    }

    const uint16_t& usReserved3() const OMG_NOEXCEPT {
        return m_usReserved3_;
    }

    void usReserved3(uint16_t value) {
        m_usReserved3_ = value;
    }

    bool operator == (const ST_INTERCHANGE_DEVICE_STATUS_INFO& other_) const;
    bool operator != (const ST_INTERCHANGE_DEVICE_STATUS_INFO& other_) const;

    void swap(ST_INTERCHANGE_DEVICE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usDeviceID_;
    uint16_t m_usDeviceStatus_;
    uint16_t m_usMainModuleStatus_;
    uint16_t m_usMainModuleStatus2_;
    uint16_t m_usIOModule1Status_;
    uint16_t m_usIOModule2Status_;
    uint16_t m_usIOModule3Status_;
    uint16_t m_usIOModule4Status_;
    uint16_t m_usPowerModuleStatus_;
    uint16_t m_usPowerModuleStatus2_;
    uint16_t m_usFanModuleStatus_;
    uint16_t m_usReserved3_;

};

inline void swap(ST_INTERCHANGE_DEVICE_STATUS_INFO& a, ST_INTERCHANGE_DEVICE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_INTERCHANGE_DEVICE_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO {
  public:
    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO();

    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_INTERCHANGE_DEVICE_STATUS_INFO& stInterchangeDeviceStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO (IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO&&) = default;
    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& operator=(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO&&) = default;
    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& operator=(const IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO&) = default;
    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO(const IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO&) = default;
    #else
    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& operator=(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_INTERCHANGE_DEVICE_STATUS_INFO& stInterchangeDeviceStatusInfo() OMG_NOEXCEPT {
        return m_stInterchangeDeviceStatusInfo_;
    }

    const ST_INTERCHANGE_DEVICE_STATUS_INFO& stInterchangeDeviceStatusInfo() const OMG_NOEXCEPT {
        return m_stInterchangeDeviceStatusInfo_;
    }

    void stInterchangeDeviceStatusInfo(const ST_INTERCHANGE_DEVICE_STATUS_INFO& value) {
        m_stInterchangeDeviceStatusInfo_ = value;
    }

    void stInterchangeDeviceStatusInfo(ST_INTERCHANGE_DEVICE_STATUS_INFO&& value) {
        m_stInterchangeDeviceStatusInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& other_) const;

    void swap(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_INTERCHANGE_DEVICE_STATUS_INFO m_stInterchangeDeviceStatusInfo_;

};

inline void swap(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& a, IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& sample);

class NDDSUSERDllExport ST_TRANSCEIVER_STATUS_INFO {
  public:
    ST_TRANSCEIVER_STATUS_INFO();

    ST_TRANSCEIVER_STATUS_INFO(uint16_t usDeviceID,uint16_t usDeviceStatus,uint16_t usTRMD_PowerModuleStatus,uint16_t usTRMD_CardStatus,uint16_t usBaseband_PowerModuleStatus,uint16_t usBaseband_CardStatus,uint16_t usGESW_CardStatus,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TRANSCEIVER_STATUS_INFO (ST_TRANSCEIVER_STATUS_INFO&&) = default;
    ST_TRANSCEIVER_STATUS_INFO& operator=(ST_TRANSCEIVER_STATUS_INFO&&) = default;
    ST_TRANSCEIVER_STATUS_INFO& operator=(const ST_TRANSCEIVER_STATUS_INFO&) = default;
    ST_TRANSCEIVER_STATUS_INFO(const ST_TRANSCEIVER_STATUS_INFO&) = default;
    #else
    ST_TRANSCEIVER_STATUS_INFO(ST_TRANSCEIVER_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_TRANSCEIVER_STATUS_INFO& operator=(ST_TRANSCEIVER_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usDeviceID() OMG_NOEXCEPT {
        return m_usDeviceID_;
    }

    const uint16_t& usDeviceID() const OMG_NOEXCEPT {
        return m_usDeviceID_;
    }

    void usDeviceID(uint16_t value) {
        m_usDeviceID_ = value;
    }

    uint16_t& usDeviceStatus() OMG_NOEXCEPT {
        return m_usDeviceStatus_;
    }

    const uint16_t& usDeviceStatus() const OMG_NOEXCEPT {
        return m_usDeviceStatus_;
    }

    void usDeviceStatus(uint16_t value) {
        m_usDeviceStatus_ = value;
    }

    uint16_t& usTRMD_PowerModuleStatus() OMG_NOEXCEPT {
        return m_usTRMD_PowerModuleStatus_;
    }

    const uint16_t& usTRMD_PowerModuleStatus() const OMG_NOEXCEPT {
        return m_usTRMD_PowerModuleStatus_;
    }

    void usTRMD_PowerModuleStatus(uint16_t value) {
        m_usTRMD_PowerModuleStatus_ = value;
    }

    uint16_t& usTRMD_CardStatus() OMG_NOEXCEPT {
        return m_usTRMD_CardStatus_;
    }

    const uint16_t& usTRMD_CardStatus() const OMG_NOEXCEPT {
        return m_usTRMD_CardStatus_;
    }

    void usTRMD_CardStatus(uint16_t value) {
        m_usTRMD_CardStatus_ = value;
    }

    uint16_t& usBaseband_PowerModuleStatus() OMG_NOEXCEPT {
        return m_usBaseband_PowerModuleStatus_;
    }

    const uint16_t& usBaseband_PowerModuleStatus() const OMG_NOEXCEPT {
        return m_usBaseband_PowerModuleStatus_;
    }

    void usBaseband_PowerModuleStatus(uint16_t value) {
        m_usBaseband_PowerModuleStatus_ = value;
    }

    uint16_t& usBaseband_CardStatus() OMG_NOEXCEPT {
        return m_usBaseband_CardStatus_;
    }

    const uint16_t& usBaseband_CardStatus() const OMG_NOEXCEPT {
        return m_usBaseband_CardStatus_;
    }

    void usBaseband_CardStatus(uint16_t value) {
        m_usBaseband_CardStatus_ = value;
    }

    uint16_t& usGESW_CardStatus() OMG_NOEXCEPT {
        return m_usGESW_CardStatus_;
    }

    const uint16_t& usGESW_CardStatus() const OMG_NOEXCEPT {
        return m_usGESW_CardStatus_;
    }

    void usGESW_CardStatus(uint16_t value) {
        m_usGESW_CardStatus_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const ST_TRANSCEIVER_STATUS_INFO& other_) const;
    bool operator != (const ST_TRANSCEIVER_STATUS_INFO& other_) const;

    void swap(ST_TRANSCEIVER_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usDeviceID_;
    uint16_t m_usDeviceStatus_;
    uint16_t m_usTRMD_PowerModuleStatus_;
    uint16_t m_usTRMD_CardStatus_;
    uint16_t m_usBaseband_PowerModuleStatus_;
    uint16_t m_usBaseband_CardStatus_;
    uint16_t m_usGESW_CardStatus_;
    uint16_t m_usReserved_;

};

inline void swap(ST_TRANSCEIVER_STATUS_INFO& a, ST_TRANSCEIVER_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TRANSCEIVER_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_RMD_TRANSCEIVER_STATUS_INFO {
  public:
    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO();

    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_TRANSCEIVER_STATUS_INFO& stTransceiverStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO (IFCCTR_RMD_TRANSCEIVER_STATUS_INFO&&) = default;
    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& operator=(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO&&) = default;
    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& operator=(const IFCCTR_RMD_TRANSCEIVER_STATUS_INFO&) = default;
    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO(const IFCCTR_RMD_TRANSCEIVER_STATUS_INFO&) = default;
    #else
    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& operator=(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_TRANSCEIVER_STATUS_INFO& stTransceiverStatusInfo() OMG_NOEXCEPT {
        return m_stTransceiverStatusInfo_;
    }

    const ST_TRANSCEIVER_STATUS_INFO& stTransceiverStatusInfo() const OMG_NOEXCEPT {
        return m_stTransceiverStatusInfo_;
    }

    void stTransceiverStatusInfo(const ST_TRANSCEIVER_STATUS_INFO& value) {
        m_stTransceiverStatusInfo_ = value;
    }

    void stTransceiverStatusInfo(ST_TRANSCEIVER_STATUS_INFO&& value) {
        m_stTransceiverStatusInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& other_) const;

    void swap(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_TRANSCEIVER_STATUS_INFO m_stTransceiverStatusInfo_;

};

inline void swap(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& a, IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& sample);

class NDDSUSERDllExport ST_SIM_RD_TARGET {
  public:
    ST_SIM_RD_TARGET();

    ST_SIM_RD_TARGET(uint32_t ulTargetNumber,uint32_t ulTrackState,float fDistance,float fBearing,float fCourse,float fSpeed,const ST_DATE_TIME& stTargetRegistrationTime,const ST_DATE_TIME& stTargetUpdateTime,const ST_DATE_TIME& stTargetHoldingTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SIM_RD_TARGET (ST_SIM_RD_TARGET&&) = default;
    ST_SIM_RD_TARGET& operator=(ST_SIM_RD_TARGET&&) = default;
    ST_SIM_RD_TARGET& operator=(const ST_SIM_RD_TARGET&) = default;
    ST_SIM_RD_TARGET(const ST_SIM_RD_TARGET&) = default;
    #else
    ST_SIM_RD_TARGET(ST_SIM_RD_TARGET&& other_) OMG_NOEXCEPT;  
    ST_SIM_RD_TARGET& operator=(ST_SIM_RD_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulTargetNumber() OMG_NOEXCEPT {
        return m_ulTargetNumber_;
    }

    const uint32_t& ulTargetNumber() const OMG_NOEXCEPT {
        return m_ulTargetNumber_;
    }

    void ulTargetNumber(uint32_t value) {
        m_ulTargetNumber_ = value;
    }

    uint32_t& ulTrackState() OMG_NOEXCEPT {
        return m_ulTrackState_;
    }

    const uint32_t& ulTrackState() const OMG_NOEXCEPT {
        return m_ulTrackState_;
    }

    void ulTrackState(uint32_t value) {
        m_ulTrackState_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fSpeed() OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    const float& fSpeed() const OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    void fSpeed(float value) {
        m_fSpeed_ = value;
    }

    ST_DATE_TIME& stTargetRegistrationTime() OMG_NOEXCEPT {
        return m_stTargetRegistrationTime_;
    }

    const ST_DATE_TIME& stTargetRegistrationTime() const OMG_NOEXCEPT {
        return m_stTargetRegistrationTime_;
    }

    void stTargetRegistrationTime(const ST_DATE_TIME& value) {
        m_stTargetRegistrationTime_ = value;
    }

    void stTargetRegistrationTime(ST_DATE_TIME&& value) {
        m_stTargetRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stTargetUpdateTime() OMG_NOEXCEPT {
        return m_stTargetUpdateTime_;
    }

    const ST_DATE_TIME& stTargetUpdateTime() const OMG_NOEXCEPT {
        return m_stTargetUpdateTime_;
    }

    void stTargetUpdateTime(const ST_DATE_TIME& value) {
        m_stTargetUpdateTime_ = value;
    }

    void stTargetUpdateTime(ST_DATE_TIME&& value) {
        m_stTargetUpdateTime_ = std::move(value);
    }
    ST_DATE_TIME& stTargetHoldingTime() OMG_NOEXCEPT {
        return m_stTargetHoldingTime_;
    }

    const ST_DATE_TIME& stTargetHoldingTime() const OMG_NOEXCEPT {
        return m_stTargetHoldingTime_;
    }

    void stTargetHoldingTime(const ST_DATE_TIME& value) {
        m_stTargetHoldingTime_ = value;
    }

    void stTargetHoldingTime(ST_DATE_TIME&& value) {
        m_stTargetHoldingTime_ = std::move(value);
    }

    bool operator == (const ST_SIM_RD_TARGET& other_) const;
    bool operator != (const ST_SIM_RD_TARGET& other_) const;

    void swap(ST_SIM_RD_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulTargetNumber_;
    uint32_t m_ulTrackState_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fCourse_;
    float m_fSpeed_;
    ST_DATE_TIME m_stTargetRegistrationTime_;
    ST_DATE_TIME m_stTargetUpdateTime_;
    ST_DATE_TIME m_stTargetHoldingTime_;

};

inline void swap(ST_SIM_RD_TARGET& a, ST_SIM_RD_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SIM_RD_TARGET& sample);

class NDDSUSERDllExport IFCCTR_SIM_RD_TARGET_INFO {
  public:
    IFCCTR_SIM_RD_TARGET_INFO();

    IFCCTR_SIM_RD_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulRadarID,const ST_DATE_TIME& stDetectionTime,uint16_t usTargetNum,uint16_t usReserved,const ::dds::core::array< ST_SIM_RD_TARGET, 64L>& stSimRadarTarget);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_SIM_RD_TARGET_INFO (IFCCTR_SIM_RD_TARGET_INFO&&) = default;
    IFCCTR_SIM_RD_TARGET_INFO& operator=(IFCCTR_SIM_RD_TARGET_INFO&&) = default;
    IFCCTR_SIM_RD_TARGET_INFO& operator=(const IFCCTR_SIM_RD_TARGET_INFO&) = default;
    IFCCTR_SIM_RD_TARGET_INFO(const IFCCTR_SIM_RD_TARGET_INFO&) = default;
    #else
    IFCCTR_SIM_RD_TARGET_INFO(IFCCTR_SIM_RD_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_SIM_RD_TARGET_INFO& operator=(IFCCTR_SIM_RD_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulRadarID() OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    const uint32_t& ulRadarID() const OMG_NOEXCEPT {
        return m_ulRadarID_;
    }

    void ulRadarID(uint32_t value) {
        m_ulRadarID_ = value;
    }

    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }
    uint16_t& usTargetNum() OMG_NOEXCEPT {
        return m_usTargetNum_;
    }

    const uint16_t& usTargetNum() const OMG_NOEXCEPT {
        return m_usTargetNum_;
    }

    void usTargetNum(uint16_t value) {
        m_usTargetNum_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    ::dds::core::array< ST_SIM_RD_TARGET, 64L>& stSimRadarTarget() OMG_NOEXCEPT {
        return m_stSimRadarTarget_;
    }

    const ::dds::core::array< ST_SIM_RD_TARGET, 64L>& stSimRadarTarget() const OMG_NOEXCEPT {
        return m_stSimRadarTarget_;
    }

    void stSimRadarTarget(const ::dds::core::array< ST_SIM_RD_TARGET, 64L>& value) {
        m_stSimRadarTarget_ = value;
    }

    void stSimRadarTarget(::dds::core::array< ST_SIM_RD_TARGET, 64L>&& value) {
        m_stSimRadarTarget_ = std::move(value);
    }

    bool operator == (const IFCCTR_SIM_RD_TARGET_INFO& other_) const;
    bool operator != (const IFCCTR_SIM_RD_TARGET_INFO& other_) const;

    void swap(IFCCTR_SIM_RD_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulRadarID_;
    ST_DATE_TIME m_stDetectionTime_;
    uint16_t m_usTargetNum_;
    uint16_t m_usReserved_;
    ::dds::core::array< ST_SIM_RD_TARGET, 64L> m_stSimRadarTarget_;

};

inline void swap(IFCCTR_SIM_RD_TARGET_INFO& a, IFCCTR_SIM_RD_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_SIM_RD_TARGET_INFO& sample);

class NDDSUSERDllExport ST_SIM_STATUS_INFO {
  public:
    ST_SIM_STATUS_INFO();

    ST_SIM_STATUS_INFO(uint16_t usStatusSM1,uint16_t usStatusSM2,uint16_t usStatusSM3,uint16_t usStatusSM4,uint32_t ulReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SIM_STATUS_INFO (ST_SIM_STATUS_INFO&&) = default;
    ST_SIM_STATUS_INFO& operator=(ST_SIM_STATUS_INFO&&) = default;
    ST_SIM_STATUS_INFO& operator=(const ST_SIM_STATUS_INFO&) = default;
    ST_SIM_STATUS_INFO(const ST_SIM_STATUS_INFO&) = default;
    #else
    ST_SIM_STATUS_INFO(ST_SIM_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_SIM_STATUS_INFO& operator=(ST_SIM_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usStatusSM1() OMG_NOEXCEPT {
        return m_usStatusSM1_;
    }

    const uint16_t& usStatusSM1() const OMG_NOEXCEPT {
        return m_usStatusSM1_;
    }

    void usStatusSM1(uint16_t value) {
        m_usStatusSM1_ = value;
    }

    uint16_t& usStatusSM2() OMG_NOEXCEPT {
        return m_usStatusSM2_;
    }

    const uint16_t& usStatusSM2() const OMG_NOEXCEPT {
        return m_usStatusSM2_;
    }

    void usStatusSM2(uint16_t value) {
        m_usStatusSM2_ = value;
    }

    uint16_t& usStatusSM3() OMG_NOEXCEPT {
        return m_usStatusSM3_;
    }

    const uint16_t& usStatusSM3() const OMG_NOEXCEPT {
        return m_usStatusSM3_;
    }

    void usStatusSM3(uint16_t value) {
        m_usStatusSM3_ = value;
    }

    uint16_t& usStatusSM4() OMG_NOEXCEPT {
        return m_usStatusSM4_;
    }

    const uint16_t& usStatusSM4() const OMG_NOEXCEPT {
        return m_usStatusSM4_;
    }

    void usStatusSM4(uint16_t value) {
        m_usStatusSM4_ = value;
    }

    uint32_t& ulReserved() OMG_NOEXCEPT {
        return m_ulReserved_;
    }

    const uint32_t& ulReserved() const OMG_NOEXCEPT {
        return m_ulReserved_;
    }

    void ulReserved(uint32_t value) {
        m_ulReserved_ = value;
    }

    bool operator == (const ST_SIM_STATUS_INFO& other_) const;
    bool operator != (const ST_SIM_STATUS_INFO& other_) const;

    void swap(ST_SIM_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usStatusSM1_;
    uint16_t m_usStatusSM2_;
    uint16_t m_usStatusSM3_;
    uint16_t m_usStatusSM4_;
    uint32_t m_ulReserved_;

};

inline void swap(ST_SIM_STATUS_INFO& a, ST_SIM_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SIM_STATUS_INFO& sample);

class NDDSUSERDllExport IFCCTR_SIM_STATUS_INFO {
  public:
    IFCCTR_SIM_STATUS_INFO();

    IFCCTR_SIM_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_SIM_STATUS_INFO& stSimStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    IFCCTR_SIM_STATUS_INFO (IFCCTR_SIM_STATUS_INFO&&) = default;
    IFCCTR_SIM_STATUS_INFO& operator=(IFCCTR_SIM_STATUS_INFO&&) = default;
    IFCCTR_SIM_STATUS_INFO& operator=(const IFCCTR_SIM_STATUS_INFO&) = default;
    IFCCTR_SIM_STATUS_INFO(const IFCCTR_SIM_STATUS_INFO&) = default;
    #else
    IFCCTR_SIM_STATUS_INFO(IFCCTR_SIM_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    IFCCTR_SIM_STATUS_INFO& operator=(IFCCTR_SIM_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_SIM_STATUS_INFO& stSimStatusInfo() OMG_NOEXCEPT {
        return m_stSimStatusInfo_;
    }

    const ST_SIM_STATUS_INFO& stSimStatusInfo() const OMG_NOEXCEPT {
        return m_stSimStatusInfo_;
    }

    void stSimStatusInfo(const ST_SIM_STATUS_INFO& value) {
        m_stSimStatusInfo_ = value;
    }

    void stSimStatusInfo(ST_SIM_STATUS_INFO&& value) {
        m_stSimStatusInfo_ = std::move(value);
    }

    bool operator == (const IFCCTR_SIM_STATUS_INFO& other_) const;
    bool operator != (const IFCCTR_SIM_STATUS_INFO& other_) const;

    void swap(IFCCTR_SIM_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_SIM_STATUS_INFO m_stSimStatusInfo_;

};

inline void swap(IFCCTR_SIM_STATUS_INFO& a, IFCCTR_SIM_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const IFCCTR_SIM_STATUS_INFO& sample);

class NDDSUSERDllExport LASDSP_LAS_A_AGC_CTRL_INFO {
  public:
    LASDSP_LAS_A_AGC_CTRL_INFO();

    LASDSP_LAS_A_AGC_CTRL_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t unAxisId,uint16_t usAgcGain,const ::dds::core::array< float, 240L>& aSensorEnergy,float fTotalEnergy);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_A_AGC_CTRL_INFO (LASDSP_LAS_A_AGC_CTRL_INFO&&) = default;
    LASDSP_LAS_A_AGC_CTRL_INFO& operator=(LASDSP_LAS_A_AGC_CTRL_INFO&&) = default;
    LASDSP_LAS_A_AGC_CTRL_INFO& operator=(const LASDSP_LAS_A_AGC_CTRL_INFO&) = default;
    LASDSP_LAS_A_AGC_CTRL_INFO(const LASDSP_LAS_A_AGC_CTRL_INFO&) = default;
    #else
    LASDSP_LAS_A_AGC_CTRL_INFO(LASDSP_LAS_A_AGC_CTRL_INFO&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_A_AGC_CTRL_INFO& operator=(LASDSP_LAS_A_AGC_CTRL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unAxisId() OMG_NOEXCEPT {
        return m_unAxisId_;
    }

    const uint16_t& unAxisId() const OMG_NOEXCEPT {
        return m_unAxisId_;
    }

    void unAxisId(uint16_t value) {
        m_unAxisId_ = value;
    }

    uint16_t& usAgcGain() OMG_NOEXCEPT {
        return m_usAgcGain_;
    }

    const uint16_t& usAgcGain() const OMG_NOEXCEPT {
        return m_usAgcGain_;
    }

    void usAgcGain(uint16_t value) {
        m_usAgcGain_ = value;
    }

    ::dds::core::array< float, 240L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 240L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 240L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 240L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    bool operator == (const LASDSP_LAS_A_AGC_CTRL_INFO& other_) const;
    bool operator != (const LASDSP_LAS_A_AGC_CTRL_INFO& other_) const;

    void swap(LASDSP_LAS_A_AGC_CTRL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unAxisId_;
    uint16_t m_usAgcGain_;
    ::dds::core::array< float, 240L> m_aSensorEnergy_;
    float m_fTotalEnergy_;

};

inline void swap(LASDSP_LAS_A_AGC_CTRL_INFO& a, LASDSP_LAS_A_AGC_CTRL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_A_AGC_CTRL_INFO& sample);

class NDDSUSERDllExport LASDSP_LAS_A_BEAM_DATA {
  public:
    LASDSP_LAS_A_BEAM_DATA();

    LASDSP_LAS_A_BEAM_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t reserved,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_A_BEAM_DATA (LASDSP_LAS_A_BEAM_DATA&&) = default;
    LASDSP_LAS_A_BEAM_DATA& operator=(LASDSP_LAS_A_BEAM_DATA&&) = default;
    LASDSP_LAS_A_BEAM_DATA& operator=(const LASDSP_LAS_A_BEAM_DATA&) = default;
    LASDSP_LAS_A_BEAM_DATA(const LASDSP_LAS_A_BEAM_DATA&) = default;
    #else
    LASDSP_LAS_A_BEAM_DATA(LASDSP_LAS_A_BEAM_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_A_BEAM_DATA& operator=(LASDSP_LAS_A_BEAM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut() OMG_NOEXCEPT {
        return m_aBeamOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut() const OMG_NOEXCEPT {
        return m_aBeamOut_;
    }

    void aBeamOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& value) {
        m_aBeamOut_ = value;
    }

    void aBeamOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>&& value) {
        m_aBeamOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_A_BEAM_DATA& other_) const;
    bool operator != (const LASDSP_LAS_A_BEAM_DATA& other_) const;

    void swap(LASDSP_LAS_A_BEAM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L> m_aBeamOut_;

};

inline void swap(LASDSP_LAS_A_BEAM_DATA& a, LASDSP_LAS_A_BEAM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_A_BEAM_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_A_ENE_DATA {
  public:
    LASDSP_LAS_A_ENE_DATA();

    LASDSP_LAS_A_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t reserved,const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_A_ENE_DATA (LASDSP_LAS_A_ENE_DATA&&) = default;
    LASDSP_LAS_A_ENE_DATA& operator=(LASDSP_LAS_A_ENE_DATA&&) = default;
    LASDSP_LAS_A_ENE_DATA& operator=(const LASDSP_LAS_A_ENE_DATA&) = default;
    LASDSP_LAS_A_ENE_DATA(const LASDSP_LAS_A_ENE_DATA&) = default;
    #else
    LASDSP_LAS_A_ENE_DATA(LASDSP_LAS_A_ENE_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_A_ENE_DATA& operator=(LASDSP_LAS_A_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut() OMG_NOEXCEPT {
        return m_aEneOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut() const OMG_NOEXCEPT {
        return m_aEneOut_;
    }

    void aEneOut(const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& value) {
        m_aEneOut_ = value;
    }

    void aEneOut(::dds::core::array< ::dds::core::array< float, 15L>, 256L>&& value) {
        m_aEneOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_A_ENE_DATA& other_) const;
    bool operator != (const LASDSP_LAS_A_ENE_DATA& other_) const;

    void swap(LASDSP_LAS_A_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< float, 15L>, 256L> m_aEneOut_;

};

inline void swap(LASDSP_LAS_A_ENE_DATA& a, LASDSP_LAS_A_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_A_ENE_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_A_FREQ_DETECTION_DATA {
  public:
    LASDSP_LAS_A_FREQ_DETECTION_DATA();

    LASDSP_LAS_A_FREQ_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usBbIntegTime,uint16_t usNbIntegTime,uint16_t reserved,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_A_FREQ_DETECTION_DATA (LASDSP_LAS_A_FREQ_DETECTION_DATA&&) = default;
    LASDSP_LAS_A_FREQ_DETECTION_DATA& operator=(LASDSP_LAS_A_FREQ_DETECTION_DATA&&) = default;
    LASDSP_LAS_A_FREQ_DETECTION_DATA& operator=(const LASDSP_LAS_A_FREQ_DETECTION_DATA&) = default;
    LASDSP_LAS_A_FREQ_DETECTION_DATA(const LASDSP_LAS_A_FREQ_DETECTION_DATA&) = default;
    #else
    LASDSP_LAS_A_FREQ_DETECTION_DATA(LASDSP_LAS_A_FREQ_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_A_FREQ_DETECTION_DATA& operator=(LASDSP_LAS_A_FREQ_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usBbIntegTime() OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    const uint16_t& usBbIntegTime() const OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    void usBbIntegTime(uint16_t value) {
        m_usBbIntegTime_ = value;
    }

    uint16_t& usNbIntegTime() OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    const uint16_t& usNbIntegTime() const OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    void usNbIntegTime(uint16_t value) {
        m_usNbIntegTime_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_A_FREQ_DETECTION_DATA& other_) const;
    bool operator != (const LASDSP_LAS_A_FREQ_DETECTION_DATA& other_) const;

    void swap(LASDSP_LAS_A_FREQ_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usBbIntegTime_;
    uint16_t m_usNbIntegTime_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;

};

inline void swap(LASDSP_LAS_A_FREQ_DETECTION_DATA& a, LASDSP_LAS_A_FREQ_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_A_FREQ_DETECTION_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_A_TIME_DETECTION_DATA {
  public:
    LASDSP_LAS_A_TIME_DETECTION_DATA();

    LASDSP_LAS_A_TIME_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBbIntegTime,uint16_t usNbIntegTime,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_A_TIME_DETECTION_DATA (LASDSP_LAS_A_TIME_DETECTION_DATA&&) = default;
    LASDSP_LAS_A_TIME_DETECTION_DATA& operator=(LASDSP_LAS_A_TIME_DETECTION_DATA&&) = default;
    LASDSP_LAS_A_TIME_DETECTION_DATA& operator=(const LASDSP_LAS_A_TIME_DETECTION_DATA&) = default;
    LASDSP_LAS_A_TIME_DETECTION_DATA(const LASDSP_LAS_A_TIME_DETECTION_DATA&) = default;
    #else
    LASDSP_LAS_A_TIME_DETECTION_DATA(LASDSP_LAS_A_TIME_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_A_TIME_DETECTION_DATA& operator=(LASDSP_LAS_A_TIME_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBbIntegTime() OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    const uint16_t& usBbIntegTime() const OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    void usBbIntegTime(uint16_t value) {
        m_usBbIntegTime_ = value;
    }

    uint16_t& usNbIntegTime() OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    const uint16_t& usNbIntegTime() const OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    void usNbIntegTime(uint16_t value) {
        m_usNbIntegTime_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut() OMG_NOEXCEPT {
        return m_aNormDemonOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut() const OMG_NOEXCEPT {
        return m_aNormDemonOut_;
    }

    void aNormDemonOut(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aNormDemonOut_ = value;
    }

    void aNormDemonOut(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aNormDemonOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut() OMG_NOEXCEPT {
        return m_aDemonOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut() const OMG_NOEXCEPT {
        return m_aDemonOut_;
    }

    void aDemonOut(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aDemonOut_ = value;
    }

    void aDemonOut(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aDemonOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_A_TIME_DETECTION_DATA& other_) const;
    bool operator != (const LASDSP_LAS_A_TIME_DETECTION_DATA& other_) const;

    void swap(LASDSP_LAS_A_TIME_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBbIntegTime_;
    uint16_t m_usNbIntegTime_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aNormDemonOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aDemonOut_;

};

inline void swap(LASDSP_LAS_A_TIME_DETECTION_DATA& a, LASDSP_LAS_A_TIME_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_A_TIME_DETECTION_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_B_AGC_CTRL_INFO {
  public:
    LASDSP_LAS_B_AGC_CTRL_INFO();

    LASDSP_LAS_B_AGC_CTRL_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t usAgcGain,const ::dds::core::array< float, 240L>& aSensorEnergy,float fTotalEnergy);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_B_AGC_CTRL_INFO (LASDSP_LAS_B_AGC_CTRL_INFO&&) = default;
    LASDSP_LAS_B_AGC_CTRL_INFO& operator=(LASDSP_LAS_B_AGC_CTRL_INFO&&) = default;
    LASDSP_LAS_B_AGC_CTRL_INFO& operator=(const LASDSP_LAS_B_AGC_CTRL_INFO&) = default;
    LASDSP_LAS_B_AGC_CTRL_INFO(const LASDSP_LAS_B_AGC_CTRL_INFO&) = default;
    #else
    LASDSP_LAS_B_AGC_CTRL_INFO(LASDSP_LAS_B_AGC_CTRL_INFO&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_B_AGC_CTRL_INFO& operator=(LASDSP_LAS_B_AGC_CTRL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usAgcGain() OMG_NOEXCEPT {
        return m_usAgcGain_;
    }

    const uint16_t& usAgcGain() const OMG_NOEXCEPT {
        return m_usAgcGain_;
    }

    void usAgcGain(uint16_t value) {
        m_usAgcGain_ = value;
    }

    ::dds::core::array< float, 240L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 240L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 240L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 240L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    bool operator == (const LASDSP_LAS_B_AGC_CTRL_INFO& other_) const;
    bool operator != (const LASDSP_LAS_B_AGC_CTRL_INFO& other_) const;

    void swap(LASDSP_LAS_B_AGC_CTRL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_usAgcGain_;
    ::dds::core::array< float, 240L> m_aSensorEnergy_;
    float m_fTotalEnergy_;

};

inline void swap(LASDSP_LAS_B_AGC_CTRL_INFO& a, LASDSP_LAS_B_AGC_CTRL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_B_AGC_CTRL_INFO& sample);

class NDDSUSERDllExport LASDSP_LAS_B_BEAM_DATA {
  public:
    LASDSP_LAS_B_BEAM_DATA();

    LASDSP_LAS_B_BEAM_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t reserved,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_B_BEAM_DATA (LASDSP_LAS_B_BEAM_DATA&&) = default;
    LASDSP_LAS_B_BEAM_DATA& operator=(LASDSP_LAS_B_BEAM_DATA&&) = default;
    LASDSP_LAS_B_BEAM_DATA& operator=(const LASDSP_LAS_B_BEAM_DATA&) = default;
    LASDSP_LAS_B_BEAM_DATA(const LASDSP_LAS_B_BEAM_DATA&) = default;
    #else
    LASDSP_LAS_B_BEAM_DATA(LASDSP_LAS_B_BEAM_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_B_BEAM_DATA& operator=(LASDSP_LAS_B_BEAM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut() OMG_NOEXCEPT {
        return m_aBeamOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut() const OMG_NOEXCEPT {
        return m_aBeamOut_;
    }

    void aBeamOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& value) {
        m_aBeamOut_ = value;
    }

    void aBeamOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>&& value) {
        m_aBeamOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_B_BEAM_DATA& other_) const;
    bool operator != (const LASDSP_LAS_B_BEAM_DATA& other_) const;

    void swap(LASDSP_LAS_B_BEAM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L> m_aBeamOut_;

};

inline void swap(LASDSP_LAS_B_BEAM_DATA& a, LASDSP_LAS_B_BEAM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_B_BEAM_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_B_ENE_DATA {
  public:
    LASDSP_LAS_B_ENE_DATA();

    LASDSP_LAS_B_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t reserved,const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_B_ENE_DATA (LASDSP_LAS_B_ENE_DATA&&) = default;
    LASDSP_LAS_B_ENE_DATA& operator=(LASDSP_LAS_B_ENE_DATA&&) = default;
    LASDSP_LAS_B_ENE_DATA& operator=(const LASDSP_LAS_B_ENE_DATA&) = default;
    LASDSP_LAS_B_ENE_DATA(const LASDSP_LAS_B_ENE_DATA&) = default;
    #else
    LASDSP_LAS_B_ENE_DATA(LASDSP_LAS_B_ENE_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_B_ENE_DATA& operator=(LASDSP_LAS_B_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut() OMG_NOEXCEPT {
        return m_aEneOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut() const OMG_NOEXCEPT {
        return m_aEneOut_;
    }

    void aEneOut(const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& value) {
        m_aEneOut_ = value;
    }

    void aEneOut(::dds::core::array< ::dds::core::array< float, 15L>, 256L>&& value) {
        m_aEneOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_B_ENE_DATA& other_) const;
    bool operator != (const LASDSP_LAS_B_ENE_DATA& other_) const;

    void swap(LASDSP_LAS_B_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< float, 15L>, 256L> m_aEneOut_;

};

inline void swap(LASDSP_LAS_B_ENE_DATA& a, LASDSP_LAS_B_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_B_ENE_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_B_FREQ_DETECTION_DATA {
  public:
    LASDSP_LAS_B_FREQ_DETECTION_DATA();

    LASDSP_LAS_B_FREQ_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usBbIntegTime,uint16_t usNbIntegTime,uint16_t reserved,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_B_FREQ_DETECTION_DATA (LASDSP_LAS_B_FREQ_DETECTION_DATA&&) = default;
    LASDSP_LAS_B_FREQ_DETECTION_DATA& operator=(LASDSP_LAS_B_FREQ_DETECTION_DATA&&) = default;
    LASDSP_LAS_B_FREQ_DETECTION_DATA& operator=(const LASDSP_LAS_B_FREQ_DETECTION_DATA&) = default;
    LASDSP_LAS_B_FREQ_DETECTION_DATA(const LASDSP_LAS_B_FREQ_DETECTION_DATA&) = default;
    #else
    LASDSP_LAS_B_FREQ_DETECTION_DATA(LASDSP_LAS_B_FREQ_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_B_FREQ_DETECTION_DATA& operator=(LASDSP_LAS_B_FREQ_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usBbIntegTime() OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    const uint16_t& usBbIntegTime() const OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    void usBbIntegTime(uint16_t value) {
        m_usBbIntegTime_ = value;
    }

    uint16_t& usNbIntegTime() OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    const uint16_t& usNbIntegTime() const OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    void usNbIntegTime(uint16_t value) {
        m_usNbIntegTime_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_B_FREQ_DETECTION_DATA& other_) const;
    bool operator != (const LASDSP_LAS_B_FREQ_DETECTION_DATA& other_) const;

    void swap(LASDSP_LAS_B_FREQ_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usBbIntegTime_;
    uint16_t m_usNbIntegTime_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;

};

inline void swap(LASDSP_LAS_B_FREQ_DETECTION_DATA& a, LASDSP_LAS_B_FREQ_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_B_FREQ_DETECTION_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_B_TIME_DETECTION_DATA {
  public:
    LASDSP_LAS_B_TIME_DETECTION_DATA();

    LASDSP_LAS_B_TIME_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBbIntegTime,uint16_t usNbIntegTime,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_B_TIME_DETECTION_DATA (LASDSP_LAS_B_TIME_DETECTION_DATA&&) = default;
    LASDSP_LAS_B_TIME_DETECTION_DATA& operator=(LASDSP_LAS_B_TIME_DETECTION_DATA&&) = default;
    LASDSP_LAS_B_TIME_DETECTION_DATA& operator=(const LASDSP_LAS_B_TIME_DETECTION_DATA&) = default;
    LASDSP_LAS_B_TIME_DETECTION_DATA(const LASDSP_LAS_B_TIME_DETECTION_DATA&) = default;
    #else
    LASDSP_LAS_B_TIME_DETECTION_DATA(LASDSP_LAS_B_TIME_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_B_TIME_DETECTION_DATA& operator=(LASDSP_LAS_B_TIME_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBbIntegTime() OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    const uint16_t& usBbIntegTime() const OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    void usBbIntegTime(uint16_t value) {
        m_usBbIntegTime_ = value;
    }

    uint16_t& usNbIntegTime() OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    const uint16_t& usNbIntegTime() const OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    void usNbIntegTime(uint16_t value) {
        m_usNbIntegTime_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut() OMG_NOEXCEPT {
        return m_aNormDemonOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut() const OMG_NOEXCEPT {
        return m_aNormDemonOut_;
    }

    void aNormDemonOut(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aNormDemonOut_ = value;
    }

    void aNormDemonOut(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aNormDemonOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut() OMG_NOEXCEPT {
        return m_aDemonOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut() const OMG_NOEXCEPT {
        return m_aDemonOut_;
    }

    void aDemonOut(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aDemonOut_ = value;
    }

    void aDemonOut(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aDemonOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_B_TIME_DETECTION_DATA& other_) const;
    bool operator != (const LASDSP_LAS_B_TIME_DETECTION_DATA& other_) const;

    void swap(LASDSP_LAS_B_TIME_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBbIntegTime_;
    uint16_t m_usNbIntegTime_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aNormDemonOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aDemonOut_;

};

inline void swap(LASDSP_LAS_B_TIME_DETECTION_DATA& a, LASDSP_LAS_B_TIME_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_B_TIME_DETECTION_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_C_AGC_CTRL_INFO {
  public:
    LASDSP_LAS_C_AGC_CTRL_INFO();

    LASDSP_LAS_C_AGC_CTRL_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAxisId,uint16_t usAgcGain,const ::dds::core::array< float, 240L>& aSensorEnergy,float fTotalEnergy);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_C_AGC_CTRL_INFO (LASDSP_LAS_C_AGC_CTRL_INFO&&) = default;
    LASDSP_LAS_C_AGC_CTRL_INFO& operator=(LASDSP_LAS_C_AGC_CTRL_INFO&&) = default;
    LASDSP_LAS_C_AGC_CTRL_INFO& operator=(const LASDSP_LAS_C_AGC_CTRL_INFO&) = default;
    LASDSP_LAS_C_AGC_CTRL_INFO(const LASDSP_LAS_C_AGC_CTRL_INFO&) = default;
    #else
    LASDSP_LAS_C_AGC_CTRL_INFO(LASDSP_LAS_C_AGC_CTRL_INFO&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_C_AGC_CTRL_INFO& operator=(LASDSP_LAS_C_AGC_CTRL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usAgcGain() OMG_NOEXCEPT {
        return m_usAgcGain_;
    }

    const uint16_t& usAgcGain() const OMG_NOEXCEPT {
        return m_usAgcGain_;
    }

    void usAgcGain(uint16_t value) {
        m_usAgcGain_ = value;
    }

    ::dds::core::array< float, 240L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< float, 240L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< float, 240L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< float, 240L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    float& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const float& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(float value) {
        m_fTotalEnergy_ = value;
    }

    bool operator == (const LASDSP_LAS_C_AGC_CTRL_INFO& other_) const;
    bool operator != (const LASDSP_LAS_C_AGC_CTRL_INFO& other_) const;

    void swap(LASDSP_LAS_C_AGC_CTRL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAxisId_;
    uint16_t m_usAgcGain_;
    ::dds::core::array< float, 240L> m_aSensorEnergy_;
    float m_fTotalEnergy_;

};

inline void swap(LASDSP_LAS_C_AGC_CTRL_INFO& a, LASDSP_LAS_C_AGC_CTRL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_C_AGC_CTRL_INFO& sample);

class NDDSUSERDllExport LASDSP_LAS_C_BEAM_DATA {
  public:
    LASDSP_LAS_C_BEAM_DATA();

    LASDSP_LAS_C_BEAM_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t reserved,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_C_BEAM_DATA (LASDSP_LAS_C_BEAM_DATA&&) = default;
    LASDSP_LAS_C_BEAM_DATA& operator=(LASDSP_LAS_C_BEAM_DATA&&) = default;
    LASDSP_LAS_C_BEAM_DATA& operator=(const LASDSP_LAS_C_BEAM_DATA&) = default;
    LASDSP_LAS_C_BEAM_DATA(const LASDSP_LAS_C_BEAM_DATA&) = default;
    #else
    LASDSP_LAS_C_BEAM_DATA(LASDSP_LAS_C_BEAM_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_C_BEAM_DATA& operator=(LASDSP_LAS_C_BEAM_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut() OMG_NOEXCEPT {
        return m_aBeamOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& aBeamOut() const OMG_NOEXCEPT {
        return m_aBeamOut_;
    }

    void aBeamOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>& value) {
        m_aBeamOut_ = value;
    }

    void aBeamOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L>&& value) {
        m_aBeamOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_C_BEAM_DATA& other_) const;
    bool operator != (const LASDSP_LAS_C_BEAM_DATA& other_) const;

    void swap(LASDSP_LAS_C_BEAM_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 2048L>, 256L>, 4L> m_aBeamOut_;

};

inline void swap(LASDSP_LAS_C_BEAM_DATA& a, LASDSP_LAS_C_BEAM_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_C_BEAM_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_C_ENE_DATA {
  public:
    LASDSP_LAS_C_ENE_DATA();

    LASDSP_LAS_C_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,uint16_t usAxisId,uint16_t reserved,const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_C_ENE_DATA (LASDSP_LAS_C_ENE_DATA&&) = default;
    LASDSP_LAS_C_ENE_DATA& operator=(LASDSP_LAS_C_ENE_DATA&&) = default;
    LASDSP_LAS_C_ENE_DATA& operator=(const LASDSP_LAS_C_ENE_DATA&) = default;
    LASDSP_LAS_C_ENE_DATA(const LASDSP_LAS_C_ENE_DATA&) = default;
    #else
    LASDSP_LAS_C_ENE_DATA(LASDSP_LAS_C_ENE_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_C_ENE_DATA& operator=(LASDSP_LAS_C_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut() OMG_NOEXCEPT {
        return m_aEneOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& aEneOut() const OMG_NOEXCEPT {
        return m_aEneOut_;
    }

    void aEneOut(const ::dds::core::array< ::dds::core::array< float, 15L>, 256L>& value) {
        m_aEneOut_ = value;
    }

    void aEneOut(::dds::core::array< ::dds::core::array< float, 15L>, 256L>&& value) {
        m_aEneOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_C_ENE_DATA& other_) const;
    bool operator != (const LASDSP_LAS_C_ENE_DATA& other_) const;

    void swap(LASDSP_LAS_C_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    uint16_t m_usAxisId_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< float, 15L>, 256L> m_aEneOut_;

};

inline void swap(LASDSP_LAS_C_ENE_DATA& a, LASDSP_LAS_C_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_C_ENE_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_C_FREQ_DETECTION_DATA {
  public:
    LASDSP_LAS_C_FREQ_DETECTION_DATA();

    LASDSP_LAS_C_FREQ_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usBbIntegTime,uint16_t usNbIntegTime,uint16_t reserved,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_C_FREQ_DETECTION_DATA (LASDSP_LAS_C_FREQ_DETECTION_DATA&&) = default;
    LASDSP_LAS_C_FREQ_DETECTION_DATA& operator=(LASDSP_LAS_C_FREQ_DETECTION_DATA&&) = default;
    LASDSP_LAS_C_FREQ_DETECTION_DATA& operator=(const LASDSP_LAS_C_FREQ_DETECTION_DATA&) = default;
    LASDSP_LAS_C_FREQ_DETECTION_DATA(const LASDSP_LAS_C_FREQ_DETECTION_DATA&) = default;
    #else
    LASDSP_LAS_C_FREQ_DETECTION_DATA(LASDSP_LAS_C_FREQ_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_C_FREQ_DETECTION_DATA& operator=(LASDSP_LAS_C_FREQ_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usBbIntegTime() OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    const uint16_t& usBbIntegTime() const OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    void usBbIntegTime(uint16_t value) {
        m_usBbIntegTime_ = value;
    }

    uint16_t& usNbIntegTime() OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    const uint16_t& usNbIntegTime() const OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    void usNbIntegTime(uint16_t value) {
        m_usNbIntegTime_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_C_FREQ_DETECTION_DATA& other_) const;
    bool operator != (const LASDSP_LAS_C_FREQ_DETECTION_DATA& other_) const;

    void swap(LASDSP_LAS_C_FREQ_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usBbIntegTime_;
    uint16_t m_usNbIntegTime_;
    uint16_t m_reserved_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;

};

inline void swap(LASDSP_LAS_C_FREQ_DETECTION_DATA& a, LASDSP_LAS_C_FREQ_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_C_FREQ_DETECTION_DATA& sample);

class NDDSUSERDllExport LASDSP_LAS_C_TIME_DETECTION_DATA {
  public:
    LASDSP_LAS_C_TIME_DETECTION_DATA();

    LASDSP_LAS_C_TIME_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,uint16_t usAxisId,uint16_t usReserved,uint16_t usSensorGain,uint16_t usBbIntegTime,uint16_t usNbIntegTime,const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut,const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    LASDSP_LAS_C_TIME_DETECTION_DATA (LASDSP_LAS_C_TIME_DETECTION_DATA&&) = default;
    LASDSP_LAS_C_TIME_DETECTION_DATA& operator=(LASDSP_LAS_C_TIME_DETECTION_DATA&&) = default;
    LASDSP_LAS_C_TIME_DETECTION_DATA& operator=(const LASDSP_LAS_C_TIME_DETECTION_DATA&) = default;
    LASDSP_LAS_C_TIME_DETECTION_DATA(const LASDSP_LAS_C_TIME_DETECTION_DATA&) = default;
    #else
    LASDSP_LAS_C_TIME_DETECTION_DATA(LASDSP_LAS_C_TIME_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    LASDSP_LAS_C_TIME_DETECTION_DATA& operator=(LASDSP_LAS_C_TIME_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    uint16_t& usAxisId() OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    const uint16_t& usAxisId() const OMG_NOEXCEPT {
        return m_usAxisId_;
    }

    void usAxisId(uint16_t value) {
        m_usAxisId_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usSensorGain() OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    const uint16_t& usSensorGain() const OMG_NOEXCEPT {
        return m_usSensorGain_;
    }

    void usSensorGain(uint16_t value) {
        m_usSensorGain_ = value;
    }

    uint16_t& usBbIntegTime() OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    const uint16_t& usBbIntegTime() const OMG_NOEXCEPT {
        return m_usBbIntegTime_;
    }

    void usBbIntegTime(uint16_t value) {
        m_usBbIntegTime_ = value;
    }

    uint16_t& usNbIntegTime() OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    const uint16_t& usNbIntegTime() const OMG_NOEXCEPT {
        return m_usNbIntegTime_;
    }

    void usNbIntegTime(uint16_t value) {
        m_usNbIntegTime_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& aNormBbdOut() const OMG_NOEXCEPT {
        return m_aNormBbdOut_;
    }

    void aNormBbdOut(const ::dds::core::array< ::dds::core::array< float, 721L>, 5L>& value) {
        m_aNormBbdOut_ = value;
    }

    void aNormBbdOut(::dds::core::array< ::dds::core::array< float, 721L>, 5L>&& value) {
        m_aNormBbdOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aNormLofarOut() const OMG_NOEXCEPT {
        return m_aNormLofarOut_;
    }

    void aNormLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aNormLofarOut_ = value;
    }

    void aNormLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aNormLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& aLofarOut() const OMG_NOEXCEPT {
        return m_aLofarOut_;
    }

    void aLofarOut(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>& value) {
        m_aLofarOut_ = value;
    }

    void aLofarOut(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L>&& value) {
        m_aLofarOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut() OMG_NOEXCEPT {
        return m_aNormDemonOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aNormDemonOut() const OMG_NOEXCEPT {
        return m_aNormDemonOut_;
    }

    void aNormDemonOut(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aNormDemonOut_ = value;
    }

    void aNormDemonOut(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aNormDemonOut_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut() OMG_NOEXCEPT {
        return m_aDemonOut_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& aDemonOut() const OMG_NOEXCEPT {
        return m_aDemonOut_;
    }

    void aDemonOut(const ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>& value) {
        m_aDemonOut_ = value;
    }

    void aDemonOut(::dds::core::array< ::dds::core::array< float, 1601L>, 256L>&& value) {
        m_aDemonOut_ = std::move(value);
    }

    bool operator == (const LASDSP_LAS_C_TIME_DETECTION_DATA& other_) const;
    bool operator != (const LASDSP_LAS_C_TIME_DETECTION_DATA& other_) const;

    void swap(LASDSP_LAS_C_TIME_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    uint16_t m_usAxisId_;
    uint16_t m_usReserved_;
    uint16_t m_usSensorGain_;
    uint16_t m_usBbIntegTime_;
    uint16_t m_usNbIntegTime_;
    ::dds::core::array< ::dds::core::array< float, 721L>, 5L> m_aNormBbdOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aNormLofarOut_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 256L>, 4L> m_aLofarOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aNormDemonOut_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 256L> m_aDemonOut_;

};

inline void swap(LASDSP_LAS_C_TIME_DETECTION_DATA& a, LASDSP_LAS_C_TIME_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const LASDSP_LAS_C_TIME_DETECTION_DATA& sample);

class NDDSUSERDllExport MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA {
  public:
    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA();

    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAColumnMASAcoSig,const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aBColumnMASAcoSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA (MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA&&) = default;
    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& operator=(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA&&) = default;
    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& operator=(const MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA&) = default;
    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA(const MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA&) = default;
    #else
    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA&& other_) OMG_NOEXCEPT;  
    MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& operator=(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAColumnMASAcoSig() OMG_NOEXCEPT {
        return m_aAColumnMASAcoSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aAColumnMASAcoSig() const OMG_NOEXCEPT {
        return m_aAColumnMASAcoSig_;
    }

    void aAColumnMASAcoSig(const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& value) {
        m_aAColumnMASAcoSig_ = value;
    }

    void aAColumnMASAcoSig(::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>&& value) {
        m_aAColumnMASAcoSig_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aBColumnMASAcoSig() OMG_NOEXCEPT {
        return m_aBColumnMASAcoSig_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& aBColumnMASAcoSig() const OMG_NOEXCEPT {
        return m_aBColumnMASAcoSig_;
    }

    void aBColumnMASAcoSig(const ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>& value) {
        m_aBColumnMASAcoSig_ = value;
    }

    void aBColumnMASAcoSig(::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L>&& value) {
        m_aBColumnMASAcoSig_ = std::move(value);
    }

    bool operator == (const MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& other_) const;
    bool operator != (const MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& other_) const;

    void swap(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L> m_aAColumnMASAcoSig_;
    ::dds::core::array< ::dds::core::array< uint16_t, 4096L>, 25L> m_aBColumnMASAcoSig_;

};

inline void swap(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& a, MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& sample);

class NDDSUSERDllExport MASDSP_MAS_AGC_CTRL_INFO {
  public:
    MASDSP_MAS_AGC_CTRL_INFO();

    MASDSP_MAS_AGC_CTRL_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 2L>& usAxisGainControlVal,const ::dds::core::array< ::dds::core::array< float, 25L>, 2L>& aSensorEnergy,const ::dds::core::array< float, 2L>& fTotalEnergy);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MASDSP_MAS_AGC_CTRL_INFO (MASDSP_MAS_AGC_CTRL_INFO&&) = default;
    MASDSP_MAS_AGC_CTRL_INFO& operator=(MASDSP_MAS_AGC_CTRL_INFO&&) = default;
    MASDSP_MAS_AGC_CTRL_INFO& operator=(const MASDSP_MAS_AGC_CTRL_INFO&) = default;
    MASDSP_MAS_AGC_CTRL_INFO(const MASDSP_MAS_AGC_CTRL_INFO&) = default;
    #else
    MASDSP_MAS_AGC_CTRL_INFO(MASDSP_MAS_AGC_CTRL_INFO&& other_) OMG_NOEXCEPT;  
    MASDSP_MAS_AGC_CTRL_INFO& operator=(MASDSP_MAS_AGC_CTRL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& usAxisGainControlVal() OMG_NOEXCEPT {
        return m_usAxisGainControlVal_;
    }

    const ::dds::core::array< uint16_t, 2L>& usAxisGainControlVal() const OMG_NOEXCEPT {
        return m_usAxisGainControlVal_;
    }

    void usAxisGainControlVal(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usAxisGainControlVal_ = value;
    }

    void usAxisGainControlVal(::dds::core::array< uint16_t, 2L>&& value) {
        m_usAxisGainControlVal_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 25L>, 2L>& aSensorEnergy() OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    const ::dds::core::array< ::dds::core::array< float, 25L>, 2L>& aSensorEnergy() const OMG_NOEXCEPT {
        return m_aSensorEnergy_;
    }

    void aSensorEnergy(const ::dds::core::array< ::dds::core::array< float, 25L>, 2L>& value) {
        m_aSensorEnergy_ = value;
    }

    void aSensorEnergy(::dds::core::array< ::dds::core::array< float, 25L>, 2L>&& value) {
        m_aSensorEnergy_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fTotalEnergy() OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    const ::dds::core::array< float, 2L>& fTotalEnergy() const OMG_NOEXCEPT {
        return m_fTotalEnergy_;
    }

    void fTotalEnergy(const ::dds::core::array< float, 2L>& value) {
        m_fTotalEnergy_ = value;
    }

    void fTotalEnergy(::dds::core::array< float, 2L>&& value) {
        m_fTotalEnergy_ = std::move(value);
    }

    bool operator == (const MASDSP_MAS_AGC_CTRL_INFO& other_) const;
    bool operator != (const MASDSP_MAS_AGC_CTRL_INFO& other_) const;

    void swap(MASDSP_MAS_AGC_CTRL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 2L> m_usAxisGainControlVal_;
    ::dds::core::array< ::dds::core::array< float, 25L>, 2L> m_aSensorEnergy_;
    ::dds::core::array< float, 2L> m_fTotalEnergy_;

};

inline void swap(MASDSP_MAS_AGC_CTRL_INFO& a, MASDSP_MAS_AGC_CTRL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MASDSP_MAS_AGC_CTRL_INFO& sample);

class NDDSUSERDllExport MASDSP_MAS_DETECTION_CTRL_INFO_REQ {
  public:
    MASDSP_MAS_DETECTION_CTRL_INFO_REQ();

    MASDSP_MAS_DETECTION_CTRL_INFO_REQ(const ST_MSG_HEADER& stMsgHeader,uint16_t unTrgDtcSetInfoRequest);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MASDSP_MAS_DETECTION_CTRL_INFO_REQ (MASDSP_MAS_DETECTION_CTRL_INFO_REQ&&) = default;
    MASDSP_MAS_DETECTION_CTRL_INFO_REQ& operator=(MASDSP_MAS_DETECTION_CTRL_INFO_REQ&&) = default;
    MASDSP_MAS_DETECTION_CTRL_INFO_REQ& operator=(const MASDSP_MAS_DETECTION_CTRL_INFO_REQ&) = default;
    MASDSP_MAS_DETECTION_CTRL_INFO_REQ(const MASDSP_MAS_DETECTION_CTRL_INFO_REQ&) = default;
    #else
    MASDSP_MAS_DETECTION_CTRL_INFO_REQ(MASDSP_MAS_DETECTION_CTRL_INFO_REQ&& other_) OMG_NOEXCEPT;  
    MASDSP_MAS_DETECTION_CTRL_INFO_REQ& operator=(MASDSP_MAS_DETECTION_CTRL_INFO_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unTrgDtcSetInfoRequest() OMG_NOEXCEPT {
        return m_unTrgDtcSetInfoRequest_;
    }

    const uint16_t& unTrgDtcSetInfoRequest() const OMG_NOEXCEPT {
        return m_unTrgDtcSetInfoRequest_;
    }

    void unTrgDtcSetInfoRequest(uint16_t value) {
        m_unTrgDtcSetInfoRequest_ = value;
    }

    bool operator == (const MASDSP_MAS_DETECTION_CTRL_INFO_REQ& other_) const;
    bool operator != (const MASDSP_MAS_DETECTION_CTRL_INFO_REQ& other_) const;

    void swap(MASDSP_MAS_DETECTION_CTRL_INFO_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unTrgDtcSetInfoRequest_;

};

inline void swap(MASDSP_MAS_DETECTION_CTRL_INFO_REQ& a, MASDSP_MAS_DETECTION_CTRL_INFO_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MASDSP_MAS_DETECTION_CTRL_INFO_REQ& sample);

class NDDSUSERDllExport MASDSP_MAS_DETECTION_DATA {
  public:
    MASDSP_MAS_DETECTION_DATA();

    MASDSP_MAS_DETECTION_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ST_DATE_TIME& stAcqusitionTime,const ::dds::core::array< uint16_t, 2L>& unSensorGainVal,uint16_t unNBDIntegTimeInfo,const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo,const ::dds::core::array< float, 800L>& fALineBBDEngInfo,const ::dds::core::array< float, 800L>& fBLineBBDEngInfo,const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& fALineNBDEngInfo,const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& fBLineNBDEngInfo,const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fALineLOFARSigNorm,const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fBLineLOFARSigNorm,const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fALineDEMONSig,const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fBLineDEMONSig,const ::dds::core::array< float, 800L>& fALineMagTrgDtcInfo,const ::dds::core::array< float, 800L>& fBLineMagTrgDtcInfo,const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& fALineMagTrgDtcInfoAxis,const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& fBLineMagTrgDtcInfoAxis,const ::dds::core::array< float, 49L>& fALineMagSyntheSig,const ::dds::core::array< float, 49L>& fBLineMagSyntheSig);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MASDSP_MAS_DETECTION_DATA (MASDSP_MAS_DETECTION_DATA&&) = default;
    MASDSP_MAS_DETECTION_DATA& operator=(MASDSP_MAS_DETECTION_DATA&&) = default;
    MASDSP_MAS_DETECTION_DATA& operator=(const MASDSP_MAS_DETECTION_DATA&) = default;
    MASDSP_MAS_DETECTION_DATA(const MASDSP_MAS_DETECTION_DATA&) = default;
    #else
    MASDSP_MAS_DETECTION_DATA(MASDSP_MAS_DETECTION_DATA&& other_) OMG_NOEXCEPT;  
    MASDSP_MAS_DETECTION_DATA& operator=(MASDSP_MAS_DETECTION_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ST_DATE_TIME& stAcqusitionTime() OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    const ST_DATE_TIME& stAcqusitionTime() const OMG_NOEXCEPT {
        return m_stAcqusitionTime_;
    }

    void stAcqusitionTime(const ST_DATE_TIME& value) {
        m_stAcqusitionTime_ = value;
    }

    void stAcqusitionTime(ST_DATE_TIME&& value) {
        m_stAcqusitionTime_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& unSensorGainVal() OMG_NOEXCEPT {
        return m_unSensorGainVal_;
    }

    const ::dds::core::array< uint16_t, 2L>& unSensorGainVal() const OMG_NOEXCEPT {
        return m_unSensorGainVal_;
    }

    void unSensorGainVal(const ::dds::core::array< uint16_t, 2L>& value) {
        m_unSensorGainVal_ = value;
    }

    void unSensorGainVal(::dds::core::array< uint16_t, 2L>&& value) {
        m_unSensorGainVal_ = std::move(value);
    }
    uint16_t& unNBDIntegTimeInfo() OMG_NOEXCEPT {
        return m_unNBDIntegTimeInfo_;
    }

    const uint16_t& unNBDIntegTimeInfo() const OMG_NOEXCEPT {
        return m_unNBDIntegTimeInfo_;
    }

    void unNBDIntegTimeInfo(uint16_t value) {
        m_unNBDIntegTimeInfo_ = value;
    }

    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() const OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    void stMASDetFreqExcInfo(const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& value) {
        m_stMASDetFreqExcInfo_ = value;
    }

    void stMASDetFreqExcInfo(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&& value) {
        m_stMASDetFreqExcInfo_ = std::move(value);
    }
    ::dds::core::array< float, 800L>& fALineBBDEngInfo() OMG_NOEXCEPT {
        return m_fALineBBDEngInfo_;
    }

    const ::dds::core::array< float, 800L>& fALineBBDEngInfo() const OMG_NOEXCEPT {
        return m_fALineBBDEngInfo_;
    }

    void fALineBBDEngInfo(const ::dds::core::array< float, 800L>& value) {
        m_fALineBBDEngInfo_ = value;
    }

    void fALineBBDEngInfo(::dds::core::array< float, 800L>&& value) {
        m_fALineBBDEngInfo_ = std::move(value);
    }
    ::dds::core::array< float, 800L>& fBLineBBDEngInfo() OMG_NOEXCEPT {
        return m_fBLineBBDEngInfo_;
    }

    const ::dds::core::array< float, 800L>& fBLineBBDEngInfo() const OMG_NOEXCEPT {
        return m_fBLineBBDEngInfo_;
    }

    void fBLineBBDEngInfo(const ::dds::core::array< float, 800L>& value) {
        m_fBLineBBDEngInfo_ = value;
    }

    void fBLineBBDEngInfo(::dds::core::array< float, 800L>&& value) {
        m_fBLineBBDEngInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& fALineNBDEngInfo() OMG_NOEXCEPT {
        return m_fALineNBDEngInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& fALineNBDEngInfo() const OMG_NOEXCEPT {
        return m_fALineNBDEngInfo_;
    }

    void fALineNBDEngInfo(const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& value) {
        m_fALineNBDEngInfo_ = value;
    }

    void fALineNBDEngInfo(::dds::core::array< ::dds::core::array< float, 800L>, 5L>&& value) {
        m_fALineNBDEngInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& fBLineNBDEngInfo() OMG_NOEXCEPT {
        return m_fBLineNBDEngInfo_;
    }

    const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& fBLineNBDEngInfo() const OMG_NOEXCEPT {
        return m_fBLineNBDEngInfo_;
    }

    void fBLineNBDEngInfo(const ::dds::core::array< ::dds::core::array< float, 800L>, 5L>& value) {
        m_fBLineNBDEngInfo_ = value;
    }

    void fBLineNBDEngInfo(::dds::core::array< ::dds::core::array< float, 800L>, 5L>&& value) {
        m_fBLineNBDEngInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fALineLOFARSigNorm() OMG_NOEXCEPT {
        return m_fALineLOFARSigNorm_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fALineLOFARSigNorm() const OMG_NOEXCEPT {
        return m_fALineLOFARSigNorm_;
    }

    void fALineLOFARSigNorm(const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& value) {
        m_fALineLOFARSigNorm_ = value;
    }

    void fALineLOFARSigNorm(::dds::core::array< ::dds::core::array< float, 1601L>, 25L>&& value) {
        m_fALineLOFARSigNorm_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fBLineLOFARSigNorm() OMG_NOEXCEPT {
        return m_fBLineLOFARSigNorm_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fBLineLOFARSigNorm() const OMG_NOEXCEPT {
        return m_fBLineLOFARSigNorm_;
    }

    void fBLineLOFARSigNorm(const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& value) {
        m_fBLineLOFARSigNorm_ = value;
    }

    void fBLineLOFARSigNorm(::dds::core::array< ::dds::core::array< float, 1601L>, 25L>&& value) {
        m_fBLineLOFARSigNorm_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fALineDEMONSig() OMG_NOEXCEPT {
        return m_fALineDEMONSig_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fALineDEMONSig() const OMG_NOEXCEPT {
        return m_fALineDEMONSig_;
    }

    void fALineDEMONSig(const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& value) {
        m_fALineDEMONSig_ = value;
    }

    void fALineDEMONSig(::dds::core::array< ::dds::core::array< float, 1601L>, 25L>&& value) {
        m_fALineDEMONSig_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fBLineDEMONSig() OMG_NOEXCEPT {
        return m_fBLineDEMONSig_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& fBLineDEMONSig() const OMG_NOEXCEPT {
        return m_fBLineDEMONSig_;
    }

    void fBLineDEMONSig(const ::dds::core::array< ::dds::core::array< float, 1601L>, 25L>& value) {
        m_fBLineDEMONSig_ = value;
    }

    void fBLineDEMONSig(::dds::core::array< ::dds::core::array< float, 1601L>, 25L>&& value) {
        m_fBLineDEMONSig_ = std::move(value);
    }
    ::dds::core::array< float, 800L>& fALineMagTrgDtcInfo() OMG_NOEXCEPT {
        return m_fALineMagTrgDtcInfo_;
    }

    const ::dds::core::array< float, 800L>& fALineMagTrgDtcInfo() const OMG_NOEXCEPT {
        return m_fALineMagTrgDtcInfo_;
    }

    void fALineMagTrgDtcInfo(const ::dds::core::array< float, 800L>& value) {
        m_fALineMagTrgDtcInfo_ = value;
    }

    void fALineMagTrgDtcInfo(::dds::core::array< float, 800L>&& value) {
        m_fALineMagTrgDtcInfo_ = std::move(value);
    }
    ::dds::core::array< float, 800L>& fBLineMagTrgDtcInfo() OMG_NOEXCEPT {
        return m_fBLineMagTrgDtcInfo_;
    }

    const ::dds::core::array< float, 800L>& fBLineMagTrgDtcInfo() const OMG_NOEXCEPT {
        return m_fBLineMagTrgDtcInfo_;
    }

    void fBLineMagTrgDtcInfo(const ::dds::core::array< float, 800L>& value) {
        m_fBLineMagTrgDtcInfo_ = value;
    }

    void fBLineMagTrgDtcInfo(::dds::core::array< float, 800L>&& value) {
        m_fBLineMagTrgDtcInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& fALineMagTrgDtcInfoAxis() OMG_NOEXCEPT {
        return m_fALineMagTrgDtcInfoAxis_;
    }

    const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& fALineMagTrgDtcInfoAxis() const OMG_NOEXCEPT {
        return m_fALineMagTrgDtcInfoAxis_;
    }

    void fALineMagTrgDtcInfoAxis(const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& value) {
        m_fALineMagTrgDtcInfoAxis_ = value;
    }

    void fALineMagTrgDtcInfoAxis(::dds::core::array< ::dds::core::array< float, 49L>, 4L>&& value) {
        m_fALineMagTrgDtcInfoAxis_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& fBLineMagTrgDtcInfoAxis() OMG_NOEXCEPT {
        return m_fBLineMagTrgDtcInfoAxis_;
    }

    const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& fBLineMagTrgDtcInfoAxis() const OMG_NOEXCEPT {
        return m_fBLineMagTrgDtcInfoAxis_;
    }

    void fBLineMagTrgDtcInfoAxis(const ::dds::core::array< ::dds::core::array< float, 49L>, 4L>& value) {
        m_fBLineMagTrgDtcInfoAxis_ = value;
    }

    void fBLineMagTrgDtcInfoAxis(::dds::core::array< ::dds::core::array< float, 49L>, 4L>&& value) {
        m_fBLineMagTrgDtcInfoAxis_ = std::move(value);
    }
    ::dds::core::array< float, 49L>& fALineMagSyntheSig() OMG_NOEXCEPT {
        return m_fALineMagSyntheSig_;
    }

    const ::dds::core::array< float, 49L>& fALineMagSyntheSig() const OMG_NOEXCEPT {
        return m_fALineMagSyntheSig_;
    }

    void fALineMagSyntheSig(const ::dds::core::array< float, 49L>& value) {
        m_fALineMagSyntheSig_ = value;
    }

    void fALineMagSyntheSig(::dds::core::array< float, 49L>&& value) {
        m_fALineMagSyntheSig_ = std::move(value);
    }
    ::dds::core::array< float, 49L>& fBLineMagSyntheSig() OMG_NOEXCEPT {
        return m_fBLineMagSyntheSig_;
    }

    const ::dds::core::array< float, 49L>& fBLineMagSyntheSig() const OMG_NOEXCEPT {
        return m_fBLineMagSyntheSig_;
    }

    void fBLineMagSyntheSig(const ::dds::core::array< float, 49L>& value) {
        m_fBLineMagSyntheSig_ = value;
    }

    void fBLineMagSyntheSig(::dds::core::array< float, 49L>&& value) {
        m_fBLineMagSyntheSig_ = std::move(value);
    }

    bool operator == (const MASDSP_MAS_DETECTION_DATA& other_) const;
    bool operator != (const MASDSP_MAS_DETECTION_DATA& other_) const;

    void swap(MASDSP_MAS_DETECTION_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ST_DATE_TIME m_stAcqusitionTime_;
    ::dds::core::array< uint16_t, 2L> m_unSensorGainVal_;
    uint16_t m_unNBDIntegTimeInfo_;
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO m_stMASDetFreqExcInfo_;
    ::dds::core::array< float, 800L> m_fALineBBDEngInfo_;
    ::dds::core::array< float, 800L> m_fBLineBBDEngInfo_;
    ::dds::core::array< ::dds::core::array< float, 800L>, 5L> m_fALineNBDEngInfo_;
    ::dds::core::array< ::dds::core::array< float, 800L>, 5L> m_fBLineNBDEngInfo_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L> m_fALineLOFARSigNorm_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L> m_fBLineLOFARSigNorm_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L> m_fALineDEMONSig_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 25L> m_fBLineDEMONSig_;
    ::dds::core::array< float, 800L> m_fALineMagTrgDtcInfo_;
    ::dds::core::array< float, 800L> m_fBLineMagTrgDtcInfo_;
    ::dds::core::array< ::dds::core::array< float, 49L>, 4L> m_fALineMagTrgDtcInfoAxis_;
    ::dds::core::array< ::dds::core::array< float, 49L>, 4L> m_fBLineMagTrgDtcInfoAxis_;
    ::dds::core::array< float, 49L> m_fALineMagSyntheSig_;
    ::dds::core::array< float, 49L> m_fBLineMagSyntheSig_;

};

inline void swap(MASDSP_MAS_DETECTION_DATA& a, MASDSP_MAS_DETECTION_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MASDSP_MAS_DETECTION_DATA& sample);

class NDDSUSERDllExport MASDSP_MAS_ENE_DATA {
  public:
    MASDSP_MAS_ENE_DATA();

    MASDSP_MAS_ENE_DATA(const ST_MSG_HEADER& stMsgHeader,uint32_t ulFrameNo,const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aAColumnENE,const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aBColumnENE);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MASDSP_MAS_ENE_DATA (MASDSP_MAS_ENE_DATA&&) = default;
    MASDSP_MAS_ENE_DATA& operator=(MASDSP_MAS_ENE_DATA&&) = default;
    MASDSP_MAS_ENE_DATA& operator=(const MASDSP_MAS_ENE_DATA&) = default;
    MASDSP_MAS_ENE_DATA(const MASDSP_MAS_ENE_DATA&) = default;
    #else
    MASDSP_MAS_ENE_DATA(MASDSP_MAS_ENE_DATA&& other_) OMG_NOEXCEPT;  
    MASDSP_MAS_ENE_DATA& operator=(MASDSP_MAS_ENE_DATA&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulFrameNo() OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    const uint32_t& ulFrameNo() const OMG_NOEXCEPT {
        return m_ulFrameNo_;
    }

    void ulFrameNo(uint32_t value) {
        m_ulFrameNo_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aAColumnENE() OMG_NOEXCEPT {
        return m_aAColumnENE_;
    }

    const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aAColumnENE() const OMG_NOEXCEPT {
        return m_aAColumnENE_;
    }

    void aAColumnENE(const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& value) {
        m_aAColumnENE_ = value;
    }

    void aAColumnENE(::dds::core::array< ::dds::core::array< float, 15L>, 25L>&& value) {
        m_aAColumnENE_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aBColumnENE() OMG_NOEXCEPT {
        return m_aBColumnENE_;
    }

    const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& aBColumnENE() const OMG_NOEXCEPT {
        return m_aBColumnENE_;
    }

    void aBColumnENE(const ::dds::core::array< ::dds::core::array< float, 15L>, 25L>& value) {
        m_aBColumnENE_ = value;
    }

    void aBColumnENE(::dds::core::array< ::dds::core::array< float, 15L>, 25L>&& value) {
        m_aBColumnENE_ = std::move(value);
    }

    bool operator == (const MASDSP_MAS_ENE_DATA& other_) const;
    bool operator != (const MASDSP_MAS_ENE_DATA& other_) const;

    void swap(MASDSP_MAS_ENE_DATA& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulFrameNo_;
    ::dds::core::array< ::dds::core::array< float, 15L>, 25L> m_aAColumnENE_;
    ::dds::core::array< ::dds::core::array< float, 15L>, 25L> m_aBColumnENE_;

};

inline void swap(MASDSP_MAS_ENE_DATA& a, MASDSP_MAS_ENE_DATA& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MASDSP_MAS_ENE_DATA& sample);

class NDDSUSERDllExport SPPANA_ANALYSIS_PROCESS_INFO {
  public:
    SPPANA_ANALYSIS_PROCESS_INFO();

    SPPANA_ANALYSIS_PROCESS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usAnalType,float fProcessRate);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_ANALYSIS_PROCESS_INFO (SPPANA_ANALYSIS_PROCESS_INFO&&) = default;
    SPPANA_ANALYSIS_PROCESS_INFO& operator=(SPPANA_ANALYSIS_PROCESS_INFO&&) = default;
    SPPANA_ANALYSIS_PROCESS_INFO& operator=(const SPPANA_ANALYSIS_PROCESS_INFO&) = default;
    SPPANA_ANALYSIS_PROCESS_INFO(const SPPANA_ANALYSIS_PROCESS_INFO&) = default;
    #else
    SPPANA_ANALYSIS_PROCESS_INFO(SPPANA_ANALYSIS_PROCESS_INFO&& other_) OMG_NOEXCEPT;  
    SPPANA_ANALYSIS_PROCESS_INFO& operator=(SPPANA_ANALYSIS_PROCESS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAnalType() OMG_NOEXCEPT {
        return m_usAnalType_;
    }

    const uint16_t& usAnalType() const OMG_NOEXCEPT {
        return m_usAnalType_;
    }

    void usAnalType(uint16_t value) {
        m_usAnalType_ = value;
    }

    float& fProcessRate() OMG_NOEXCEPT {
        return m_fProcessRate_;
    }

    const float& fProcessRate() const OMG_NOEXCEPT {
        return m_fProcessRate_;
    }

    void fProcessRate(float value) {
        m_fProcessRate_ = value;
    }

    bool operator == (const SPPANA_ANALYSIS_PROCESS_INFO& other_) const;
    bool operator != (const SPPANA_ANALYSIS_PROCESS_INFO& other_) const;

    void swap(SPPANA_ANALYSIS_PROCESS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAnalType_;
    float m_fProcessRate_;

};

inline void swap(SPPANA_ANALYSIS_PROCESS_INFO& a, SPPANA_ANALYSIS_PROCESS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_ANALYSIS_PROCESS_INFO& sample);

class NDDSUSERDllExport SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT {
  public:
    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT();

    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,const ::dds::core::array< char, 80L>& acASPDRayFolder,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT (SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(const SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    ::dds::core::array< char, 80L>& acASPDRayFolder() OMG_NOEXCEPT {
        return m_acASPDRayFolder_;
    }

    const ::dds::core::array< char, 80L>& acASPDRayFolder() const OMG_NOEXCEPT {
        return m_acASPDRayFolder_;
    }

    void acASPDRayFolder(const ::dds::core::array< char, 80L>& value) {
        m_acASPDRayFolder_ = value;
    }

    void acASPDRayFolder(::dds::core::array< char, 80L>&& value) {
        m_acASPDRayFolder_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    ::dds::core::array< char, 80L> m_acASPDRayFolder_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& a, SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST {
  public:
    SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST();

    explicit SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST(const ST_MSG_HEADER& stMsgHeader);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST (SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&&) = default;
    SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& operator=(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&&) = default;
    SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& operator=(const SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&) = default;
    SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST(const SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&) = default;
    #else
    SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&& other_) OMG_NOEXCEPT;  
    SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& operator=(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }

    bool operator == (const SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& other_) const;
    bool operator != (const SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& other_) const;

    void swap(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;

};

inline void swap(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& a, SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample);

class NDDSUSERDllExport SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT {
  public:
    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT();

    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,double dAnalPointLat,double dAnalPointLon,float fAnalPointDepth,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT (SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT&&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& operator=(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT&&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& operator=(const SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT(const SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& operator=(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    double& dAnalPointLat() OMG_NOEXCEPT {
        return m_dAnalPointLat_;
    }

    const double& dAnalPointLat() const OMG_NOEXCEPT {
        return m_dAnalPointLat_;
    }

    void dAnalPointLat(double value) {
        m_dAnalPointLat_ = value;
    }

    double& dAnalPointLon() OMG_NOEXCEPT {
        return m_dAnalPointLon_;
    }

    const double& dAnalPointLon() const OMG_NOEXCEPT {
        return m_dAnalPointLon_;
    }

    void dAnalPointLon(double value) {
        m_dAnalPointLon_ = value;
    }

    float& fAnalPointDepth() OMG_NOEXCEPT {
        return m_fAnalPointDepth_;
    }

    const float& fAnalPointDepth() const OMG_NOEXCEPT {
        return m_fAnalPointDepth_;
    }

    void fAnalPointDepth(float value) {
        m_fAnalPointDepth_ = value;
    }

    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    double m_dAnalPointLat_;
    double m_dAnalPointLon_;
    float m_fAnalPointDepth_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& a, SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT {
  public:
    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT();

    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< char, 80L>& acFindResultFolder,double dAnalPointLat,double dAnalPointLon,float fAnalPointDepth,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT (SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT&&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& operator=(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT&&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& operator=(const SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT(const SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& operator=(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acFindResultFolder() OMG_NOEXCEPT {
        return m_acFindResultFolder_;
    }

    const ::dds::core::array< char, 80L>& acFindResultFolder() const OMG_NOEXCEPT {
        return m_acFindResultFolder_;
    }

    void acFindResultFolder(const ::dds::core::array< char, 80L>& value) {
        m_acFindResultFolder_ = value;
    }

    void acFindResultFolder(::dds::core::array< char, 80L>&& value) {
        m_acFindResultFolder_ = std::move(value);
    }
    double& dAnalPointLat() OMG_NOEXCEPT {
        return m_dAnalPointLat_;
    }

    const double& dAnalPointLat() const OMG_NOEXCEPT {
        return m_dAnalPointLat_;
    }

    void dAnalPointLat(double value) {
        m_dAnalPointLat_ = value;
    }

    double& dAnalPointLon() OMG_NOEXCEPT {
        return m_dAnalPointLon_;
    }

    const double& dAnalPointLon() const OMG_NOEXCEPT {
        return m_dAnalPointLon_;
    }

    void dAnalPointLon(double value) {
        m_dAnalPointLon_ = value;
    }

    float& fAnalPointDepth() OMG_NOEXCEPT {
        return m_fAnalPointDepth_;
    }

    const float& fAnalPointDepth() const OMG_NOEXCEPT {
        return m_fAnalPointDepth_;
    }

    void fAnalPointDepth(float value) {
        m_fAnalPointDepth_ = value;
    }

    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< char, 80L> m_acFindResultFolder_;
    double m_dAnalPointLat_;
    double m_dAnalPointLon_;
    float m_fAnalPointDepth_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& a, SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT {
  public:
    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT();

    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< char, 80L>& acSearchResultFolder,uint16_t usPosNum,const ::dds::core::array< double, 3L>& dAnalPointLat,const ::dds::core::array< double, 3L>& dAnalPointLon,const ::dds::core::array< float, 3L>& fAnalPointDepth,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT (SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT&&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& operator=(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT&&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& operator=(const SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT&) = default;
    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT(const SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& operator=(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acSearchResultFolder() OMG_NOEXCEPT {
        return m_acSearchResultFolder_;
    }

    const ::dds::core::array< char, 80L>& acSearchResultFolder() const OMG_NOEXCEPT {
        return m_acSearchResultFolder_;
    }

    void acSearchResultFolder(const ::dds::core::array< char, 80L>& value) {
        m_acSearchResultFolder_ = value;
    }

    void acSearchResultFolder(::dds::core::array< char, 80L>&& value) {
        m_acSearchResultFolder_ = std::move(value);
    }
    uint16_t& usPosNum() OMG_NOEXCEPT {
        return m_usPosNum_;
    }

    const uint16_t& usPosNum() const OMG_NOEXCEPT {
        return m_usPosNum_;
    }

    void usPosNum(uint16_t value) {
        m_usPosNum_ = value;
    }

    ::dds::core::array< double, 3L>& dAnalPointLat() OMG_NOEXCEPT {
        return m_dAnalPointLat_;
    }

    const ::dds::core::array< double, 3L>& dAnalPointLat() const OMG_NOEXCEPT {
        return m_dAnalPointLat_;
    }

    void dAnalPointLat(const ::dds::core::array< double, 3L>& value) {
        m_dAnalPointLat_ = value;
    }

    void dAnalPointLat(::dds::core::array< double, 3L>&& value) {
        m_dAnalPointLat_ = std::move(value);
    }
    ::dds::core::array< double, 3L>& dAnalPointLon() OMG_NOEXCEPT {
        return m_dAnalPointLon_;
    }

    const ::dds::core::array< double, 3L>& dAnalPointLon() const OMG_NOEXCEPT {
        return m_dAnalPointLon_;
    }

    void dAnalPointLon(const ::dds::core::array< double, 3L>& value) {
        m_dAnalPointLon_ = value;
    }

    void dAnalPointLon(::dds::core::array< double, 3L>&& value) {
        m_dAnalPointLon_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& fAnalPointDepth() OMG_NOEXCEPT {
        return m_fAnalPointDepth_;
    }

    const ::dds::core::array< float, 3L>& fAnalPointDepth() const OMG_NOEXCEPT {
        return m_fAnalPointDepth_;
    }

    void fAnalPointDepth(const ::dds::core::array< float, 3L>& value) {
        m_fAnalPointDepth_ = value;
    }

    void fAnalPointDepth(::dds::core::array< float, 3L>&& value) {
        m_fAnalPointDepth_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< char, 80L> m_acSearchResultFolder_;
    uint16_t m_usPosNum_;
    ::dds::core::array< double, 3L> m_dAnalPointLat_;
    ::dds::core::array< double, 3L> m_dAnalPointLon_;
    ::dds::core::array< float, 3L> m_fAnalPointDepth_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& a, SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT {
  public:
    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT();

    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,const ::dds::core::array< char, 80L>& acBIPDFolder,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT (SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(const SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    ::dds::core::array< char, 80L>& acBIPDFolder() OMG_NOEXCEPT {
        return m_acBIPDFolder_;
    }

    const ::dds::core::array< char, 80L>& acBIPDFolder() const OMG_NOEXCEPT {
        return m_acBIPDFolder_;
    }

    void acBIPDFolder(const ::dds::core::array< char, 80L>& value) {
        m_acBIPDFolder_ = value;
    }

    void acBIPDFolder(::dds::core::array< char, 80L>&& value) {
        m_acBIPDFolder_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    ::dds::core::array< char, 80L> m_acBIPDFolder_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& a, SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_HORIZONTAL_ANALYSIS_RESULT {
  public:
    SPPANA_HORIZONTAL_ANALYSIS_RESULT();

    SPPANA_HORIZONTAL_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,float fAnalXRangeRes,float fAnalYRangeRes,const ::dds::core::array< char, 80L>& acDepthDataName,const ::dds::core::array< char, 80L>& acTempDataName,const ::dds::core::array< char, 80L>& acSVPDataName,const ::dds::core::array< char, 80L>& acContourLineName,const ::dds::core::array< char, 80L>& acUnderwaterObsName,const ::dds::core::array< char, 80L>& acSediInfo,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_HORIZONTAL_ANALYSIS_RESULT (SPPANA_HORIZONTAL_ANALYSIS_RESULT&&) = default;
    SPPANA_HORIZONTAL_ANALYSIS_RESULT& operator=(SPPANA_HORIZONTAL_ANALYSIS_RESULT&&) = default;
    SPPANA_HORIZONTAL_ANALYSIS_RESULT& operator=(const SPPANA_HORIZONTAL_ANALYSIS_RESULT&) = default;
    SPPANA_HORIZONTAL_ANALYSIS_RESULT(const SPPANA_HORIZONTAL_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_HORIZONTAL_ANALYSIS_RESULT(SPPANA_HORIZONTAL_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_HORIZONTAL_ANALYSIS_RESULT& operator=(SPPANA_HORIZONTAL_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    float& fAnalXRangeRes() OMG_NOEXCEPT {
        return m_fAnalXRangeRes_;
    }

    const float& fAnalXRangeRes() const OMG_NOEXCEPT {
        return m_fAnalXRangeRes_;
    }

    void fAnalXRangeRes(float value) {
        m_fAnalXRangeRes_ = value;
    }

    float& fAnalYRangeRes() OMG_NOEXCEPT {
        return m_fAnalYRangeRes_;
    }

    const float& fAnalYRangeRes() const OMG_NOEXCEPT {
        return m_fAnalYRangeRes_;
    }

    void fAnalYRangeRes(float value) {
        m_fAnalYRangeRes_ = value;
    }

    ::dds::core::array< char, 80L>& acDepthDataName() OMG_NOEXCEPT {
        return m_acDepthDataName_;
    }

    const ::dds::core::array< char, 80L>& acDepthDataName() const OMG_NOEXCEPT {
        return m_acDepthDataName_;
    }

    void acDepthDataName(const ::dds::core::array< char, 80L>& value) {
        m_acDepthDataName_ = value;
    }

    void acDepthDataName(::dds::core::array< char, 80L>&& value) {
        m_acDepthDataName_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acTempDataName() OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    const ::dds::core::array< char, 80L>& acTempDataName() const OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    void acTempDataName(const ::dds::core::array< char, 80L>& value) {
        m_acTempDataName_ = value;
    }

    void acTempDataName(::dds::core::array< char, 80L>&& value) {
        m_acTempDataName_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acSVPDataName() OMG_NOEXCEPT {
        return m_acSVPDataName_;
    }

    const ::dds::core::array< char, 80L>& acSVPDataName() const OMG_NOEXCEPT {
        return m_acSVPDataName_;
    }

    void acSVPDataName(const ::dds::core::array< char, 80L>& value) {
        m_acSVPDataName_ = value;
    }

    void acSVPDataName(::dds::core::array< char, 80L>&& value) {
        m_acSVPDataName_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acContourLineName() OMG_NOEXCEPT {
        return m_acContourLineName_;
    }

    const ::dds::core::array< char, 80L>& acContourLineName() const OMG_NOEXCEPT {
        return m_acContourLineName_;
    }

    void acContourLineName(const ::dds::core::array< char, 80L>& value) {
        m_acContourLineName_ = value;
    }

    void acContourLineName(::dds::core::array< char, 80L>&& value) {
        m_acContourLineName_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acUnderwaterObsName() OMG_NOEXCEPT {
        return m_acUnderwaterObsName_;
    }

    const ::dds::core::array< char, 80L>& acUnderwaterObsName() const OMG_NOEXCEPT {
        return m_acUnderwaterObsName_;
    }

    void acUnderwaterObsName(const ::dds::core::array< char, 80L>& value) {
        m_acUnderwaterObsName_ = value;
    }

    void acUnderwaterObsName(::dds::core::array< char, 80L>&& value) {
        m_acUnderwaterObsName_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acSediInfo() OMG_NOEXCEPT {
        return m_acSediInfo_;
    }

    const ::dds::core::array< char, 80L>& acSediInfo() const OMG_NOEXCEPT {
        return m_acSediInfo_;
    }

    void acSediInfo(const ::dds::core::array< char, 80L>& value) {
        m_acSediInfo_ = value;
    }

    void acSediInfo(::dds::core::array< char, 80L>&& value) {
        m_acSediInfo_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_HORIZONTAL_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_HORIZONTAL_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_HORIZONTAL_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    float m_fAnalXRangeRes_;
    float m_fAnalYRangeRes_;
    ::dds::core::array< char, 80L> m_acDepthDataName_;
    ::dds::core::array< char, 80L> m_acTempDataName_;
    ::dds::core::array< char, 80L> m_acSVPDataName_;
    ::dds::core::array< char, 80L> m_acContourLineName_;
    ::dds::core::array< char, 80L> m_acUnderwaterObsName_;
    ::dds::core::array< char, 80L> m_acSediInfo_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_HORIZONTAL_ANALYSIS_RESULT& a, SPPANA_HORIZONTAL_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_HORIZONTAL_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT {
  public:
    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT();

    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,const ::dds::core::array< char, 80L>& acLASPDRayFolder,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT (SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(const SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    ::dds::core::array< char, 80L>& acLASPDRayFolder() OMG_NOEXCEPT {
        return m_acLASPDRayFolder_;
    }

    const ::dds::core::array< char, 80L>& acLASPDRayFolder() const OMG_NOEXCEPT {
        return m_acLASPDRayFolder_;
    }

    void acLASPDRayFolder(const ::dds::core::array< char, 80L>& value) {
        m_acLASPDRayFolder_ = value;
    }

    void acLASPDRayFolder(::dds::core::array< char, 80L>&& value) {
        m_acLASPDRayFolder_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    ::dds::core::array< char, 80L> m_acLASPDRayFolder_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& a, SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT {
  public:
    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT();

    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,const ::dds::core::array< char, 80L>& acMASPDRayFolder,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT (SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&) = default;
    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(const SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(const SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& operator=(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    ::dds::core::array< char, 80L>& acMASPDRayFolder() OMG_NOEXCEPT {
        return m_acMASPDRayFolder_;
    }

    const ::dds::core::array< char, 80L>& acMASPDRayFolder() const OMG_NOEXCEPT {
        return m_acMASPDRayFolder_;
    }

    void acMASPDRayFolder(const ::dds::core::array< char, 80L>& value) {
        m_acMASPDRayFolder_ = value;
    }

    void acMASPDRayFolder(::dds::core::array< char, 80L>&& value) {
        m_acMASPDRayFolder_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    ::dds::core::array< char, 80L> m_acMASPDRayFolder_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& a, SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_MODEL_PROCESS_STATUS_RESULT {
  public:
    SPPANA_MODEL_PROCESS_STATUS_RESULT();

    SPPANA_MODEL_PROCESS_STATUS_RESULT(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,bool bPerform,uint16_t usAnalType,bool bDBType,const ::dds::core::array< char, 80L>& acTempDataName);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_MODEL_PROCESS_STATUS_RESULT (SPPANA_MODEL_PROCESS_STATUS_RESULT&&) = default;
    SPPANA_MODEL_PROCESS_STATUS_RESULT& operator=(SPPANA_MODEL_PROCESS_STATUS_RESULT&&) = default;
    SPPANA_MODEL_PROCESS_STATUS_RESULT& operator=(const SPPANA_MODEL_PROCESS_STATUS_RESULT&) = default;
    SPPANA_MODEL_PROCESS_STATUS_RESULT(const SPPANA_MODEL_PROCESS_STATUS_RESULT&) = default;
    #else
    SPPANA_MODEL_PROCESS_STATUS_RESULT(SPPANA_MODEL_PROCESS_STATUS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_MODEL_PROCESS_STATUS_RESULT& operator=(SPPANA_MODEL_PROCESS_STATUS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    bool& bPerform() OMG_NOEXCEPT {
        return m_bPerform_;
    }

    const bool& bPerform() const OMG_NOEXCEPT {
        return m_bPerform_;
    }

    void bPerform(bool value) {
        m_bPerform_ = value;
    }

    uint16_t& usAnalType() OMG_NOEXCEPT {
        return m_usAnalType_;
    }

    const uint16_t& usAnalType() const OMG_NOEXCEPT {
        return m_usAnalType_;
    }

    void usAnalType(uint16_t value) {
        m_usAnalType_ = value;
    }

    bool& bDBType() OMG_NOEXCEPT {
        return m_bDBType_;
    }

    const bool& bDBType() const OMG_NOEXCEPT {
        return m_bDBType_;
    }

    void bDBType(bool value) {
        m_bDBType_ = value;
    }

    ::dds::core::array< char, 80L>& acTempDataName() OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    const ::dds::core::array< char, 80L>& acTempDataName() const OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    void acTempDataName(const ::dds::core::array< char, 80L>& value) {
        m_acTempDataName_ = value;
    }

    void acTempDataName(::dds::core::array< char, 80L>&& value) {
        m_acTempDataName_ = std::move(value);
    }

    bool operator == (const SPPANA_MODEL_PROCESS_STATUS_RESULT& other_) const;
    bool operator != (const SPPANA_MODEL_PROCESS_STATUS_RESULT& other_) const;

    void swap(SPPANA_MODEL_PROCESS_STATUS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    bool m_bPerform_;
    uint16_t m_usAnalType_;
    bool m_bDBType_;
    ::dds::core::array< char, 80L> m_acTempDataName_;

};

inline void swap(SPPANA_MODEL_PROCESS_STATUS_RESULT& a, SPPANA_MODEL_PROCESS_STATUS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_MODEL_PROCESS_STATUS_RESULT& sample);

class NDDSUSERDllExport SPPANA_POINT_ANALYSIS_RESULT {
  public:
    SPPANA_POINT_ANALYSIS_RESULT();

    SPPANA_POINT_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unTempDataLength,float fBottom,const ::dds::core::array< char, 80L>& acTempDataName,const ::dds::core::array< char, 80L>& acSVPDataName,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_POINT_ANALYSIS_RESULT (SPPANA_POINT_ANALYSIS_RESULT&&) = default;
    SPPANA_POINT_ANALYSIS_RESULT& operator=(SPPANA_POINT_ANALYSIS_RESULT&&) = default;
    SPPANA_POINT_ANALYSIS_RESULT& operator=(const SPPANA_POINT_ANALYSIS_RESULT&) = default;
    SPPANA_POINT_ANALYSIS_RESULT(const SPPANA_POINT_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_POINT_ANALYSIS_RESULT(SPPANA_POINT_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_POINT_ANALYSIS_RESULT& operator=(SPPANA_POINT_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unTempDataLength() OMG_NOEXCEPT {
        return m_unTempDataLength_;
    }

    const uint16_t& unTempDataLength() const OMG_NOEXCEPT {
        return m_unTempDataLength_;
    }

    void unTempDataLength(uint16_t value) {
        m_unTempDataLength_ = value;
    }

    float& fBottom() OMG_NOEXCEPT {
        return m_fBottom_;
    }

    const float& fBottom() const OMG_NOEXCEPT {
        return m_fBottom_;
    }

    void fBottom(float value) {
        m_fBottom_ = value;
    }

    ::dds::core::array< char, 80L>& acTempDataName() OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    const ::dds::core::array< char, 80L>& acTempDataName() const OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    void acTempDataName(const ::dds::core::array< char, 80L>& value) {
        m_acTempDataName_ = value;
    }

    void acTempDataName(::dds::core::array< char, 80L>&& value) {
        m_acTempDataName_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acSVPDataName() OMG_NOEXCEPT {
        return m_acSVPDataName_;
    }

    const ::dds::core::array< char, 80L>& acSVPDataName() const OMG_NOEXCEPT {
        return m_acSVPDataName_;
    }

    void acSVPDataName(const ::dds::core::array< char, 80L>& value) {
        m_acSVPDataName_ = value;
    }

    void acSVPDataName(::dds::core::array< char, 80L>&& value) {
        m_acSVPDataName_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_POINT_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_POINT_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_POINT_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unTempDataLength_;
    float m_fBottom_;
    ::dds::core::array< char, 80L> m_acTempDataName_;
    ::dds::core::array< char, 80L> m_acSVPDataName_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_POINT_ANALYSIS_RESULT& a, SPPANA_POINT_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_POINT_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport SPPANA_VERTICAL_ANALYSIS_RESULT {
  public:
    SPPANA_VERTICAL_ANALYSIS_RESULT();

    SPPANA_VERTICAL_ANALYSIS_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unTempDataLength,float fTempAnalXRangeRes,float fTempAnalYRangeRes,const ::dds::core::array< char, 80L>& acTempDataName,const ::dds::core::array< char, 80L>& acSVPDataName,bool bProcesson);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SPPANA_VERTICAL_ANALYSIS_RESULT (SPPANA_VERTICAL_ANALYSIS_RESULT&&) = default;
    SPPANA_VERTICAL_ANALYSIS_RESULT& operator=(SPPANA_VERTICAL_ANALYSIS_RESULT&&) = default;
    SPPANA_VERTICAL_ANALYSIS_RESULT& operator=(const SPPANA_VERTICAL_ANALYSIS_RESULT&) = default;
    SPPANA_VERTICAL_ANALYSIS_RESULT(const SPPANA_VERTICAL_ANALYSIS_RESULT&) = default;
    #else
    SPPANA_VERTICAL_ANALYSIS_RESULT(SPPANA_VERTICAL_ANALYSIS_RESULT&& other_) OMG_NOEXCEPT;  
    SPPANA_VERTICAL_ANALYSIS_RESULT& operator=(SPPANA_VERTICAL_ANALYSIS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unTempDataLength() OMG_NOEXCEPT {
        return m_unTempDataLength_;
    }

    const uint16_t& unTempDataLength() const OMG_NOEXCEPT {
        return m_unTempDataLength_;
    }

    void unTempDataLength(uint16_t value) {
        m_unTempDataLength_ = value;
    }

    float& fTempAnalXRangeRes() OMG_NOEXCEPT {
        return m_fTempAnalXRangeRes_;
    }

    const float& fTempAnalXRangeRes() const OMG_NOEXCEPT {
        return m_fTempAnalXRangeRes_;
    }

    void fTempAnalXRangeRes(float value) {
        m_fTempAnalXRangeRes_ = value;
    }

    float& fTempAnalYRangeRes() OMG_NOEXCEPT {
        return m_fTempAnalYRangeRes_;
    }

    const float& fTempAnalYRangeRes() const OMG_NOEXCEPT {
        return m_fTempAnalYRangeRes_;
    }

    void fTempAnalYRangeRes(float value) {
        m_fTempAnalYRangeRes_ = value;
    }

    ::dds::core::array< char, 80L>& acTempDataName() OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    const ::dds::core::array< char, 80L>& acTempDataName() const OMG_NOEXCEPT {
        return m_acTempDataName_;
    }

    void acTempDataName(const ::dds::core::array< char, 80L>& value) {
        m_acTempDataName_ = value;
    }

    void acTempDataName(::dds::core::array< char, 80L>&& value) {
        m_acTempDataName_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acSVPDataName() OMG_NOEXCEPT {
        return m_acSVPDataName_;
    }

    const ::dds::core::array< char, 80L>& acSVPDataName() const OMG_NOEXCEPT {
        return m_acSVPDataName_;
    }

    void acSVPDataName(const ::dds::core::array< char, 80L>& value) {
        m_acSVPDataName_ = value;
    }

    void acSVPDataName(::dds::core::array< char, 80L>&& value) {
        m_acSVPDataName_ = std::move(value);
    }
    bool& bProcesson() OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    const bool& bProcesson() const OMG_NOEXCEPT {
        return m_bProcesson_;
    }

    void bProcesson(bool value) {
        m_bProcesson_ = value;
    }

    bool operator == (const SPPANA_VERTICAL_ANALYSIS_RESULT& other_) const;
    bool operator != (const SPPANA_VERTICAL_ANALYSIS_RESULT& other_) const;

    void swap(SPPANA_VERTICAL_ANALYSIS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unTempDataLength_;
    float m_fTempAnalXRangeRes_;
    float m_fTempAnalYRangeRes_;
    ::dds::core::array< char, 80L> m_acTempDataName_;
    ::dds::core::array< char, 80L> m_acSVPDataName_;
    bool m_bProcesson_;

};

inline void swap(SPPANA_VERTICAL_ANALYSIS_RESULT& a, SPPANA_VERTICAL_ANALYSIS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SPPANA_VERTICAL_ANALYSIS_RESULT& sample);

class NDDSUSERDllExport ST_NIC_ADDR {
  public:
    ST_NIC_ADDR();

    ST_NIC_ADDR(const ::dds::core::array< uint8_t, 20L>& oIP1,const ::dds::core::array< uint8_t, 20L>& oIP2,const ::dds::core::array< uint8_t, 20L>& oIP3,const ::dds::core::array< uint8_t, 20L>& oIP4);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_NIC_ADDR (ST_NIC_ADDR&&) = default;
    ST_NIC_ADDR& operator=(ST_NIC_ADDR&&) = default;
    ST_NIC_ADDR& operator=(const ST_NIC_ADDR&) = default;
    ST_NIC_ADDR(const ST_NIC_ADDR&) = default;
    #else
    ST_NIC_ADDR(ST_NIC_ADDR&& other_) OMG_NOEXCEPT;  
    ST_NIC_ADDR& operator=(ST_NIC_ADDR&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 20L>& oIP1() OMG_NOEXCEPT {
        return m_oIP1_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP1() const OMG_NOEXCEPT {
        return m_oIP1_;
    }

    void oIP1(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP1_ = value;
    }

    void oIP1(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP1_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP2() OMG_NOEXCEPT {
        return m_oIP2_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP2() const OMG_NOEXCEPT {
        return m_oIP2_;
    }

    void oIP2(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP2_ = value;
    }

    void oIP2(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP2_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP3() OMG_NOEXCEPT {
        return m_oIP3_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP3() const OMG_NOEXCEPT {
        return m_oIP3_;
    }

    void oIP3(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP3_ = value;
    }

    void oIP3(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP3_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP4() OMG_NOEXCEPT {
        return m_oIP4_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP4() const OMG_NOEXCEPT {
        return m_oIP4_;
    }

    void oIP4(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP4_ = value;
    }

    void oIP4(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP4_ = std::move(value);
    }

    bool operator == (const ST_NIC_ADDR& other_) const;
    bool operator != (const ST_NIC_ADDR& other_) const;

    void swap(ST_NIC_ADDR& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 20L> m_oIP1_;
    ::dds::core::array< uint8_t, 20L> m_oIP2_;
    ::dds::core::array< uint8_t, 20L> m_oIP3_;
    ::dds::core::array< uint8_t, 20L> m_oIP4_;

};

inline void swap(ST_NIC_ADDR& a, ST_NIC_ADDR& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_NIC_ADDR& sample);

class NDDSUSERDllExport ST_EQUIP_DIAGNOSTIC_RESULT {
  public:
    ST_EQUIP_DIAGNOSTIC_RESULT();

    ST_EQUIP_DIAGNOSTIC_RESULT(int32_t lCPUTestResult,int32_t lCPUTestTime,int32_t lMemTestResult,int32_t lMemTestTime,int32_t lHDDTestTime,int32_t lHDDTestResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EQUIP_DIAGNOSTIC_RESULT (ST_EQUIP_DIAGNOSTIC_RESULT&&) = default;
    ST_EQUIP_DIAGNOSTIC_RESULT& operator=(ST_EQUIP_DIAGNOSTIC_RESULT&&) = default;
    ST_EQUIP_DIAGNOSTIC_RESULT& operator=(const ST_EQUIP_DIAGNOSTIC_RESULT&) = default;
    ST_EQUIP_DIAGNOSTIC_RESULT(const ST_EQUIP_DIAGNOSTIC_RESULT&) = default;
    #else
    ST_EQUIP_DIAGNOSTIC_RESULT(ST_EQUIP_DIAGNOSTIC_RESULT&& other_) OMG_NOEXCEPT;  
    ST_EQUIP_DIAGNOSTIC_RESULT& operator=(ST_EQUIP_DIAGNOSTIC_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    int32_t& lCPUTestResult() OMG_NOEXCEPT {
        return m_lCPUTestResult_;
    }

    const int32_t& lCPUTestResult() const OMG_NOEXCEPT {
        return m_lCPUTestResult_;
    }

    void lCPUTestResult(int32_t value) {
        m_lCPUTestResult_ = value;
    }

    int32_t& lCPUTestTime() OMG_NOEXCEPT {
        return m_lCPUTestTime_;
    }

    const int32_t& lCPUTestTime() const OMG_NOEXCEPT {
        return m_lCPUTestTime_;
    }

    void lCPUTestTime(int32_t value) {
        m_lCPUTestTime_ = value;
    }

    int32_t& lMemTestResult() OMG_NOEXCEPT {
        return m_lMemTestResult_;
    }

    const int32_t& lMemTestResult() const OMG_NOEXCEPT {
        return m_lMemTestResult_;
    }

    void lMemTestResult(int32_t value) {
        m_lMemTestResult_ = value;
    }

    int32_t& lMemTestTime() OMG_NOEXCEPT {
        return m_lMemTestTime_;
    }

    const int32_t& lMemTestTime() const OMG_NOEXCEPT {
        return m_lMemTestTime_;
    }

    void lMemTestTime(int32_t value) {
        m_lMemTestTime_ = value;
    }

    int32_t& lHDDTestTime() OMG_NOEXCEPT {
        return m_lHDDTestTime_;
    }

    const int32_t& lHDDTestTime() const OMG_NOEXCEPT {
        return m_lHDDTestTime_;
    }

    void lHDDTestTime(int32_t value) {
        m_lHDDTestTime_ = value;
    }

    int32_t& lHDDTestResult() OMG_NOEXCEPT {
        return m_lHDDTestResult_;
    }

    const int32_t& lHDDTestResult() const OMG_NOEXCEPT {
        return m_lHDDTestResult_;
    }

    void lHDDTestResult(int32_t value) {
        m_lHDDTestResult_ = value;
    }

    bool operator == (const ST_EQUIP_DIAGNOSTIC_RESULT& other_) const;
    bool operator != (const ST_EQUIP_DIAGNOSTIC_RESULT& other_) const;

    void swap(ST_EQUIP_DIAGNOSTIC_RESULT& other_) OMG_NOEXCEPT ;

  private:

    int32_t m_lCPUTestResult_;
    int32_t m_lCPUTestTime_;
    int32_t m_lMemTestResult_;
    int32_t m_lMemTestTime_;
    int32_t m_lHDDTestTime_;
    int32_t m_lHDDTestResult_;

};

inline void swap(ST_EQUIP_DIAGNOSTIC_RESULT& a, ST_EQUIP_DIAGNOSTIC_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EQUIP_DIAGNOSTIC_RESULT& sample);

class NDDSUSERDllExport SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT {
  public:
    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT();

    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT(const ST_MSG_HEADER& stMsgHeader,const ST_NIC_ADDR& stNICIPAddress,const ST_EQUIP_DIAGNOSTIC_RESULT& stEquipDiagnosticResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT (SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT&&) = default;
    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& operator=(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT&&) = default;
    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& operator=(const SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT&) = default;
    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT(const SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT&) = default;
    #else
    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT&& other_) OMG_NOEXCEPT;  
    SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& operator=(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_NIC_ADDR& stNICIPAddress() OMG_NOEXCEPT {
        return m_stNICIPAddress_;
    }

    const ST_NIC_ADDR& stNICIPAddress() const OMG_NOEXCEPT {
        return m_stNICIPAddress_;
    }

    void stNICIPAddress(const ST_NIC_ADDR& value) {
        m_stNICIPAddress_ = value;
    }

    void stNICIPAddress(ST_NIC_ADDR&& value) {
        m_stNICIPAddress_ = std::move(value);
    }
    ST_EQUIP_DIAGNOSTIC_RESULT& stEquipDiagnosticResult() OMG_NOEXCEPT {
        return m_stEquipDiagnosticResult_;
    }

    const ST_EQUIP_DIAGNOSTIC_RESULT& stEquipDiagnosticResult() const OMG_NOEXCEPT {
        return m_stEquipDiagnosticResult_;
    }

    void stEquipDiagnosticResult(const ST_EQUIP_DIAGNOSTIC_RESULT& value) {
        m_stEquipDiagnosticResult_ = value;
    }

    void stEquipDiagnosticResult(ST_EQUIP_DIAGNOSTIC_RESULT&& value) {
        m_stEquipDiagnosticResult_ = std::move(value);
    }

    bool operator == (const SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& other_) const;
    bool operator != (const SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& other_) const;

    void swap(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_NIC_ADDR m_stNICIPAddress_;
    ST_EQUIP_DIAGNOSTIC_RESULT m_stEquipDiagnosticResult_;

};

inline void swap(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& a, SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& sample);

class NDDSUSERDllExport SYSMGR_ALERT_CMD {
  public:
    SYSMGR_ALERT_CMD();

    SYSMGR_ALERT_CMD(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 128L>& oSWName,const ::dds::core::array< uint8_t, 20L>& oIP,uint8_t oCmdType,uint32_t ulMsgID,const ::dds::core::array< uint8_t, 128L>& oOperatorName,uint8_t oAlertType,const ::dds::core::array< uint8_t, 500L>& oMsg);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_ALERT_CMD (SYSMGR_ALERT_CMD&&) = default;
    SYSMGR_ALERT_CMD& operator=(SYSMGR_ALERT_CMD&&) = default;
    SYSMGR_ALERT_CMD& operator=(const SYSMGR_ALERT_CMD&) = default;
    SYSMGR_ALERT_CMD(const SYSMGR_ALERT_CMD&) = default;
    #else
    SYSMGR_ALERT_CMD(SYSMGR_ALERT_CMD&& other_) OMG_NOEXCEPT;  
    SYSMGR_ALERT_CMD& operator=(SYSMGR_ALERT_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName() OMG_NOEXCEPT {
        return m_oSWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName() const OMG_NOEXCEPT {
        return m_oSWName_;
    }

    void oSWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName_ = value;
    }

    void oSWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    uint8_t& oCmdType() OMG_NOEXCEPT {
        return m_oCmdType_;
    }

    const uint8_t& oCmdType() const OMG_NOEXCEPT {
        return m_oCmdType_;
    }

    void oCmdType(uint8_t value) {
        m_oCmdType_ = value;
    }

    uint32_t& ulMsgID() OMG_NOEXCEPT {
        return m_ulMsgID_;
    }

    const uint32_t& ulMsgID() const OMG_NOEXCEPT {
        return m_ulMsgID_;
    }

    void ulMsgID(uint32_t value) {
        m_ulMsgID_ = value;
    }

    ::dds::core::array< uint8_t, 128L>& oOperatorName() OMG_NOEXCEPT {
        return m_oOperatorName_;
    }

    const ::dds::core::array< uint8_t, 128L>& oOperatorName() const OMG_NOEXCEPT {
        return m_oOperatorName_;
    }

    void oOperatorName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oOperatorName_ = value;
    }

    void oOperatorName(::dds::core::array< uint8_t, 128L>&& value) {
        m_oOperatorName_ = std::move(value);
    }
    uint8_t& oAlertType() OMG_NOEXCEPT {
        return m_oAlertType_;
    }

    const uint8_t& oAlertType() const OMG_NOEXCEPT {
        return m_oAlertType_;
    }

    void oAlertType(uint8_t value) {
        m_oAlertType_ = value;
    }

    ::dds::core::array< uint8_t, 500L>& oMsg() OMG_NOEXCEPT {
        return m_oMsg_;
    }

    const ::dds::core::array< uint8_t, 500L>& oMsg() const OMG_NOEXCEPT {
        return m_oMsg_;
    }

    void oMsg(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oMsg_ = value;
    }

    void oMsg(::dds::core::array< uint8_t, 500L>&& value) {
        m_oMsg_ = std::move(value);
    }

    bool operator == (const SYSMGR_ALERT_CMD& other_) const;
    bool operator != (const SYSMGR_ALERT_CMD& other_) const;

    void swap(SYSMGR_ALERT_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 128L> m_oSWName_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;
    uint8_t m_oCmdType_;
    uint32_t m_ulMsgID_;
    ::dds::core::array< uint8_t, 128L> m_oOperatorName_;
    uint8_t m_oAlertType_;
    ::dds::core::array< uint8_t, 500L> m_oMsg_;

};

inline void swap(SYSMGR_ALERT_CMD& a, SYSMGR_ALERT_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_ALERT_CMD& sample);

class NDDSUSERDllExport SYSMGR_ALERT_REPORT {
  public:
    SYSMGR_ALERT_REPORT();

    SYSMGR_ALERT_REPORT(const ST_MSG_HEADER& stMsgHeader,uint32_t ulMsgID,const ::dds::core::array< uint8_t, 128L>& oSWName,const ::dds::core::array< uint8_t, 20L>& oIP,uint8_t oAlertType,const ::dds::core::array< uint8_t, 500L>& oMsg);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_ALERT_REPORT (SYSMGR_ALERT_REPORT&&) = default;
    SYSMGR_ALERT_REPORT& operator=(SYSMGR_ALERT_REPORT&&) = default;
    SYSMGR_ALERT_REPORT& operator=(const SYSMGR_ALERT_REPORT&) = default;
    SYSMGR_ALERT_REPORT(const SYSMGR_ALERT_REPORT&) = default;
    #else
    SYSMGR_ALERT_REPORT(SYSMGR_ALERT_REPORT&& other_) OMG_NOEXCEPT;  
    SYSMGR_ALERT_REPORT& operator=(SYSMGR_ALERT_REPORT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulMsgID() OMG_NOEXCEPT {
        return m_ulMsgID_;
    }

    const uint32_t& ulMsgID() const OMG_NOEXCEPT {
        return m_ulMsgID_;
    }

    void ulMsgID(uint32_t value) {
        m_ulMsgID_ = value;
    }

    ::dds::core::array< uint8_t, 128L>& oSWName() OMG_NOEXCEPT {
        return m_oSWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName() const OMG_NOEXCEPT {
        return m_oSWName_;
    }

    void oSWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName_ = value;
    }

    void oSWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    uint8_t& oAlertType() OMG_NOEXCEPT {
        return m_oAlertType_;
    }

    const uint8_t& oAlertType() const OMG_NOEXCEPT {
        return m_oAlertType_;
    }

    void oAlertType(uint8_t value) {
        m_oAlertType_ = value;
    }

    ::dds::core::array< uint8_t, 500L>& oMsg() OMG_NOEXCEPT {
        return m_oMsg_;
    }

    const ::dds::core::array< uint8_t, 500L>& oMsg() const OMG_NOEXCEPT {
        return m_oMsg_;
    }

    void oMsg(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oMsg_ = value;
    }

    void oMsg(::dds::core::array< uint8_t, 500L>&& value) {
        m_oMsg_ = std::move(value);
    }

    bool operator == (const SYSMGR_ALERT_REPORT& other_) const;
    bool operator != (const SYSMGR_ALERT_REPORT& other_) const;

    void swap(SYSMGR_ALERT_REPORT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulMsgID_;
    ::dds::core::array< uint8_t, 128L> m_oSWName_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;
    uint8_t m_oAlertType_;
    ::dds::core::array< uint8_t, 500L> m_oMsg_;

};

inline void swap(SYSMGR_ALERT_REPORT& a, SYSMGR_ALERT_REPORT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_ALERT_REPORT& sample);

class NDDSUSERDllExport ST_SW_NAME {
  public:
    ST_SW_NAME();

    ST_SW_NAME(const ::dds::core::array< uint8_t, 128L>& oSWName1,const ::dds::core::array< uint8_t, 128L>& oSWName2,const ::dds::core::array< uint8_t, 128L>& oSWName3,const ::dds::core::array< uint8_t, 128L>& oSWName4,const ::dds::core::array< uint8_t, 128L>& oSWName5,const ::dds::core::array< uint8_t, 128L>& oSWName6,const ::dds::core::array< uint8_t, 128L>& oSWName7,const ::dds::core::array< uint8_t, 128L>& oSWName8,const ::dds::core::array< uint8_t, 128L>& oSWName9,const ::dds::core::array< uint8_t, 128L>& oSWName10);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_NAME (ST_SW_NAME&&) = default;
    ST_SW_NAME& operator=(ST_SW_NAME&&) = default;
    ST_SW_NAME& operator=(const ST_SW_NAME&) = default;
    ST_SW_NAME(const ST_SW_NAME&) = default;
    #else
    ST_SW_NAME(ST_SW_NAME&& other_) OMG_NOEXCEPT;  
    ST_SW_NAME& operator=(ST_SW_NAME&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 128L>& oSWName1() OMG_NOEXCEPT {
        return m_oSWName1_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName1() const OMG_NOEXCEPT {
        return m_oSWName1_;
    }

    void oSWName1(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName1_ = value;
    }

    void oSWName1(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName1_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName2() OMG_NOEXCEPT {
        return m_oSWName2_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName2() const OMG_NOEXCEPT {
        return m_oSWName2_;
    }

    void oSWName2(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName2_ = value;
    }

    void oSWName2(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName2_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName3() OMG_NOEXCEPT {
        return m_oSWName3_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName3() const OMG_NOEXCEPT {
        return m_oSWName3_;
    }

    void oSWName3(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName3_ = value;
    }

    void oSWName3(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName3_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName4() OMG_NOEXCEPT {
        return m_oSWName4_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName4() const OMG_NOEXCEPT {
        return m_oSWName4_;
    }

    void oSWName4(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName4_ = value;
    }

    void oSWName4(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName4_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName5() OMG_NOEXCEPT {
        return m_oSWName5_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName5() const OMG_NOEXCEPT {
        return m_oSWName5_;
    }

    void oSWName5(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName5_ = value;
    }

    void oSWName5(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName5_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName6() OMG_NOEXCEPT {
        return m_oSWName6_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName6() const OMG_NOEXCEPT {
        return m_oSWName6_;
    }

    void oSWName6(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName6_ = value;
    }

    void oSWName6(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName6_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName7() OMG_NOEXCEPT {
        return m_oSWName7_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName7() const OMG_NOEXCEPT {
        return m_oSWName7_;
    }

    void oSWName7(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName7_ = value;
    }

    void oSWName7(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName7_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName8() OMG_NOEXCEPT {
        return m_oSWName8_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName8() const OMG_NOEXCEPT {
        return m_oSWName8_;
    }

    void oSWName8(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName8_ = value;
    }

    void oSWName8(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName8_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName9() OMG_NOEXCEPT {
        return m_oSWName9_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName9() const OMG_NOEXCEPT {
        return m_oSWName9_;
    }

    void oSWName9(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName9_ = value;
    }

    void oSWName9(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName9_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName10() OMG_NOEXCEPT {
        return m_oSWName10_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName10() const OMG_NOEXCEPT {
        return m_oSWName10_;
    }

    void oSWName10(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName10_ = value;
    }

    void oSWName10(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName10_ = std::move(value);
    }

    bool operator == (const ST_SW_NAME& other_) const;
    bool operator != (const ST_SW_NAME& other_) const;

    void swap(ST_SW_NAME& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 128L> m_oSWName1_;
    ::dds::core::array< uint8_t, 128L> m_oSWName2_;
    ::dds::core::array< uint8_t, 128L> m_oSWName3_;
    ::dds::core::array< uint8_t, 128L> m_oSWName4_;
    ::dds::core::array< uint8_t, 128L> m_oSWName5_;
    ::dds::core::array< uint8_t, 128L> m_oSWName6_;
    ::dds::core::array< uint8_t, 128L> m_oSWName7_;
    ::dds::core::array< uint8_t, 128L> m_oSWName8_;
    ::dds::core::array< uint8_t, 128L> m_oSWName9_;
    ::dds::core::array< uint8_t, 128L> m_oSWName10_;

};

inline void swap(ST_SW_NAME& a, ST_SW_NAME& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_NAME& sample);

class NDDSUSERDllExport SYSMGR_DEV_RUN_CMD {
  public:
    SYSMGR_DEV_RUN_CMD();

    SYSMGR_DEV_RUN_CMD(const ST_MSG_HEADER& stMsgHeader,const ST_NIC_ADDR& stIP,const ST_SW_NAME& stSWName,uint16_t usForce,uint16_t usRunType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_DEV_RUN_CMD (SYSMGR_DEV_RUN_CMD&&) = default;
    SYSMGR_DEV_RUN_CMD& operator=(SYSMGR_DEV_RUN_CMD&&) = default;
    SYSMGR_DEV_RUN_CMD& operator=(const SYSMGR_DEV_RUN_CMD&) = default;
    SYSMGR_DEV_RUN_CMD(const SYSMGR_DEV_RUN_CMD&) = default;
    #else
    SYSMGR_DEV_RUN_CMD(SYSMGR_DEV_RUN_CMD&& other_) OMG_NOEXCEPT;  
    SYSMGR_DEV_RUN_CMD& operator=(SYSMGR_DEV_RUN_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_NIC_ADDR& stIP() OMG_NOEXCEPT {
        return m_stIP_;
    }

    const ST_NIC_ADDR& stIP() const OMG_NOEXCEPT {
        return m_stIP_;
    }

    void stIP(const ST_NIC_ADDR& value) {
        m_stIP_ = value;
    }

    void stIP(ST_NIC_ADDR&& value) {
        m_stIP_ = std::move(value);
    }
    ST_SW_NAME& stSWName() OMG_NOEXCEPT {
        return m_stSWName_;
    }

    const ST_SW_NAME& stSWName() const OMG_NOEXCEPT {
        return m_stSWName_;
    }

    void stSWName(const ST_SW_NAME& value) {
        m_stSWName_ = value;
    }

    void stSWName(ST_SW_NAME&& value) {
        m_stSWName_ = std::move(value);
    }
    uint16_t& usForce() OMG_NOEXCEPT {
        return m_usForce_;
    }

    const uint16_t& usForce() const OMG_NOEXCEPT {
        return m_usForce_;
    }

    void usForce(uint16_t value) {
        m_usForce_ = value;
    }

    uint16_t& usRunType() OMG_NOEXCEPT {
        return m_usRunType_;
    }

    const uint16_t& usRunType() const OMG_NOEXCEPT {
        return m_usRunType_;
    }

    void usRunType(uint16_t value) {
        m_usRunType_ = value;
    }

    bool operator == (const SYSMGR_DEV_RUN_CMD& other_) const;
    bool operator != (const SYSMGR_DEV_RUN_CMD& other_) const;

    void swap(SYSMGR_DEV_RUN_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_NIC_ADDR m_stIP_;
    ST_SW_NAME m_stSWName_;
    uint16_t m_usForce_;
    uint16_t m_usRunType_;

};

inline void swap(SYSMGR_DEV_RUN_CMD& a, SYSMGR_DEV_RUN_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_DEV_RUN_CMD& sample);

class NDDSUSERDllExport ST_SW_VERSION {
  public:
    ST_SW_VERSION();

    ST_SW_VERSION(uint16_t usMajorVer,uint16_t usMinorVer,uint16_t usBuildVer,uint16_t reserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_VERSION (ST_SW_VERSION&&) = default;
    ST_SW_VERSION& operator=(ST_SW_VERSION&&) = default;
    ST_SW_VERSION& operator=(const ST_SW_VERSION&) = default;
    ST_SW_VERSION(const ST_SW_VERSION&) = default;
    #else
    ST_SW_VERSION(ST_SW_VERSION&& other_) OMG_NOEXCEPT;  
    ST_SW_VERSION& operator=(ST_SW_VERSION&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usMajorVer() OMG_NOEXCEPT {
        return m_usMajorVer_;
    }

    const uint16_t& usMajorVer() const OMG_NOEXCEPT {
        return m_usMajorVer_;
    }

    void usMajorVer(uint16_t value) {
        m_usMajorVer_ = value;
    }

    uint16_t& usMinorVer() OMG_NOEXCEPT {
        return m_usMinorVer_;
    }

    const uint16_t& usMinorVer() const OMG_NOEXCEPT {
        return m_usMinorVer_;
    }

    void usMinorVer(uint16_t value) {
        m_usMinorVer_ = value;
    }

    uint16_t& usBuildVer() OMG_NOEXCEPT {
        return m_usBuildVer_;
    }

    const uint16_t& usBuildVer() const OMG_NOEXCEPT {
        return m_usBuildVer_;
    }

    void usBuildVer(uint16_t value) {
        m_usBuildVer_ = value;
    }

    uint16_t& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const uint16_t& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(uint16_t value) {
        m_reserved_ = value;
    }

    bool operator == (const ST_SW_VERSION& other_) const;
    bool operator != (const ST_SW_VERSION& other_) const;

    void swap(ST_SW_VERSION& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usMajorVer_;
    uint16_t m_usMinorVer_;
    uint16_t m_usBuildVer_;
    uint16_t m_reserved_;

};

inline void swap(ST_SW_VERSION& a, ST_SW_VERSION& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_VERSION& sample);

class NDDSUSERDllExport ST_SW_STATUS_INFO {
  public:
    ST_SW_STATUS_INFO();

    ST_SW_STATUS_INFO(const ::dds::core::array< uint8_t, 128L>& oSWName,uint32_t ulProcID,uint8_t oActive,uint8_t oStatus,const ::dds::core::array< uint8_t, 32L>& aSubUnitStatus,uint8_t oOnOff,uint8_t oMode,const ST_SW_VERSION& stSWVersion);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_STATUS_INFO (ST_SW_STATUS_INFO&&) = default;
    ST_SW_STATUS_INFO& operator=(ST_SW_STATUS_INFO&&) = default;
    ST_SW_STATUS_INFO& operator=(const ST_SW_STATUS_INFO&) = default;
    ST_SW_STATUS_INFO(const ST_SW_STATUS_INFO&) = default;
    #else
    ST_SW_STATUS_INFO(ST_SW_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_SW_STATUS_INFO& operator=(ST_SW_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 128L>& oSWName() OMG_NOEXCEPT {
        return m_oSWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName() const OMG_NOEXCEPT {
        return m_oSWName_;
    }

    void oSWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName_ = value;
    }

    void oSWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName_ = std::move(value);
    }
    uint32_t& ulProcID() OMG_NOEXCEPT {
        return m_ulProcID_;
    }

    const uint32_t& ulProcID() const OMG_NOEXCEPT {
        return m_ulProcID_;
    }

    void ulProcID(uint32_t value) {
        m_ulProcID_ = value;
    }

    uint8_t& oActive() OMG_NOEXCEPT {
        return m_oActive_;
    }

    const uint8_t& oActive() const OMG_NOEXCEPT {
        return m_oActive_;
    }

    void oActive(uint8_t value) {
        m_oActive_ = value;
    }

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    ::dds::core::array< uint8_t, 32L>& aSubUnitStatus() OMG_NOEXCEPT {
        return m_aSubUnitStatus_;
    }

    const ::dds::core::array< uint8_t, 32L>& aSubUnitStatus() const OMG_NOEXCEPT {
        return m_aSubUnitStatus_;
    }

    void aSubUnitStatus(const ::dds::core::array< uint8_t, 32L>& value) {
        m_aSubUnitStatus_ = value;
    }

    void aSubUnitStatus(::dds::core::array< uint8_t, 32L>&& value) {
        m_aSubUnitStatus_ = std::move(value);
    }
    uint8_t& oOnOff() OMG_NOEXCEPT {
        return m_oOnOff_;
    }

    const uint8_t& oOnOff() const OMG_NOEXCEPT {
        return m_oOnOff_;
    }

    void oOnOff(uint8_t value) {
        m_oOnOff_ = value;
    }

    uint8_t& oMode() OMG_NOEXCEPT {
        return m_oMode_;
    }

    const uint8_t& oMode() const OMG_NOEXCEPT {
        return m_oMode_;
    }

    void oMode(uint8_t value) {
        m_oMode_ = value;
    }

    ST_SW_VERSION& stSWVersion() OMG_NOEXCEPT {
        return m_stSWVersion_;
    }

    const ST_SW_VERSION& stSWVersion() const OMG_NOEXCEPT {
        return m_stSWVersion_;
    }

    void stSWVersion(const ST_SW_VERSION& value) {
        m_stSWVersion_ = value;
    }

    void stSWVersion(ST_SW_VERSION&& value) {
        m_stSWVersion_ = std::move(value);
    }

    bool operator == (const ST_SW_STATUS_INFO& other_) const;
    bool operator != (const ST_SW_STATUS_INFO& other_) const;

    void swap(ST_SW_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 128L> m_oSWName_;
    uint32_t m_ulProcID_;
    uint8_t m_oActive_;
    uint8_t m_oStatus_;
    ::dds::core::array< uint8_t, 32L> m_aSubUnitStatus_;
    uint8_t m_oOnOff_;
    uint8_t m_oMode_;
    ST_SW_VERSION m_stSWVersion_;

};

inline void swap(ST_SW_STATUS_INFO& a, ST_SW_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_STATUS_INFO& sample);

class NDDSUSERDllExport ST_SW_ALL_STATUS_INFO {
  public:
    ST_SW_ALL_STATUS_INFO();

    ST_SW_ALL_STATUS_INFO(uint32_t ulSWID,uint32_t ulHWID,const ST_SW_STATUS_INFO& stSWStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_ALL_STATUS_INFO (ST_SW_ALL_STATUS_INFO&&) = default;
    ST_SW_ALL_STATUS_INFO& operator=(ST_SW_ALL_STATUS_INFO&&) = default;
    ST_SW_ALL_STATUS_INFO& operator=(const ST_SW_ALL_STATUS_INFO&) = default;
    ST_SW_ALL_STATUS_INFO(const ST_SW_ALL_STATUS_INFO&) = default;
    #else
    ST_SW_ALL_STATUS_INFO(ST_SW_ALL_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_SW_ALL_STATUS_INFO& operator=(ST_SW_ALL_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulSWID() OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    const uint32_t& ulSWID() const OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    void ulSWID(uint32_t value) {
        m_ulSWID_ = value;
    }

    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    ST_SW_STATUS_INFO& stSWStatusInfo() OMG_NOEXCEPT {
        return m_stSWStatusInfo_;
    }

    const ST_SW_STATUS_INFO& stSWStatusInfo() const OMG_NOEXCEPT {
        return m_stSWStatusInfo_;
    }

    void stSWStatusInfo(const ST_SW_STATUS_INFO& value) {
        m_stSWStatusInfo_ = value;
    }

    void stSWStatusInfo(ST_SW_STATUS_INFO&& value) {
        m_stSWStatusInfo_ = std::move(value);
    }

    bool operator == (const ST_SW_ALL_STATUS_INFO& other_) const;
    bool operator != (const ST_SW_ALL_STATUS_INFO& other_) const;

    void swap(ST_SW_ALL_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulSWID_;
    uint32_t m_ulHWID_;
    ST_SW_STATUS_INFO m_stSWStatusInfo_;

};

inline void swap(ST_SW_ALL_STATUS_INFO& a, ST_SW_ALL_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_ALL_STATUS_INFO& sample);

class NDDSUSERDllExport ST_CPU_INFO {
  public:
    ST_CPU_INFO();

    ST_CPU_INFO(uint32_t nCoreCount,uint32_t nUsage);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_CPU_INFO (ST_CPU_INFO&&) = default;
    ST_CPU_INFO& operator=(ST_CPU_INFO&&) = default;
    ST_CPU_INFO& operator=(const ST_CPU_INFO&) = default;
    ST_CPU_INFO(const ST_CPU_INFO&) = default;
    #else
    ST_CPU_INFO(ST_CPU_INFO&& other_) OMG_NOEXCEPT;  
    ST_CPU_INFO& operator=(ST_CPU_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& nCoreCount() OMG_NOEXCEPT {
        return m_nCoreCount_;
    }

    const uint32_t& nCoreCount() const OMG_NOEXCEPT {
        return m_nCoreCount_;
    }

    void nCoreCount(uint32_t value) {
        m_nCoreCount_ = value;
    }

    uint32_t& nUsage() OMG_NOEXCEPT {
        return m_nUsage_;
    }

    const uint32_t& nUsage() const OMG_NOEXCEPT {
        return m_nUsage_;
    }

    void nUsage(uint32_t value) {
        m_nUsage_ = value;
    }

    bool operator == (const ST_CPU_INFO& other_) const;
    bool operator != (const ST_CPU_INFO& other_) const;

    void swap(ST_CPU_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_nCoreCount_;
    uint32_t m_nUsage_;

};

inline void swap(ST_CPU_INFO& a, ST_CPU_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_CPU_INFO& sample);

class NDDSUSERDllExport ST_NIC_INFO {
  public:
    ST_NIC_INFO();

    ST_NIC_INFO(const ::dds::core::array< uint8_t, 20L>& oIP,const ::dds::core::array< uint8_t, 256L>& oNicName,bool bEnable,uint32_t ulBandWidth,uint64_t ullBytesRecvPerSec,uint64_t ullBytesSendPerSec,uint64_t ullBytesTotalPerSec);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_NIC_INFO (ST_NIC_INFO&&) = default;
    ST_NIC_INFO& operator=(ST_NIC_INFO&&) = default;
    ST_NIC_INFO& operator=(const ST_NIC_INFO&) = default;
    ST_NIC_INFO(const ST_NIC_INFO&) = default;
    #else
    ST_NIC_INFO(ST_NIC_INFO&& other_) OMG_NOEXCEPT;  
    ST_NIC_INFO& operator=(ST_NIC_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& oNicName() OMG_NOEXCEPT {
        return m_oNicName_;
    }

    const ::dds::core::array< uint8_t, 256L>& oNicName() const OMG_NOEXCEPT {
        return m_oNicName_;
    }

    void oNicName(const ::dds::core::array< uint8_t, 256L>& value) {
        m_oNicName_ = value;
    }

    void oNicName(::dds::core::array< uint8_t, 256L>&& value) {
        m_oNicName_ = std::move(value);
    }
    bool& bEnable() OMG_NOEXCEPT {
        return m_bEnable_;
    }

    const bool& bEnable() const OMG_NOEXCEPT {
        return m_bEnable_;
    }

    void bEnable(bool value) {
        m_bEnable_ = value;
    }

    uint32_t& ulBandWidth() OMG_NOEXCEPT {
        return m_ulBandWidth_;
    }

    const uint32_t& ulBandWidth() const OMG_NOEXCEPT {
        return m_ulBandWidth_;
    }

    void ulBandWidth(uint32_t value) {
        m_ulBandWidth_ = value;
    }

    uint64_t& ullBytesRecvPerSec() OMG_NOEXCEPT {
        return m_ullBytesRecvPerSec_;
    }

    const uint64_t& ullBytesRecvPerSec() const OMG_NOEXCEPT {
        return m_ullBytesRecvPerSec_;
    }

    void ullBytesRecvPerSec(uint64_t value) {
        m_ullBytesRecvPerSec_ = value;
    }

    uint64_t& ullBytesSendPerSec() OMG_NOEXCEPT {
        return m_ullBytesSendPerSec_;
    }

    const uint64_t& ullBytesSendPerSec() const OMG_NOEXCEPT {
        return m_ullBytesSendPerSec_;
    }

    void ullBytesSendPerSec(uint64_t value) {
        m_ullBytesSendPerSec_ = value;
    }

    uint64_t& ullBytesTotalPerSec() OMG_NOEXCEPT {
        return m_ullBytesTotalPerSec_;
    }

    const uint64_t& ullBytesTotalPerSec() const OMG_NOEXCEPT {
        return m_ullBytesTotalPerSec_;
    }

    void ullBytesTotalPerSec(uint64_t value) {
        m_ullBytesTotalPerSec_ = value;
    }

    bool operator == (const ST_NIC_INFO& other_) const;
    bool operator != (const ST_NIC_INFO& other_) const;

    void swap(ST_NIC_INFO& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 20L> m_oIP_;
    ::dds::core::array< uint8_t, 256L> m_oNicName_;
    bool m_bEnable_;
    uint32_t m_ulBandWidth_;
    uint64_t m_ullBytesRecvPerSec_;
    uint64_t m_ullBytesSendPerSec_;
    uint64_t m_ullBytesTotalPerSec_;

};

inline void swap(ST_NIC_INFO& a, ST_NIC_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_NIC_INFO& sample);

class NDDSUSERDllExport ST_MEM_INFO {
  public:
    ST_MEM_INFO();

    ST_MEM_INFO(uint32_t ulTotalSize,uint32_t ulUsedSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MEM_INFO (ST_MEM_INFO&&) = default;
    ST_MEM_INFO& operator=(ST_MEM_INFO&&) = default;
    ST_MEM_INFO& operator=(const ST_MEM_INFO&) = default;
    ST_MEM_INFO(const ST_MEM_INFO&) = default;
    #else
    ST_MEM_INFO(ST_MEM_INFO&& other_) OMG_NOEXCEPT;  
    ST_MEM_INFO& operator=(ST_MEM_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulTotalSize() OMG_NOEXCEPT {
        return m_ulTotalSize_;
    }

    const uint32_t& ulTotalSize() const OMG_NOEXCEPT {
        return m_ulTotalSize_;
    }

    void ulTotalSize(uint32_t value) {
        m_ulTotalSize_ = value;
    }

    uint32_t& ulUsedSize() OMG_NOEXCEPT {
        return m_ulUsedSize_;
    }

    const uint32_t& ulUsedSize() const OMG_NOEXCEPT {
        return m_ulUsedSize_;
    }

    void ulUsedSize(uint32_t value) {
        m_ulUsedSize_ = value;
    }

    bool operator == (const ST_MEM_INFO& other_) const;
    bool operator != (const ST_MEM_INFO& other_) const;

    void swap(ST_MEM_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulTotalSize_;
    uint32_t m_ulUsedSize_;

};

inline void swap(ST_MEM_INFO& a, ST_MEM_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MEM_INFO& sample);

class NDDSUSERDllExport ST_DRIVE_INFO {
  public:
    ST_DRIVE_INFO();

    ST_DRIVE_INFO(bool bUse,const ::dds::core::array< uint8_t, 3L>& reserved,const ::dds::core::array< uint8_t, 10L>& oDrive,const ::dds::core::array< uint8_t, 256L>& oVolume,uint32_t ulDriveType,uint32_t ulDriveFileSystem,uint64_t ullTotalSize,uint64_t ullUsedSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_DRIVE_INFO (ST_DRIVE_INFO&&) = default;
    ST_DRIVE_INFO& operator=(ST_DRIVE_INFO&&) = default;
    ST_DRIVE_INFO& operator=(const ST_DRIVE_INFO&) = default;
    ST_DRIVE_INFO(const ST_DRIVE_INFO&) = default;
    #else
    ST_DRIVE_INFO(ST_DRIVE_INFO&& other_) OMG_NOEXCEPT;  
    ST_DRIVE_INFO& operator=(ST_DRIVE_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    bool& bUse() OMG_NOEXCEPT {
        return m_bUse_;
    }

    const bool& bUse() const OMG_NOEXCEPT {
        return m_bUse_;
    }

    void bUse(bool value) {
        m_bUse_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& reserved() OMG_NOEXCEPT {
        return m_reserved_;
    }

    const ::dds::core::array< uint8_t, 3L>& reserved() const OMG_NOEXCEPT {
        return m_reserved_;
    }

    void reserved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_reserved_ = value;
    }

    void reserved(::dds::core::array< uint8_t, 3L>&& value) {
        m_reserved_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 10L>& oDrive() OMG_NOEXCEPT {
        return m_oDrive_;
    }

    const ::dds::core::array< uint8_t, 10L>& oDrive() const OMG_NOEXCEPT {
        return m_oDrive_;
    }

    void oDrive(const ::dds::core::array< uint8_t, 10L>& value) {
        m_oDrive_ = value;
    }

    void oDrive(::dds::core::array< uint8_t, 10L>&& value) {
        m_oDrive_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& oVolume() OMG_NOEXCEPT {
        return m_oVolume_;
    }

    const ::dds::core::array< uint8_t, 256L>& oVolume() const OMG_NOEXCEPT {
        return m_oVolume_;
    }

    void oVolume(const ::dds::core::array< uint8_t, 256L>& value) {
        m_oVolume_ = value;
    }

    void oVolume(::dds::core::array< uint8_t, 256L>&& value) {
        m_oVolume_ = std::move(value);
    }
    uint32_t& ulDriveType() OMG_NOEXCEPT {
        return m_ulDriveType_;
    }

    const uint32_t& ulDriveType() const OMG_NOEXCEPT {
        return m_ulDriveType_;
    }

    void ulDriveType(uint32_t value) {
        m_ulDriveType_ = value;
    }

    uint32_t& ulDriveFileSystem() OMG_NOEXCEPT {
        return m_ulDriveFileSystem_;
    }

    const uint32_t& ulDriveFileSystem() const OMG_NOEXCEPT {
        return m_ulDriveFileSystem_;
    }

    void ulDriveFileSystem(uint32_t value) {
        m_ulDriveFileSystem_ = value;
    }

    uint64_t& ullTotalSize() OMG_NOEXCEPT {
        return m_ullTotalSize_;
    }

    const uint64_t& ullTotalSize() const OMG_NOEXCEPT {
        return m_ullTotalSize_;
    }

    void ullTotalSize(uint64_t value) {
        m_ullTotalSize_ = value;
    }

    uint64_t& ullUsedSize() OMG_NOEXCEPT {
        return m_ullUsedSize_;
    }

    const uint64_t& ullUsedSize() const OMG_NOEXCEPT {
        return m_ullUsedSize_;
    }

    void ullUsedSize(uint64_t value) {
        m_ullUsedSize_ = value;
    }

    bool operator == (const ST_DRIVE_INFO& other_) const;
    bool operator != (const ST_DRIVE_INFO& other_) const;

    void swap(ST_DRIVE_INFO& other_) OMG_NOEXCEPT ;

  private:

    bool m_bUse_;
    ::dds::core::array< uint8_t, 3L> m_reserved_;
    ::dds::core::array< uint8_t, 10L> m_oDrive_;
    ::dds::core::array< uint8_t, 256L> m_oVolume_;
    uint32_t m_ulDriveType_;
    uint32_t m_ulDriveFileSystem_;
    uint64_t m_ullTotalSize_;
    uint64_t m_ullUsedSize_;

};

inline void swap(ST_DRIVE_INFO& a, ST_DRIVE_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_DRIVE_INFO& sample);

class NDDSUSERDllExport ST_HW_STATUS_FOR_HCI {
  public:
    ST_HW_STATUS_FOR_HCI();

    ST_HW_STATUS_FOR_HCI(uint32_t lHWID,uint8_t oState,uint8_t oReallocation,uint32_t relHWID,const ST_CPU_INFO& stCpuInfo,uint8_t oCpuState,const ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo,const ::dds::core::array< uint8_t, 4L>& oNicState,const ::dds::core::array< uint8_t, 4L>& oNicBandwidthState,const ST_MEM_INFO& stMemInfo,uint8_t oMemState,uint8_t oMemTotalSizeState,const ::dds::core::array< ST_DRIVE_INFO, 5L>& stPartitionInfo,const ::dds::core::array< uint8_t, 5L>& oDriveState,const ::dds::core::array< uint8_t, 5L>& oDriveTotalSizeState);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HW_STATUS_FOR_HCI (ST_HW_STATUS_FOR_HCI&&) = default;
    ST_HW_STATUS_FOR_HCI& operator=(ST_HW_STATUS_FOR_HCI&&) = default;
    ST_HW_STATUS_FOR_HCI& operator=(const ST_HW_STATUS_FOR_HCI&) = default;
    ST_HW_STATUS_FOR_HCI(const ST_HW_STATUS_FOR_HCI&) = default;
    #else
    ST_HW_STATUS_FOR_HCI(ST_HW_STATUS_FOR_HCI&& other_) OMG_NOEXCEPT;  
    ST_HW_STATUS_FOR_HCI& operator=(ST_HW_STATUS_FOR_HCI&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& lHWID() OMG_NOEXCEPT {
        return m_lHWID_;
    }

    const uint32_t& lHWID() const OMG_NOEXCEPT {
        return m_lHWID_;
    }

    void lHWID(uint32_t value) {
        m_lHWID_ = value;
    }

    uint8_t& oState() OMG_NOEXCEPT {
        return m_oState_;
    }

    const uint8_t& oState() const OMG_NOEXCEPT {
        return m_oState_;
    }

    void oState(uint8_t value) {
        m_oState_ = value;
    }

    uint8_t& oReallocation() OMG_NOEXCEPT {
        return m_oReallocation_;
    }

    const uint8_t& oReallocation() const OMG_NOEXCEPT {
        return m_oReallocation_;
    }

    void oReallocation(uint8_t value) {
        m_oReallocation_ = value;
    }

    uint32_t& relHWID() OMG_NOEXCEPT {
        return m_relHWID_;
    }

    const uint32_t& relHWID() const OMG_NOEXCEPT {
        return m_relHWID_;
    }

    void relHWID(uint32_t value) {
        m_relHWID_ = value;
    }

    ST_CPU_INFO& stCpuInfo() OMG_NOEXCEPT {
        return m_stCpuInfo_;
    }

    const ST_CPU_INFO& stCpuInfo() const OMG_NOEXCEPT {
        return m_stCpuInfo_;
    }

    void stCpuInfo(const ST_CPU_INFO& value) {
        m_stCpuInfo_ = value;
    }

    void stCpuInfo(ST_CPU_INFO&& value) {
        m_stCpuInfo_ = std::move(value);
    }
    uint8_t& oCpuState() OMG_NOEXCEPT {
        return m_oCpuState_;
    }

    const uint8_t& oCpuState() const OMG_NOEXCEPT {
        return m_oCpuState_;
    }

    void oCpuState(uint8_t value) {
        m_oCpuState_ = value;
    }

    ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo() OMG_NOEXCEPT {
        return m_stNicInfo_;
    }

    const ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo() const OMG_NOEXCEPT {
        return m_stNicInfo_;
    }

    void stNicInfo(const ::dds::core::array< ST_NIC_INFO, 4L>& value) {
        m_stNicInfo_ = value;
    }

    void stNicInfo(::dds::core::array< ST_NIC_INFO, 4L>&& value) {
        m_stNicInfo_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 4L>& oNicState() OMG_NOEXCEPT {
        return m_oNicState_;
    }

    const ::dds::core::array< uint8_t, 4L>& oNicState() const OMG_NOEXCEPT {
        return m_oNicState_;
    }

    void oNicState(const ::dds::core::array< uint8_t, 4L>& value) {
        m_oNicState_ = value;
    }

    void oNicState(::dds::core::array< uint8_t, 4L>&& value) {
        m_oNicState_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 4L>& oNicBandwidthState() OMG_NOEXCEPT {
        return m_oNicBandwidthState_;
    }

    const ::dds::core::array< uint8_t, 4L>& oNicBandwidthState() const OMG_NOEXCEPT {
        return m_oNicBandwidthState_;
    }

    void oNicBandwidthState(const ::dds::core::array< uint8_t, 4L>& value) {
        m_oNicBandwidthState_ = value;
    }

    void oNicBandwidthState(::dds::core::array< uint8_t, 4L>&& value) {
        m_oNicBandwidthState_ = std::move(value);
    }
    ST_MEM_INFO& stMemInfo() OMG_NOEXCEPT {
        return m_stMemInfo_;
    }

    const ST_MEM_INFO& stMemInfo() const OMG_NOEXCEPT {
        return m_stMemInfo_;
    }

    void stMemInfo(const ST_MEM_INFO& value) {
        m_stMemInfo_ = value;
    }

    void stMemInfo(ST_MEM_INFO&& value) {
        m_stMemInfo_ = std::move(value);
    }
    uint8_t& oMemState() OMG_NOEXCEPT {
        return m_oMemState_;
    }

    const uint8_t& oMemState() const OMG_NOEXCEPT {
        return m_oMemState_;
    }

    void oMemState(uint8_t value) {
        m_oMemState_ = value;
    }

    uint8_t& oMemTotalSizeState() OMG_NOEXCEPT {
        return m_oMemTotalSizeState_;
    }

    const uint8_t& oMemTotalSizeState() const OMG_NOEXCEPT {
        return m_oMemTotalSizeState_;
    }

    void oMemTotalSizeState(uint8_t value) {
        m_oMemTotalSizeState_ = value;
    }

    ::dds::core::array< ST_DRIVE_INFO, 5L>& stPartitionInfo() OMG_NOEXCEPT {
        return m_stPartitionInfo_;
    }

    const ::dds::core::array< ST_DRIVE_INFO, 5L>& stPartitionInfo() const OMG_NOEXCEPT {
        return m_stPartitionInfo_;
    }

    void stPartitionInfo(const ::dds::core::array< ST_DRIVE_INFO, 5L>& value) {
        m_stPartitionInfo_ = value;
    }

    void stPartitionInfo(::dds::core::array< ST_DRIVE_INFO, 5L>&& value) {
        m_stPartitionInfo_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 5L>& oDriveState() OMG_NOEXCEPT {
        return m_oDriveState_;
    }

    const ::dds::core::array< uint8_t, 5L>& oDriveState() const OMG_NOEXCEPT {
        return m_oDriveState_;
    }

    void oDriveState(const ::dds::core::array< uint8_t, 5L>& value) {
        m_oDriveState_ = value;
    }

    void oDriveState(::dds::core::array< uint8_t, 5L>&& value) {
        m_oDriveState_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 5L>& oDriveTotalSizeState() OMG_NOEXCEPT {
        return m_oDriveTotalSizeState_;
    }

    const ::dds::core::array< uint8_t, 5L>& oDriveTotalSizeState() const OMG_NOEXCEPT {
        return m_oDriveTotalSizeState_;
    }

    void oDriveTotalSizeState(const ::dds::core::array< uint8_t, 5L>& value) {
        m_oDriveTotalSizeState_ = value;
    }

    void oDriveTotalSizeState(::dds::core::array< uint8_t, 5L>&& value) {
        m_oDriveTotalSizeState_ = std::move(value);
    }

    bool operator == (const ST_HW_STATUS_FOR_HCI& other_) const;
    bool operator != (const ST_HW_STATUS_FOR_HCI& other_) const;

    void swap(ST_HW_STATUS_FOR_HCI& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_lHWID_;
    uint8_t m_oState_;
    uint8_t m_oReallocation_;
    uint32_t m_relHWID_;
    ST_CPU_INFO m_stCpuInfo_;
    uint8_t m_oCpuState_;
    ::dds::core::array< ST_NIC_INFO, 4L> m_stNicInfo_;
    ::dds::core::array< uint8_t, 4L> m_oNicState_;
    ::dds::core::array< uint8_t, 4L> m_oNicBandwidthState_;
    ST_MEM_INFO m_stMemInfo_;
    uint8_t m_oMemState_;
    uint8_t m_oMemTotalSizeState_;
    ::dds::core::array< ST_DRIVE_INFO, 5L> m_stPartitionInfo_;
    ::dds::core::array< uint8_t, 5L> m_oDriveState_;
    ::dds::core::array< uint8_t, 5L> m_oDriveTotalSizeState_;

};

inline void swap(ST_HW_STATUS_FOR_HCI& a, ST_HW_STATUS_FOR_HCI& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HW_STATUS_FOR_HCI& sample);

class NDDSUSERDllExport ST_HW_ALL_STATUS_INFO {
  public:
    ST_HW_ALL_STATUS_INFO();

    ST_HW_ALL_STATUS_INFO(uint32_t ulHWID,const ST_HW_STATUS_FOR_HCI& stHWStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HW_ALL_STATUS_INFO (ST_HW_ALL_STATUS_INFO&&) = default;
    ST_HW_ALL_STATUS_INFO& operator=(ST_HW_ALL_STATUS_INFO&&) = default;
    ST_HW_ALL_STATUS_INFO& operator=(const ST_HW_ALL_STATUS_INFO&) = default;
    ST_HW_ALL_STATUS_INFO(const ST_HW_ALL_STATUS_INFO&) = default;
    #else
    ST_HW_ALL_STATUS_INFO(ST_HW_ALL_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_HW_ALL_STATUS_INFO& operator=(ST_HW_ALL_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    ST_HW_STATUS_FOR_HCI& stHWStatusInfo() OMG_NOEXCEPT {
        return m_stHWStatusInfo_;
    }

    const ST_HW_STATUS_FOR_HCI& stHWStatusInfo() const OMG_NOEXCEPT {
        return m_stHWStatusInfo_;
    }

    void stHWStatusInfo(const ST_HW_STATUS_FOR_HCI& value) {
        m_stHWStatusInfo_ = value;
    }

    void stHWStatusInfo(ST_HW_STATUS_FOR_HCI&& value) {
        m_stHWStatusInfo_ = std::move(value);
    }

    bool operator == (const ST_HW_ALL_STATUS_INFO& other_) const;
    bool operator != (const ST_HW_ALL_STATUS_INFO& other_) const;

    void swap(ST_HW_ALL_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulHWID_;
    ST_HW_STATUS_FOR_HCI m_stHWStatusInfo_;

};

inline void swap(ST_HW_ALL_STATUS_INFO& a, ST_HW_ALL_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HW_ALL_STATUS_INFO& sample);

class NDDSUSERDllExport ST_HW_EQUIP_BOARD_STATUS_INFO {
  public:
    ST_HW_EQUIP_BOARD_STATUS_INFO();

    ST_HW_EQUIP_BOARD_STATUS_INFO(uint32_t ulEquipID,const ::dds::core::array< uint8_t, 32L>& oStatus,uint8_t oHWStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HW_EQUIP_BOARD_STATUS_INFO (ST_HW_EQUIP_BOARD_STATUS_INFO&&) = default;
    ST_HW_EQUIP_BOARD_STATUS_INFO& operator=(ST_HW_EQUIP_BOARD_STATUS_INFO&&) = default;
    ST_HW_EQUIP_BOARD_STATUS_INFO& operator=(const ST_HW_EQUIP_BOARD_STATUS_INFO&) = default;
    ST_HW_EQUIP_BOARD_STATUS_INFO(const ST_HW_EQUIP_BOARD_STATUS_INFO&) = default;
    #else
    ST_HW_EQUIP_BOARD_STATUS_INFO(ST_HW_EQUIP_BOARD_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_HW_EQUIP_BOARD_STATUS_INFO& operator=(ST_HW_EQUIP_BOARD_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulEquipID() OMG_NOEXCEPT {
        return m_ulEquipID_;
    }

    const uint32_t& ulEquipID() const OMG_NOEXCEPT {
        return m_ulEquipID_;
    }

    void ulEquipID(uint32_t value) {
        m_ulEquipID_ = value;
    }

    ::dds::core::array< uint8_t, 32L>& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const ::dds::core::array< uint8_t, 32L>& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(const ::dds::core::array< uint8_t, 32L>& value) {
        m_oStatus_ = value;
    }

    void oStatus(::dds::core::array< uint8_t, 32L>&& value) {
        m_oStatus_ = std::move(value);
    }
    uint8_t& oHWStatus() OMG_NOEXCEPT {
        return m_oHWStatus_;
    }

    const uint8_t& oHWStatus() const OMG_NOEXCEPT {
        return m_oHWStatus_;
    }

    void oHWStatus(uint8_t value) {
        m_oHWStatus_ = value;
    }

    bool operator == (const ST_HW_EQUIP_BOARD_STATUS_INFO& other_) const;
    bool operator != (const ST_HW_EQUIP_BOARD_STATUS_INFO& other_) const;

    void swap(ST_HW_EQUIP_BOARD_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulEquipID_;
    ::dds::core::array< uint8_t, 32L> m_oStatus_;
    uint8_t m_oHWStatus_;

};

inline void swap(ST_HW_EQUIP_BOARD_STATUS_INFO& a, ST_HW_EQUIP_BOARD_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HW_EQUIP_BOARD_STATUS_INFO& sample);

class NDDSUSERDllExport SYSMGR_EQUIP_DIAGNOSTIC_RESULT {
  public:
    SYSMGR_EQUIP_DIAGNOSTIC_RESULT();

    SYSMGR_EQUIP_DIAGNOSTIC_RESULT(const ST_MSG_HEADER& stMsgHeader,uint32_t ulHWID,const ST_EQUIP_DIAGNOSTIC_RESULT& stEquipDiagnosticResult,const ::dds::core::array< ST_SW_ALL_STATUS_INFO, 20L>& stSWStatus,const ST_HW_ALL_STATUS_INFO& stHWServerStatus,const ST_HW_EQUIP_BOARD_STATUS_INFO& stHWEquipBoardStatus,uint8_t oUseSWStatus,uint8_t oUseHWStatus,uint8_t oEquipType,uint8_t oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_EQUIP_DIAGNOSTIC_RESULT (SYSMGR_EQUIP_DIAGNOSTIC_RESULT&&) = default;
    SYSMGR_EQUIP_DIAGNOSTIC_RESULT& operator=(SYSMGR_EQUIP_DIAGNOSTIC_RESULT&&) = default;
    SYSMGR_EQUIP_DIAGNOSTIC_RESULT& operator=(const SYSMGR_EQUIP_DIAGNOSTIC_RESULT&) = default;
    SYSMGR_EQUIP_DIAGNOSTIC_RESULT(const SYSMGR_EQUIP_DIAGNOSTIC_RESULT&) = default;
    #else
    SYSMGR_EQUIP_DIAGNOSTIC_RESULT(SYSMGR_EQUIP_DIAGNOSTIC_RESULT&& other_) OMG_NOEXCEPT;  
    SYSMGR_EQUIP_DIAGNOSTIC_RESULT& operator=(SYSMGR_EQUIP_DIAGNOSTIC_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    ST_EQUIP_DIAGNOSTIC_RESULT& stEquipDiagnosticResult() OMG_NOEXCEPT {
        return m_stEquipDiagnosticResult_;
    }

    const ST_EQUIP_DIAGNOSTIC_RESULT& stEquipDiagnosticResult() const OMG_NOEXCEPT {
        return m_stEquipDiagnosticResult_;
    }

    void stEquipDiagnosticResult(const ST_EQUIP_DIAGNOSTIC_RESULT& value) {
        m_stEquipDiagnosticResult_ = value;
    }

    void stEquipDiagnosticResult(ST_EQUIP_DIAGNOSTIC_RESULT&& value) {
        m_stEquipDiagnosticResult_ = std::move(value);
    }
    ::dds::core::array< ST_SW_ALL_STATUS_INFO, 20L>& stSWStatus() OMG_NOEXCEPT {
        return m_stSWStatus_;
    }

    const ::dds::core::array< ST_SW_ALL_STATUS_INFO, 20L>& stSWStatus() const OMG_NOEXCEPT {
        return m_stSWStatus_;
    }

    void stSWStatus(const ::dds::core::array< ST_SW_ALL_STATUS_INFO, 20L>& value) {
        m_stSWStatus_ = value;
    }

    void stSWStatus(::dds::core::array< ST_SW_ALL_STATUS_INFO, 20L>&& value) {
        m_stSWStatus_ = std::move(value);
    }
    ST_HW_ALL_STATUS_INFO& stHWServerStatus() OMG_NOEXCEPT {
        return m_stHWServerStatus_;
    }

    const ST_HW_ALL_STATUS_INFO& stHWServerStatus() const OMG_NOEXCEPT {
        return m_stHWServerStatus_;
    }

    void stHWServerStatus(const ST_HW_ALL_STATUS_INFO& value) {
        m_stHWServerStatus_ = value;
    }

    void stHWServerStatus(ST_HW_ALL_STATUS_INFO&& value) {
        m_stHWServerStatus_ = std::move(value);
    }
    ST_HW_EQUIP_BOARD_STATUS_INFO& stHWEquipBoardStatus() OMG_NOEXCEPT {
        return m_stHWEquipBoardStatus_;
    }

    const ST_HW_EQUIP_BOARD_STATUS_INFO& stHWEquipBoardStatus() const OMG_NOEXCEPT {
        return m_stHWEquipBoardStatus_;
    }

    void stHWEquipBoardStatus(const ST_HW_EQUIP_BOARD_STATUS_INFO& value) {
        m_stHWEquipBoardStatus_ = value;
    }

    void stHWEquipBoardStatus(ST_HW_EQUIP_BOARD_STATUS_INFO&& value) {
        m_stHWEquipBoardStatus_ = std::move(value);
    }
    uint8_t& oUseSWStatus() OMG_NOEXCEPT {
        return m_oUseSWStatus_;
    }

    const uint8_t& oUseSWStatus() const OMG_NOEXCEPT {
        return m_oUseSWStatus_;
    }

    void oUseSWStatus(uint8_t value) {
        m_oUseSWStatus_ = value;
    }

    uint8_t& oUseHWStatus() OMG_NOEXCEPT {
        return m_oUseHWStatus_;
    }

    const uint8_t& oUseHWStatus() const OMG_NOEXCEPT {
        return m_oUseHWStatus_;
    }

    void oUseHWStatus(uint8_t value) {
        m_oUseHWStatus_ = value;
    }

    uint8_t& oEquipType() OMG_NOEXCEPT {
        return m_oEquipType_;
    }

    const uint8_t& oEquipType() const OMG_NOEXCEPT {
        return m_oEquipType_;
    }

    void oEquipType(uint8_t value) {
        m_oEquipType_ = value;
    }

    uint8_t& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const uint8_t& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(uint8_t value) {
        m_oResearved_ = value;
    }

    bool operator == (const SYSMGR_EQUIP_DIAGNOSTIC_RESULT& other_) const;
    bool operator != (const SYSMGR_EQUIP_DIAGNOSTIC_RESULT& other_) const;

    void swap(SYSMGR_EQUIP_DIAGNOSTIC_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulHWID_;
    ST_EQUIP_DIAGNOSTIC_RESULT m_stEquipDiagnosticResult_;
    ::dds::core::array< ST_SW_ALL_STATUS_INFO, 20L> m_stSWStatus_;
    ST_HW_ALL_STATUS_INFO m_stHWServerStatus_;
    ST_HW_EQUIP_BOARD_STATUS_INFO m_stHWEquipBoardStatus_;
    uint8_t m_oUseSWStatus_;
    uint8_t m_oUseHWStatus_;
    uint8_t m_oEquipType_;
    uint8_t m_oResearved_;

};

inline void swap(SYSMGR_EQUIP_DIAGNOSTIC_RESULT& a, SYSMGR_EQUIP_DIAGNOSTIC_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_EQUIP_DIAGNOSTIC_RESULT& sample);

class NDDSUSERDllExport SYSMGR_GPS_STS_INFO {
  public:
    SYSMGR_GPS_STS_INFO();

    SYSMGR_GPS_STS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_GPS_STS_INFO (SYSMGR_GPS_STS_INFO&&) = default;
    SYSMGR_GPS_STS_INFO& operator=(SYSMGR_GPS_STS_INFO&&) = default;
    SYSMGR_GPS_STS_INFO& operator=(const SYSMGR_GPS_STS_INFO&) = default;
    SYSMGR_GPS_STS_INFO(const SYSMGR_GPS_STS_INFO&) = default;
    #else
    SYSMGR_GPS_STS_INFO(SYSMGR_GPS_STS_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_GPS_STS_INFO& operator=(SYSMGR_GPS_STS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usStatus() OMG_NOEXCEPT {
        return m_usStatus_;
    }

    const uint16_t& usStatus() const OMG_NOEXCEPT {
        return m_usStatus_;
    }

    void usStatus(uint16_t value) {
        m_usStatus_ = value;
    }

    bool operator == (const SYSMGR_GPS_STS_INFO& other_) const;
    bool operator != (const SYSMGR_GPS_STS_INFO& other_) const;

    void swap(SYSMGR_GPS_STS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usStatus_;

};

inline void swap(SYSMGR_GPS_STS_INFO& a, SYSMGR_GPS_STS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_GPS_STS_INFO& sample);

class NDDSUSERDllExport ST_HUSS_STATUS_INFO {
  public:
    ST_HUSS_STATUS_INFO();

    ST_HUSS_STATUS_INFO(uint32_t ulHUSSEquipID,uint8_t oStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HUSS_STATUS_INFO (ST_HUSS_STATUS_INFO&&) = default;
    ST_HUSS_STATUS_INFO& operator=(ST_HUSS_STATUS_INFO&&) = default;
    ST_HUSS_STATUS_INFO& operator=(const ST_HUSS_STATUS_INFO&) = default;
    ST_HUSS_STATUS_INFO(const ST_HUSS_STATUS_INFO&) = default;
    #else
    ST_HUSS_STATUS_INFO(ST_HUSS_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_HUSS_STATUS_INFO& operator=(ST_HUSS_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulHUSSEquipID() OMG_NOEXCEPT {
        return m_ulHUSSEquipID_;
    }

    const uint32_t& ulHUSSEquipID() const OMG_NOEXCEPT {
        return m_ulHUSSEquipID_;
    }

    void ulHUSSEquipID(uint32_t value) {
        m_ulHUSSEquipID_ = value;
    }

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    bool operator == (const ST_HUSS_STATUS_INFO& other_) const;
    bool operator != (const ST_HUSS_STATUS_INFO& other_) const;

    void swap(ST_HUSS_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulHUSSEquipID_;
    uint8_t m_oStatus_;

};

inline void swap(ST_HUSS_STATUS_INFO& a, ST_HUSS_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HUSS_STATUS_INFO& sample);

class NDDSUSERDllExport ST_HUSS_EQUIP_STATUS_INFO {
  public:
    ST_HUSS_EQUIP_STATUS_INFO();

    ST_HUSS_EQUIP_STATUS_INFO(uint32_t ulHWID,uint8_t oStatus,uint8_t oHWStatus,uint8_t oSWStatus,bool bHWStatusUse,bool bSWStatusUse,const ::dds::core::array< uint8_t, 3L>& oReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HUSS_EQUIP_STATUS_INFO (ST_HUSS_EQUIP_STATUS_INFO&&) = default;
    ST_HUSS_EQUIP_STATUS_INFO& operator=(ST_HUSS_EQUIP_STATUS_INFO&&) = default;
    ST_HUSS_EQUIP_STATUS_INFO& operator=(const ST_HUSS_EQUIP_STATUS_INFO&) = default;
    ST_HUSS_EQUIP_STATUS_INFO(const ST_HUSS_EQUIP_STATUS_INFO&) = default;
    #else
    ST_HUSS_EQUIP_STATUS_INFO(ST_HUSS_EQUIP_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_HUSS_EQUIP_STATUS_INFO& operator=(ST_HUSS_EQUIP_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    uint8_t& oHWStatus() OMG_NOEXCEPT {
        return m_oHWStatus_;
    }

    const uint8_t& oHWStatus() const OMG_NOEXCEPT {
        return m_oHWStatus_;
    }

    void oHWStatus(uint8_t value) {
        m_oHWStatus_ = value;
    }

    uint8_t& oSWStatus() OMG_NOEXCEPT {
        return m_oSWStatus_;
    }

    const uint8_t& oSWStatus() const OMG_NOEXCEPT {
        return m_oSWStatus_;
    }

    void oSWStatus(uint8_t value) {
        m_oSWStatus_ = value;
    }

    bool& bHWStatusUse() OMG_NOEXCEPT {
        return m_bHWStatusUse_;
    }

    const bool& bHWStatusUse() const OMG_NOEXCEPT {
        return m_bHWStatusUse_;
    }

    void bHWStatusUse(bool value) {
        m_bHWStatusUse_ = value;
    }

    bool& bSWStatusUse() OMG_NOEXCEPT {
        return m_bSWStatusUse_;
    }

    const bool& bSWStatusUse() const OMG_NOEXCEPT {
        return m_bSWStatusUse_;
    }

    void bSWStatusUse(bool value) {
        m_bSWStatusUse_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oReserved() OMG_NOEXCEPT {
        return m_oReserved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oReserved() const OMG_NOEXCEPT {
        return m_oReserved_;
    }

    void oReserved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oReserved_ = value;
    }

    void oReserved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oReserved_ = std::move(value);
    }

    bool operator == (const ST_HUSS_EQUIP_STATUS_INFO& other_) const;
    bool operator != (const ST_HUSS_EQUIP_STATUS_INFO& other_) const;

    void swap(ST_HUSS_EQUIP_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulHWID_;
    uint8_t m_oStatus_;
    uint8_t m_oHWStatus_;
    uint8_t m_oSWStatus_;
    bool m_bHWStatusUse_;
    bool m_bSWStatusUse_;
    ::dds::core::array< uint8_t, 3L> m_oReserved_;

};

inline void swap(ST_HUSS_EQUIP_STATUS_INFO& a, ST_HUSS_EQUIP_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HUSS_EQUIP_STATUS_INFO& sample);

class NDDSUSERDllExport SYSMGR_HUSS_STATUS_INFO {
  public:
    SYSMGR_HUSS_STATUS_INFO();

    SYSMGR_HUSS_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_HUSS_STATUS_INFO, 100L>& stHUSSStatusInfo,const ::dds::core::array< ST_HUSS_EQUIP_STATUS_INFO, 200L>& stHUSSEquipStatusInfo,uint8_t oHUSSState);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_HUSS_STATUS_INFO (SYSMGR_HUSS_STATUS_INFO&&) = default;
    SYSMGR_HUSS_STATUS_INFO& operator=(SYSMGR_HUSS_STATUS_INFO&&) = default;
    SYSMGR_HUSS_STATUS_INFO& operator=(const SYSMGR_HUSS_STATUS_INFO&) = default;
    SYSMGR_HUSS_STATUS_INFO(const SYSMGR_HUSS_STATUS_INFO&) = default;
    #else
    SYSMGR_HUSS_STATUS_INFO(SYSMGR_HUSS_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_HUSS_STATUS_INFO& operator=(SYSMGR_HUSS_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_HUSS_STATUS_INFO, 100L>& stHUSSStatusInfo() OMG_NOEXCEPT {
        return m_stHUSSStatusInfo_;
    }

    const ::dds::core::array< ST_HUSS_STATUS_INFO, 100L>& stHUSSStatusInfo() const OMG_NOEXCEPT {
        return m_stHUSSStatusInfo_;
    }

    void stHUSSStatusInfo(const ::dds::core::array< ST_HUSS_STATUS_INFO, 100L>& value) {
        m_stHUSSStatusInfo_ = value;
    }

    void stHUSSStatusInfo(::dds::core::array< ST_HUSS_STATUS_INFO, 100L>&& value) {
        m_stHUSSStatusInfo_ = std::move(value);
    }
    ::dds::core::array< ST_HUSS_EQUIP_STATUS_INFO, 200L>& stHUSSEquipStatusInfo() OMG_NOEXCEPT {
        return m_stHUSSEquipStatusInfo_;
    }

    const ::dds::core::array< ST_HUSS_EQUIP_STATUS_INFO, 200L>& stHUSSEquipStatusInfo() const OMG_NOEXCEPT {
        return m_stHUSSEquipStatusInfo_;
    }

    void stHUSSEquipStatusInfo(const ::dds::core::array< ST_HUSS_EQUIP_STATUS_INFO, 200L>& value) {
        m_stHUSSEquipStatusInfo_ = value;
    }

    void stHUSSEquipStatusInfo(::dds::core::array< ST_HUSS_EQUIP_STATUS_INFO, 200L>&& value) {
        m_stHUSSEquipStatusInfo_ = std::move(value);
    }
    uint8_t& oHUSSState() OMG_NOEXCEPT {
        return m_oHUSSState_;
    }

    const uint8_t& oHUSSState() const OMG_NOEXCEPT {
        return m_oHUSSState_;
    }

    void oHUSSState(uint8_t value) {
        m_oHUSSState_ = value;
    }

    bool operator == (const SYSMGR_HUSS_STATUS_INFO& other_) const;
    bool operator != (const SYSMGR_HUSS_STATUS_INFO& other_) const;

    void swap(SYSMGR_HUSS_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_HUSS_STATUS_INFO, 100L> m_stHUSSStatusInfo_;
    ::dds::core::array< ST_HUSS_EQUIP_STATUS_INFO, 200L> m_stHUSSEquipStatusInfo_;
    uint8_t m_oHUSSState_;

};

inline void swap(SYSMGR_HUSS_STATUS_INFO& a, SYSMGR_HUSS_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_HUSS_STATUS_INFO& sample);

class NDDSUSERDllExport ST_HW_EQUIP_STATUS_INFO {
  public:
    ST_HW_EQUIP_STATUS_INFO();

    ST_HW_EQUIP_STATUS_INFO(uint32_t ulEquipID,uint8_t oStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HW_EQUIP_STATUS_INFO (ST_HW_EQUIP_STATUS_INFO&&) = default;
    ST_HW_EQUIP_STATUS_INFO& operator=(ST_HW_EQUIP_STATUS_INFO&&) = default;
    ST_HW_EQUIP_STATUS_INFO& operator=(const ST_HW_EQUIP_STATUS_INFO&) = default;
    ST_HW_EQUIP_STATUS_INFO(const ST_HW_EQUIP_STATUS_INFO&) = default;
    #else
    ST_HW_EQUIP_STATUS_INFO(ST_HW_EQUIP_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_HW_EQUIP_STATUS_INFO& operator=(ST_HW_EQUIP_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulEquipID() OMG_NOEXCEPT {
        return m_ulEquipID_;
    }

    const uint32_t& ulEquipID() const OMG_NOEXCEPT {
        return m_ulEquipID_;
    }

    void ulEquipID(uint32_t value) {
        m_ulEquipID_ = value;
    }

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    bool operator == (const ST_HW_EQUIP_STATUS_INFO& other_) const;
    bool operator != (const ST_HW_EQUIP_STATUS_INFO& other_) const;

    void swap(ST_HW_EQUIP_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulEquipID_;
    uint8_t m_oStatus_;

};

inline void swap(ST_HW_EQUIP_STATUS_INFO& a, ST_HW_EQUIP_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HW_EQUIP_STATUS_INFO& sample);

class NDDSUSERDllExport ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX {
  public:
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX();

    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX(const ST_STORAGE_STATUS_INFO& stStorageStatusInfo,const ST_ASE_STATUS_INFO& stAseStatusInfo,const ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& LAS_stSensorStatus,const ST_SENSOR_IFC_STATUS& LAS_stSensorIFCStatus,const ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& BIS_stSensorStatus,const ST_SENSOR_IFC_STATUS& BIS_stSensorIFCStatus,const ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& MAS_stSensorStatus,const ST_SENSOR_IFC_STATUS& MAS_stSensorIFCStatus,const ::dds::core::array< ST_RD_STATUS_INFO, 2L>& stRdStatusInfo,const ::dds::core::array< ST_INTERCHANGE_DEVICE_STATUS_INFO, 3L>& stInterchangeDeviceStatusInfo,const ST_EA_INTERWORKING_STATUS_INFO& stEaInterworkingStatusInfo,const ::dds::core::array< ST_TRANSCEIVER_STATUS_INFO, 6L>& stTransceiverStatusInfo,const ::dds::core::array< ST_EOTE_STATUS_INFO, 2L>& stEoteStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX (ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX&&) = default;
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& operator=(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX&&) = default;
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& operator=(const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX&) = default;
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX(const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX&) = default;
    #else
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX&& other_) OMG_NOEXCEPT;  
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& operator=(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_STORAGE_STATUS_INFO& stStorageStatusInfo() OMG_NOEXCEPT {
        return m_stStorageStatusInfo_;
    }

    const ST_STORAGE_STATUS_INFO& stStorageStatusInfo() const OMG_NOEXCEPT {
        return m_stStorageStatusInfo_;
    }

    void stStorageStatusInfo(const ST_STORAGE_STATUS_INFO& value) {
        m_stStorageStatusInfo_ = value;
    }

    void stStorageStatusInfo(ST_STORAGE_STATUS_INFO&& value) {
        m_stStorageStatusInfo_ = std::move(value);
    }
    ST_ASE_STATUS_INFO& stAseStatusInfo() OMG_NOEXCEPT {
        return m_stAseStatusInfo_;
    }

    const ST_ASE_STATUS_INFO& stAseStatusInfo() const OMG_NOEXCEPT {
        return m_stAseStatusInfo_;
    }

    void stAseStatusInfo(const ST_ASE_STATUS_INFO& value) {
        m_stAseStatusInfo_ = value;
    }

    void stAseStatusInfo(ST_ASE_STATUS_INFO&& value) {
        m_stAseStatusInfo_ = std::move(value);
    }
    ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& LAS_stSensorStatus() OMG_NOEXCEPT {
        return m_LAS_stSensorStatus_;
    }

    const ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& LAS_stSensorStatus() const OMG_NOEXCEPT {
        return m_LAS_stSensorStatus_;
    }

    void LAS_stSensorStatus(const ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>& value) {
        m_LAS_stSensorStatus_ = value;
    }

    void LAS_stSensorStatus(::dds::core::array< ST_LAS_SENSOR_STATUS, 3L>&& value) {
        m_LAS_stSensorStatus_ = std::move(value);
    }
    ST_SENSOR_IFC_STATUS& LAS_stSensorIFCStatus() OMG_NOEXCEPT {
        return m_LAS_stSensorIFCStatus_;
    }

    const ST_SENSOR_IFC_STATUS& LAS_stSensorIFCStatus() const OMG_NOEXCEPT {
        return m_LAS_stSensorIFCStatus_;
    }

    void LAS_stSensorIFCStatus(const ST_SENSOR_IFC_STATUS& value) {
        m_LAS_stSensorIFCStatus_ = value;
    }

    void LAS_stSensorIFCStatus(ST_SENSOR_IFC_STATUS&& value) {
        m_LAS_stSensorIFCStatus_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& BIS_stSensorStatus() OMG_NOEXCEPT {
        return m_BIS_stSensorStatus_;
    }

    const ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& BIS_stSensorStatus() const OMG_NOEXCEPT {
        return m_BIS_stSensorStatus_;
    }

    void BIS_stSensorStatus(const ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>& value) {
        m_BIS_stSensorStatus_ = value;
    }

    void BIS_stSensorStatus(::dds::core::array< ST_BIS_SENSOR_STATUS, 3L>&& value) {
        m_BIS_stSensorStatus_ = std::move(value);
    }
    ST_SENSOR_IFC_STATUS& BIS_stSensorIFCStatus() OMG_NOEXCEPT {
        return m_BIS_stSensorIFCStatus_;
    }

    const ST_SENSOR_IFC_STATUS& BIS_stSensorIFCStatus() const OMG_NOEXCEPT {
        return m_BIS_stSensorIFCStatus_;
    }

    void BIS_stSensorIFCStatus(const ST_SENSOR_IFC_STATUS& value) {
        m_BIS_stSensorIFCStatus_ = value;
    }

    void BIS_stSensorIFCStatus(ST_SENSOR_IFC_STATUS&& value) {
        m_BIS_stSensorIFCStatus_ = std::move(value);
    }
    ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& MAS_stSensorStatus() OMG_NOEXCEPT {
        return m_MAS_stSensorStatus_;
    }

    const ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& MAS_stSensorStatus() const OMG_NOEXCEPT {
        return m_MAS_stSensorStatus_;
    }

    void MAS_stSensorStatus(const ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>& value) {
        m_MAS_stSensorStatus_ = value;
    }

    void MAS_stSensorStatus(::dds::core::array< ST_MAS_SENSOR_STATUS, 2L>&& value) {
        m_MAS_stSensorStatus_ = std::move(value);
    }
    ST_SENSOR_IFC_STATUS& MAS_stSensorIFCStatus() OMG_NOEXCEPT {
        return m_MAS_stSensorIFCStatus_;
    }

    const ST_SENSOR_IFC_STATUS& MAS_stSensorIFCStatus() const OMG_NOEXCEPT {
        return m_MAS_stSensorIFCStatus_;
    }

    void MAS_stSensorIFCStatus(const ST_SENSOR_IFC_STATUS& value) {
        m_MAS_stSensorIFCStatus_ = value;
    }

    void MAS_stSensorIFCStatus(ST_SENSOR_IFC_STATUS&& value) {
        m_MAS_stSensorIFCStatus_ = std::move(value);
    }
    ::dds::core::array< ST_RD_STATUS_INFO, 2L>& stRdStatusInfo() OMG_NOEXCEPT {
        return m_stRdStatusInfo_;
    }

    const ::dds::core::array< ST_RD_STATUS_INFO, 2L>& stRdStatusInfo() const OMG_NOEXCEPT {
        return m_stRdStatusInfo_;
    }

    void stRdStatusInfo(const ::dds::core::array< ST_RD_STATUS_INFO, 2L>& value) {
        m_stRdStatusInfo_ = value;
    }

    void stRdStatusInfo(::dds::core::array< ST_RD_STATUS_INFO, 2L>&& value) {
        m_stRdStatusInfo_ = std::move(value);
    }
    ::dds::core::array< ST_INTERCHANGE_DEVICE_STATUS_INFO, 3L>& stInterchangeDeviceStatusInfo() OMG_NOEXCEPT {
        return m_stInterchangeDeviceStatusInfo_;
    }

    const ::dds::core::array< ST_INTERCHANGE_DEVICE_STATUS_INFO, 3L>& stInterchangeDeviceStatusInfo() const OMG_NOEXCEPT {
        return m_stInterchangeDeviceStatusInfo_;
    }

    void stInterchangeDeviceStatusInfo(const ::dds::core::array< ST_INTERCHANGE_DEVICE_STATUS_INFO, 3L>& value) {
        m_stInterchangeDeviceStatusInfo_ = value;
    }

    void stInterchangeDeviceStatusInfo(::dds::core::array< ST_INTERCHANGE_DEVICE_STATUS_INFO, 3L>&& value) {
        m_stInterchangeDeviceStatusInfo_ = std::move(value);
    }
    ST_EA_INTERWORKING_STATUS_INFO& stEaInterworkingStatusInfo() OMG_NOEXCEPT {
        return m_stEaInterworkingStatusInfo_;
    }

    const ST_EA_INTERWORKING_STATUS_INFO& stEaInterworkingStatusInfo() const OMG_NOEXCEPT {
        return m_stEaInterworkingStatusInfo_;
    }

    void stEaInterworkingStatusInfo(const ST_EA_INTERWORKING_STATUS_INFO& value) {
        m_stEaInterworkingStatusInfo_ = value;
    }

    void stEaInterworkingStatusInfo(ST_EA_INTERWORKING_STATUS_INFO&& value) {
        m_stEaInterworkingStatusInfo_ = std::move(value);
    }
    ::dds::core::array< ST_TRANSCEIVER_STATUS_INFO, 6L>& stTransceiverStatusInfo() OMG_NOEXCEPT {
        return m_stTransceiverStatusInfo_;
    }

    const ::dds::core::array< ST_TRANSCEIVER_STATUS_INFO, 6L>& stTransceiverStatusInfo() const OMG_NOEXCEPT {
        return m_stTransceiverStatusInfo_;
    }

    void stTransceiverStatusInfo(const ::dds::core::array< ST_TRANSCEIVER_STATUS_INFO, 6L>& value) {
        m_stTransceiverStatusInfo_ = value;
    }

    void stTransceiverStatusInfo(::dds::core::array< ST_TRANSCEIVER_STATUS_INFO, 6L>&& value) {
        m_stTransceiverStatusInfo_ = std::move(value);
    }
    ::dds::core::array< ST_EOTE_STATUS_INFO, 2L>& stEoteStatusInfo() OMG_NOEXCEPT {
        return m_stEoteStatusInfo_;
    }

    const ::dds::core::array< ST_EOTE_STATUS_INFO, 2L>& stEoteStatusInfo() const OMG_NOEXCEPT {
        return m_stEoteStatusInfo_;
    }

    void stEoteStatusInfo(const ::dds::core::array< ST_EOTE_STATUS_INFO, 2L>& value) {
        m_stEoteStatusInfo_ = value;
    }

    void stEoteStatusInfo(::dds::core::array< ST_EOTE_STATUS_INFO, 2L>&& value) {
        m_stEoteStatusInfo_ = std::move(value);
    }

    bool operator == (const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& other_) const;
    bool operator != (const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& other_) const;

    void swap(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& other_) OMG_NOEXCEPT ;

  private:

    ST_STORAGE_STATUS_INFO m_stStorageStatusInfo_;
    ST_ASE_STATUS_INFO m_stAseStatusInfo_;
    ::dds::core::array< ST_LAS_SENSOR_STATUS, 3L> m_LAS_stSensorStatus_;
    ST_SENSOR_IFC_STATUS m_LAS_stSensorIFCStatus_;
    ::dds::core::array< ST_BIS_SENSOR_STATUS, 3L> m_BIS_stSensorStatus_;
    ST_SENSOR_IFC_STATUS m_BIS_stSensorIFCStatus_;
    ::dds::core::array< ST_MAS_SENSOR_STATUS, 2L> m_MAS_stSensorStatus_;
    ST_SENSOR_IFC_STATUS m_MAS_stSensorIFCStatus_;
    ::dds::core::array< ST_RD_STATUS_INFO, 2L> m_stRdStatusInfo_;
    ::dds::core::array< ST_INTERCHANGE_DEVICE_STATUS_INFO, 3L> m_stInterchangeDeviceStatusInfo_;
    ST_EA_INTERWORKING_STATUS_INFO m_stEaInterworkingStatusInfo_;
    ::dds::core::array< ST_TRANSCEIVER_STATUS_INFO, 6L> m_stTransceiverStatusInfo_;
    ::dds::core::array< ST_EOTE_STATUS_INFO, 2L> m_stEoteStatusInfo_;

};

inline void swap(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& a, ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& sample);

class NDDSUSERDllExport SYSMGR_HW_ALL_STATUS_INFO {
  public:
    SYSMGR_HW_ALL_STATUS_INFO();

    SYSMGR_HW_ALL_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_HW_ALL_STATUS_INFO, 100L>& stHwStatusInfo,const ::dds::core::array< ST_HW_EQUIP_STATUS_INFO, 300L>& stHWEquipStatusInfo,uint8_t oHwAllState,const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& stHwEquipBoardAllStatusInfo_Ex,const ::dds::core::array< ST_HW_EQUIP_BOARD_STATUS_INFO, 100L>& stHwEquipBoardStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_HW_ALL_STATUS_INFO (SYSMGR_HW_ALL_STATUS_INFO&&) = default;
    SYSMGR_HW_ALL_STATUS_INFO& operator=(SYSMGR_HW_ALL_STATUS_INFO&&) = default;
    SYSMGR_HW_ALL_STATUS_INFO& operator=(const SYSMGR_HW_ALL_STATUS_INFO&) = default;
    SYSMGR_HW_ALL_STATUS_INFO(const SYSMGR_HW_ALL_STATUS_INFO&) = default;
    #else
    SYSMGR_HW_ALL_STATUS_INFO(SYSMGR_HW_ALL_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_HW_ALL_STATUS_INFO& operator=(SYSMGR_HW_ALL_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_HW_ALL_STATUS_INFO, 100L>& stHwStatusInfo() OMG_NOEXCEPT {
        return m_stHwStatusInfo_;
    }

    const ::dds::core::array< ST_HW_ALL_STATUS_INFO, 100L>& stHwStatusInfo() const OMG_NOEXCEPT {
        return m_stHwStatusInfo_;
    }

    void stHwStatusInfo(const ::dds::core::array< ST_HW_ALL_STATUS_INFO, 100L>& value) {
        m_stHwStatusInfo_ = value;
    }

    void stHwStatusInfo(::dds::core::array< ST_HW_ALL_STATUS_INFO, 100L>&& value) {
        m_stHwStatusInfo_ = std::move(value);
    }
    ::dds::core::array< ST_HW_EQUIP_STATUS_INFO, 300L>& stHWEquipStatusInfo() OMG_NOEXCEPT {
        return m_stHWEquipStatusInfo_;
    }

    const ::dds::core::array< ST_HW_EQUIP_STATUS_INFO, 300L>& stHWEquipStatusInfo() const OMG_NOEXCEPT {
        return m_stHWEquipStatusInfo_;
    }

    void stHWEquipStatusInfo(const ::dds::core::array< ST_HW_EQUIP_STATUS_INFO, 300L>& value) {
        m_stHWEquipStatusInfo_ = value;
    }

    void stHWEquipStatusInfo(::dds::core::array< ST_HW_EQUIP_STATUS_INFO, 300L>&& value) {
        m_stHWEquipStatusInfo_ = std::move(value);
    }
    uint8_t& oHwAllState() OMG_NOEXCEPT {
        return m_oHwAllState_;
    }

    const uint8_t& oHwAllState() const OMG_NOEXCEPT {
        return m_oHwAllState_;
    }

    void oHwAllState(uint8_t value) {
        m_oHwAllState_ = value;
    }

    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& stHwEquipBoardAllStatusInfo_Ex() OMG_NOEXCEPT {
        return m_stHwEquipBoardAllStatusInfo_Ex_;
    }

    const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& stHwEquipBoardAllStatusInfo_Ex() const OMG_NOEXCEPT {
        return m_stHwEquipBoardAllStatusInfo_Ex_;
    }

    void stHwEquipBoardAllStatusInfo_Ex(const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& value) {
        m_stHwEquipBoardAllStatusInfo_Ex_ = value;
    }

    void stHwEquipBoardAllStatusInfo_Ex(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX&& value) {
        m_stHwEquipBoardAllStatusInfo_Ex_ = std::move(value);
    }
    ::dds::core::array< ST_HW_EQUIP_BOARD_STATUS_INFO, 100L>& stHwEquipBoardStatusInfo() OMG_NOEXCEPT {
        return m_stHwEquipBoardStatusInfo_;
    }

    const ::dds::core::array< ST_HW_EQUIP_BOARD_STATUS_INFO, 100L>& stHwEquipBoardStatusInfo() const OMG_NOEXCEPT {
        return m_stHwEquipBoardStatusInfo_;
    }

    void stHwEquipBoardStatusInfo(const ::dds::core::array< ST_HW_EQUIP_BOARD_STATUS_INFO, 100L>& value) {
        m_stHwEquipBoardStatusInfo_ = value;
    }

    void stHwEquipBoardStatusInfo(::dds::core::array< ST_HW_EQUIP_BOARD_STATUS_INFO, 100L>&& value) {
        m_stHwEquipBoardStatusInfo_ = std::move(value);
    }

    bool operator == (const SYSMGR_HW_ALL_STATUS_INFO& other_) const;
    bool operator != (const SYSMGR_HW_ALL_STATUS_INFO& other_) const;

    void swap(SYSMGR_HW_ALL_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_HW_ALL_STATUS_INFO, 100L> m_stHwStatusInfo_;
    ::dds::core::array< ST_HW_EQUIP_STATUS_INFO, 300L> m_stHWEquipStatusInfo_;
    uint8_t m_oHwAllState_;
    ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX m_stHwEquipBoardAllStatusInfo_Ex_;
    ::dds::core::array< ST_HW_EQUIP_BOARD_STATUS_INFO, 100L> m_stHwEquipBoardStatusInfo_;

};

inline void swap(SYSMGR_HW_ALL_STATUS_INFO& a, SYSMGR_HW_ALL_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_HW_ALL_STATUS_INFO& sample);

class NDDSUSERDllExport SYSMGR_HW_STATUS_HCI_INFO {
  public:
    SYSMGR_HW_STATUS_HCI_INFO();

    SYSMGR_HW_STATUS_HCI_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t lHWID,uint8_t oState,uint8_t oReallocation,uint32_t relHWID,const ST_CPU_INFO& stCpuInfo,uint8_t oCpuState,const ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo,const ::dds::core::array< uint8_t, 4L>& oNicState,const ST_MEM_INFO& stMemInfo,uint8_t oMemState,const ::dds::core::array< ST_DRIVE_INFO, 26L>& stPartitionInfo,uint8_t oDriveState);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_HW_STATUS_HCI_INFO (SYSMGR_HW_STATUS_HCI_INFO&&) = default;
    SYSMGR_HW_STATUS_HCI_INFO& operator=(SYSMGR_HW_STATUS_HCI_INFO&&) = default;
    SYSMGR_HW_STATUS_HCI_INFO& operator=(const SYSMGR_HW_STATUS_HCI_INFO&) = default;
    SYSMGR_HW_STATUS_HCI_INFO(const SYSMGR_HW_STATUS_HCI_INFO&) = default;
    #else
    SYSMGR_HW_STATUS_HCI_INFO(SYSMGR_HW_STATUS_HCI_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_HW_STATUS_HCI_INFO& operator=(SYSMGR_HW_STATUS_HCI_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& lHWID() OMG_NOEXCEPT {
        return m_lHWID_;
    }

    const uint32_t& lHWID() const OMG_NOEXCEPT {
        return m_lHWID_;
    }

    void lHWID(uint32_t value) {
        m_lHWID_ = value;
    }

    uint8_t& oState() OMG_NOEXCEPT {
        return m_oState_;
    }

    const uint8_t& oState() const OMG_NOEXCEPT {
        return m_oState_;
    }

    void oState(uint8_t value) {
        m_oState_ = value;
    }

    uint8_t& oReallocation() OMG_NOEXCEPT {
        return m_oReallocation_;
    }

    const uint8_t& oReallocation() const OMG_NOEXCEPT {
        return m_oReallocation_;
    }

    void oReallocation(uint8_t value) {
        m_oReallocation_ = value;
    }

    uint32_t& relHWID() OMG_NOEXCEPT {
        return m_relHWID_;
    }

    const uint32_t& relHWID() const OMG_NOEXCEPT {
        return m_relHWID_;
    }

    void relHWID(uint32_t value) {
        m_relHWID_ = value;
    }

    ST_CPU_INFO& stCpuInfo() OMG_NOEXCEPT {
        return m_stCpuInfo_;
    }

    const ST_CPU_INFO& stCpuInfo() const OMG_NOEXCEPT {
        return m_stCpuInfo_;
    }

    void stCpuInfo(const ST_CPU_INFO& value) {
        m_stCpuInfo_ = value;
    }

    void stCpuInfo(ST_CPU_INFO&& value) {
        m_stCpuInfo_ = std::move(value);
    }
    uint8_t& oCpuState() OMG_NOEXCEPT {
        return m_oCpuState_;
    }

    const uint8_t& oCpuState() const OMG_NOEXCEPT {
        return m_oCpuState_;
    }

    void oCpuState(uint8_t value) {
        m_oCpuState_ = value;
    }

    ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo() OMG_NOEXCEPT {
        return m_stNicInfo_;
    }

    const ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo() const OMG_NOEXCEPT {
        return m_stNicInfo_;
    }

    void stNicInfo(const ::dds::core::array< ST_NIC_INFO, 4L>& value) {
        m_stNicInfo_ = value;
    }

    void stNicInfo(::dds::core::array< ST_NIC_INFO, 4L>&& value) {
        m_stNicInfo_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 4L>& oNicState() OMG_NOEXCEPT {
        return m_oNicState_;
    }

    const ::dds::core::array< uint8_t, 4L>& oNicState() const OMG_NOEXCEPT {
        return m_oNicState_;
    }

    void oNicState(const ::dds::core::array< uint8_t, 4L>& value) {
        m_oNicState_ = value;
    }

    void oNicState(::dds::core::array< uint8_t, 4L>&& value) {
        m_oNicState_ = std::move(value);
    }
    ST_MEM_INFO& stMemInfo() OMG_NOEXCEPT {
        return m_stMemInfo_;
    }

    const ST_MEM_INFO& stMemInfo() const OMG_NOEXCEPT {
        return m_stMemInfo_;
    }

    void stMemInfo(const ST_MEM_INFO& value) {
        m_stMemInfo_ = value;
    }

    void stMemInfo(ST_MEM_INFO&& value) {
        m_stMemInfo_ = std::move(value);
    }
    uint8_t& oMemState() OMG_NOEXCEPT {
        return m_oMemState_;
    }

    const uint8_t& oMemState() const OMG_NOEXCEPT {
        return m_oMemState_;
    }

    void oMemState(uint8_t value) {
        m_oMemState_ = value;
    }

    ::dds::core::array< ST_DRIVE_INFO, 26L>& stPartitionInfo() OMG_NOEXCEPT {
        return m_stPartitionInfo_;
    }

    const ::dds::core::array< ST_DRIVE_INFO, 26L>& stPartitionInfo() const OMG_NOEXCEPT {
        return m_stPartitionInfo_;
    }

    void stPartitionInfo(const ::dds::core::array< ST_DRIVE_INFO, 26L>& value) {
        m_stPartitionInfo_ = value;
    }

    void stPartitionInfo(::dds::core::array< ST_DRIVE_INFO, 26L>&& value) {
        m_stPartitionInfo_ = std::move(value);
    }
    uint8_t& oDriveState() OMG_NOEXCEPT {
        return m_oDriveState_;
    }

    const uint8_t& oDriveState() const OMG_NOEXCEPT {
        return m_oDriveState_;
    }

    void oDriveState(uint8_t value) {
        m_oDriveState_ = value;
    }

    bool operator == (const SYSMGR_HW_STATUS_HCI_INFO& other_) const;
    bool operator != (const SYSMGR_HW_STATUS_HCI_INFO& other_) const;

    void swap(SYSMGR_HW_STATUS_HCI_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_lHWID_;
    uint8_t m_oState_;
    uint8_t m_oReallocation_;
    uint32_t m_relHWID_;
    ST_CPU_INFO m_stCpuInfo_;
    uint8_t m_oCpuState_;
    ::dds::core::array< ST_NIC_INFO, 4L> m_stNicInfo_;
    ::dds::core::array< uint8_t, 4L> m_oNicState_;
    ST_MEM_INFO m_stMemInfo_;
    uint8_t m_oMemState_;
    ::dds::core::array< ST_DRIVE_INFO, 26L> m_stPartitionInfo_;
    uint8_t m_oDriveState_;

};

inline void swap(SYSMGR_HW_STATUS_HCI_INFO& a, SYSMGR_HW_STATUS_HCI_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_HW_STATUS_HCI_INFO& sample);

class NDDSUSERDllExport SYSMGR_HW_STATUS_INFO {
  public:
    SYSMGR_HW_STATUS_INFO();

    SYSMGR_HW_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usHwID,const ST_CPU_INFO& stCpuInfo,const ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo,const ST_MEM_INFO& stMenInfo,const ::dds::core::array< ST_DRIVE_INFO, 26L>& stPartitionInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_HW_STATUS_INFO (SYSMGR_HW_STATUS_INFO&&) = default;
    SYSMGR_HW_STATUS_INFO& operator=(SYSMGR_HW_STATUS_INFO&&) = default;
    SYSMGR_HW_STATUS_INFO& operator=(const SYSMGR_HW_STATUS_INFO&) = default;
    SYSMGR_HW_STATUS_INFO(const SYSMGR_HW_STATUS_INFO&) = default;
    #else
    SYSMGR_HW_STATUS_INFO(SYSMGR_HW_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_HW_STATUS_INFO& operator=(SYSMGR_HW_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usHwID() OMG_NOEXCEPT {
        return m_usHwID_;
    }

    const uint16_t& usHwID() const OMG_NOEXCEPT {
        return m_usHwID_;
    }

    void usHwID(uint16_t value) {
        m_usHwID_ = value;
    }

    ST_CPU_INFO& stCpuInfo() OMG_NOEXCEPT {
        return m_stCpuInfo_;
    }

    const ST_CPU_INFO& stCpuInfo() const OMG_NOEXCEPT {
        return m_stCpuInfo_;
    }

    void stCpuInfo(const ST_CPU_INFO& value) {
        m_stCpuInfo_ = value;
    }

    void stCpuInfo(ST_CPU_INFO&& value) {
        m_stCpuInfo_ = std::move(value);
    }
    ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo() OMG_NOEXCEPT {
        return m_stNicInfo_;
    }

    const ::dds::core::array< ST_NIC_INFO, 4L>& stNicInfo() const OMG_NOEXCEPT {
        return m_stNicInfo_;
    }

    void stNicInfo(const ::dds::core::array< ST_NIC_INFO, 4L>& value) {
        m_stNicInfo_ = value;
    }

    void stNicInfo(::dds::core::array< ST_NIC_INFO, 4L>&& value) {
        m_stNicInfo_ = std::move(value);
    }
    ST_MEM_INFO& stMenInfo() OMG_NOEXCEPT {
        return m_stMenInfo_;
    }

    const ST_MEM_INFO& stMenInfo() const OMG_NOEXCEPT {
        return m_stMenInfo_;
    }

    void stMenInfo(const ST_MEM_INFO& value) {
        m_stMenInfo_ = value;
    }

    void stMenInfo(ST_MEM_INFO&& value) {
        m_stMenInfo_ = std::move(value);
    }
    ::dds::core::array< ST_DRIVE_INFO, 26L>& stPartitionInfo() OMG_NOEXCEPT {
        return m_stPartitionInfo_;
    }

    const ::dds::core::array< ST_DRIVE_INFO, 26L>& stPartitionInfo() const OMG_NOEXCEPT {
        return m_stPartitionInfo_;
    }

    void stPartitionInfo(const ::dds::core::array< ST_DRIVE_INFO, 26L>& value) {
        m_stPartitionInfo_ = value;
    }

    void stPartitionInfo(::dds::core::array< ST_DRIVE_INFO, 26L>&& value) {
        m_stPartitionInfo_ = std::move(value);
    }

    bool operator == (const SYSMGR_HW_STATUS_INFO& other_) const;
    bool operator != (const SYSMGR_HW_STATUS_INFO& other_) const;

    void swap(SYSMGR_HW_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usHwID_;
    ST_CPU_INFO m_stCpuInfo_;
    ::dds::core::array< ST_NIC_INFO, 4L> m_stNicInfo_;
    ST_MEM_INFO m_stMenInfo_;
    ::dds::core::array< ST_DRIVE_INFO, 26L> m_stPartitionInfo_;

};

inline void swap(SYSMGR_HW_STATUS_INFO& a, SYSMGR_HW_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_HW_STATUS_INFO& sample);

class NDDSUSERDllExport SYSMGR_NOTIFICATION_INFO {
  public:
    SYSMGR_NOTIFICATION_INFO();

    SYSMGR_NOTIFICATION_INFO(const ST_MSG_HEADER& stMsgHeader,int32_t eSendSW,uint8_t oDestinationConsoleID,uint32_t ulMsgID,const ::dds::core::array< uint8_t, 500L>& oExtMsg,uint8_t oNotificationType,uint8_t oDisplayType,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_NOTIFICATION_INFO (SYSMGR_NOTIFICATION_INFO&&) = default;
    SYSMGR_NOTIFICATION_INFO& operator=(SYSMGR_NOTIFICATION_INFO&&) = default;
    SYSMGR_NOTIFICATION_INFO& operator=(const SYSMGR_NOTIFICATION_INFO&) = default;
    SYSMGR_NOTIFICATION_INFO(const SYSMGR_NOTIFICATION_INFO&) = default;
    #else
    SYSMGR_NOTIFICATION_INFO(SYSMGR_NOTIFICATION_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_NOTIFICATION_INFO& operator=(SYSMGR_NOTIFICATION_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int32_t& eSendSW() OMG_NOEXCEPT {
        return m_eSendSW_;
    }

    const int32_t& eSendSW() const OMG_NOEXCEPT {
        return m_eSendSW_;
    }

    void eSendSW(int32_t value) {
        m_eSendSW_ = value;
    }

    uint8_t& oDestinationConsoleID() OMG_NOEXCEPT {
        return m_oDestinationConsoleID_;
    }

    const uint8_t& oDestinationConsoleID() const OMG_NOEXCEPT {
        return m_oDestinationConsoleID_;
    }

    void oDestinationConsoleID(uint8_t value) {
        m_oDestinationConsoleID_ = value;
    }

    uint32_t& ulMsgID() OMG_NOEXCEPT {
        return m_ulMsgID_;
    }

    const uint32_t& ulMsgID() const OMG_NOEXCEPT {
        return m_ulMsgID_;
    }

    void ulMsgID(uint32_t value) {
        m_ulMsgID_ = value;
    }

    ::dds::core::array< uint8_t, 500L>& oExtMsg() OMG_NOEXCEPT {
        return m_oExtMsg_;
    }

    const ::dds::core::array< uint8_t, 500L>& oExtMsg() const OMG_NOEXCEPT {
        return m_oExtMsg_;
    }

    void oExtMsg(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oExtMsg_ = value;
    }

    void oExtMsg(::dds::core::array< uint8_t, 500L>&& value) {
        m_oExtMsg_ = std::move(value);
    }
    uint8_t& oNotificationType() OMG_NOEXCEPT {
        return m_oNotificationType_;
    }

    const uint8_t& oNotificationType() const OMG_NOEXCEPT {
        return m_oNotificationType_;
    }

    void oNotificationType(uint8_t value) {
        m_oNotificationType_ = value;
    }

    uint8_t& oDisplayType() OMG_NOEXCEPT {
        return m_oDisplayType_;
    }

    const uint8_t& oDisplayType() const OMG_NOEXCEPT {
        return m_oDisplayType_;
    }

    void oDisplayType(uint8_t value) {
        m_oDisplayType_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const SYSMGR_NOTIFICATION_INFO& other_) const;
    bool operator != (const SYSMGR_NOTIFICATION_INFO& other_) const;

    void swap(SYSMGR_NOTIFICATION_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int32_t m_eSendSW_;
    uint8_t m_oDestinationConsoleID_;
    uint32_t m_ulMsgID_;
    ::dds::core::array< uint8_t, 500L> m_oExtMsg_;
    uint8_t m_oNotificationType_;
    uint8_t m_oDisplayType_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(SYSMGR_NOTIFICATION_INFO& a, SYSMGR_NOTIFICATION_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_NOTIFICATION_INFO& sample);

class NDDSUSERDllExport ST_PARAMETER {
  public:
    ST_PARAMETER();

    ST_PARAMETER(const ::dds::core::array< uint8_t, 100L>& oParaKey,const ::dds::core::array< uint8_t, 500L>& oParaValue);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_PARAMETER (ST_PARAMETER&&) = default;
    ST_PARAMETER& operator=(ST_PARAMETER&&) = default;
    ST_PARAMETER& operator=(const ST_PARAMETER&) = default;
    ST_PARAMETER(const ST_PARAMETER&) = default;
    #else
    ST_PARAMETER(ST_PARAMETER&& other_) OMG_NOEXCEPT;  
    ST_PARAMETER& operator=(ST_PARAMETER&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 100L>& oParaKey() OMG_NOEXCEPT {
        return m_oParaKey_;
    }

    const ::dds::core::array< uint8_t, 100L>& oParaKey() const OMG_NOEXCEPT {
        return m_oParaKey_;
    }

    void oParaKey(const ::dds::core::array< uint8_t, 100L>& value) {
        m_oParaKey_ = value;
    }

    void oParaKey(::dds::core::array< uint8_t, 100L>&& value) {
        m_oParaKey_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 500L>& oParaValue() OMG_NOEXCEPT {
        return m_oParaValue_;
    }

    const ::dds::core::array< uint8_t, 500L>& oParaValue() const OMG_NOEXCEPT {
        return m_oParaValue_;
    }

    void oParaValue(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oParaValue_ = value;
    }

    void oParaValue(::dds::core::array< uint8_t, 500L>&& value) {
        m_oParaValue_ = std::move(value);
    }

    bool operator == (const ST_PARAMETER& other_) const;
    bool operator != (const ST_PARAMETER& other_) const;

    void swap(ST_PARAMETER& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 100L> m_oParaKey_;
    ::dds::core::array< uint8_t, 500L> m_oParaValue_;

};

inline void swap(ST_PARAMETER& a, ST_PARAMETER& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_PARAMETER& sample);

class NDDSUSERDllExport SYSMGR_PARAMETER_REQ {
  public:
    SYSMGR_PARAMETER_REQ();

    SYSMGR_PARAMETER_REQ(const ST_MSG_HEADER& stMsgHeader,uint8_t oFlag,const ::dds::core::array< uint8_t, 128L>& szSWName,uint32_t ulCount,const ::dds::core::array< ST_PARAMETER, 100L>& stParameter);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_PARAMETER_REQ (SYSMGR_PARAMETER_REQ&&) = default;
    SYSMGR_PARAMETER_REQ& operator=(SYSMGR_PARAMETER_REQ&&) = default;
    SYSMGR_PARAMETER_REQ& operator=(const SYSMGR_PARAMETER_REQ&) = default;
    SYSMGR_PARAMETER_REQ(const SYSMGR_PARAMETER_REQ&) = default;
    #else
    SYSMGR_PARAMETER_REQ(SYSMGR_PARAMETER_REQ&& other_) OMG_NOEXCEPT;  
    SYSMGR_PARAMETER_REQ& operator=(SYSMGR_PARAMETER_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oFlag() OMG_NOEXCEPT {
        return m_oFlag_;
    }

    const uint8_t& oFlag() const OMG_NOEXCEPT {
        return m_oFlag_;
    }

    void oFlag(uint8_t value) {
        m_oFlag_ = value;
    }

    ::dds::core::array< uint8_t, 128L>& szSWName() OMG_NOEXCEPT {
        return m_szSWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& szSWName() const OMG_NOEXCEPT {
        return m_szSWName_;
    }

    void szSWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_szSWName_ = value;
    }

    void szSWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_szSWName_ = std::move(value);
    }
    uint32_t& ulCount() OMG_NOEXCEPT {
        return m_ulCount_;
    }

    const uint32_t& ulCount() const OMG_NOEXCEPT {
        return m_ulCount_;
    }

    void ulCount(uint32_t value) {
        m_ulCount_ = value;
    }

    ::dds::core::array< ST_PARAMETER, 100L>& stParameter() OMG_NOEXCEPT {
        return m_stParameter_;
    }

    const ::dds::core::array< ST_PARAMETER, 100L>& stParameter() const OMG_NOEXCEPT {
        return m_stParameter_;
    }

    void stParameter(const ::dds::core::array< ST_PARAMETER, 100L>& value) {
        m_stParameter_ = value;
    }

    void stParameter(::dds::core::array< ST_PARAMETER, 100L>&& value) {
        m_stParameter_ = std::move(value);
    }

    bool operator == (const SYSMGR_PARAMETER_REQ& other_) const;
    bool operator != (const SYSMGR_PARAMETER_REQ& other_) const;

    void swap(SYSMGR_PARAMETER_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oFlag_;
    ::dds::core::array< uint8_t, 128L> m_szSWName_;
    uint32_t m_ulCount_;
    ::dds::core::array< ST_PARAMETER, 100L> m_stParameter_;

};

inline void swap(SYSMGR_PARAMETER_REQ& a, SYSMGR_PARAMETER_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_PARAMETER_REQ& sample);

class NDDSUSERDllExport SYSMGR_PARAMETER_RESULT {
  public:
    SYSMGR_PARAMETER_RESULT();

    SYSMGR_PARAMETER_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 20L>& oIP,const ::dds::core::array< uint8_t, 128L>& szSWName,int32_t lResult,uint32_t ulCount,const ::dds::core::array< ST_PARAMETER, 100L>& stParameter);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_PARAMETER_RESULT (SYSMGR_PARAMETER_RESULT&&) = default;
    SYSMGR_PARAMETER_RESULT& operator=(SYSMGR_PARAMETER_RESULT&&) = default;
    SYSMGR_PARAMETER_RESULT& operator=(const SYSMGR_PARAMETER_RESULT&) = default;
    SYSMGR_PARAMETER_RESULT(const SYSMGR_PARAMETER_RESULT&) = default;
    #else
    SYSMGR_PARAMETER_RESULT(SYSMGR_PARAMETER_RESULT&& other_) OMG_NOEXCEPT;  
    SYSMGR_PARAMETER_RESULT& operator=(SYSMGR_PARAMETER_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& szSWName() OMG_NOEXCEPT {
        return m_szSWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& szSWName() const OMG_NOEXCEPT {
        return m_szSWName_;
    }

    void szSWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_szSWName_ = value;
    }

    void szSWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_szSWName_ = std::move(value);
    }
    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    uint32_t& ulCount() OMG_NOEXCEPT {
        return m_ulCount_;
    }

    const uint32_t& ulCount() const OMG_NOEXCEPT {
        return m_ulCount_;
    }

    void ulCount(uint32_t value) {
        m_ulCount_ = value;
    }

    ::dds::core::array< ST_PARAMETER, 100L>& stParameter() OMG_NOEXCEPT {
        return m_stParameter_;
    }

    const ::dds::core::array< ST_PARAMETER, 100L>& stParameter() const OMG_NOEXCEPT {
        return m_stParameter_;
    }

    void stParameter(const ::dds::core::array< ST_PARAMETER, 100L>& value) {
        m_stParameter_ = value;
    }

    void stParameter(::dds::core::array< ST_PARAMETER, 100L>&& value) {
        m_stParameter_ = std::move(value);
    }

    bool operator == (const SYSMGR_PARAMETER_RESULT& other_) const;
    bool operator != (const SYSMGR_PARAMETER_RESULT& other_) const;

    void swap(SYSMGR_PARAMETER_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;
    ::dds::core::array< uint8_t, 128L> m_szSWName_;
    int32_t m_lResult_;
    uint32_t m_ulCount_;
    ::dds::core::array< ST_PARAMETER, 100L> m_stParameter_;

};

inline void swap(SYSMGR_PARAMETER_RESULT& a, SYSMGR_PARAMETER_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_PARAMETER_RESULT& sample);

class NDDSUSERDllExport SYSMGR_SERVER_START_INFO {
  public:
    SYSMGR_SERVER_START_INFO();

    SYSMGR_SERVER_START_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oCMDType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SERVER_START_INFO (SYSMGR_SERVER_START_INFO&&) = default;
    SYSMGR_SERVER_START_INFO& operator=(SYSMGR_SERVER_START_INFO&&) = default;
    SYSMGR_SERVER_START_INFO& operator=(const SYSMGR_SERVER_START_INFO&) = default;
    SYSMGR_SERVER_START_INFO(const SYSMGR_SERVER_START_INFO&) = default;
    #else
    SYSMGR_SERVER_START_INFO(SYSMGR_SERVER_START_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_SERVER_START_INFO& operator=(SYSMGR_SERVER_START_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oCMDType() OMG_NOEXCEPT {
        return m_oCMDType_;
    }

    const uint8_t& oCMDType() const OMG_NOEXCEPT {
        return m_oCMDType_;
    }

    void oCMDType(uint8_t value) {
        m_oCMDType_ = value;
    }

    bool operator == (const SYSMGR_SERVER_START_INFO& other_) const;
    bool operator != (const SYSMGR_SERVER_START_INFO& other_) const;

    void swap(SYSMGR_SERVER_START_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oCMDType_;

};

inline void swap(SYSMGR_SERVER_START_INFO& a, SYSMGR_SERVER_START_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SERVER_START_INFO& sample);

class NDDSUSERDllExport SYSMGR_SWUPDATE_CMD {
  public:
    SYSMGR_SWUPDATE_CMD();

    SYSMGR_SWUPDATE_CMD(const ST_MSG_HEADER& stMsgHeader,uint16_t usInstallHWID,const ::dds::core::array< uint8_t, 20L>& oIP,uint16_t usInstallSWID,const ::dds::core::array< uint8_t, 128L>& oSWExeName,const ::dds::core::array< uint8_t, 1000L>& usInstallSWPath);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SWUPDATE_CMD (SYSMGR_SWUPDATE_CMD&&) = default;
    SYSMGR_SWUPDATE_CMD& operator=(SYSMGR_SWUPDATE_CMD&&) = default;
    SYSMGR_SWUPDATE_CMD& operator=(const SYSMGR_SWUPDATE_CMD&) = default;
    SYSMGR_SWUPDATE_CMD(const SYSMGR_SWUPDATE_CMD&) = default;
    #else
    SYSMGR_SWUPDATE_CMD(SYSMGR_SWUPDATE_CMD&& other_) OMG_NOEXCEPT;  
    SYSMGR_SWUPDATE_CMD& operator=(SYSMGR_SWUPDATE_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usInstallHWID() OMG_NOEXCEPT {
        return m_usInstallHWID_;
    }

    const uint16_t& usInstallHWID() const OMG_NOEXCEPT {
        return m_usInstallHWID_;
    }

    void usInstallHWID(uint16_t value) {
        m_usInstallHWID_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    uint16_t& usInstallSWID() OMG_NOEXCEPT {
        return m_usInstallSWID_;
    }

    const uint16_t& usInstallSWID() const OMG_NOEXCEPT {
        return m_usInstallSWID_;
    }

    void usInstallSWID(uint16_t value) {
        m_usInstallSWID_ = value;
    }

    ::dds::core::array< uint8_t, 128L>& oSWExeName() OMG_NOEXCEPT {
        return m_oSWExeName_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWExeName() const OMG_NOEXCEPT {
        return m_oSWExeName_;
    }

    void oSWExeName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWExeName_ = value;
    }

    void oSWExeName(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWExeName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 1000L>& usInstallSWPath() OMG_NOEXCEPT {
        return m_usInstallSWPath_;
    }

    const ::dds::core::array< uint8_t, 1000L>& usInstallSWPath() const OMG_NOEXCEPT {
        return m_usInstallSWPath_;
    }

    void usInstallSWPath(const ::dds::core::array< uint8_t, 1000L>& value) {
        m_usInstallSWPath_ = value;
    }

    void usInstallSWPath(::dds::core::array< uint8_t, 1000L>&& value) {
        m_usInstallSWPath_ = std::move(value);
    }

    bool operator == (const SYSMGR_SWUPDATE_CMD& other_) const;
    bool operator != (const SYSMGR_SWUPDATE_CMD& other_) const;

    void swap(SYSMGR_SWUPDATE_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usInstallHWID_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;
    uint16_t m_usInstallSWID_;
    ::dds::core::array< uint8_t, 128L> m_oSWExeName_;
    ::dds::core::array< uint8_t, 1000L> m_usInstallSWPath_;

};

inline void swap(SYSMGR_SWUPDATE_CMD& a, SYSMGR_SWUPDATE_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SWUPDATE_CMD& sample);

class NDDSUSERDllExport ST_SWUPDATE_OVERALL_RESULT {
  public:
    ST_SWUPDATE_OVERALL_RESULT();

    ST_SWUPDATE_OVERALL_RESULT(bool bUSE,uint32_t ulHWID,uint32_t ulSWID,uint32_t ulInstallResult,const ::dds::core::array< uint8_t, 3L>& oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SWUPDATE_OVERALL_RESULT (ST_SWUPDATE_OVERALL_RESULT&&) = default;
    ST_SWUPDATE_OVERALL_RESULT& operator=(ST_SWUPDATE_OVERALL_RESULT&&) = default;
    ST_SWUPDATE_OVERALL_RESULT& operator=(const ST_SWUPDATE_OVERALL_RESULT&) = default;
    ST_SWUPDATE_OVERALL_RESULT(const ST_SWUPDATE_OVERALL_RESULT&) = default;
    #else
    ST_SWUPDATE_OVERALL_RESULT(ST_SWUPDATE_OVERALL_RESULT&& other_) OMG_NOEXCEPT;  
    ST_SWUPDATE_OVERALL_RESULT& operator=(ST_SWUPDATE_OVERALL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    bool& bUSE() OMG_NOEXCEPT {
        return m_bUSE_;
    }

    const bool& bUSE() const OMG_NOEXCEPT {
        return m_bUSE_;
    }

    void bUSE(bool value) {
        m_bUSE_ = value;
    }

    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    uint32_t& ulSWID() OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    const uint32_t& ulSWID() const OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    void ulSWID(uint32_t value) {
        m_ulSWID_ = value;
    }

    uint32_t& ulInstallResult() OMG_NOEXCEPT {
        return m_ulInstallResult_;
    }

    const uint32_t& ulInstallResult() const OMG_NOEXCEPT {
        return m_ulInstallResult_;
    }

    void ulInstallResult(uint32_t value) {
        m_ulInstallResult_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oResearved_ = std::move(value);
    }

    bool operator == (const ST_SWUPDATE_OVERALL_RESULT& other_) const;
    bool operator != (const ST_SWUPDATE_OVERALL_RESULT& other_) const;

    void swap(ST_SWUPDATE_OVERALL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    bool m_bUSE_;
    uint32_t m_ulHWID_;
    uint32_t m_ulSWID_;
    uint32_t m_ulInstallResult_;
    ::dds::core::array< uint8_t, 3L> m_oResearved_;

};

inline void swap(ST_SWUPDATE_OVERALL_RESULT& a, ST_SWUPDATE_OVERALL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SWUPDATE_OVERALL_RESULT& sample);

class NDDSUSERDllExport SYSMGR_SWUPDATE_OVERALL_RESULT {
  public:
    SYSMGR_SWUPDATE_OVERALL_RESULT();

    SYSMGR_SWUPDATE_OVERALL_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_SWUPDATE_OVERALL_RESULT, 100L>& stSWUpdateOverallResult,const ::dds::core::array< uint8_t, 500L>& oMSG);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SWUPDATE_OVERALL_RESULT (SYSMGR_SWUPDATE_OVERALL_RESULT&&) = default;
    SYSMGR_SWUPDATE_OVERALL_RESULT& operator=(SYSMGR_SWUPDATE_OVERALL_RESULT&&) = default;
    SYSMGR_SWUPDATE_OVERALL_RESULT& operator=(const SYSMGR_SWUPDATE_OVERALL_RESULT&) = default;
    SYSMGR_SWUPDATE_OVERALL_RESULT(const SYSMGR_SWUPDATE_OVERALL_RESULT&) = default;
    #else
    SYSMGR_SWUPDATE_OVERALL_RESULT(SYSMGR_SWUPDATE_OVERALL_RESULT&& other_) OMG_NOEXCEPT;  
    SYSMGR_SWUPDATE_OVERALL_RESULT& operator=(SYSMGR_SWUPDATE_OVERALL_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_SWUPDATE_OVERALL_RESULT, 100L>& stSWUpdateOverallResult() OMG_NOEXCEPT {
        return m_stSWUpdateOverallResult_;
    }

    const ::dds::core::array< ST_SWUPDATE_OVERALL_RESULT, 100L>& stSWUpdateOverallResult() const OMG_NOEXCEPT {
        return m_stSWUpdateOverallResult_;
    }

    void stSWUpdateOverallResult(const ::dds::core::array< ST_SWUPDATE_OVERALL_RESULT, 100L>& value) {
        m_stSWUpdateOverallResult_ = value;
    }

    void stSWUpdateOverallResult(::dds::core::array< ST_SWUPDATE_OVERALL_RESULT, 100L>&& value) {
        m_stSWUpdateOverallResult_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 500L>& oMSG() OMG_NOEXCEPT {
        return m_oMSG_;
    }

    const ::dds::core::array< uint8_t, 500L>& oMSG() const OMG_NOEXCEPT {
        return m_oMSG_;
    }

    void oMSG(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oMSG_ = value;
    }

    void oMSG(::dds::core::array< uint8_t, 500L>&& value) {
        m_oMSG_ = std::move(value);
    }

    bool operator == (const SYSMGR_SWUPDATE_OVERALL_RESULT& other_) const;
    bool operator != (const SYSMGR_SWUPDATE_OVERALL_RESULT& other_) const;

    void swap(SYSMGR_SWUPDATE_OVERALL_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_SWUPDATE_OVERALL_RESULT, 100L> m_stSWUpdateOverallResult_;
    ::dds::core::array< uint8_t, 500L> m_oMSG_;

};

inline void swap(SYSMGR_SWUPDATE_OVERALL_RESULT& a, SYSMGR_SWUPDATE_OVERALL_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SWUPDATE_OVERALL_RESULT& sample);

class NDDSUSERDllExport SYSMGR_SWUPDATE_RESULT {
  public:
    SYSMGR_SWUPDATE_RESULT();

    SYSMGR_SWUPDATE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t usInstallHWID,uint16_t usInstallSWID,uint16_t usInstallResult,const ::dds::core::array< uint8_t, 128L>& oErrMsg);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SWUPDATE_RESULT (SYSMGR_SWUPDATE_RESULT&&) = default;
    SYSMGR_SWUPDATE_RESULT& operator=(SYSMGR_SWUPDATE_RESULT&&) = default;
    SYSMGR_SWUPDATE_RESULT& operator=(const SYSMGR_SWUPDATE_RESULT&) = default;
    SYSMGR_SWUPDATE_RESULT(const SYSMGR_SWUPDATE_RESULT&) = default;
    #else
    SYSMGR_SWUPDATE_RESULT(SYSMGR_SWUPDATE_RESULT&& other_) OMG_NOEXCEPT;  
    SYSMGR_SWUPDATE_RESULT& operator=(SYSMGR_SWUPDATE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usInstallHWID() OMG_NOEXCEPT {
        return m_usInstallHWID_;
    }

    const uint16_t& usInstallHWID() const OMG_NOEXCEPT {
        return m_usInstallHWID_;
    }

    void usInstallHWID(uint16_t value) {
        m_usInstallHWID_ = value;
    }

    uint16_t& usInstallSWID() OMG_NOEXCEPT {
        return m_usInstallSWID_;
    }

    const uint16_t& usInstallSWID() const OMG_NOEXCEPT {
        return m_usInstallSWID_;
    }

    void usInstallSWID(uint16_t value) {
        m_usInstallSWID_ = value;
    }

    uint16_t& usInstallResult() OMG_NOEXCEPT {
        return m_usInstallResult_;
    }

    const uint16_t& usInstallResult() const OMG_NOEXCEPT {
        return m_usInstallResult_;
    }

    void usInstallResult(uint16_t value) {
        m_usInstallResult_ = value;
    }

    ::dds::core::array< uint8_t, 128L>& oErrMsg() OMG_NOEXCEPT {
        return m_oErrMsg_;
    }

    const ::dds::core::array< uint8_t, 128L>& oErrMsg() const OMG_NOEXCEPT {
        return m_oErrMsg_;
    }

    void oErrMsg(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oErrMsg_ = value;
    }

    void oErrMsg(::dds::core::array< uint8_t, 128L>&& value) {
        m_oErrMsg_ = std::move(value);
    }

    bool operator == (const SYSMGR_SWUPDATE_RESULT& other_) const;
    bool operator != (const SYSMGR_SWUPDATE_RESULT& other_) const;

    void swap(SYSMGR_SWUPDATE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usInstallHWID_;
    uint16_t m_usInstallSWID_;
    uint16_t m_usInstallResult_;
    ::dds::core::array< uint8_t, 128L> m_oErrMsg_;

};

inline void swap(SYSMGR_SWUPDATE_RESULT& a, SYSMGR_SWUPDATE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SWUPDATE_RESULT& sample);

class NDDSUSERDllExport ST_SW_GROUP_STATUS_INFO {
  public:
    ST_SW_GROUP_STATUS_INFO();

    ST_SW_GROUP_STATUS_INFO(uint32_t ulHWID,uint8_t oStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_GROUP_STATUS_INFO (ST_SW_GROUP_STATUS_INFO&&) = default;
    ST_SW_GROUP_STATUS_INFO& operator=(ST_SW_GROUP_STATUS_INFO&&) = default;
    ST_SW_GROUP_STATUS_INFO& operator=(const ST_SW_GROUP_STATUS_INFO&) = default;
    ST_SW_GROUP_STATUS_INFO(const ST_SW_GROUP_STATUS_INFO&) = default;
    #else
    ST_SW_GROUP_STATUS_INFO(ST_SW_GROUP_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_SW_GROUP_STATUS_INFO& operator=(ST_SW_GROUP_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    bool operator == (const ST_SW_GROUP_STATUS_INFO& other_) const;
    bool operator != (const ST_SW_GROUP_STATUS_INFO& other_) const;

    void swap(ST_SW_GROUP_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulHWID_;
    uint8_t m_oStatus_;

};

inline void swap(ST_SW_GROUP_STATUS_INFO& a, ST_SW_GROUP_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_GROUP_STATUS_INFO& sample);

class NDDSUSERDllExport ST_SW_EQUIP_STATUS_INFO {
  public:
    ST_SW_EQUIP_STATUS_INFO();

    ST_SW_EQUIP_STATUS_INFO(uint32_t ulEquipID,uint8_t oStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_EQUIP_STATUS_INFO (ST_SW_EQUIP_STATUS_INFO&&) = default;
    ST_SW_EQUIP_STATUS_INFO& operator=(ST_SW_EQUIP_STATUS_INFO&&) = default;
    ST_SW_EQUIP_STATUS_INFO& operator=(const ST_SW_EQUIP_STATUS_INFO&) = default;
    ST_SW_EQUIP_STATUS_INFO(const ST_SW_EQUIP_STATUS_INFO&) = default;
    #else
    ST_SW_EQUIP_STATUS_INFO(ST_SW_EQUIP_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    ST_SW_EQUIP_STATUS_INFO& operator=(ST_SW_EQUIP_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulEquipID() OMG_NOEXCEPT {
        return m_ulEquipID_;
    }

    const uint32_t& ulEquipID() const OMG_NOEXCEPT {
        return m_ulEquipID_;
    }

    void ulEquipID(uint32_t value) {
        m_ulEquipID_ = value;
    }

    uint8_t& oStatus() OMG_NOEXCEPT {
        return m_oStatus_;
    }

    const uint8_t& oStatus() const OMG_NOEXCEPT {
        return m_oStatus_;
    }

    void oStatus(uint8_t value) {
        m_oStatus_ = value;
    }

    bool operator == (const ST_SW_EQUIP_STATUS_INFO& other_) const;
    bool operator != (const ST_SW_EQUIP_STATUS_INFO& other_) const;

    void swap(ST_SW_EQUIP_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulEquipID_;
    uint8_t m_oStatus_;

};

inline void swap(ST_SW_EQUIP_STATUS_INFO& a, ST_SW_EQUIP_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_EQUIP_STATUS_INFO& sample);

class NDDSUSERDllExport SYSMGR_SW_ALL_STATUS_INFO {
  public:
    SYSMGR_SW_ALL_STATUS_INFO();

    SYSMGR_SW_ALL_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_SW_ALL_STATUS_INFO, 100L>& stSwStatusInfo,const ::dds::core::array< ST_SW_GROUP_STATUS_INFO, 100L>& stSWGroupInfo,const ::dds::core::array< ST_SW_EQUIP_STATUS_INFO, 100L>& stSWEquipInfo,uint8_t oSwAllState);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SW_ALL_STATUS_INFO (SYSMGR_SW_ALL_STATUS_INFO&&) = default;
    SYSMGR_SW_ALL_STATUS_INFO& operator=(SYSMGR_SW_ALL_STATUS_INFO&&) = default;
    SYSMGR_SW_ALL_STATUS_INFO& operator=(const SYSMGR_SW_ALL_STATUS_INFO&) = default;
    SYSMGR_SW_ALL_STATUS_INFO(const SYSMGR_SW_ALL_STATUS_INFO&) = default;
    #else
    SYSMGR_SW_ALL_STATUS_INFO(SYSMGR_SW_ALL_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_SW_ALL_STATUS_INFO& operator=(SYSMGR_SW_ALL_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_SW_ALL_STATUS_INFO, 100L>& stSwStatusInfo() OMG_NOEXCEPT {
        return m_stSwStatusInfo_;
    }

    const ::dds::core::array< ST_SW_ALL_STATUS_INFO, 100L>& stSwStatusInfo() const OMG_NOEXCEPT {
        return m_stSwStatusInfo_;
    }

    void stSwStatusInfo(const ::dds::core::array< ST_SW_ALL_STATUS_INFO, 100L>& value) {
        m_stSwStatusInfo_ = value;
    }

    void stSwStatusInfo(::dds::core::array< ST_SW_ALL_STATUS_INFO, 100L>&& value) {
        m_stSwStatusInfo_ = std::move(value);
    }
    ::dds::core::array< ST_SW_GROUP_STATUS_INFO, 100L>& stSWGroupInfo() OMG_NOEXCEPT {
        return m_stSWGroupInfo_;
    }

    const ::dds::core::array< ST_SW_GROUP_STATUS_INFO, 100L>& stSWGroupInfo() const OMG_NOEXCEPT {
        return m_stSWGroupInfo_;
    }

    void stSWGroupInfo(const ::dds::core::array< ST_SW_GROUP_STATUS_INFO, 100L>& value) {
        m_stSWGroupInfo_ = value;
    }

    void stSWGroupInfo(::dds::core::array< ST_SW_GROUP_STATUS_INFO, 100L>&& value) {
        m_stSWGroupInfo_ = std::move(value);
    }
    ::dds::core::array< ST_SW_EQUIP_STATUS_INFO, 100L>& stSWEquipInfo() OMG_NOEXCEPT {
        return m_stSWEquipInfo_;
    }

    const ::dds::core::array< ST_SW_EQUIP_STATUS_INFO, 100L>& stSWEquipInfo() const OMG_NOEXCEPT {
        return m_stSWEquipInfo_;
    }

    void stSWEquipInfo(const ::dds::core::array< ST_SW_EQUIP_STATUS_INFO, 100L>& value) {
        m_stSWEquipInfo_ = value;
    }

    void stSWEquipInfo(::dds::core::array< ST_SW_EQUIP_STATUS_INFO, 100L>&& value) {
        m_stSWEquipInfo_ = std::move(value);
    }
    uint8_t& oSwAllState() OMG_NOEXCEPT {
        return m_oSwAllState_;
    }

    const uint8_t& oSwAllState() const OMG_NOEXCEPT {
        return m_oSwAllState_;
    }

    void oSwAllState(uint8_t value) {
        m_oSwAllState_ = value;
    }

    bool operator == (const SYSMGR_SW_ALL_STATUS_INFO& other_) const;
    bool operator != (const SYSMGR_SW_ALL_STATUS_INFO& other_) const;

    void swap(SYSMGR_SW_ALL_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_SW_ALL_STATUS_INFO, 100L> m_stSwStatusInfo_;
    ::dds::core::array< ST_SW_GROUP_STATUS_INFO, 100L> m_stSWGroupInfo_;
    ::dds::core::array< ST_SW_EQUIP_STATUS_INFO, 100L> m_stSWEquipInfo_;
    uint8_t m_oSwAllState_;

};

inline void swap(SYSMGR_SW_ALL_STATUS_INFO& a, SYSMGR_SW_ALL_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SW_ALL_STATUS_INFO& sample);

class NDDSUSERDllExport SYSMGR_SW_FIRST_RUN_REQ {
  public:
    SYSMGR_SW_FIRST_RUN_REQ();

    SYSMGR_SW_FIRST_RUN_REQ(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 20L>& oIP,uint16_t usCmd);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SW_FIRST_RUN_REQ (SYSMGR_SW_FIRST_RUN_REQ&&) = default;
    SYSMGR_SW_FIRST_RUN_REQ& operator=(SYSMGR_SW_FIRST_RUN_REQ&&) = default;
    SYSMGR_SW_FIRST_RUN_REQ& operator=(const SYSMGR_SW_FIRST_RUN_REQ&) = default;
    SYSMGR_SW_FIRST_RUN_REQ(const SYSMGR_SW_FIRST_RUN_REQ&) = default;
    #else
    SYSMGR_SW_FIRST_RUN_REQ(SYSMGR_SW_FIRST_RUN_REQ&& other_) OMG_NOEXCEPT;  
    SYSMGR_SW_FIRST_RUN_REQ& operator=(SYSMGR_SW_FIRST_RUN_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    uint16_t& usCmd() OMG_NOEXCEPT {
        return m_usCmd_;
    }

    const uint16_t& usCmd() const OMG_NOEXCEPT {
        return m_usCmd_;
    }

    void usCmd(uint16_t value) {
        m_usCmd_ = value;
    }

    bool operator == (const SYSMGR_SW_FIRST_RUN_REQ& other_) const;
    bool operator != (const SYSMGR_SW_FIRST_RUN_REQ& other_) const;

    void swap(SYSMGR_SW_FIRST_RUN_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;
    uint16_t m_usCmd_;

};

inline void swap(SYSMGR_SW_FIRST_RUN_REQ& a, SYSMGR_SW_FIRST_RUN_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SW_FIRST_RUN_REQ& sample);

class NDDSUSERDllExport SYSMGR_SW_KILL_CMD {
  public:
    SYSMGR_SW_KILL_CMD();

    SYSMGR_SW_KILL_CMD(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 20L>& oIP,const ::dds::core::array< uint8_t, 128L>& oSWName,uint32_t ulProcID,uint16_t usForce,uint16_t usRunType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SW_KILL_CMD (SYSMGR_SW_KILL_CMD&&) = default;
    SYSMGR_SW_KILL_CMD& operator=(SYSMGR_SW_KILL_CMD&&) = default;
    SYSMGR_SW_KILL_CMD& operator=(const SYSMGR_SW_KILL_CMD&) = default;
    SYSMGR_SW_KILL_CMD(const SYSMGR_SW_KILL_CMD&) = default;
    #else
    SYSMGR_SW_KILL_CMD(SYSMGR_SW_KILL_CMD&& other_) OMG_NOEXCEPT;  
    SYSMGR_SW_KILL_CMD& operator=(SYSMGR_SW_KILL_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oSWName() OMG_NOEXCEPT {
        return m_oSWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& oSWName() const OMG_NOEXCEPT {
        return m_oSWName_;
    }

    void oSWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oSWName_ = value;
    }

    void oSWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_oSWName_ = std::move(value);
    }
    uint32_t& ulProcID() OMG_NOEXCEPT {
        return m_ulProcID_;
    }

    const uint32_t& ulProcID() const OMG_NOEXCEPT {
        return m_ulProcID_;
    }

    void ulProcID(uint32_t value) {
        m_ulProcID_ = value;
    }

    uint16_t& usForce() OMG_NOEXCEPT {
        return m_usForce_;
    }

    const uint16_t& usForce() const OMG_NOEXCEPT {
        return m_usForce_;
    }

    void usForce(uint16_t value) {
        m_usForce_ = value;
    }

    uint16_t& usRunType() OMG_NOEXCEPT {
        return m_usRunType_;
    }

    const uint16_t& usRunType() const OMG_NOEXCEPT {
        return m_usRunType_;
    }

    void usRunType(uint16_t value) {
        m_usRunType_ = value;
    }

    bool operator == (const SYSMGR_SW_KILL_CMD& other_) const;
    bool operator != (const SYSMGR_SW_KILL_CMD& other_) const;

    void swap(SYSMGR_SW_KILL_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;
    ::dds::core::array< uint8_t, 128L> m_oSWName_;
    uint32_t m_ulProcID_;
    uint16_t m_usForce_;
    uint16_t m_usRunType_;

};

inline void swap(SYSMGR_SW_KILL_CMD& a, SYSMGR_SW_KILL_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SW_KILL_CMD& sample);

class NDDSUSERDllExport SYSMGR_SW_RUN_CMD {
  public:
    SYSMGR_SW_RUN_CMD();

    SYSMGR_SW_RUN_CMD(const ST_MSG_HEADER& stMsgHeader,const ST_NIC_ADDR& stNicName,const ::dds::core::array< uint8_t, 128L>& szSWName,uint32_t ulProcID,uint16_t usForce,uint16_t usRunType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SW_RUN_CMD (SYSMGR_SW_RUN_CMD&&) = default;
    SYSMGR_SW_RUN_CMD& operator=(SYSMGR_SW_RUN_CMD&&) = default;
    SYSMGR_SW_RUN_CMD& operator=(const SYSMGR_SW_RUN_CMD&) = default;
    SYSMGR_SW_RUN_CMD(const SYSMGR_SW_RUN_CMD&) = default;
    #else
    SYSMGR_SW_RUN_CMD(SYSMGR_SW_RUN_CMD&& other_) OMG_NOEXCEPT;  
    SYSMGR_SW_RUN_CMD& operator=(SYSMGR_SW_RUN_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_NIC_ADDR& stNicName() OMG_NOEXCEPT {
        return m_stNicName_;
    }

    const ST_NIC_ADDR& stNicName() const OMG_NOEXCEPT {
        return m_stNicName_;
    }

    void stNicName(const ST_NIC_ADDR& value) {
        m_stNicName_ = value;
    }

    void stNicName(ST_NIC_ADDR&& value) {
        m_stNicName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& szSWName() OMG_NOEXCEPT {
        return m_szSWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& szSWName() const OMG_NOEXCEPT {
        return m_szSWName_;
    }

    void szSWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_szSWName_ = value;
    }

    void szSWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_szSWName_ = std::move(value);
    }
    uint32_t& ulProcID() OMG_NOEXCEPT {
        return m_ulProcID_;
    }

    const uint32_t& ulProcID() const OMG_NOEXCEPT {
        return m_ulProcID_;
    }

    void ulProcID(uint32_t value) {
        m_ulProcID_ = value;
    }

    uint16_t& usForce() OMG_NOEXCEPT {
        return m_usForce_;
    }

    const uint16_t& usForce() const OMG_NOEXCEPT {
        return m_usForce_;
    }

    void usForce(uint16_t value) {
        m_usForce_ = value;
    }

    uint16_t& usRunType() OMG_NOEXCEPT {
        return m_usRunType_;
    }

    const uint16_t& usRunType() const OMG_NOEXCEPT {
        return m_usRunType_;
    }

    void usRunType(uint16_t value) {
        m_usRunType_ = value;
    }

    bool operator == (const SYSMGR_SW_RUN_CMD& other_) const;
    bool operator != (const SYSMGR_SW_RUN_CMD& other_) const;

    void swap(SYSMGR_SW_RUN_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_NIC_ADDR m_stNicName_;
    ::dds::core::array< uint8_t, 128L> m_szSWName_;
    uint32_t m_ulProcID_;
    uint16_t m_usForce_;
    uint16_t m_usRunType_;

};

inline void swap(SYSMGR_SW_RUN_CMD& a, SYSMGR_SW_RUN_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SW_RUN_CMD& sample);

class NDDSUSERDllExport SYSMGR_SW_RUN_CMD_ALL {
  public:
    SYSMGR_SW_RUN_CMD_ALL();

    SYSMGR_SW_RUN_CMD_ALL(const ST_MSG_HEADER& stMsgHeader,uint16_t usRunType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SW_RUN_CMD_ALL (SYSMGR_SW_RUN_CMD_ALL&&) = default;
    SYSMGR_SW_RUN_CMD_ALL& operator=(SYSMGR_SW_RUN_CMD_ALL&&) = default;
    SYSMGR_SW_RUN_CMD_ALL& operator=(const SYSMGR_SW_RUN_CMD_ALL&) = default;
    SYSMGR_SW_RUN_CMD_ALL(const SYSMGR_SW_RUN_CMD_ALL&) = default;
    #else
    SYSMGR_SW_RUN_CMD_ALL(SYSMGR_SW_RUN_CMD_ALL&& other_) OMG_NOEXCEPT;  
    SYSMGR_SW_RUN_CMD_ALL& operator=(SYSMGR_SW_RUN_CMD_ALL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usRunType() OMG_NOEXCEPT {
        return m_usRunType_;
    }

    const uint16_t& usRunType() const OMG_NOEXCEPT {
        return m_usRunType_;
    }

    void usRunType(uint16_t value) {
        m_usRunType_ = value;
    }

    bool operator == (const SYSMGR_SW_RUN_CMD_ALL& other_) const;
    bool operator != (const SYSMGR_SW_RUN_CMD_ALL& other_) const;

    void swap(SYSMGR_SW_RUN_CMD_ALL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usRunType_;

};

inline void swap(SYSMGR_SW_RUN_CMD_ALL& a, SYSMGR_SW_RUN_CMD_ALL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SW_RUN_CMD_ALL& sample);

class NDDSUSERDllExport SYSMGR_SW_STATUS_HCI_INFO {
  public:
    SYSMGR_SW_STATUS_HCI_INFO();

    SYSMGR_SW_STATUS_HCI_INFO(const ST_MSG_HEADER& stMsgHeader,int32_t lHWID,const ::dds::core::array< uint8_t, 20L>& oIP,const ST_SW_STATUS_INFO& stSWStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SW_STATUS_HCI_INFO (SYSMGR_SW_STATUS_HCI_INFO&&) = default;
    SYSMGR_SW_STATUS_HCI_INFO& operator=(SYSMGR_SW_STATUS_HCI_INFO&&) = default;
    SYSMGR_SW_STATUS_HCI_INFO& operator=(const SYSMGR_SW_STATUS_HCI_INFO&) = default;
    SYSMGR_SW_STATUS_HCI_INFO(const SYSMGR_SW_STATUS_HCI_INFO&) = default;
    #else
    SYSMGR_SW_STATUS_HCI_INFO(SYSMGR_SW_STATUS_HCI_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_SW_STATUS_HCI_INFO& operator=(SYSMGR_SW_STATUS_HCI_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int32_t& lHWID() OMG_NOEXCEPT {
        return m_lHWID_;
    }

    const int32_t& lHWID() const OMG_NOEXCEPT {
        return m_lHWID_;
    }

    void lHWID(int32_t value) {
        m_lHWID_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }
    ST_SW_STATUS_INFO& stSWStatusInfo() OMG_NOEXCEPT {
        return m_stSWStatusInfo_;
    }

    const ST_SW_STATUS_INFO& stSWStatusInfo() const OMG_NOEXCEPT {
        return m_stSWStatusInfo_;
    }

    void stSWStatusInfo(const ST_SW_STATUS_INFO& value) {
        m_stSWStatusInfo_ = value;
    }

    void stSWStatusInfo(ST_SW_STATUS_INFO&& value) {
        m_stSWStatusInfo_ = std::move(value);
    }

    bool operator == (const SYSMGR_SW_STATUS_HCI_INFO& other_) const;
    bool operator != (const SYSMGR_SW_STATUS_HCI_INFO& other_) const;

    void swap(SYSMGR_SW_STATUS_HCI_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int32_t m_lHWID_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;
    ST_SW_STATUS_INFO m_stSWStatusInfo_;

};

inline void swap(SYSMGR_SW_STATUS_HCI_INFO& a, SYSMGR_SW_STATUS_HCI_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SW_STATUS_HCI_INFO& sample);

class NDDSUSERDllExport SYSMGR_SW_STATUS_INFO {
  public:
    SYSMGR_SW_STATUS_INFO();

    SYSMGR_SW_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 128L>& oHWName,const ST_NIC_ADDR& stnicName,const ST_SW_STATUS_INFO& stSWStatusInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_SW_STATUS_INFO (SYSMGR_SW_STATUS_INFO&&) = default;
    SYSMGR_SW_STATUS_INFO& operator=(SYSMGR_SW_STATUS_INFO&&) = default;
    SYSMGR_SW_STATUS_INFO& operator=(const SYSMGR_SW_STATUS_INFO&) = default;
    SYSMGR_SW_STATUS_INFO(const SYSMGR_SW_STATUS_INFO&) = default;
    #else
    SYSMGR_SW_STATUS_INFO(SYSMGR_SW_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_SW_STATUS_INFO& operator=(SYSMGR_SW_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 128L>& oHWName() OMG_NOEXCEPT {
        return m_oHWName_;
    }

    const ::dds::core::array< uint8_t, 128L>& oHWName() const OMG_NOEXCEPT {
        return m_oHWName_;
    }

    void oHWName(const ::dds::core::array< uint8_t, 128L>& value) {
        m_oHWName_ = value;
    }

    void oHWName(::dds::core::array< uint8_t, 128L>&& value) {
        m_oHWName_ = std::move(value);
    }
    ST_NIC_ADDR& stnicName() OMG_NOEXCEPT {
        return m_stnicName_;
    }

    const ST_NIC_ADDR& stnicName() const OMG_NOEXCEPT {
        return m_stnicName_;
    }

    void stnicName(const ST_NIC_ADDR& value) {
        m_stnicName_ = value;
    }

    void stnicName(ST_NIC_ADDR&& value) {
        m_stnicName_ = std::move(value);
    }
    ST_SW_STATUS_INFO& stSWStatusInfo() OMG_NOEXCEPT {
        return m_stSWStatusInfo_;
    }

    const ST_SW_STATUS_INFO& stSWStatusInfo() const OMG_NOEXCEPT {
        return m_stSWStatusInfo_;
    }

    void stSWStatusInfo(const ST_SW_STATUS_INFO& value) {
        m_stSWStatusInfo_ = value;
    }

    void stSWStatusInfo(ST_SW_STATUS_INFO&& value) {
        m_stSWStatusInfo_ = std::move(value);
    }

    bool operator == (const SYSMGR_SW_STATUS_INFO& other_) const;
    bool operator != (const SYSMGR_SW_STATUS_INFO& other_) const;

    void swap(SYSMGR_SW_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 128L> m_oHWName_;
    ST_NIC_ADDR m_stnicName_;
    ST_SW_STATUS_INFO m_stSWStatusInfo_;

};

inline void swap(SYSMGR_SW_STATUS_INFO& a, SYSMGR_SW_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_SW_STATUS_INFO& sample);

class NDDSUSERDllExport SYSMGR_TIMESYNC_CMD {
  public:
    SYSMGR_TIMESYNC_CMD();

    SYSMGR_TIMESYNC_CMD(const ST_MSG_HEADER& stMsgHeader,uint16_t usCmd);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_TIMESYNC_CMD (SYSMGR_TIMESYNC_CMD&&) = default;
    SYSMGR_TIMESYNC_CMD& operator=(SYSMGR_TIMESYNC_CMD&&) = default;
    SYSMGR_TIMESYNC_CMD& operator=(const SYSMGR_TIMESYNC_CMD&) = default;
    SYSMGR_TIMESYNC_CMD(const SYSMGR_TIMESYNC_CMD&) = default;
    #else
    SYSMGR_TIMESYNC_CMD(SYSMGR_TIMESYNC_CMD&& other_) OMG_NOEXCEPT;  
    SYSMGR_TIMESYNC_CMD& operator=(SYSMGR_TIMESYNC_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usCmd() OMG_NOEXCEPT {
        return m_usCmd_;
    }

    const uint16_t& usCmd() const OMG_NOEXCEPT {
        return m_usCmd_;
    }

    void usCmd(uint16_t value) {
        m_usCmd_ = value;
    }

    bool operator == (const SYSMGR_TIMESYNC_CMD& other_) const;
    bool operator != (const SYSMGR_TIMESYNC_CMD& other_) const;

    void swap(SYSMGR_TIMESYNC_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usCmd_;

};

inline void swap(SYSMGR_TIMESYNC_CMD& a, SYSMGR_TIMESYNC_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_TIMESYNC_CMD& sample);

class NDDSUSERDllExport SYSMGR_TIMESYNC_DEV_CMD {
  public:
    SYSMGR_TIMESYNC_DEV_CMD();

    SYSMGR_TIMESYNC_DEV_CMD(const ST_MSG_HEADER& stMsgHeader,uint16_t unSync,uint16_t usType,const ::dds::core::array< uint8_t, 20L>& oIP);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_TIMESYNC_DEV_CMD (SYSMGR_TIMESYNC_DEV_CMD&&) = default;
    SYSMGR_TIMESYNC_DEV_CMD& operator=(SYSMGR_TIMESYNC_DEV_CMD&&) = default;
    SYSMGR_TIMESYNC_DEV_CMD& operator=(const SYSMGR_TIMESYNC_DEV_CMD&) = default;
    SYSMGR_TIMESYNC_DEV_CMD(const SYSMGR_TIMESYNC_DEV_CMD&) = default;
    #else
    SYSMGR_TIMESYNC_DEV_CMD(SYSMGR_TIMESYNC_DEV_CMD&& other_) OMG_NOEXCEPT;  
    SYSMGR_TIMESYNC_DEV_CMD& operator=(SYSMGR_TIMESYNC_DEV_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unSync() OMG_NOEXCEPT {
        return m_unSync_;
    }

    const uint16_t& unSync() const OMG_NOEXCEPT {
        return m_unSync_;
    }

    void unSync(uint16_t value) {
        m_unSync_ = value;
    }

    uint16_t& usType() OMG_NOEXCEPT {
        return m_usType_;
    }

    const uint16_t& usType() const OMG_NOEXCEPT {
        return m_usType_;
    }

    void usType(uint16_t value) {
        m_usType_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& oIP() OMG_NOEXCEPT {
        return m_oIP_;
    }

    const ::dds::core::array< uint8_t, 20L>& oIP() const OMG_NOEXCEPT {
        return m_oIP_;
    }

    void oIP(const ::dds::core::array< uint8_t, 20L>& value) {
        m_oIP_ = value;
    }

    void oIP(::dds::core::array< uint8_t, 20L>&& value) {
        m_oIP_ = std::move(value);
    }

    bool operator == (const SYSMGR_TIMESYNC_DEV_CMD& other_) const;
    bool operator != (const SYSMGR_TIMESYNC_DEV_CMD& other_) const;

    void swap(SYSMGR_TIMESYNC_DEV_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unSync_;
    uint16_t m_usType_;
    ::dds::core::array< uint8_t, 20L> m_oIP_;

};

inline void swap(SYSMGR_TIMESYNC_DEV_CMD& a, SYSMGR_TIMESYNC_DEV_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_TIMESYNC_DEV_CMD& sample);

class NDDSUSERDllExport SYSMGR_TIMESYNC_MODE_INFO {
  public:
    SYSMGR_TIMESYNC_MODE_INFO();

    SYSMGR_TIMESYNC_MODE_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usMode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_TIMESYNC_MODE_INFO (SYSMGR_TIMESYNC_MODE_INFO&&) = default;
    SYSMGR_TIMESYNC_MODE_INFO& operator=(SYSMGR_TIMESYNC_MODE_INFO&&) = default;
    SYSMGR_TIMESYNC_MODE_INFO& operator=(const SYSMGR_TIMESYNC_MODE_INFO&) = default;
    SYSMGR_TIMESYNC_MODE_INFO(const SYSMGR_TIMESYNC_MODE_INFO&) = default;
    #else
    SYSMGR_TIMESYNC_MODE_INFO(SYSMGR_TIMESYNC_MODE_INFO&& other_) OMG_NOEXCEPT;  
    SYSMGR_TIMESYNC_MODE_INFO& operator=(SYSMGR_TIMESYNC_MODE_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usMode() OMG_NOEXCEPT {
        return m_usMode_;
    }

    const uint16_t& usMode() const OMG_NOEXCEPT {
        return m_usMode_;
    }

    void usMode(uint16_t value) {
        m_usMode_ = value;
    }

    bool operator == (const SYSMGR_TIMESYNC_MODE_INFO& other_) const;
    bool operator != (const SYSMGR_TIMESYNC_MODE_INFO& other_) const;

    void swap(SYSMGR_TIMESYNC_MODE_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usMode_;

};

inline void swap(SYSMGR_TIMESYNC_MODE_INFO& a, SYSMGR_TIMESYNC_MODE_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_TIMESYNC_MODE_INFO& sample);

class NDDSUSERDllExport ST_USER_ACCOUNT_INFO {
  public:
    ST_USER_ACCOUNT_INFO();

    ST_USER_ACCOUNT_INFO(const ::dds::core::array< uint8_t, 32L>& oUserID,const ::dds::core::array< uint8_t, 32L>& oUserPW,const ::dds::core::array< uint8_t, 32L>& oUserName,uint8_t oUserGrade,uint8_t oUserAuthority,const ::dds::core::array< uint8_t, 2L>& oResearved,const ST_DATE_TIME& stAssignDate,const ST_DATE_TIME& stExpireDate);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_USER_ACCOUNT_INFO (ST_USER_ACCOUNT_INFO&&) = default;
    ST_USER_ACCOUNT_INFO& operator=(ST_USER_ACCOUNT_INFO&&) = default;
    ST_USER_ACCOUNT_INFO& operator=(const ST_USER_ACCOUNT_INFO&) = default;
    ST_USER_ACCOUNT_INFO(const ST_USER_ACCOUNT_INFO&) = default;
    #else
    ST_USER_ACCOUNT_INFO(ST_USER_ACCOUNT_INFO&& other_) OMG_NOEXCEPT;  
    ST_USER_ACCOUNT_INFO& operator=(ST_USER_ACCOUNT_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 32L>& oUserID() OMG_NOEXCEPT {
        return m_oUserID_;
    }

    const ::dds::core::array< uint8_t, 32L>& oUserID() const OMG_NOEXCEPT {
        return m_oUserID_;
    }

    void oUserID(const ::dds::core::array< uint8_t, 32L>& value) {
        m_oUserID_ = value;
    }

    void oUserID(::dds::core::array< uint8_t, 32L>&& value) {
        m_oUserID_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& oUserPW() OMG_NOEXCEPT {
        return m_oUserPW_;
    }

    const ::dds::core::array< uint8_t, 32L>& oUserPW() const OMG_NOEXCEPT {
        return m_oUserPW_;
    }

    void oUserPW(const ::dds::core::array< uint8_t, 32L>& value) {
        m_oUserPW_ = value;
    }

    void oUserPW(::dds::core::array< uint8_t, 32L>&& value) {
        m_oUserPW_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& oUserName() OMG_NOEXCEPT {
        return m_oUserName_;
    }

    const ::dds::core::array< uint8_t, 32L>& oUserName() const OMG_NOEXCEPT {
        return m_oUserName_;
    }

    void oUserName(const ::dds::core::array< uint8_t, 32L>& value) {
        m_oUserName_ = value;
    }

    void oUserName(::dds::core::array< uint8_t, 32L>&& value) {
        m_oUserName_ = std::move(value);
    }
    uint8_t& oUserGrade() OMG_NOEXCEPT {
        return m_oUserGrade_;
    }

    const uint8_t& oUserGrade() const OMG_NOEXCEPT {
        return m_oUserGrade_;
    }

    void oUserGrade(uint8_t value) {
        m_oUserGrade_ = value;
    }

    uint8_t& oUserAuthority() OMG_NOEXCEPT {
        return m_oUserAuthority_;
    }

    const uint8_t& oUserAuthority() const OMG_NOEXCEPT {
        return m_oUserAuthority_;
    }

    void oUserAuthority(uint8_t value) {
        m_oUserAuthority_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 2L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 2L>&& value) {
        m_oResearved_ = std::move(value);
    }
    ST_DATE_TIME& stAssignDate() OMG_NOEXCEPT {
        return m_stAssignDate_;
    }

    const ST_DATE_TIME& stAssignDate() const OMG_NOEXCEPT {
        return m_stAssignDate_;
    }

    void stAssignDate(const ST_DATE_TIME& value) {
        m_stAssignDate_ = value;
    }

    void stAssignDate(ST_DATE_TIME&& value) {
        m_stAssignDate_ = std::move(value);
    }
    ST_DATE_TIME& stExpireDate() OMG_NOEXCEPT {
        return m_stExpireDate_;
    }

    const ST_DATE_TIME& stExpireDate() const OMG_NOEXCEPT {
        return m_stExpireDate_;
    }

    void stExpireDate(const ST_DATE_TIME& value) {
        m_stExpireDate_ = value;
    }

    void stExpireDate(ST_DATE_TIME&& value) {
        m_stExpireDate_ = std::move(value);
    }

    bool operator == (const ST_USER_ACCOUNT_INFO& other_) const;
    bool operator != (const ST_USER_ACCOUNT_INFO& other_) const;

    void swap(ST_USER_ACCOUNT_INFO& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 32L> m_oUserID_;
    ::dds::core::array< uint8_t, 32L> m_oUserPW_;
    ::dds::core::array< uint8_t, 32L> m_oUserName_;
    uint8_t m_oUserGrade_;
    uint8_t m_oUserAuthority_;
    ::dds::core::array< uint8_t, 2L> m_oResearved_;
    ST_DATE_TIME m_stAssignDate_;
    ST_DATE_TIME m_stExpireDate_;

};

inline void swap(ST_USER_ACCOUNT_INFO& a, ST_USER_ACCOUNT_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_USER_ACCOUNT_INFO& sample);

class NDDSUSERDllExport SYSMGR_USER_ACCOUNT_INFO_RSP {
  public:
    SYSMGR_USER_ACCOUNT_INFO_RSP();

    SYSMGR_USER_ACCOUNT_INFO_RSP(const ST_MSG_HEADER& stMsgHeader,const ST_USER_ACCOUNT_INFO& stUserAccountInfo,uint8_t oMode,uint8_t oResult,uint8_t oStationID,uint8_t oResearved,const ::dds::core::array< uint8_t, 500L>& oMSG);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_USER_ACCOUNT_INFO_RSP (SYSMGR_USER_ACCOUNT_INFO_RSP&&) = default;
    SYSMGR_USER_ACCOUNT_INFO_RSP& operator=(SYSMGR_USER_ACCOUNT_INFO_RSP&&) = default;
    SYSMGR_USER_ACCOUNT_INFO_RSP& operator=(const SYSMGR_USER_ACCOUNT_INFO_RSP&) = default;
    SYSMGR_USER_ACCOUNT_INFO_RSP(const SYSMGR_USER_ACCOUNT_INFO_RSP&) = default;
    #else
    SYSMGR_USER_ACCOUNT_INFO_RSP(SYSMGR_USER_ACCOUNT_INFO_RSP&& other_) OMG_NOEXCEPT;  
    SYSMGR_USER_ACCOUNT_INFO_RSP& operator=(SYSMGR_USER_ACCOUNT_INFO_RSP&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_USER_ACCOUNT_INFO& stUserAccountInfo() OMG_NOEXCEPT {
        return m_stUserAccountInfo_;
    }

    const ST_USER_ACCOUNT_INFO& stUserAccountInfo() const OMG_NOEXCEPT {
        return m_stUserAccountInfo_;
    }

    void stUserAccountInfo(const ST_USER_ACCOUNT_INFO& value) {
        m_stUserAccountInfo_ = value;
    }

    void stUserAccountInfo(ST_USER_ACCOUNT_INFO&& value) {
        m_stUserAccountInfo_ = std::move(value);
    }
    uint8_t& oMode() OMG_NOEXCEPT {
        return m_oMode_;
    }

    const uint8_t& oMode() const OMG_NOEXCEPT {
        return m_oMode_;
    }

    void oMode(uint8_t value) {
        m_oMode_ = value;
    }

    uint8_t& oResult() OMG_NOEXCEPT {
        return m_oResult_;
    }

    const uint8_t& oResult() const OMG_NOEXCEPT {
        return m_oResult_;
    }

    void oResult(uint8_t value) {
        m_oResult_ = value;
    }

    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    uint8_t& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const uint8_t& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(uint8_t value) {
        m_oResearved_ = value;
    }

    ::dds::core::array< uint8_t, 500L>& oMSG() OMG_NOEXCEPT {
        return m_oMSG_;
    }

    const ::dds::core::array< uint8_t, 500L>& oMSG() const OMG_NOEXCEPT {
        return m_oMSG_;
    }

    void oMSG(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oMSG_ = value;
    }

    void oMSG(::dds::core::array< uint8_t, 500L>&& value) {
        m_oMSG_ = std::move(value);
    }

    bool operator == (const SYSMGR_USER_ACCOUNT_INFO_RSP& other_) const;
    bool operator != (const SYSMGR_USER_ACCOUNT_INFO_RSP& other_) const;

    void swap(SYSMGR_USER_ACCOUNT_INFO_RSP& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_USER_ACCOUNT_INFO m_stUserAccountInfo_;
    uint8_t m_oMode_;
    uint8_t m_oResult_;
    uint8_t m_oStationID_;
    uint8_t m_oResearved_;
    ::dds::core::array< uint8_t, 500L> m_oMSG_;

};

inline void swap(SYSMGR_USER_ACCOUNT_INFO_RSP& a, SYSMGR_USER_ACCOUNT_INFO_RSP& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_USER_ACCOUNT_INFO_RSP& sample);

class NDDSUSERDllExport ST_USER_ACCOUNT_LIST_INFO {
  public:
    ST_USER_ACCOUNT_LIST_INFO();

    ST_USER_ACCOUNT_LIST_INFO(const ST_USER_ACCOUNT_INFO& stUserAccountInfo,bool bEnable,const ::dds::core::array< uint8_t, 3L>& oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_USER_ACCOUNT_LIST_INFO (ST_USER_ACCOUNT_LIST_INFO&&) = default;
    ST_USER_ACCOUNT_LIST_INFO& operator=(ST_USER_ACCOUNT_LIST_INFO&&) = default;
    ST_USER_ACCOUNT_LIST_INFO& operator=(const ST_USER_ACCOUNT_LIST_INFO&) = default;
    ST_USER_ACCOUNT_LIST_INFO(const ST_USER_ACCOUNT_LIST_INFO&) = default;
    #else
    ST_USER_ACCOUNT_LIST_INFO(ST_USER_ACCOUNT_LIST_INFO&& other_) OMG_NOEXCEPT;  
    ST_USER_ACCOUNT_LIST_INFO& operator=(ST_USER_ACCOUNT_LIST_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_USER_ACCOUNT_INFO& stUserAccountInfo() OMG_NOEXCEPT {
        return m_stUserAccountInfo_;
    }

    const ST_USER_ACCOUNT_INFO& stUserAccountInfo() const OMG_NOEXCEPT {
        return m_stUserAccountInfo_;
    }

    void stUserAccountInfo(const ST_USER_ACCOUNT_INFO& value) {
        m_stUserAccountInfo_ = value;
    }

    void stUserAccountInfo(ST_USER_ACCOUNT_INFO&& value) {
        m_stUserAccountInfo_ = std::move(value);
    }
    bool& bEnable() OMG_NOEXCEPT {
        return m_bEnable_;
    }

    const bool& bEnable() const OMG_NOEXCEPT {
        return m_bEnable_;
    }

    void bEnable(bool value) {
        m_bEnable_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oResearved_ = std::move(value);
    }

    bool operator == (const ST_USER_ACCOUNT_LIST_INFO& other_) const;
    bool operator != (const ST_USER_ACCOUNT_LIST_INFO& other_) const;

    void swap(ST_USER_ACCOUNT_LIST_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_USER_ACCOUNT_INFO m_stUserAccountInfo_;
    bool m_bEnable_;
    ::dds::core::array< uint8_t, 3L> m_oResearved_;

};

inline void swap(ST_USER_ACCOUNT_LIST_INFO& a, ST_USER_ACCOUNT_LIST_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_USER_ACCOUNT_LIST_INFO& sample);

class NDDSUSERDllExport SYSMGR_USER_ACCOUNT_LIST_RSP {
  public:
    SYSMGR_USER_ACCOUNT_LIST_RSP();

    SYSMGR_USER_ACCOUNT_LIST_RSP(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_USER_ACCOUNT_LIST_INFO, 50L>& stUserAccountListInfo,uint8_t oStationID,const ::dds::core::array< uint8_t, 3L>& oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_USER_ACCOUNT_LIST_RSP (SYSMGR_USER_ACCOUNT_LIST_RSP&&) = default;
    SYSMGR_USER_ACCOUNT_LIST_RSP& operator=(SYSMGR_USER_ACCOUNT_LIST_RSP&&) = default;
    SYSMGR_USER_ACCOUNT_LIST_RSP& operator=(const SYSMGR_USER_ACCOUNT_LIST_RSP&) = default;
    SYSMGR_USER_ACCOUNT_LIST_RSP(const SYSMGR_USER_ACCOUNT_LIST_RSP&) = default;
    #else
    SYSMGR_USER_ACCOUNT_LIST_RSP(SYSMGR_USER_ACCOUNT_LIST_RSP&& other_) OMG_NOEXCEPT;  
    SYSMGR_USER_ACCOUNT_LIST_RSP& operator=(SYSMGR_USER_ACCOUNT_LIST_RSP&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_USER_ACCOUNT_LIST_INFO, 50L>& stUserAccountListInfo() OMG_NOEXCEPT {
        return m_stUserAccountListInfo_;
    }

    const ::dds::core::array< ST_USER_ACCOUNT_LIST_INFO, 50L>& stUserAccountListInfo() const OMG_NOEXCEPT {
        return m_stUserAccountListInfo_;
    }

    void stUserAccountListInfo(const ::dds::core::array< ST_USER_ACCOUNT_LIST_INFO, 50L>& value) {
        m_stUserAccountListInfo_ = value;
    }

    void stUserAccountListInfo(::dds::core::array< ST_USER_ACCOUNT_LIST_INFO, 50L>&& value) {
        m_stUserAccountListInfo_ = std::move(value);
    }
    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oResearved_ = std::move(value);
    }

    bool operator == (const SYSMGR_USER_ACCOUNT_LIST_RSP& other_) const;
    bool operator != (const SYSMGR_USER_ACCOUNT_LIST_RSP& other_) const;

    void swap(SYSMGR_USER_ACCOUNT_LIST_RSP& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_USER_ACCOUNT_LIST_INFO, 50L> m_stUserAccountListInfo_;
    uint8_t m_oStationID_;
    ::dds::core::array< uint8_t, 3L> m_oResearved_;

};

inline void swap(SYSMGR_USER_ACCOUNT_LIST_RSP& a, SYSMGR_USER_ACCOUNT_LIST_RSP& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_USER_ACCOUNT_LIST_RSP& sample);

class NDDSUSERDllExport ST_USER_ACCOUNT_LOG_INFO {
  public:
    ST_USER_ACCOUNT_LOG_INFO();

    ST_USER_ACCOUNT_LOG_INFO(const ::dds::core::array< uint8_t, 32L>& oUserID,const ::dds::core::array< uint8_t, 32L>& oUserName,const ST_DATE_TIME& stLogDate,const ::dds::core::array< uint8_t, 200L>& oMSG);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_USER_ACCOUNT_LOG_INFO (ST_USER_ACCOUNT_LOG_INFO&&) = default;
    ST_USER_ACCOUNT_LOG_INFO& operator=(ST_USER_ACCOUNT_LOG_INFO&&) = default;
    ST_USER_ACCOUNT_LOG_INFO& operator=(const ST_USER_ACCOUNT_LOG_INFO&) = default;
    ST_USER_ACCOUNT_LOG_INFO(const ST_USER_ACCOUNT_LOG_INFO&) = default;
    #else
    ST_USER_ACCOUNT_LOG_INFO(ST_USER_ACCOUNT_LOG_INFO&& other_) OMG_NOEXCEPT;  
    ST_USER_ACCOUNT_LOG_INFO& operator=(ST_USER_ACCOUNT_LOG_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< uint8_t, 32L>& oUserID() OMG_NOEXCEPT {
        return m_oUserID_;
    }

    const ::dds::core::array< uint8_t, 32L>& oUserID() const OMG_NOEXCEPT {
        return m_oUserID_;
    }

    void oUserID(const ::dds::core::array< uint8_t, 32L>& value) {
        m_oUserID_ = value;
    }

    void oUserID(::dds::core::array< uint8_t, 32L>&& value) {
        m_oUserID_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& oUserName() OMG_NOEXCEPT {
        return m_oUserName_;
    }

    const ::dds::core::array< uint8_t, 32L>& oUserName() const OMG_NOEXCEPT {
        return m_oUserName_;
    }

    void oUserName(const ::dds::core::array< uint8_t, 32L>& value) {
        m_oUserName_ = value;
    }

    void oUserName(::dds::core::array< uint8_t, 32L>&& value) {
        m_oUserName_ = std::move(value);
    }
    ST_DATE_TIME& stLogDate() OMG_NOEXCEPT {
        return m_stLogDate_;
    }

    const ST_DATE_TIME& stLogDate() const OMG_NOEXCEPT {
        return m_stLogDate_;
    }

    void stLogDate(const ST_DATE_TIME& value) {
        m_stLogDate_ = value;
    }

    void stLogDate(ST_DATE_TIME&& value) {
        m_stLogDate_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 200L>& oMSG() OMG_NOEXCEPT {
        return m_oMSG_;
    }

    const ::dds::core::array< uint8_t, 200L>& oMSG() const OMG_NOEXCEPT {
        return m_oMSG_;
    }

    void oMSG(const ::dds::core::array< uint8_t, 200L>& value) {
        m_oMSG_ = value;
    }

    void oMSG(::dds::core::array< uint8_t, 200L>&& value) {
        m_oMSG_ = std::move(value);
    }

    bool operator == (const ST_USER_ACCOUNT_LOG_INFO& other_) const;
    bool operator != (const ST_USER_ACCOUNT_LOG_INFO& other_) const;

    void swap(ST_USER_ACCOUNT_LOG_INFO& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< uint8_t, 32L> m_oUserID_;
    ::dds::core::array< uint8_t, 32L> m_oUserName_;
    ST_DATE_TIME m_stLogDate_;
    ::dds::core::array< uint8_t, 200L> m_oMSG_;

};

inline void swap(ST_USER_ACCOUNT_LOG_INFO& a, ST_USER_ACCOUNT_LOG_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_USER_ACCOUNT_LOG_INFO& sample);

class NDDSUSERDllExport SYSMGR_USER_ACCOUNT_LOG_RSP {
  public:
    SYSMGR_USER_ACCOUNT_LOG_RSP();

    SYSMGR_USER_ACCOUNT_LOG_RSP(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_USER_ACCOUNT_LOG_INFO, 100L>& stUserAccountLogInfo,uint16_t unTotalPageNum,uint16_t unCurrentPageNum,uint8_t oStationID,const ::dds::core::array< uint8_t, 3L>& oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_USER_ACCOUNT_LOG_RSP (SYSMGR_USER_ACCOUNT_LOG_RSP&&) = default;
    SYSMGR_USER_ACCOUNT_LOG_RSP& operator=(SYSMGR_USER_ACCOUNT_LOG_RSP&&) = default;
    SYSMGR_USER_ACCOUNT_LOG_RSP& operator=(const SYSMGR_USER_ACCOUNT_LOG_RSP&) = default;
    SYSMGR_USER_ACCOUNT_LOG_RSP(const SYSMGR_USER_ACCOUNT_LOG_RSP&) = default;
    #else
    SYSMGR_USER_ACCOUNT_LOG_RSP(SYSMGR_USER_ACCOUNT_LOG_RSP&& other_) OMG_NOEXCEPT;  
    SYSMGR_USER_ACCOUNT_LOG_RSP& operator=(SYSMGR_USER_ACCOUNT_LOG_RSP&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_USER_ACCOUNT_LOG_INFO, 100L>& stUserAccountLogInfo() OMG_NOEXCEPT {
        return m_stUserAccountLogInfo_;
    }

    const ::dds::core::array< ST_USER_ACCOUNT_LOG_INFO, 100L>& stUserAccountLogInfo() const OMG_NOEXCEPT {
        return m_stUserAccountLogInfo_;
    }

    void stUserAccountLogInfo(const ::dds::core::array< ST_USER_ACCOUNT_LOG_INFO, 100L>& value) {
        m_stUserAccountLogInfo_ = value;
    }

    void stUserAccountLogInfo(::dds::core::array< ST_USER_ACCOUNT_LOG_INFO, 100L>&& value) {
        m_stUserAccountLogInfo_ = std::move(value);
    }
    uint16_t& unTotalPageNum() OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    const uint16_t& unTotalPageNum() const OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    void unTotalPageNum(uint16_t value) {
        m_unTotalPageNum_ = value;
    }

    uint16_t& unCurrentPageNum() OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    const uint16_t& unCurrentPageNum() const OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    void unCurrentPageNum(uint16_t value) {
        m_unCurrentPageNum_ = value;
    }

    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oResearved_ = std::move(value);
    }

    bool operator == (const SYSMGR_USER_ACCOUNT_LOG_RSP& other_) const;
    bool operator != (const SYSMGR_USER_ACCOUNT_LOG_RSP& other_) const;

    void swap(SYSMGR_USER_ACCOUNT_LOG_RSP& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_USER_ACCOUNT_LOG_INFO, 100L> m_stUserAccountLogInfo_;
    uint16_t m_unTotalPageNum_;
    uint16_t m_unCurrentPageNum_;
    uint8_t m_oStationID_;
    ::dds::core::array< uint8_t, 3L> m_oResearved_;

};

inline void swap(SYSMGR_USER_ACCOUNT_LOG_RSP& a, SYSMGR_USER_ACCOUNT_LOG_RSP& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_USER_ACCOUNT_LOG_RSP& sample);

class NDDSUSERDllExport SYSMGR_USER_REALLOCATION_RSP {
  public:
    SYSMGR_USER_REALLOCATION_RSP();

    SYSMGR_USER_REALLOCATION_RSP(const ST_MSG_HEADER& stMsgHeader,uint16_t usSrcHWID,uint16_t usDesHWID,int32_t lResult,const ::dds::core::array< uint8_t, 500L>& oMSG);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    SYSMGR_USER_REALLOCATION_RSP (SYSMGR_USER_REALLOCATION_RSP&&) = default;
    SYSMGR_USER_REALLOCATION_RSP& operator=(SYSMGR_USER_REALLOCATION_RSP&&) = default;
    SYSMGR_USER_REALLOCATION_RSP& operator=(const SYSMGR_USER_REALLOCATION_RSP&) = default;
    SYSMGR_USER_REALLOCATION_RSP(const SYSMGR_USER_REALLOCATION_RSP&) = default;
    #else
    SYSMGR_USER_REALLOCATION_RSP(SYSMGR_USER_REALLOCATION_RSP&& other_) OMG_NOEXCEPT;  
    SYSMGR_USER_REALLOCATION_RSP& operator=(SYSMGR_USER_REALLOCATION_RSP&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSrcHWID() OMG_NOEXCEPT {
        return m_usSrcHWID_;
    }

    const uint16_t& usSrcHWID() const OMG_NOEXCEPT {
        return m_usSrcHWID_;
    }

    void usSrcHWID(uint16_t value) {
        m_usSrcHWID_ = value;
    }

    uint16_t& usDesHWID() OMG_NOEXCEPT {
        return m_usDesHWID_;
    }

    const uint16_t& usDesHWID() const OMG_NOEXCEPT {
        return m_usDesHWID_;
    }

    void usDesHWID(uint16_t value) {
        m_usDesHWID_ = value;
    }

    int32_t& lResult() OMG_NOEXCEPT {
        return m_lResult_;
    }

    const int32_t& lResult() const OMG_NOEXCEPT {
        return m_lResult_;
    }

    void lResult(int32_t value) {
        m_lResult_ = value;
    }

    ::dds::core::array< uint8_t, 500L>& oMSG() OMG_NOEXCEPT {
        return m_oMSG_;
    }

    const ::dds::core::array< uint8_t, 500L>& oMSG() const OMG_NOEXCEPT {
        return m_oMSG_;
    }

    void oMSG(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oMSG_ = value;
    }

    void oMSG(::dds::core::array< uint8_t, 500L>&& value) {
        m_oMSG_ = std::move(value);
    }

    bool operator == (const SYSMGR_USER_REALLOCATION_RSP& other_) const;
    bool operator != (const SYSMGR_USER_REALLOCATION_RSP& other_) const;

    void swap(SYSMGR_USER_REALLOCATION_RSP& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSrcHWID_;
    uint16_t m_usDesHWID_;
    int32_t m_lResult_;
    ::dds::core::array< uint8_t, 500L> m_oMSG_;

};

inline void swap(SYSMGR_USER_REALLOCATION_RSP& a, SYSMGR_USER_REALLOCATION_RSP& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const SYSMGR_USER_REALLOCATION_RSP& sample);

class NDDSUSERDllExport TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT {
  public:
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT();

    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t usGlobalTargetNum,const ST_DATE_TIME& stReqTime,const ST_DATE_TIME& stSendTime,uint16_t usClaRetNum,uint16_t usSensorID,const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAInfo,uint16_t usLOFARFrameNum,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram,uint16_t usDEMONFrameNum,const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram,const ST_FEATURE_FREQ_INFO& stFeatureInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT (TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT&&) = default;
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& operator=(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT&&) = default;
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& operator=(const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT&) = default;
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT(const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT&) = default;
    #else
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT&& other_) OMG_NOEXCEPT;  
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& operator=(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usGlobalTargetNum() OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    const uint16_t& usGlobalTargetNum() const OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    void usGlobalTargetNum(uint16_t value) {
        m_usGlobalTargetNum_ = value;
    }

    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    ST_DATE_TIME& stSendTime() OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    const ST_DATE_TIME& stSendTime() const OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    void stSendTime(const ST_DATE_TIME& value) {
        m_stSendTime_ = value;
    }

    void stSendTime(ST_DATE_TIME&& value) {
        m_stSendTime_ = std::move(value);
    }
    uint16_t& usClaRetNum() OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    const uint16_t& usClaRetNum() const OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    void usClaRetNum(uint16_t value) {
        m_usClaRetNum_ = value;
    }

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAInfo() OMG_NOEXCEPT {
        return m_stCLAInfo_;
    }

    const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAInfo() const OMG_NOEXCEPT {
        return m_stCLAInfo_;
    }

    void stCLAInfo(const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& value) {
        m_stCLAInfo_ = value;
    }

    void stCLAInfo(::dds::core::array< ST_CLA_RESULT_INFO, 8L>&& value) {
        m_stCLAInfo_ = std::move(value);
    }
    uint16_t& usLOFARFrameNum() OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    const uint16_t& usLOFARFrameNum() const OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    void usLOFARFrameNum(uint16_t value) {
        m_usLOFARFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() const OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    void fLOFARGram(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& value) {
        m_fLOFARGram_ = value;
    }

    void fLOFARGram(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>&& value) {
        m_fLOFARGram_ = std::move(value);
    }
    uint16_t& usDEMONFrameNum() OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    const uint16_t& usDEMONFrameNum() const OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    void usDEMONFrameNum(uint16_t value) {
        m_usDEMONFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() const OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    void fDEMONGram(const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& value) {
        m_fDEMONGram_ = value;
    }

    void fDEMONGram(::dds::core::array< ::dds::core::array< float, 1601L>, 300L>&& value) {
        m_fDEMONGram_ = std::move(value);
    }
    ST_FEATURE_FREQ_INFO& stFeatureInfo() OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    const ST_FEATURE_FREQ_INFO& stFeatureInfo() const OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    void stFeatureInfo(const ST_FEATURE_FREQ_INFO& value) {
        m_stFeatureInfo_ = value;
    }

    void stFeatureInfo(ST_FEATURE_FREQ_INFO&& value) {
        m_stFeatureInfo_ = std::move(value);
    }

    bool operator == (const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& other_) const;
    bool operator != (const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& other_) const;

    void swap(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usGlobalTargetNum_;
    ST_DATE_TIME m_stReqTime_;
    ST_DATE_TIME m_stSendTime_;
    uint16_t m_usClaRetNum_;
    uint16_t m_usSensorID_;
    ::dds::core::array< ST_CLA_RESULT_INFO, 8L> m_stCLAInfo_;
    uint16_t m_usLOFARFrameNum_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L> m_fLOFARGram_;
    uint16_t m_usDEMONFrameNum_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L> m_fDEMONGram_;
    ST_FEATURE_FREQ_INFO m_stFeatureInfo_;

};

inline void swap(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& a, TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& sample);

class NDDSUSERDllExport TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT {
  public:
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT();

    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t usGlobalTargetNum,const ST_DATE_TIME& stReqTime,const ST_DATE_TIME& stSendTime,uint16_t usClaRetNum,const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT (TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT&&) = default;
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& operator=(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT&&) = default;
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& operator=(const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT&) = default;
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT(const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT&) = default;
    #else
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT&& other_) OMG_NOEXCEPT;  
    TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& operator=(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usGlobalTargetNum() OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    const uint16_t& usGlobalTargetNum() const OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    void usGlobalTargetNum(uint16_t value) {
        m_usGlobalTargetNum_ = value;
    }

    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    ST_DATE_TIME& stSendTime() OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    const ST_DATE_TIME& stSendTime() const OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    void stSendTime(const ST_DATE_TIME& value) {
        m_stSendTime_ = value;
    }

    void stSendTime(ST_DATE_TIME&& value) {
        m_stSendTime_ = std::move(value);
    }
    uint16_t& usClaRetNum() OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    const uint16_t& usClaRetNum() const OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    void usClaRetNum(uint16_t value) {
        m_usClaRetNum_ = value;
    }

    ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAInfo() OMG_NOEXCEPT {
        return m_stCLAInfo_;
    }

    const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLAInfo() const OMG_NOEXCEPT {
        return m_stCLAInfo_;
    }

    void stCLAInfo(const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& value) {
        m_stCLAInfo_ = value;
    }

    void stCLAInfo(::dds::core::array< ST_CLA_RESULT_INFO, 8L>&& value) {
        m_stCLAInfo_ = std::move(value);
    }

    bool operator == (const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& other_) const;
    bool operator != (const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& other_) const;

    void swap(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usGlobalTargetNum_;
    ST_DATE_TIME m_stReqTime_;
    ST_DATE_TIME m_stSendTime_;
    uint16_t m_usClaRetNum_;
    ::dds::core::array< ST_CLA_RESULT_INFO, 8L> m_stCLAInfo_;

};

inline void swap(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& a, TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& sample);

class NDDSUSERDllExport TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT {
  public:
    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT();

    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oDBBackupRestoreResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT (TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT&&) = default;
    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& operator=(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT&&) = default;
    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& operator=(const TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT&) = default;
    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT(const TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT&) = default;
    #else
    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT&& other_) OMG_NOEXCEPT;  
    TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& operator=(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oDBBackupRestoreResult() OMG_NOEXCEPT {
        return m_oDBBackupRestoreResult_;
    }

    const uint8_t& oDBBackupRestoreResult() const OMG_NOEXCEPT {
        return m_oDBBackupRestoreResult_;
    }

    void oDBBackupRestoreResult(uint8_t value) {
        m_oDBBackupRestoreResult_ = value;
    }

    bool operator == (const TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& other_) const;
    bool operator != (const TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& other_) const;

    void swap(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oDBBackupRestoreResult_;

};

inline void swap(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& a, TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& sample);

class NDDSUSERDllExport TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT {
  public:
    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT();

    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT(const ST_MSG_HEADER& stMsgHeader,const ST_DATE_TIME& stReqTime,const ST_DATE_TIME& stSendTime,uint16_t usClaRetNum,const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLARet);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT (TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT&&) = default;
    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& operator=(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT&&) = default;
    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& operator=(const TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT&) = default;
    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT(const TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT&) = default;
    #else
    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT&& other_) OMG_NOEXCEPT;  
    TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& operator=(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    ST_DATE_TIME& stSendTime() OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    const ST_DATE_TIME& stSendTime() const OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    void stSendTime(const ST_DATE_TIME& value) {
        m_stSendTime_ = value;
    }

    void stSendTime(ST_DATE_TIME&& value) {
        m_stSendTime_ = std::move(value);
    }
    uint16_t& usClaRetNum() OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    const uint16_t& usClaRetNum() const OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    void usClaRetNum(uint16_t value) {
        m_usClaRetNum_ = value;
    }

    ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLARet() OMG_NOEXCEPT {
        return m_stCLARet_;
    }

    const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stCLARet() const OMG_NOEXCEPT {
        return m_stCLARet_;
    }

    void stCLARet(const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& value) {
        m_stCLARet_ = value;
    }

    void stCLARet(::dds::core::array< ST_CLA_RESULT_INFO, 8L>&& value) {
        m_stCLARet_ = std::move(value);
    }

    bool operator == (const TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& other_) const;
    bool operator != (const TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& other_) const;

    void swap(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_DATE_TIME m_stReqTime_;
    ST_DATE_TIME m_stSendTime_;
    uint16_t m_usClaRetNum_;
    ::dds::core::array< ST_CLA_RESULT_INFO, 8L> m_stCLARet_;

};

inline void swap(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& a, TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& sample);

class NDDSUSERDllExport TGTCLA_OI_CLASSIFICATION_FREQ_INFO {
  public:
    TGTCLA_OI_CLASSIFICATION_FREQ_INFO();

    TGTCLA_OI_CLASSIFICATION_FREQ_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_FEATURE_FREQ_INFO& stFeatureInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTCLA_OI_CLASSIFICATION_FREQ_INFO (TGTCLA_OI_CLASSIFICATION_FREQ_INFO&&) = default;
    TGTCLA_OI_CLASSIFICATION_FREQ_INFO& operator=(TGTCLA_OI_CLASSIFICATION_FREQ_INFO&&) = default;
    TGTCLA_OI_CLASSIFICATION_FREQ_INFO& operator=(const TGTCLA_OI_CLASSIFICATION_FREQ_INFO&) = default;
    TGTCLA_OI_CLASSIFICATION_FREQ_INFO(const TGTCLA_OI_CLASSIFICATION_FREQ_INFO&) = default;
    #else
    TGTCLA_OI_CLASSIFICATION_FREQ_INFO(TGTCLA_OI_CLASSIFICATION_FREQ_INFO&& other_) OMG_NOEXCEPT;  
    TGTCLA_OI_CLASSIFICATION_FREQ_INFO& operator=(TGTCLA_OI_CLASSIFICATION_FREQ_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_FEATURE_FREQ_INFO& stFeatureInfo() OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    const ST_FEATURE_FREQ_INFO& stFeatureInfo() const OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    void stFeatureInfo(const ST_FEATURE_FREQ_INFO& value) {
        m_stFeatureInfo_ = value;
    }

    void stFeatureInfo(ST_FEATURE_FREQ_INFO&& value) {
        m_stFeatureInfo_ = std::move(value);
    }

    bool operator == (const TGTCLA_OI_CLASSIFICATION_FREQ_INFO& other_) const;
    bool operator != (const TGTCLA_OI_CLASSIFICATION_FREQ_INFO& other_) const;

    void swap(TGTCLA_OI_CLASSIFICATION_FREQ_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_FEATURE_FREQ_INFO m_stFeatureInfo_;

};

inline void swap(TGTCLA_OI_CLASSIFICATION_FREQ_INFO& a, TGTCLA_OI_CLASSIFICATION_FREQ_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTCLA_OI_CLASSIFICATION_FREQ_INFO& sample);

class NDDSUSERDllExport TGTCLA_STANDARD_CLA_DB_INFO_RESULT {
  public:
    TGTCLA_STANDARD_CLA_DB_INFO_RESULT();

    TGTCLA_STANDARD_CLA_DB_INFO_RESULT(const ST_MSG_HEADER& stMsgHeader,uint8_t oDBInterfaceResult,const ::dds::core::array< char, 240L>& acDBInterfaceLog);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTCLA_STANDARD_CLA_DB_INFO_RESULT (TGTCLA_STANDARD_CLA_DB_INFO_RESULT&&) = default;
    TGTCLA_STANDARD_CLA_DB_INFO_RESULT& operator=(TGTCLA_STANDARD_CLA_DB_INFO_RESULT&&) = default;
    TGTCLA_STANDARD_CLA_DB_INFO_RESULT& operator=(const TGTCLA_STANDARD_CLA_DB_INFO_RESULT&) = default;
    TGTCLA_STANDARD_CLA_DB_INFO_RESULT(const TGTCLA_STANDARD_CLA_DB_INFO_RESULT&) = default;
    #else
    TGTCLA_STANDARD_CLA_DB_INFO_RESULT(TGTCLA_STANDARD_CLA_DB_INFO_RESULT&& other_) OMG_NOEXCEPT;  
    TGTCLA_STANDARD_CLA_DB_INFO_RESULT& operator=(TGTCLA_STANDARD_CLA_DB_INFO_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oDBInterfaceResult() OMG_NOEXCEPT {
        return m_oDBInterfaceResult_;
    }

    const uint8_t& oDBInterfaceResult() const OMG_NOEXCEPT {
        return m_oDBInterfaceResult_;
    }

    void oDBInterfaceResult(uint8_t value) {
        m_oDBInterfaceResult_ = value;
    }

    ::dds::core::array< char, 240L>& acDBInterfaceLog() OMG_NOEXCEPT {
        return m_acDBInterfaceLog_;
    }

    const ::dds::core::array< char, 240L>& acDBInterfaceLog() const OMG_NOEXCEPT {
        return m_acDBInterfaceLog_;
    }

    void acDBInterfaceLog(const ::dds::core::array< char, 240L>& value) {
        m_acDBInterfaceLog_ = value;
    }

    void acDBInterfaceLog(::dds::core::array< char, 240L>&& value) {
        m_acDBInterfaceLog_ = std::move(value);
    }

    bool operator == (const TGTCLA_STANDARD_CLA_DB_INFO_RESULT& other_) const;
    bool operator != (const TGTCLA_STANDARD_CLA_DB_INFO_RESULT& other_) const;

    void swap(TGTCLA_STANDARD_CLA_DB_INFO_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oDBInterfaceResult_;
    ::dds::core::array< char, 240L> m_acDBInterfaceLog_;

};

inline void swap(TGTCLA_STANDARD_CLA_DB_INFO_RESULT& a, TGTCLA_STANDARD_CLA_DB_INFO_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTCLA_STANDARD_CLA_DB_INFO_RESULT& sample);

class NDDSUSERDllExport ST_FUSED_GLOBAL_TARGET {
  public:
    ST_FUSED_GLOBAL_TARGET();

    ST_FUSED_GLOBAL_TARGET(uint8_t oFusionProcessed,uint8_t oUsedSensorForAssociation,uint16_t usTgtNumber,uint16_t usTrackStatus,uint8_t oLOFARTonalFreqCnt,const ::dds::core::array< float, 24L>& aLOFARTonalFreq,const ::dds::core::array< uint8_t, 24L>& aIsThreatFreq,uint8_t oDEMONTonalFreqCnt,const ::dds::core::array< float, 8L>& aDEMONTonalFreq,uint8_t oInOutInfo,const ::dds::core::array< float, 4L>& aStateVector,const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aMatP,uint8_t oNoOfAssociatedSensors,const ::dds::core::array< uint8_t, 32L>& aAssociatedSensors,const ::dds::core::array< uint32_t, 32L>& aAssociatedLocalTgtID,uint8_t oOriginSensorID,const ::dds::core::array< uint16_t, 2L>& aTrackReliability,bool bIsRegisteredByManual,uint8_t oTargetType,uint8_t oRefSensorIDForBearingTgt,float fAzimuthForBearingTgt,uint8_t oAssociatedStatus,uint16_t usAssociatedMasterTgtID,uint8_t oNoOfAssociatedSystemTgts,const ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID,uint8_t oAssociationReliability,const ST_DATE_TIME& stAssociationTime,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_FUSED_GLOBAL_TARGET (ST_FUSED_GLOBAL_TARGET&&) = default;
    ST_FUSED_GLOBAL_TARGET& operator=(ST_FUSED_GLOBAL_TARGET&&) = default;
    ST_FUSED_GLOBAL_TARGET& operator=(const ST_FUSED_GLOBAL_TARGET&) = default;
    ST_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_FUSED_GLOBAL_TARGET(ST_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_FUSED_GLOBAL_TARGET& operator=(ST_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oFusionProcessed() OMG_NOEXCEPT {
        return m_oFusionProcessed_;
    }

    const uint8_t& oFusionProcessed() const OMG_NOEXCEPT {
        return m_oFusionProcessed_;
    }

    void oFusionProcessed(uint8_t value) {
        m_oFusionProcessed_ = value;
    }

    uint8_t& oUsedSensorForAssociation() OMG_NOEXCEPT {
        return m_oUsedSensorForAssociation_;
    }

    const uint8_t& oUsedSensorForAssociation() const OMG_NOEXCEPT {
        return m_oUsedSensorForAssociation_;
    }

    void oUsedSensorForAssociation(uint8_t value) {
        m_oUsedSensorForAssociation_ = value;
    }

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    uint16_t& usTrackStatus() OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    const uint16_t& usTrackStatus() const OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    void usTrackStatus(uint16_t value) {
        m_usTrackStatus_ = value;
    }

    uint8_t& oLOFARTonalFreqCnt() OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    const uint8_t& oLOFARTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    void oLOFARTonalFreqCnt(uint8_t value) {
        m_oLOFARTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aLOFARTonalFreq() OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    const ::dds::core::array< float, 24L>& aLOFARTonalFreq() const OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    void aLOFARTonalFreq(const ::dds::core::array< float, 24L>& value) {
        m_aLOFARTonalFreq_ = value;
    }

    void aLOFARTonalFreq(::dds::core::array< float, 24L>&& value) {
        m_aLOFARTonalFreq_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 24L>& aIsThreatFreq() OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    const ::dds::core::array< uint8_t, 24L>& aIsThreatFreq() const OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    void aIsThreatFreq(const ::dds::core::array< uint8_t, 24L>& value) {
        m_aIsThreatFreq_ = value;
    }

    void aIsThreatFreq(::dds::core::array< uint8_t, 24L>&& value) {
        m_aIsThreatFreq_ = std::move(value);
    }
    uint8_t& oDEMONTonalFreqCnt() OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    const uint8_t& oDEMONTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    void oDEMONTonalFreqCnt(uint8_t value) {
        m_oDEMONTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 8L>& aDEMONTonalFreq() OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    const ::dds::core::array< float, 8L>& aDEMONTonalFreq() const OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    void aDEMONTonalFreq(const ::dds::core::array< float, 8L>& value) {
        m_aDEMONTonalFreq_ = value;
    }

    void aDEMONTonalFreq(::dds::core::array< float, 8L>&& value) {
        m_aDEMONTonalFreq_ = std::move(value);
    }
    uint8_t& oInOutInfo() OMG_NOEXCEPT {
        return m_oInOutInfo_;
    }

    const uint8_t& oInOutInfo() const OMG_NOEXCEPT {
        return m_oInOutInfo_;
    }

    void oInOutInfo(uint8_t value) {
        m_oInOutInfo_ = value;
    }

    ::dds::core::array< float, 4L>& aStateVector() OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    const ::dds::core::array< float, 4L>& aStateVector() const OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    void aStateVector(const ::dds::core::array< float, 4L>& value) {
        m_aStateVector_ = value;
    }

    void aStateVector(::dds::core::array< float, 4L>&& value) {
        m_aStateVector_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aMatP() OMG_NOEXCEPT {
        return m_aMatP_;
    }

    const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aMatP() const OMG_NOEXCEPT {
        return m_aMatP_;
    }

    void aMatP(const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& value) {
        m_aMatP_ = value;
    }

    void aMatP(::dds::core::array< ::dds::core::array< float, 4L>, 4L>&& value) {
        m_aMatP_ = std::move(value);
    }
    uint8_t& oNoOfAssociatedSensors() OMG_NOEXCEPT {
        return m_oNoOfAssociatedSensors_;
    }

    const uint8_t& oNoOfAssociatedSensors() const OMG_NOEXCEPT {
        return m_oNoOfAssociatedSensors_;
    }

    void oNoOfAssociatedSensors(uint8_t value) {
        m_oNoOfAssociatedSensors_ = value;
    }

    ::dds::core::array< uint8_t, 32L>& aAssociatedSensors() OMG_NOEXCEPT {
        return m_aAssociatedSensors_;
    }

    const ::dds::core::array< uint8_t, 32L>& aAssociatedSensors() const OMG_NOEXCEPT {
        return m_aAssociatedSensors_;
    }

    void aAssociatedSensors(const ::dds::core::array< uint8_t, 32L>& value) {
        m_aAssociatedSensors_ = value;
    }

    void aAssociatedSensors(::dds::core::array< uint8_t, 32L>&& value) {
        m_aAssociatedSensors_ = std::move(value);
    }
    ::dds::core::array< uint32_t, 32L>& aAssociatedLocalTgtID() OMG_NOEXCEPT {
        return m_aAssociatedLocalTgtID_;
    }

    const ::dds::core::array< uint32_t, 32L>& aAssociatedLocalTgtID() const OMG_NOEXCEPT {
        return m_aAssociatedLocalTgtID_;
    }

    void aAssociatedLocalTgtID(const ::dds::core::array< uint32_t, 32L>& value) {
        m_aAssociatedLocalTgtID_ = value;
    }

    void aAssociatedLocalTgtID(::dds::core::array< uint32_t, 32L>&& value) {
        m_aAssociatedLocalTgtID_ = std::move(value);
    }
    uint8_t& oOriginSensorID() OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    const uint8_t& oOriginSensorID() const OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    void oOriginSensorID(uint8_t value) {
        m_oOriginSensorID_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aTrackReliability() OMG_NOEXCEPT {
        return m_aTrackReliability_;
    }

    const ::dds::core::array< uint16_t, 2L>& aTrackReliability() const OMG_NOEXCEPT {
        return m_aTrackReliability_;
    }

    void aTrackReliability(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aTrackReliability_ = value;
    }

    void aTrackReliability(::dds::core::array< uint16_t, 2L>&& value) {
        m_aTrackReliability_ = std::move(value);
    }
    bool& bIsRegisteredByManual() OMG_NOEXCEPT {
        return m_bIsRegisteredByManual_;
    }

    const bool& bIsRegisteredByManual() const OMG_NOEXCEPT {
        return m_bIsRegisteredByManual_;
    }

    void bIsRegisteredByManual(bool value) {
        m_bIsRegisteredByManual_ = value;
    }

    uint8_t& oTargetType() OMG_NOEXCEPT {
        return m_oTargetType_;
    }

    const uint8_t& oTargetType() const OMG_NOEXCEPT {
        return m_oTargetType_;
    }

    void oTargetType(uint8_t value) {
        m_oTargetType_ = value;
    }

    uint8_t& oRefSensorIDForBearingTgt() OMG_NOEXCEPT {
        return m_oRefSensorIDForBearingTgt_;
    }

    const uint8_t& oRefSensorIDForBearingTgt() const OMG_NOEXCEPT {
        return m_oRefSensorIDForBearingTgt_;
    }

    void oRefSensorIDForBearingTgt(uint8_t value) {
        m_oRefSensorIDForBearingTgt_ = value;
    }

    float& fAzimuthForBearingTgt() OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    const float& fAzimuthForBearingTgt() const OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    void fAzimuthForBearingTgt(float value) {
        m_fAzimuthForBearingTgt_ = value;
    }

    uint8_t& oAssociatedStatus() OMG_NOEXCEPT {
        return m_oAssociatedStatus_;
    }

    const uint8_t& oAssociatedStatus() const OMG_NOEXCEPT {
        return m_oAssociatedStatus_;
    }

    void oAssociatedStatus(uint8_t value) {
        m_oAssociatedStatus_ = value;
    }

    uint16_t& usAssociatedMasterTgtID() OMG_NOEXCEPT {
        return m_usAssociatedMasterTgtID_;
    }

    const uint16_t& usAssociatedMasterTgtID() const OMG_NOEXCEPT {
        return m_usAssociatedMasterTgtID_;
    }

    void usAssociatedMasterTgtID(uint16_t value) {
        m_usAssociatedMasterTgtID_ = value;
    }

    uint8_t& oNoOfAssociatedSystemTgts() OMG_NOEXCEPT {
        return m_oNoOfAssociatedSystemTgts_;
    }

    const uint8_t& oNoOfAssociatedSystemTgts() const OMG_NOEXCEPT {
        return m_oNoOfAssociatedSystemTgts_;
    }

    void oNoOfAssociatedSystemTgts(uint8_t value) {
        m_oNoOfAssociatedSystemTgts_ = value;
    }

    ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID() OMG_NOEXCEPT {
        return m_aAssociatedSystemTgtID_;
    }

    const ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID() const OMG_NOEXCEPT {
        return m_aAssociatedSystemTgtID_;
    }

    void aAssociatedSystemTgtID(const ::dds::core::array< uint16_t, 32L>& value) {
        m_aAssociatedSystemTgtID_ = value;
    }

    void aAssociatedSystemTgtID(::dds::core::array< uint16_t, 32L>&& value) {
        m_aAssociatedSystemTgtID_ = std::move(value);
    }
    uint8_t& oAssociationReliability() OMG_NOEXCEPT {
        return m_oAssociationReliability_;
    }

    const uint8_t& oAssociationReliability() const OMG_NOEXCEPT {
        return m_oAssociationReliability_;
    }

    void oAssociationReliability(uint8_t value) {
        m_oAssociationReliability_ = value;
    }

    ST_DATE_TIME& stAssociationTime() OMG_NOEXCEPT {
        return m_stAssociationTime_;
    }

    const ST_DATE_TIME& stAssociationTime() const OMG_NOEXCEPT {
        return m_stAssociationTime_;
    }

    void stAssociationTime(const ST_DATE_TIME& value) {
        m_stAssociationTime_ = value;
    }

    void stAssociationTime(ST_DATE_TIME&& value) {
        m_stAssociationTime_ = std::move(value);
    }
    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const ST_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oFusionProcessed_;
    uint8_t m_oUsedSensorForAssociation_;
    uint16_t m_usTgtNumber_;
    uint16_t m_usTrackStatus_;
    uint8_t m_oLOFARTonalFreqCnt_;
    ::dds::core::array< float, 24L> m_aLOFARTonalFreq_;
    ::dds::core::array< uint8_t, 24L> m_aIsThreatFreq_;
    uint8_t m_oDEMONTonalFreqCnt_;
    ::dds::core::array< float, 8L> m_aDEMONTonalFreq_;
    uint8_t m_oInOutInfo_;
    ::dds::core::array< float, 4L> m_aStateVector_;
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L> m_aMatP_;
    uint8_t m_oNoOfAssociatedSensors_;
    ::dds::core::array< uint8_t, 32L> m_aAssociatedSensors_;
    ::dds::core::array< uint32_t, 32L> m_aAssociatedLocalTgtID_;
    uint8_t m_oOriginSensorID_;
    ::dds::core::array< uint16_t, 2L> m_aTrackReliability_;
    bool m_bIsRegisteredByManual_;
    uint8_t m_oTargetType_;
    uint8_t m_oRefSensorIDForBearingTgt_;
    float m_fAzimuthForBearingTgt_;
    uint8_t m_oAssociatedStatus_;
    uint16_t m_usAssociatedMasterTgtID_;
    uint8_t m_oNoOfAssociatedSystemTgts_;
    ::dds::core::array< uint16_t, 32L> m_aAssociatedSystemTgtID_;
    uint8_t m_oAssociationReliability_;
    ST_DATE_TIME m_stAssociationTime_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(ST_FUSED_GLOBAL_TARGET& a, ST_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport ST_AIS_TARGET_ASSOICATED {
  public:
    ST_AIS_TARGET_ASSOICATED();

    ST_AIS_TARGET_ASSOICATED(uint8_t oAssociatedSensorID,uint32_t ulTargetNumber,uint32_t ulMMSINumber,const ::dds::core::array< uint8_t, 20L>& aAISShipName,float fShipWidth,float fShipLength,uint16_t usNationalityCode,const ST_DATE_TIME& stTrackDetectTime,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint8_t oUserChange,uint8_t oRegistCnt,uint8_t oProcessCnt,float fAssociationReliability);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AIS_TARGET_ASSOICATED (ST_AIS_TARGET_ASSOICATED&&) = default;
    ST_AIS_TARGET_ASSOICATED& operator=(ST_AIS_TARGET_ASSOICATED&&) = default;
    ST_AIS_TARGET_ASSOICATED& operator=(const ST_AIS_TARGET_ASSOICATED&) = default;
    ST_AIS_TARGET_ASSOICATED(const ST_AIS_TARGET_ASSOICATED&) = default;
    #else
    ST_AIS_TARGET_ASSOICATED(ST_AIS_TARGET_ASSOICATED&& other_) OMG_NOEXCEPT;  
    ST_AIS_TARGET_ASSOICATED& operator=(ST_AIS_TARGET_ASSOICATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    uint32_t& ulTargetNumber() OMG_NOEXCEPT {
        return m_ulTargetNumber_;
    }

    const uint32_t& ulTargetNumber() const OMG_NOEXCEPT {
        return m_ulTargetNumber_;
    }

    void ulTargetNumber(uint32_t value) {
        m_ulTargetNumber_ = value;
    }

    uint32_t& ulMMSINumber() OMG_NOEXCEPT {
        return m_ulMMSINumber_;
    }

    const uint32_t& ulMMSINumber() const OMG_NOEXCEPT {
        return m_ulMMSINumber_;
    }

    void ulMMSINumber(uint32_t value) {
        m_ulMMSINumber_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& aAISShipName() OMG_NOEXCEPT {
        return m_aAISShipName_;
    }

    const ::dds::core::array< uint8_t, 20L>& aAISShipName() const OMG_NOEXCEPT {
        return m_aAISShipName_;
    }

    void aAISShipName(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aAISShipName_ = value;
    }

    void aAISShipName(::dds::core::array< uint8_t, 20L>&& value) {
        m_aAISShipName_ = std::move(value);
    }
    float& fShipWidth() OMG_NOEXCEPT {
        return m_fShipWidth_;
    }

    const float& fShipWidth() const OMG_NOEXCEPT {
        return m_fShipWidth_;
    }

    void fShipWidth(float value) {
        m_fShipWidth_ = value;
    }

    float& fShipLength() OMG_NOEXCEPT {
        return m_fShipLength_;
    }

    const float& fShipLength() const OMG_NOEXCEPT {
        return m_fShipLength_;
    }

    void fShipLength(float value) {
        m_fShipLength_ = value;
    }

    uint16_t& usNationalityCode() OMG_NOEXCEPT {
        return m_usNationalityCode_;
    }

    const uint16_t& usNationalityCode() const OMG_NOEXCEPT {
        return m_usNationalityCode_;
    }

    void usNationalityCode(uint16_t value) {
        m_usNationalityCode_ = value;
    }

    ST_DATE_TIME& stTrackDetectTime() OMG_NOEXCEPT {
        return m_stTrackDetectTime_;
    }

    const ST_DATE_TIME& stTrackDetectTime() const OMG_NOEXCEPT {
        return m_stTrackDetectTime_;
    }

    void stTrackDetectTime(const ST_DATE_TIME& value) {
        m_stTrackDetectTime_ = value;
    }

    void stTrackDetectTime(ST_DATE_TIME&& value) {
        m_stTrackDetectTime_ = std::move(value);
    }
    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    bool operator == (const ST_AIS_TARGET_ASSOICATED& other_) const;
    bool operator != (const ST_AIS_TARGET_ASSOICATED& other_) const;

    void swap(ST_AIS_TARGET_ASSOICATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    uint32_t m_ulTargetNumber_;
    uint32_t m_ulMMSINumber_;
    ::dds::core::array< uint8_t, 20L> m_aAISShipName_;
    float m_fShipWidth_;
    float m_fShipLength_;
    uint16_t m_usNationalityCode_;
    ST_DATE_TIME m_stTrackDetectTime_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint8_t m_oUserChange_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    float m_fAssociationReliability_;

};

inline void swap(ST_AIS_TARGET_ASSOICATED& a, ST_AIS_TARGET_ASSOICATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AIS_TARGET_ASSOICATED& sample);

class NDDSUSERDllExport ST_AIS_FUSED_GLOBAL_TARGET {
  public:
    ST_AIS_FUSED_GLOBAL_TARGET();

    ST_AIS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ST_AIS_TARGET_ASSOICATED& stAISTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AIS_FUSED_GLOBAL_TARGET (ST_AIS_FUSED_GLOBAL_TARGET&&) = default;
    ST_AIS_FUSED_GLOBAL_TARGET& operator=(ST_AIS_FUSED_GLOBAL_TARGET&&) = default;
    ST_AIS_FUSED_GLOBAL_TARGET& operator=(const ST_AIS_FUSED_GLOBAL_TARGET&) = default;
    ST_AIS_FUSED_GLOBAL_TARGET(const ST_AIS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_AIS_FUSED_GLOBAL_TARGET(ST_AIS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_AIS_FUSED_GLOBAL_TARGET& operator=(ST_AIS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ST_AIS_TARGET_ASSOICATED& stAISTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stAISTgtInfoAssociated_;
    }

    const ST_AIS_TARGET_ASSOICATED& stAISTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stAISTgtInfoAssociated_;
    }

    void stAISTgtInfoAssociated(const ST_AIS_TARGET_ASSOICATED& value) {
        m_stAISTgtInfoAssociated_ = value;
    }

    void stAISTgtInfoAssociated(ST_AIS_TARGET_ASSOICATED&& value) {
        m_stAISTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_AIS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_AIS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_AIS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ST_AIS_TARGET_ASSOICATED m_stAISTgtInfoAssociated_;

};

inline void swap(ST_AIS_FUSED_GLOBAL_TARGET& a, ST_AIS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AIS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_AIS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_AIS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_AIS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_AIS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_AIS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_AIS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport ST_AS_TARGET_ASSOCIATED {
  public:
    ST_AS_TARGET_ASSOCIATED();

    ST_AS_TARGET_ASSOCIATED(uint8_t oAssociatedSensorID,uint16_t usTargetNumber,uint16_t usAssociatedTrackID,float fAssociationReliability,float fBearing,float fDistance,uint16_t usBeamNo,uint8_t oTrackInitType,uint8_t oTrackReliability,uint16_t usTgtClsResult,float fTgtClsPrecisionInfo,uint16_t usPulseType,float fTargetTS,const ST_DATE_TIME& stUpdateTime,const ST_DATE_TIME& stRegistrationTime,uint16_t usTargetClassificationResult,uint8_t oRegistCnt,uint8_t oProcessCnt,uint8_t oUserChange,uint8_t oIsTrainingTgt);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_TARGET_ASSOCIATED (ST_AS_TARGET_ASSOCIATED&&) = default;
    ST_AS_TARGET_ASSOCIATED& operator=(ST_AS_TARGET_ASSOCIATED&&) = default;
    ST_AS_TARGET_ASSOCIATED& operator=(const ST_AS_TARGET_ASSOCIATED&) = default;
    ST_AS_TARGET_ASSOCIATED(const ST_AS_TARGET_ASSOCIATED&) = default;
    #else
    ST_AS_TARGET_ASSOCIATED(ST_AS_TARGET_ASSOCIATED&& other_) OMG_NOEXCEPT;  
    ST_AS_TARGET_ASSOCIATED& operator=(ST_AS_TARGET_ASSOCIATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    uint16_t& usTargetNumber() OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    const uint16_t& usTargetNumber() const OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    void usTargetNumber(uint16_t value) {
        m_usTargetNumber_ = value;
    }

    uint16_t& usAssociatedTrackID() OMG_NOEXCEPT {
        return m_usAssociatedTrackID_;
    }

    const uint16_t& usAssociatedTrackID() const OMG_NOEXCEPT {
        return m_usAssociatedTrackID_;
    }

    void usAssociatedTrackID(uint16_t value) {
        m_usAssociatedTrackID_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    uint16_t& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const uint16_t& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(uint16_t value) {
        m_usBeamNo_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    uint16_t& usTgtClsResult() OMG_NOEXCEPT {
        return m_usTgtClsResult_;
    }

    const uint16_t& usTgtClsResult() const OMG_NOEXCEPT {
        return m_usTgtClsResult_;
    }

    void usTgtClsResult(uint16_t value) {
        m_usTgtClsResult_ = value;
    }

    float& fTgtClsPrecisionInfo() OMG_NOEXCEPT {
        return m_fTgtClsPrecisionInfo_;
    }

    const float& fTgtClsPrecisionInfo() const OMG_NOEXCEPT {
        return m_fTgtClsPrecisionInfo_;
    }

    void fTgtClsPrecisionInfo(float value) {
        m_fTgtClsPrecisionInfo_ = value;
    }

    uint16_t& usPulseType() OMG_NOEXCEPT {
        return m_usPulseType_;
    }

    const uint16_t& usPulseType() const OMG_NOEXCEPT {
        return m_usPulseType_;
    }

    void usPulseType(uint16_t value) {
        m_usPulseType_ = value;
    }

    float& fTargetTS() OMG_NOEXCEPT {
        return m_fTargetTS_;
    }

    const float& fTargetTS() const OMG_NOEXCEPT {
        return m_fTargetTS_;
    }

    void fTargetTS(float value) {
        m_fTargetTS_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    uint16_t& usTargetClassificationResult() OMG_NOEXCEPT {
        return m_usTargetClassificationResult_;
    }

    const uint16_t& usTargetClassificationResult() const OMG_NOEXCEPT {
        return m_usTargetClassificationResult_;
    }

    void usTargetClassificationResult(uint16_t value) {
        m_usTargetClassificationResult_ = value;
    }

    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    uint8_t& oIsTrainingTgt() OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    const uint8_t& oIsTrainingTgt() const OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    void oIsTrainingTgt(uint8_t value) {
        m_oIsTrainingTgt_ = value;
    }

    bool operator == (const ST_AS_TARGET_ASSOCIATED& other_) const;
    bool operator != (const ST_AS_TARGET_ASSOCIATED& other_) const;

    void swap(ST_AS_TARGET_ASSOCIATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    uint16_t m_usTargetNumber_;
    uint16_t m_usAssociatedTrackID_;
    float m_fAssociationReliability_;
    float m_fBearing_;
    float m_fDistance_;
    uint16_t m_usBeamNo_;
    uint8_t m_oTrackInitType_;
    uint8_t m_oTrackReliability_;
    uint16_t m_usTgtClsResult_;
    float m_fTgtClsPrecisionInfo_;
    uint16_t m_usPulseType_;
    float m_fTargetTS_;
    ST_DATE_TIME m_stUpdateTime_;
    ST_DATE_TIME m_stRegistrationTime_;
    uint16_t m_usTargetClassificationResult_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    uint8_t m_oUserChange_;
    uint8_t m_oIsTrainingTgt_;

};

inline void swap(ST_AS_TARGET_ASSOCIATED& a, ST_AS_TARGET_ASSOCIATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_TARGET_ASSOCIATED& sample);

class NDDSUSERDllExport ST_AS_FUSED_GLOBAL_TARGET {
  public:
    ST_AS_FUSED_GLOBAL_TARGET();

    ST_AS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& stASTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_FUSED_GLOBAL_TARGET (ST_AS_FUSED_GLOBAL_TARGET&&) = default;
    ST_AS_FUSED_GLOBAL_TARGET& operator=(ST_AS_FUSED_GLOBAL_TARGET&&) = default;
    ST_AS_FUSED_GLOBAL_TARGET& operator=(const ST_AS_FUSED_GLOBAL_TARGET&) = default;
    ST_AS_FUSED_GLOBAL_TARGET(const ST_AS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_AS_FUSED_GLOBAL_TARGET(ST_AS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_AS_FUSED_GLOBAL_TARGET& operator=(ST_AS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& stASTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stASTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& stASTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stASTgtInfoAssociated_;
    }

    void stASTgtInfoAssociated(const ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& value) {
        m_stASTgtInfoAssociated_ = value;
    }

    void stASTgtInfoAssociated(::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>&& value) {
        m_stASTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_AS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_AS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_AS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L> m_stASTgtInfoAssociated_;

};

inline void swap(ST_AS_FUSED_GLOBAL_TARGET& a, ST_AS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_AS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_AS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_AS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_AS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_AS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_AS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND {
  public:
    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND();

    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usCommandID,uint8_t oSensorID,uint16_t usTgtID,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND (TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& operator=(const TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND&) = default;
    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND(const TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint8_t& oSensorID() OMG_NOEXCEPT {
        return m_oSensorID_;
    }

    const uint8_t& oSensorID() const OMG_NOEXCEPT {
        return m_oSensorID_;
    }

    void oSensorID(uint8_t value) {
        m_oSensorID_ = value;
    }

    uint16_t& usTgtID() OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    const uint16_t& usTgtID() const OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    void usTgtID(uint16_t value) {
        m_usTgtID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usCommandID_;
    uint8_t m_oSensorID_;
    uint16_t m_usTgtID_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& a, TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport ST_BIS_TARGET_ASSOCIATED {
  public:
    ST_BIS_TARGET_ASSOCIATED();

    ST_BIS_TARGET_ASSOCIATED(uint8_t oAssociatedSensorID,const ::dds::core::array< uint16_t, 2L>& aTgtNumber,uint16_t usRealTgtNumber,uint16_t usAssociatedTrackID,float fAssociationReliability,float fBearing,float fDistance,uint16_t usBeamNo,uint8_t oTrackInitType,uint8_t oTrackReliability,uint8_t oFusionStatus,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint8_t oRegistCnt,uint8_t oProcessCnt,uint8_t oUserChange,uint8_t oIsTrainingTgt);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_TARGET_ASSOCIATED (ST_BIS_TARGET_ASSOCIATED&&) = default;
    ST_BIS_TARGET_ASSOCIATED& operator=(ST_BIS_TARGET_ASSOCIATED&&) = default;
    ST_BIS_TARGET_ASSOCIATED& operator=(const ST_BIS_TARGET_ASSOCIATED&) = default;
    ST_BIS_TARGET_ASSOCIATED(const ST_BIS_TARGET_ASSOCIATED&) = default;
    #else
    ST_BIS_TARGET_ASSOCIATED(ST_BIS_TARGET_ASSOCIATED&& other_) OMG_NOEXCEPT;  
    ST_BIS_TARGET_ASSOCIATED& operator=(ST_BIS_TARGET_ASSOCIATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aTgtNumber() OMG_NOEXCEPT {
        return m_aTgtNumber_;
    }

    const ::dds::core::array< uint16_t, 2L>& aTgtNumber() const OMG_NOEXCEPT {
        return m_aTgtNumber_;
    }

    void aTgtNumber(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aTgtNumber_ = value;
    }

    void aTgtNumber(::dds::core::array< uint16_t, 2L>&& value) {
        m_aTgtNumber_ = std::move(value);
    }
    uint16_t& usRealTgtNumber() OMG_NOEXCEPT {
        return m_usRealTgtNumber_;
    }

    const uint16_t& usRealTgtNumber() const OMG_NOEXCEPT {
        return m_usRealTgtNumber_;
    }

    void usRealTgtNumber(uint16_t value) {
        m_usRealTgtNumber_ = value;
    }

    uint16_t& usAssociatedTrackID() OMG_NOEXCEPT {
        return m_usAssociatedTrackID_;
    }

    const uint16_t& usAssociatedTrackID() const OMG_NOEXCEPT {
        return m_usAssociatedTrackID_;
    }

    void usAssociatedTrackID(uint16_t value) {
        m_usAssociatedTrackID_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    uint16_t& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const uint16_t& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(uint16_t value) {
        m_usBeamNo_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    uint8_t& oFusionStatus() OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    const uint8_t& oFusionStatus() const OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    void oFusionStatus(uint8_t value) {
        m_oFusionStatus_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    uint8_t& oIsTrainingTgt() OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    const uint8_t& oIsTrainingTgt() const OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    void oIsTrainingTgt(uint8_t value) {
        m_oIsTrainingTgt_ = value;
    }

    bool operator == (const ST_BIS_TARGET_ASSOCIATED& other_) const;
    bool operator != (const ST_BIS_TARGET_ASSOCIATED& other_) const;

    void swap(ST_BIS_TARGET_ASSOCIATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    ::dds::core::array< uint16_t, 2L> m_aTgtNumber_;
    uint16_t m_usRealTgtNumber_;
    uint16_t m_usAssociatedTrackID_;
    float m_fAssociationReliability_;
    float m_fBearing_;
    float m_fDistance_;
    uint16_t m_usBeamNo_;
    uint8_t m_oTrackInitType_;
    uint8_t m_oTrackReliability_;
    uint8_t m_oFusionStatus_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    uint8_t m_oUserChange_;
    uint8_t m_oIsTrainingTgt_;

};

inline void swap(ST_BIS_TARGET_ASSOCIATED& a, ST_BIS_TARGET_ASSOCIATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_TARGET_ASSOCIATED& sample);

class NDDSUSERDllExport ST_BIS_FUSED_GLOBAL_TARGET {
  public:
    ST_BIS_FUSED_GLOBAL_TARGET();

    ST_BIS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& stBISTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_FUSED_GLOBAL_TARGET (ST_BIS_FUSED_GLOBAL_TARGET&&) = default;
    ST_BIS_FUSED_GLOBAL_TARGET& operator=(ST_BIS_FUSED_GLOBAL_TARGET&&) = default;
    ST_BIS_FUSED_GLOBAL_TARGET& operator=(const ST_BIS_FUSED_GLOBAL_TARGET&) = default;
    ST_BIS_FUSED_GLOBAL_TARGET(const ST_BIS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_BIS_FUSED_GLOBAL_TARGET(ST_BIS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_BIS_FUSED_GLOBAL_TARGET& operator=(ST_BIS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& stBISTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stBISTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& stBISTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stBISTgtInfoAssociated_;
    }

    void stBISTgtInfoAssociated(const ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& value) {
        m_stBISTgtInfoAssociated_ = value;
    }

    void stBISTgtInfoAssociated(::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>&& value) {
        m_stBISTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_BIS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_BIS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_BIS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L> m_stBISTgtInfoAssociated_;

};

inline void swap(ST_BIS_FUSED_GLOBAL_TARGET& a, ST_BIS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_BIS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_BIS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_BIS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_BIS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_BIS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_BIS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport TGTMGR_BIS_SOURCE_MANUEVER_INFO {
  public:
    TGTMGR_BIS_SOURCE_MANUEVER_INFO();

    TGTMGR_BIS_SOURCE_MANUEVER_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usPulseID,uint16_t usInfoType,uint16_t usPulseType,uint16_t usTxSourceType,uint16_t usTargetNo,const ST_DATE_TIME& stUpdateTime,float fVelocity,float fHeading,const ::dds::core::array< float, 3L>& fTxTgtDistanceFromBISSensor,const ::dds::core::array< float, 3L>& fTxTgtBearingFromBISSensor,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_BIS_SOURCE_MANUEVER_INFO (TGTMGR_BIS_SOURCE_MANUEVER_INFO&&) = default;
    TGTMGR_BIS_SOURCE_MANUEVER_INFO& operator=(TGTMGR_BIS_SOURCE_MANUEVER_INFO&&) = default;
    TGTMGR_BIS_SOURCE_MANUEVER_INFO& operator=(const TGTMGR_BIS_SOURCE_MANUEVER_INFO&) = default;
    TGTMGR_BIS_SOURCE_MANUEVER_INFO(const TGTMGR_BIS_SOURCE_MANUEVER_INFO&) = default;
    #else
    TGTMGR_BIS_SOURCE_MANUEVER_INFO(TGTMGR_BIS_SOURCE_MANUEVER_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_BIS_SOURCE_MANUEVER_INFO& operator=(TGTMGR_BIS_SOURCE_MANUEVER_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usPulseID() OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    const uint16_t& usPulseID() const OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    void usPulseID(uint16_t value) {
        m_usPulseID_ = value;
    }

    uint16_t& usInfoType() OMG_NOEXCEPT {
        return m_usInfoType_;
    }

    const uint16_t& usInfoType() const OMG_NOEXCEPT {
        return m_usInfoType_;
    }

    void usInfoType(uint16_t value) {
        m_usInfoType_ = value;
    }

    uint16_t& usPulseType() OMG_NOEXCEPT {
        return m_usPulseType_;
    }

    const uint16_t& usPulseType() const OMG_NOEXCEPT {
        return m_usPulseType_;
    }

    void usPulseType(uint16_t value) {
        m_usPulseType_ = value;
    }

    uint16_t& usTxSourceType() OMG_NOEXCEPT {
        return m_usTxSourceType_;
    }

    const uint16_t& usTxSourceType() const OMG_NOEXCEPT {
        return m_usTxSourceType_;
    }

    void usTxSourceType(uint16_t value) {
        m_usTxSourceType_ = value;
    }

    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    float& fHeading() OMG_NOEXCEPT {
        return m_fHeading_;
    }

    const float& fHeading() const OMG_NOEXCEPT {
        return m_fHeading_;
    }

    void fHeading(float value) {
        m_fHeading_ = value;
    }

    ::dds::core::array< float, 3L>& fTxTgtDistanceFromBISSensor() OMG_NOEXCEPT {
        return m_fTxTgtDistanceFromBISSensor_;
    }

    const ::dds::core::array< float, 3L>& fTxTgtDistanceFromBISSensor() const OMG_NOEXCEPT {
        return m_fTxTgtDistanceFromBISSensor_;
    }

    void fTxTgtDistanceFromBISSensor(const ::dds::core::array< float, 3L>& value) {
        m_fTxTgtDistanceFromBISSensor_ = value;
    }

    void fTxTgtDistanceFromBISSensor(::dds::core::array< float, 3L>&& value) {
        m_fTxTgtDistanceFromBISSensor_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& fTxTgtBearingFromBISSensor() OMG_NOEXCEPT {
        return m_fTxTgtBearingFromBISSensor_;
    }

    const ::dds::core::array< float, 3L>& fTxTgtBearingFromBISSensor() const OMG_NOEXCEPT {
        return m_fTxTgtBearingFromBISSensor_;
    }

    void fTxTgtBearingFromBISSensor(const ::dds::core::array< float, 3L>& value) {
        m_fTxTgtBearingFromBISSensor_ = value;
    }

    void fTxTgtBearingFromBISSensor(::dds::core::array< float, 3L>&& value) {
        m_fTxTgtBearingFromBISSensor_ = std::move(value);
    }
    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const TGTMGR_BIS_SOURCE_MANUEVER_INFO& other_) const;
    bool operator != (const TGTMGR_BIS_SOURCE_MANUEVER_INFO& other_) const;

    void swap(TGTMGR_BIS_SOURCE_MANUEVER_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usPulseID_;
    uint16_t m_usInfoType_;
    uint16_t m_usPulseType_;
    uint16_t m_usTxSourceType_;
    uint16_t m_usTargetNo_;
    ST_DATE_TIME m_stUpdateTime_;
    float m_fVelocity_;
    float m_fHeading_;
    ::dds::core::array< float, 3L> m_fTxTgtDistanceFromBISSensor_;
    ::dds::core::array< float, 3L> m_fTxTgtBearingFromBISSensor_;
    uint16_t m_usReserved_;

};

inline void swap(TGTMGR_BIS_SOURCE_MANUEVER_INFO& a, TGTMGR_BIS_SOURCE_MANUEVER_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_BIS_SOURCE_MANUEVER_INFO& sample);

class NDDSUSERDllExport TGTMGR_BIS_TRACK_DELETE_CONTROL {
  public:
    TGTMGR_BIS_TRACK_DELETE_CONTROL();

    TGTMGR_BIS_TRACK_DELETE_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint16_t usTgtNo,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_BIS_TRACK_DELETE_CONTROL (TGTMGR_BIS_TRACK_DELETE_CONTROL&&) = default;
    TGTMGR_BIS_TRACK_DELETE_CONTROL& operator=(TGTMGR_BIS_TRACK_DELETE_CONTROL&&) = default;
    TGTMGR_BIS_TRACK_DELETE_CONTROL& operator=(const TGTMGR_BIS_TRACK_DELETE_CONTROL&) = default;
    TGTMGR_BIS_TRACK_DELETE_CONTROL(const TGTMGR_BIS_TRACK_DELETE_CONTROL&) = default;
    #else
    TGTMGR_BIS_TRACK_DELETE_CONTROL(TGTMGR_BIS_TRACK_DELETE_CONTROL&& other_) OMG_NOEXCEPT;  
    TGTMGR_BIS_TRACK_DELETE_CONTROL& operator=(TGTMGR_BIS_TRACK_DELETE_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint16_t& usTgtNo() OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    const uint16_t& usTgtNo() const OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    void usTgtNo(uint16_t value) {
        m_usTgtNo_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const TGTMGR_BIS_TRACK_DELETE_CONTROL& other_) const;
    bool operator != (const TGTMGR_BIS_TRACK_DELETE_CONTROL& other_) const;

    void swap(TGTMGR_BIS_TRACK_DELETE_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint16_t m_usTgtNo_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(TGTMGR_BIS_TRACK_DELETE_CONTROL& a, TGTMGR_BIS_TRACK_DELETE_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_BIS_TRACK_DELETE_CONTROL& sample);

class NDDSUSERDllExport TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND {
  public:
    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND();

    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usCommandID,uint8_t oAxis,uint16_t usTgtID,uint8_t oDetectionType,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND (TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& operator=(const TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND&) = default;
    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND(const TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& usTgtID() OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    const uint16_t& usTgtID() const OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    void usTgtID(uint16_t value) {
        m_usTgtID_ = value;
    }

    uint8_t& oDetectionType() OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    const uint8_t& oDetectionType() const OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    void oDetectionType(uint8_t value) {
        m_oDetectionType_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usCommandID_;
    uint8_t m_oAxis_;
    uint16_t m_usTgtID_;
    uint8_t m_oDetectionType_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& a, TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport ST_TARGET_TRACK_HISTORY {
  public:
    ST_TARGET_TRACK_HISTORY();

    ST_TARGET_TRACK_HISTORY(uint8_t oRecordTimeHour,uint8_t oRecordTimeMin,uint8_t oRecordTimeSec,const ::dds::core::array< double, 2L>& dTgtPos);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_TARGET_TRACK_HISTORY (ST_TARGET_TRACK_HISTORY&&) = default;
    ST_TARGET_TRACK_HISTORY& operator=(ST_TARGET_TRACK_HISTORY&&) = default;
    ST_TARGET_TRACK_HISTORY& operator=(const ST_TARGET_TRACK_HISTORY&) = default;
    ST_TARGET_TRACK_HISTORY(const ST_TARGET_TRACK_HISTORY&) = default;
    #else
    ST_TARGET_TRACK_HISTORY(ST_TARGET_TRACK_HISTORY&& other_) OMG_NOEXCEPT;  
    ST_TARGET_TRACK_HISTORY& operator=(ST_TARGET_TRACK_HISTORY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oRecordTimeHour() OMG_NOEXCEPT {
        return m_oRecordTimeHour_;
    }

    const uint8_t& oRecordTimeHour() const OMG_NOEXCEPT {
        return m_oRecordTimeHour_;
    }

    void oRecordTimeHour(uint8_t value) {
        m_oRecordTimeHour_ = value;
    }

    uint8_t& oRecordTimeMin() OMG_NOEXCEPT {
        return m_oRecordTimeMin_;
    }

    const uint8_t& oRecordTimeMin() const OMG_NOEXCEPT {
        return m_oRecordTimeMin_;
    }

    void oRecordTimeMin(uint8_t value) {
        m_oRecordTimeMin_ = value;
    }

    uint8_t& oRecordTimeSec() OMG_NOEXCEPT {
        return m_oRecordTimeSec_;
    }

    const uint8_t& oRecordTimeSec() const OMG_NOEXCEPT {
        return m_oRecordTimeSec_;
    }

    void oRecordTimeSec(uint8_t value) {
        m_oRecordTimeSec_ = value;
    }

    ::dds::core::array< double, 2L>& dTgtPos() OMG_NOEXCEPT {
        return m_dTgtPos_;
    }

    const ::dds::core::array< double, 2L>& dTgtPos() const OMG_NOEXCEPT {
        return m_dTgtPos_;
    }

    void dTgtPos(const ::dds::core::array< double, 2L>& value) {
        m_dTgtPos_ = value;
    }

    void dTgtPos(::dds::core::array< double, 2L>&& value) {
        m_dTgtPos_ = std::move(value);
    }

    bool operator == (const ST_TARGET_TRACK_HISTORY& other_) const;
    bool operator != (const ST_TARGET_TRACK_HISTORY& other_) const;

    void swap(ST_TARGET_TRACK_HISTORY& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oRecordTimeHour_;
    uint8_t m_oRecordTimeMin_;
    uint8_t m_oRecordTimeSec_;
    ::dds::core::array< double, 2L> m_dTgtPos_;

};

inline void swap(ST_TARGET_TRACK_HISTORY& a, ST_TARGET_TRACK_HISTORY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_TARGET_TRACK_HISTORY& sample);

class NDDSUSERDllExport ST_FOC_INFO {
  public:
    ST_FOC_INFO();

    ST_FOC_INFO(const ST_DATE_TIME& stReqTime,float fDistance);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_FOC_INFO (ST_FOC_INFO&&) = default;
    ST_FOC_INFO& operator=(ST_FOC_INFO&&) = default;
    ST_FOC_INFO& operator=(const ST_FOC_INFO&) = default;
    ST_FOC_INFO(const ST_FOC_INFO&) = default;
    #else
    ST_FOC_INFO(ST_FOC_INFO&& other_) OMG_NOEXCEPT;  
    ST_FOC_INFO& operator=(ST_FOC_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    bool operator == (const ST_FOC_INFO& other_) const;
    bool operator != (const ST_FOC_INFO& other_) const;

    void swap(ST_FOC_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_DATE_TIME m_stReqTime_;
    float m_fDistance_;

};

inline void swap(ST_FOC_INFO& a, ST_FOC_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_FOC_INFO& sample);

class NDDSUSERDllExport ST_DR_INFO {
  public:
    ST_DR_INFO();

    ST_DR_INFO(const ST_DATE_TIME& stReqTime,double dLatitude,double dLongitude,float fCourse,float fVelocity,uint32_t ulEstimationTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_DR_INFO (ST_DR_INFO&&) = default;
    ST_DR_INFO& operator=(ST_DR_INFO&&) = default;
    ST_DR_INFO& operator=(const ST_DR_INFO&) = default;
    ST_DR_INFO(const ST_DR_INFO&) = default;
    #else
    ST_DR_INFO(ST_DR_INFO&& other_) OMG_NOEXCEPT;  
    ST_DR_INFO& operator=(ST_DR_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    uint32_t& ulEstimationTime() OMG_NOEXCEPT {
        return m_ulEstimationTime_;
    }

    const uint32_t& ulEstimationTime() const OMG_NOEXCEPT {
        return m_ulEstimationTime_;
    }

    void ulEstimationTime(uint32_t value) {
        m_ulEstimationTime_ = value;
    }

    bool operator == (const ST_DR_INFO& other_) const;
    bool operator != (const ST_DR_INFO& other_) const;

    void swap(ST_DR_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_DATE_TIME m_stReqTime_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fCourse_;
    float m_fVelocity_;
    uint32_t m_ulEstimationTime_;

};

inline void swap(ST_DR_INFO& a, ST_DR_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_DR_INFO& sample);

class NDDSUSERDllExport ST_CCRN_TARGET {
  public:
    ST_CCRN_TARGET();

    ST_CCRN_TARGET(uint16_t usTgtNo,uint16_t usGTTgtNo,uint8_t oTargetStatus,uint8_t oRegistrationType,float fCourse,float fVelocity,double dLatitude,double dLongitude,bool bIsThreatTgt,uint8_t oThreatGrade,uint8_t oAnchoredThreatTgt,uint32_t ulAnchoringDurationTime,uint8_t oFriendlyInfo,uint8_t oClassInfo,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint32_t stMaintainTime,uint8_t oLOFARTonalFreqCnt,const ::dds::core::array< float, 24L>& aLOFARTonalFreq,uint8_t oDEMONTonalFreqCnt,const ::dds::core::array< float, 8L>& aDEMONTonalFreq,uint16_t usNoOfTrkHistory,const ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& aTgtTrkHistory,uint8_t oFOCStatus,uint8_t oDRStatus,const ST_FOC_INFO& stFOCInfo,const ST_DR_INFO& stDRInfo,uint8_t oOriginSensorID,const ::dds::core::array< float, 32L>& aRelativeBearingFromSensors,const ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors,const ::dds::core::array< uint8_t, 20L>& aTagInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_CCRN_TARGET (ST_CCRN_TARGET&&) = default;
    ST_CCRN_TARGET& operator=(ST_CCRN_TARGET&&) = default;
    ST_CCRN_TARGET& operator=(const ST_CCRN_TARGET&) = default;
    ST_CCRN_TARGET(const ST_CCRN_TARGET&) = default;
    #else
    ST_CCRN_TARGET(ST_CCRN_TARGET&& other_) OMG_NOEXCEPT;  
    ST_CCRN_TARGET& operator=(ST_CCRN_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNo() OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    const uint16_t& usTgtNo() const OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    void usTgtNo(uint16_t value) {
        m_usTgtNo_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint8_t& oTargetStatus() OMG_NOEXCEPT {
        return m_oTargetStatus_;
    }

    const uint8_t& oTargetStatus() const OMG_NOEXCEPT {
        return m_oTargetStatus_;
    }

    void oTargetStatus(uint8_t value) {
        m_oTargetStatus_ = value;
    }

    uint8_t& oRegistrationType() OMG_NOEXCEPT {
        return m_oRegistrationType_;
    }

    const uint8_t& oRegistrationType() const OMG_NOEXCEPT {
        return m_oRegistrationType_;
    }

    void oRegistrationType(uint8_t value) {
        m_oRegistrationType_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    bool& bIsThreatTgt() OMG_NOEXCEPT {
        return m_bIsThreatTgt_;
    }

    const bool& bIsThreatTgt() const OMG_NOEXCEPT {
        return m_bIsThreatTgt_;
    }

    void bIsThreatTgt(bool value) {
        m_bIsThreatTgt_ = value;
    }

    uint8_t& oThreatGrade() OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    const uint8_t& oThreatGrade() const OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    void oThreatGrade(uint8_t value) {
        m_oThreatGrade_ = value;
    }

    uint8_t& oAnchoredThreatTgt() OMG_NOEXCEPT {
        return m_oAnchoredThreatTgt_;
    }

    const uint8_t& oAnchoredThreatTgt() const OMG_NOEXCEPT {
        return m_oAnchoredThreatTgt_;
    }

    void oAnchoredThreatTgt(uint8_t value) {
        m_oAnchoredThreatTgt_ = value;
    }

    uint32_t& ulAnchoringDurationTime() OMG_NOEXCEPT {
        return m_ulAnchoringDurationTime_;
    }

    const uint32_t& ulAnchoringDurationTime() const OMG_NOEXCEPT {
        return m_ulAnchoringDurationTime_;
    }

    void ulAnchoringDurationTime(uint32_t value) {
        m_ulAnchoringDurationTime_ = value;
    }

    uint8_t& oFriendlyInfo() OMG_NOEXCEPT {
        return m_oFriendlyInfo_;
    }

    const uint8_t& oFriendlyInfo() const OMG_NOEXCEPT {
        return m_oFriendlyInfo_;
    }

    void oFriendlyInfo(uint8_t value) {
        m_oFriendlyInfo_ = value;
    }

    uint8_t& oClassInfo() OMG_NOEXCEPT {
        return m_oClassInfo_;
    }

    const uint8_t& oClassInfo() const OMG_NOEXCEPT {
        return m_oClassInfo_;
    }

    void oClassInfo(uint8_t value) {
        m_oClassInfo_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint32_t& stMaintainTime() OMG_NOEXCEPT {
        return m_stMaintainTime_;
    }

    const uint32_t& stMaintainTime() const OMG_NOEXCEPT {
        return m_stMaintainTime_;
    }

    void stMaintainTime(uint32_t value) {
        m_stMaintainTime_ = value;
    }

    uint8_t& oLOFARTonalFreqCnt() OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    const uint8_t& oLOFARTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    void oLOFARTonalFreqCnt(uint8_t value) {
        m_oLOFARTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aLOFARTonalFreq() OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    const ::dds::core::array< float, 24L>& aLOFARTonalFreq() const OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    void aLOFARTonalFreq(const ::dds::core::array< float, 24L>& value) {
        m_aLOFARTonalFreq_ = value;
    }

    void aLOFARTonalFreq(::dds::core::array< float, 24L>&& value) {
        m_aLOFARTonalFreq_ = std::move(value);
    }
    uint8_t& oDEMONTonalFreqCnt() OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    const uint8_t& oDEMONTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    void oDEMONTonalFreqCnt(uint8_t value) {
        m_oDEMONTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 8L>& aDEMONTonalFreq() OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    const ::dds::core::array< float, 8L>& aDEMONTonalFreq() const OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    void aDEMONTonalFreq(const ::dds::core::array< float, 8L>& value) {
        m_aDEMONTonalFreq_ = value;
    }

    void aDEMONTonalFreq(::dds::core::array< float, 8L>&& value) {
        m_aDEMONTonalFreq_ = std::move(value);
    }
    uint16_t& usNoOfTrkHistory() OMG_NOEXCEPT {
        return m_usNoOfTrkHistory_;
    }

    const uint16_t& usNoOfTrkHistory() const OMG_NOEXCEPT {
        return m_usNoOfTrkHistory_;
    }

    void usNoOfTrkHistory(uint16_t value) {
        m_usNoOfTrkHistory_ = value;
    }

    ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& aTgtTrkHistory() OMG_NOEXCEPT {
        return m_aTgtTrkHistory_;
    }

    const ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& aTgtTrkHistory() const OMG_NOEXCEPT {
        return m_aTgtTrkHistory_;
    }

    void aTgtTrkHistory(const ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& value) {
        m_aTgtTrkHistory_ = value;
    }

    void aTgtTrkHistory(::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>&& value) {
        m_aTgtTrkHistory_ = std::move(value);
    }
    uint8_t& oFOCStatus() OMG_NOEXCEPT {
        return m_oFOCStatus_;
    }

    const uint8_t& oFOCStatus() const OMG_NOEXCEPT {
        return m_oFOCStatus_;
    }

    void oFOCStatus(uint8_t value) {
        m_oFOCStatus_ = value;
    }

    uint8_t& oDRStatus() OMG_NOEXCEPT {
        return m_oDRStatus_;
    }

    const uint8_t& oDRStatus() const OMG_NOEXCEPT {
        return m_oDRStatus_;
    }

    void oDRStatus(uint8_t value) {
        m_oDRStatus_ = value;
    }

    ST_FOC_INFO& stFOCInfo() OMG_NOEXCEPT {
        return m_stFOCInfo_;
    }

    const ST_FOC_INFO& stFOCInfo() const OMG_NOEXCEPT {
        return m_stFOCInfo_;
    }

    void stFOCInfo(const ST_FOC_INFO& value) {
        m_stFOCInfo_ = value;
    }

    void stFOCInfo(ST_FOC_INFO&& value) {
        m_stFOCInfo_ = std::move(value);
    }
    ST_DR_INFO& stDRInfo() OMG_NOEXCEPT {
        return m_stDRInfo_;
    }

    const ST_DR_INFO& stDRInfo() const OMG_NOEXCEPT {
        return m_stDRInfo_;
    }

    void stDRInfo(const ST_DR_INFO& value) {
        m_stDRInfo_ = value;
    }

    void stDRInfo(ST_DR_INFO&& value) {
        m_stDRInfo_ = std::move(value);
    }
    uint8_t& oOriginSensorID() OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    const uint8_t& oOriginSensorID() const OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    void oOriginSensorID(uint8_t value) {
        m_oOriginSensorID_ = value;
    }

    ::dds::core::array< float, 32L>& aRelativeBearingFromSensors() OMG_NOEXCEPT {
        return m_aRelativeBearingFromSensors_;
    }

    const ::dds::core::array< float, 32L>& aRelativeBearingFromSensors() const OMG_NOEXCEPT {
        return m_aRelativeBearingFromSensors_;
    }

    void aRelativeBearingFromSensors(const ::dds::core::array< float, 32L>& value) {
        m_aRelativeBearingFromSensors_ = value;
    }

    void aRelativeBearingFromSensors(::dds::core::array< float, 32L>&& value) {
        m_aRelativeBearingFromSensors_ = std::move(value);
    }
    ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors() OMG_NOEXCEPT {
        return m_aRelativeDistanceFromSensors_;
    }

    const ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors() const OMG_NOEXCEPT {
        return m_aRelativeDistanceFromSensors_;
    }

    void aRelativeDistanceFromSensors(const ::dds::core::array< float, 32L>& value) {
        m_aRelativeDistanceFromSensors_ = value;
    }

    void aRelativeDistanceFromSensors(::dds::core::array< float, 32L>&& value) {
        m_aRelativeDistanceFromSensors_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& aTagInfo() OMG_NOEXCEPT {
        return m_aTagInfo_;
    }

    const ::dds::core::array< uint8_t, 20L>& aTagInfo() const OMG_NOEXCEPT {
        return m_aTagInfo_;
    }

    void aTagInfo(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aTagInfo_ = value;
    }

    void aTagInfo(::dds::core::array< uint8_t, 20L>&& value) {
        m_aTagInfo_ = std::move(value);
    }

    bool operator == (const ST_CCRN_TARGET& other_) const;
    bool operator != (const ST_CCRN_TARGET& other_) const;

    void swap(ST_CCRN_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNo_;
    uint16_t m_usGTTgtNo_;
    uint8_t m_oTargetStatus_;
    uint8_t m_oRegistrationType_;
    float m_fCourse_;
    float m_fVelocity_;
    double m_dLatitude_;
    double m_dLongitude_;
    bool m_bIsThreatTgt_;
    uint8_t m_oThreatGrade_;
    uint8_t m_oAnchoredThreatTgt_;
    uint32_t m_ulAnchoringDurationTime_;
    uint8_t m_oFriendlyInfo_;
    uint8_t m_oClassInfo_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint32_t m_stMaintainTime_;
    uint8_t m_oLOFARTonalFreqCnt_;
    ::dds::core::array< float, 24L> m_aLOFARTonalFreq_;
    uint8_t m_oDEMONTonalFreqCnt_;
    ::dds::core::array< float, 8L> m_aDEMONTonalFreq_;
    uint16_t m_usNoOfTrkHistory_;
    ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L> m_aTgtTrkHistory_;
    uint8_t m_oFOCStatus_;
    uint8_t m_oDRStatus_;
    ST_FOC_INFO m_stFOCInfo_;
    ST_DR_INFO m_stDRInfo_;
    uint8_t m_oOriginSensorID_;
    ::dds::core::array< float, 32L> m_aRelativeBearingFromSensors_;
    ::dds::core::array< float, 32L> m_aRelativeDistanceFromSensors_;
    ::dds::core::array< uint8_t, 20L> m_aTagInfo_;

};

inline void swap(ST_CCRN_TARGET& a, ST_CCRN_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_CCRN_TARGET& sample);

class NDDSUSERDllExport TGTMGR_CONCERNED_TARGET_INFO {
  public:
    TGTMGR_CONCERNED_TARGET_INFO();

    TGTMGR_CONCERNED_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_CCRN_TARGET, 1000L>& stCcrnTrgInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_CONCERNED_TARGET_INFO (TGTMGR_CONCERNED_TARGET_INFO&&) = default;
    TGTMGR_CONCERNED_TARGET_INFO& operator=(TGTMGR_CONCERNED_TARGET_INFO&&) = default;
    TGTMGR_CONCERNED_TARGET_INFO& operator=(const TGTMGR_CONCERNED_TARGET_INFO&) = default;
    TGTMGR_CONCERNED_TARGET_INFO(const TGTMGR_CONCERNED_TARGET_INFO&) = default;
    #else
    TGTMGR_CONCERNED_TARGET_INFO(TGTMGR_CONCERNED_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_CONCERNED_TARGET_INFO& operator=(TGTMGR_CONCERNED_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_CCRN_TARGET, 1000L>& stCcrnTrgInfo() OMG_NOEXCEPT {
        return m_stCcrnTrgInfo_;
    }

    const ::dds::core::array< ST_CCRN_TARGET, 1000L>& stCcrnTrgInfo() const OMG_NOEXCEPT {
        return m_stCcrnTrgInfo_;
    }

    void stCcrnTrgInfo(const ::dds::core::array< ST_CCRN_TARGET, 1000L>& value) {
        m_stCcrnTrgInfo_ = value;
    }

    void stCcrnTrgInfo(::dds::core::array< ST_CCRN_TARGET, 1000L>&& value) {
        m_stCcrnTrgInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_CONCERNED_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_CONCERNED_TARGET_INFO& other_) const;

    void swap(TGTMGR_CONCERNED_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_CCRN_TARGET, 1000L> m_stCcrnTrgInfo_;

};

inline void swap(TGTMGR_CONCERNED_TARGET_INFO& a, TGTMGR_CONCERNED_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_CONCERNED_TARGET_INFO& sample);

class NDDSUSERDllExport ST_EO_TARGET_ASSOCIATED {
  public:
    ST_EO_TARGET_ASSOCIATED();

    ST_EO_TARGET_ASSOCIATED(uint8_t oAssociatedSensorID,uint16_t usTargetNumber,float fBearing,float fDistance,uint8_t oTrackStatus,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,const ST_DATE_TIME& stRecentRangeMeasureTime,uint8_t oRegistCnt,uint8_t oProcessCnt,float fAssociationReliability,uint8_t oUserChange);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EO_TARGET_ASSOCIATED (ST_EO_TARGET_ASSOCIATED&&) = default;
    ST_EO_TARGET_ASSOCIATED& operator=(ST_EO_TARGET_ASSOCIATED&&) = default;
    ST_EO_TARGET_ASSOCIATED& operator=(const ST_EO_TARGET_ASSOCIATED&) = default;
    ST_EO_TARGET_ASSOCIATED(const ST_EO_TARGET_ASSOCIATED&) = default;
    #else
    ST_EO_TARGET_ASSOCIATED(ST_EO_TARGET_ASSOCIATED&& other_) OMG_NOEXCEPT;  
    ST_EO_TARGET_ASSOCIATED& operator=(ST_EO_TARGET_ASSOCIATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    uint16_t& usTargetNumber() OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    const uint16_t& usTargetNumber() const OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    void usTargetNumber(uint16_t value) {
        m_usTargetNumber_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    uint8_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint8_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint8_t value) {
        m_oTrackStatus_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ST_DATE_TIME& stRecentRangeMeasureTime() OMG_NOEXCEPT {
        return m_stRecentRangeMeasureTime_;
    }

    const ST_DATE_TIME& stRecentRangeMeasureTime() const OMG_NOEXCEPT {
        return m_stRecentRangeMeasureTime_;
    }

    void stRecentRangeMeasureTime(const ST_DATE_TIME& value) {
        m_stRecentRangeMeasureTime_ = value;
    }

    void stRecentRangeMeasureTime(ST_DATE_TIME&& value) {
        m_stRecentRangeMeasureTime_ = std::move(value);
    }
    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    bool operator == (const ST_EO_TARGET_ASSOCIATED& other_) const;
    bool operator != (const ST_EO_TARGET_ASSOCIATED& other_) const;

    void swap(ST_EO_TARGET_ASSOCIATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    uint16_t m_usTargetNumber_;
    float m_fBearing_;
    float m_fDistance_;
    uint8_t m_oTrackStatus_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    ST_DATE_TIME m_stRecentRangeMeasureTime_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    float m_fAssociationReliability_;
    uint8_t m_oUserChange_;

};

inline void swap(ST_EO_TARGET_ASSOCIATED& a, ST_EO_TARGET_ASSOCIATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EO_TARGET_ASSOCIATED& sample);

class NDDSUSERDllExport ST_EOS_FUSED_GLOBAL_TARGET {
  public:
    ST_EOS_FUSED_GLOBAL_TARGET();

    ST_EOS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& stEOTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EOS_FUSED_GLOBAL_TARGET (ST_EOS_FUSED_GLOBAL_TARGET&&) = default;
    ST_EOS_FUSED_GLOBAL_TARGET& operator=(ST_EOS_FUSED_GLOBAL_TARGET&&) = default;
    ST_EOS_FUSED_GLOBAL_TARGET& operator=(const ST_EOS_FUSED_GLOBAL_TARGET&) = default;
    ST_EOS_FUSED_GLOBAL_TARGET(const ST_EOS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_EOS_FUSED_GLOBAL_TARGET(ST_EOS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_EOS_FUSED_GLOBAL_TARGET& operator=(ST_EOS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& stEOTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stEOTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& stEOTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stEOTgtInfoAssociated_;
    }

    void stEOTgtInfoAssociated(const ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& value) {
        m_stEOTgtInfoAssociated_ = value;
    }

    void stEOTgtInfoAssociated(::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>&& value) {
        m_stEOTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_EOS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_EOS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_EOS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L> m_stEOTgtInfoAssociated_;

};

inline void swap(ST_EOS_FUSED_GLOBAL_TARGET& a, ST_EOS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EOS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_EOS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_EOS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_EOS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_EOS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_EOS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_EOS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport ST_AS_LOCAL_TARGET {
  public:
    ST_AS_LOCAL_TARGET();

    ST_AS_LOCAL_TARGET(uint16_t usTgtNumber,uint16_t usTrackState,float fDepth,float fDistance,float fBearing,float fCourse,float fVelocity,float fTargetTS,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint16_t usTgtClsResult,float fTgtClsPrecisionInfo,uint16_t usPulseType,float fPulsePRI,const ::dds::core::array< float, 4L>& aStateVector,const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aPosCovArry,float fTrackReliability,double dLatitude,double dLongitude,float fPosXOnGlobalCoordinate,float fPosYOnGlobalCoordinate,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_LOCAL_TARGET (ST_AS_LOCAL_TARGET&&) = default;
    ST_AS_LOCAL_TARGET& operator=(ST_AS_LOCAL_TARGET&&) = default;
    ST_AS_LOCAL_TARGET& operator=(const ST_AS_LOCAL_TARGET&) = default;
    ST_AS_LOCAL_TARGET(const ST_AS_LOCAL_TARGET&) = default;
    #else
    ST_AS_LOCAL_TARGET(ST_AS_LOCAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_AS_LOCAL_TARGET& operator=(ST_AS_LOCAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    uint16_t& usTrackState() OMG_NOEXCEPT {
        return m_usTrackState_;
    }

    const uint16_t& usTrackState() const OMG_NOEXCEPT {
        return m_usTrackState_;
    }

    void usTrackState(uint16_t value) {
        m_usTrackState_ = value;
    }

    float& fDepth() OMG_NOEXCEPT {
        return m_fDepth_;
    }

    const float& fDepth() const OMG_NOEXCEPT {
        return m_fDepth_;
    }

    void fDepth(float value) {
        m_fDepth_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    float& fTargetTS() OMG_NOEXCEPT {
        return m_fTargetTS_;
    }

    const float& fTargetTS() const OMG_NOEXCEPT {
        return m_fTargetTS_;
    }

    void fTargetTS(float value) {
        m_fTargetTS_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint16_t& usTgtClsResult() OMG_NOEXCEPT {
        return m_usTgtClsResult_;
    }

    const uint16_t& usTgtClsResult() const OMG_NOEXCEPT {
        return m_usTgtClsResult_;
    }

    void usTgtClsResult(uint16_t value) {
        m_usTgtClsResult_ = value;
    }

    float& fTgtClsPrecisionInfo() OMG_NOEXCEPT {
        return m_fTgtClsPrecisionInfo_;
    }

    const float& fTgtClsPrecisionInfo() const OMG_NOEXCEPT {
        return m_fTgtClsPrecisionInfo_;
    }

    void fTgtClsPrecisionInfo(float value) {
        m_fTgtClsPrecisionInfo_ = value;
    }

    uint16_t& usPulseType() OMG_NOEXCEPT {
        return m_usPulseType_;
    }

    const uint16_t& usPulseType() const OMG_NOEXCEPT {
        return m_usPulseType_;
    }

    void usPulseType(uint16_t value) {
        m_usPulseType_ = value;
    }

    float& fPulsePRI() OMG_NOEXCEPT {
        return m_fPulsePRI_;
    }

    const float& fPulsePRI() const OMG_NOEXCEPT {
        return m_fPulsePRI_;
    }

    void fPulsePRI(float value) {
        m_fPulsePRI_ = value;
    }

    ::dds::core::array< float, 4L>& aStateVector() OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    const ::dds::core::array< float, 4L>& aStateVector() const OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    void aStateVector(const ::dds::core::array< float, 4L>& value) {
        m_aStateVector_ = value;
    }

    void aStateVector(::dds::core::array< float, 4L>&& value) {
        m_aStateVector_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aPosCovArry() OMG_NOEXCEPT {
        return m_aPosCovArry_;
    }

    const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aPosCovArry() const OMG_NOEXCEPT {
        return m_aPosCovArry_;
    }

    void aPosCovArry(const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& value) {
        m_aPosCovArry_ = value;
    }

    void aPosCovArry(::dds::core::array< ::dds::core::array< float, 4L>, 4L>&& value) {
        m_aPosCovArry_ = std::move(value);
    }
    float& fTrackReliability() OMG_NOEXCEPT {
        return m_fTrackReliability_;
    }

    const float& fTrackReliability() const OMG_NOEXCEPT {
        return m_fTrackReliability_;
    }

    void fTrackReliability(float value) {
        m_fTrackReliability_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fPosXOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    const float& fPosXOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    void fPosXOnGlobalCoordinate(float value) {
        m_fPosXOnGlobalCoordinate_ = value;
    }

    float& fPosYOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    const float& fPosYOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    void fPosYOnGlobalCoordinate(float value) {
        m_fPosYOnGlobalCoordinate_ = value;
    }

    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    bool operator == (const ST_AS_LOCAL_TARGET& other_) const;
    bool operator != (const ST_AS_LOCAL_TARGET& other_) const;

    void swap(ST_AS_LOCAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNumber_;
    uint16_t m_usTrackState_;
    float m_fDepth_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fCourse_;
    float m_fVelocity_;
    float m_fTargetTS_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint16_t m_usTgtClsResult_;
    float m_fTgtClsPrecisionInfo_;
    uint16_t m_usPulseType_;
    float m_fPulsePRI_;
    ::dds::core::array< float, 4L> m_aStateVector_;
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L> m_aPosCovArry_;
    float m_fTrackReliability_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fPosXOnGlobalCoordinate_;
    float m_fPosYOnGlobalCoordinate_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;

};

inline void swap(ST_AS_LOCAL_TARGET& a, ST_AS_LOCAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_LOCAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO {
  public:
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO();

    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ::dds::core::array< ST_AS_LOCAL_TARGET, 1000L>& stASTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO (TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& operator=(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO&) = default;
    #else
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_AS_LOCAL_TARGET, 1000L>& stASTgtInfo() OMG_NOEXCEPT {
        return m_stASTgtInfo_;
    }

    const ::dds::core::array< ST_AS_LOCAL_TARGET, 1000L>& stASTgtInfo() const OMG_NOEXCEPT {
        return m_stASTgtInfo_;
    }

    void stASTgtInfo(const ::dds::core::array< ST_AS_LOCAL_TARGET, 1000L>& value) {
        m_stASTgtInfo_ = value;
    }

    void stASTgtInfo(::dds::core::array< ST_AS_LOCAL_TARGET, 1000L>&& value) {
        m_stASTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& other_) const;
    bool operator != (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& other_) const;

    void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_AS_LOCAL_TARGET, 1000L> m_stASTgtInfo_;

};

inline void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& a, TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& sample);

class NDDSUSERDllExport ST_BIS_TARGET {
  public:
    ST_BIS_TARGET();

    ST_BIS_TARGET(uint16_t usTgtNumber,const ST_DATE_TIME& stRegistrationTime,uint16_t usTrackMainCnt,uint16_t oTrackStatus,uint8_t oTrackInitType,float fTrackReliability,uint8_t oPulseType,float fPulsePRI,uint16_t usDetectSourceTgtNo,uint8_t oFusionStatus,uint16_t usNoOfAssociatedTgts,const ::dds::core::array< uint16_t, 2L>& aAssociatedTgtNo,uint16_t usBeamNo,float fDistance,float fBearing,float fCourse,float fVelocity,float fDistanceVar,float fBearingVar,float fPosX,float fPosY,float fPosXVar,float fPosYVar,const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& fPosCovArry,const ::dds::core::array< float, 4L>& fBearingCovArry,const ::dds::core::array< float, 4L>& fDistranceCovArry,uint8_t oPairTgtFlag,uint16_t usPairTgtNo,double dLatitude,double dLongitude,float fPosXOnGlobalCoordinate,float fPosYOnGlobalCoordinate,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_TARGET (ST_BIS_TARGET&&) = default;
    ST_BIS_TARGET& operator=(ST_BIS_TARGET&&) = default;
    ST_BIS_TARGET& operator=(const ST_BIS_TARGET&) = default;
    ST_BIS_TARGET(const ST_BIS_TARGET&) = default;
    #else
    ST_BIS_TARGET(ST_BIS_TARGET&& other_) OMG_NOEXCEPT;  
    ST_BIS_TARGET& operator=(ST_BIS_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    uint16_t& usTrackMainCnt() OMG_NOEXCEPT {
        return m_usTrackMainCnt_;
    }

    const uint16_t& usTrackMainCnt() const OMG_NOEXCEPT {
        return m_usTrackMainCnt_;
    }

    void usTrackMainCnt(uint16_t value) {
        m_usTrackMainCnt_ = value;
    }

    uint16_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint16_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint16_t value) {
        m_oTrackStatus_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    float& fTrackReliability() OMG_NOEXCEPT {
        return m_fTrackReliability_;
    }

    const float& fTrackReliability() const OMG_NOEXCEPT {
        return m_fTrackReliability_;
    }

    void fTrackReliability(float value) {
        m_fTrackReliability_ = value;
    }

    uint8_t& oPulseType() OMG_NOEXCEPT {
        return m_oPulseType_;
    }

    const uint8_t& oPulseType() const OMG_NOEXCEPT {
        return m_oPulseType_;
    }

    void oPulseType(uint8_t value) {
        m_oPulseType_ = value;
    }

    float& fPulsePRI() OMG_NOEXCEPT {
        return m_fPulsePRI_;
    }

    const float& fPulsePRI() const OMG_NOEXCEPT {
        return m_fPulsePRI_;
    }

    void fPulsePRI(float value) {
        m_fPulsePRI_ = value;
    }

    uint16_t& usDetectSourceTgtNo() OMG_NOEXCEPT {
        return m_usDetectSourceTgtNo_;
    }

    const uint16_t& usDetectSourceTgtNo() const OMG_NOEXCEPT {
        return m_usDetectSourceTgtNo_;
    }

    void usDetectSourceTgtNo(uint16_t value) {
        m_usDetectSourceTgtNo_ = value;
    }

    uint8_t& oFusionStatus() OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    const uint8_t& oFusionStatus() const OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    void oFusionStatus(uint8_t value) {
        m_oFusionStatus_ = value;
    }

    uint16_t& usNoOfAssociatedTgts() OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    const uint16_t& usNoOfAssociatedTgts() const OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    void usNoOfAssociatedTgts(uint16_t value) {
        m_usNoOfAssociatedTgts_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aAssociatedTgtNo() OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    const ::dds::core::array< uint16_t, 2L>& aAssociatedTgtNo() const OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    void aAssociatedTgtNo(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aAssociatedTgtNo_ = value;
    }

    void aAssociatedTgtNo(::dds::core::array< uint16_t, 2L>&& value) {
        m_aAssociatedTgtNo_ = std::move(value);
    }
    uint16_t& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const uint16_t& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(uint16_t value) {
        m_usBeamNo_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    float& fDistanceVar() OMG_NOEXCEPT {
        return m_fDistanceVar_;
    }

    const float& fDistanceVar() const OMG_NOEXCEPT {
        return m_fDistanceVar_;
    }

    void fDistanceVar(float value) {
        m_fDistanceVar_ = value;
    }

    float& fBearingVar() OMG_NOEXCEPT {
        return m_fBearingVar_;
    }

    const float& fBearingVar() const OMG_NOEXCEPT {
        return m_fBearingVar_;
    }

    void fBearingVar(float value) {
        m_fBearingVar_ = value;
    }

    float& fPosX() OMG_NOEXCEPT {
        return m_fPosX_;
    }

    const float& fPosX() const OMG_NOEXCEPT {
        return m_fPosX_;
    }

    void fPosX(float value) {
        m_fPosX_ = value;
    }

    float& fPosY() OMG_NOEXCEPT {
        return m_fPosY_;
    }

    const float& fPosY() const OMG_NOEXCEPT {
        return m_fPosY_;
    }

    void fPosY(float value) {
        m_fPosY_ = value;
    }

    float& fPosXVar() OMG_NOEXCEPT {
        return m_fPosXVar_;
    }

    const float& fPosXVar() const OMG_NOEXCEPT {
        return m_fPosXVar_;
    }

    void fPosXVar(float value) {
        m_fPosXVar_ = value;
    }

    float& fPosYVar() OMG_NOEXCEPT {
        return m_fPosYVar_;
    }

    const float& fPosYVar() const OMG_NOEXCEPT {
        return m_fPosYVar_;
    }

    void fPosYVar(float value) {
        m_fPosYVar_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& fPosCovArry() OMG_NOEXCEPT {
        return m_fPosCovArry_;
    }

    const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& fPosCovArry() const OMG_NOEXCEPT {
        return m_fPosCovArry_;
    }

    void fPosCovArry(const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& value) {
        m_fPosCovArry_ = value;
    }

    void fPosCovArry(::dds::core::array< ::dds::core::array< float, 4L>, 4L>&& value) {
        m_fPosCovArry_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fBearingCovArry() OMG_NOEXCEPT {
        return m_fBearingCovArry_;
    }

    const ::dds::core::array< float, 4L>& fBearingCovArry() const OMG_NOEXCEPT {
        return m_fBearingCovArry_;
    }

    void fBearingCovArry(const ::dds::core::array< float, 4L>& value) {
        m_fBearingCovArry_ = value;
    }

    void fBearingCovArry(::dds::core::array< float, 4L>&& value) {
        m_fBearingCovArry_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fDistranceCovArry() OMG_NOEXCEPT {
        return m_fDistranceCovArry_;
    }

    const ::dds::core::array< float, 4L>& fDistranceCovArry() const OMG_NOEXCEPT {
        return m_fDistranceCovArry_;
    }

    void fDistranceCovArry(const ::dds::core::array< float, 4L>& value) {
        m_fDistranceCovArry_ = value;
    }

    void fDistranceCovArry(::dds::core::array< float, 4L>&& value) {
        m_fDistranceCovArry_ = std::move(value);
    }
    uint8_t& oPairTgtFlag() OMG_NOEXCEPT {
        return m_oPairTgtFlag_;
    }

    const uint8_t& oPairTgtFlag() const OMG_NOEXCEPT {
        return m_oPairTgtFlag_;
    }

    void oPairTgtFlag(uint8_t value) {
        m_oPairTgtFlag_ = value;
    }

    uint16_t& usPairTgtNo() OMG_NOEXCEPT {
        return m_usPairTgtNo_;
    }

    const uint16_t& usPairTgtNo() const OMG_NOEXCEPT {
        return m_usPairTgtNo_;
    }

    void usPairTgtNo(uint16_t value) {
        m_usPairTgtNo_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fPosXOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    const float& fPosXOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    void fPosXOnGlobalCoordinate(float value) {
        m_fPosXOnGlobalCoordinate_ = value;
    }

    float& fPosYOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    const float& fPosYOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    void fPosYOnGlobalCoordinate(float value) {
        m_fPosYOnGlobalCoordinate_ = value;
    }

    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    bool operator == (const ST_BIS_TARGET& other_) const;
    bool operator != (const ST_BIS_TARGET& other_) const;

    void swap(ST_BIS_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNumber_;
    ST_DATE_TIME m_stRegistrationTime_;
    uint16_t m_usTrackMainCnt_;
    uint16_t m_oTrackStatus_;
    uint8_t m_oTrackInitType_;
    float m_fTrackReliability_;
    uint8_t m_oPulseType_;
    float m_fPulsePRI_;
    uint16_t m_usDetectSourceTgtNo_;
    uint8_t m_oFusionStatus_;
    uint16_t m_usNoOfAssociatedTgts_;
    ::dds::core::array< uint16_t, 2L> m_aAssociatedTgtNo_;
    uint16_t m_usBeamNo_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fCourse_;
    float m_fVelocity_;
    float m_fDistanceVar_;
    float m_fBearingVar_;
    float m_fPosX_;
    float m_fPosY_;
    float m_fPosXVar_;
    float m_fPosYVar_;
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L> m_fPosCovArry_;
    ::dds::core::array< float, 4L> m_fBearingCovArry_;
    ::dds::core::array< float, 4L> m_fDistranceCovArry_;
    uint8_t m_oPairTgtFlag_;
    uint16_t m_usPairTgtNo_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fPosXOnGlobalCoordinate_;
    float m_fPosYOnGlobalCoordinate_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;

};

inline void swap(ST_BIS_TARGET& a, ST_BIS_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_TARGET& sample);

class NDDSUSERDllExport ST_BIS_LOCAL_TARGET {
  public:
    ST_BIS_LOCAL_TARGET();

    ST_BIS_LOCAL_TARGET(uint16_t usSensorID,uint16_t usNumOfTargets,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_BIS_TARGET, 192L>& stBisTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_LOCAL_TARGET (ST_BIS_LOCAL_TARGET&&) = default;
    ST_BIS_LOCAL_TARGET& operator=(ST_BIS_LOCAL_TARGET&&) = default;
    ST_BIS_LOCAL_TARGET& operator=(const ST_BIS_LOCAL_TARGET&) = default;
    ST_BIS_LOCAL_TARGET(const ST_BIS_LOCAL_TARGET&) = default;
    #else
    ST_BIS_LOCAL_TARGET(ST_BIS_LOCAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_BIS_LOCAL_TARGET& operator=(ST_BIS_LOCAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_TARGET, 192L>& stBisTargetLocal() OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    const ::dds::core::array< ST_BIS_TARGET, 192L>& stBisTargetLocal() const OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    void stBisTargetLocal(const ::dds::core::array< ST_BIS_TARGET, 192L>& value) {
        m_stBisTargetLocal_ = value;
    }

    void stBisTargetLocal(::dds::core::array< ST_BIS_TARGET, 192L>&& value) {
        m_stBisTargetLocal_ = std::move(value);
    }

    bool operator == (const ST_BIS_LOCAL_TARGET& other_) const;
    bool operator != (const ST_BIS_LOCAL_TARGET& other_) const;

    void swap(ST_BIS_LOCAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_BIS_TARGET, 192L> m_stBisTargetLocal_;

};

inline void swap(ST_BIS_LOCAL_TARGET& a, ST_BIS_LOCAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_LOCAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO {
  public:
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO();

    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,const ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& stBISTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO (TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& operator=(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO&) = default;
    #else
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& stBISTgtInfo() OMG_NOEXCEPT {
        return m_stBISTgtInfo_;
    }

    const ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& stBISTgtInfo() const OMG_NOEXCEPT {
        return m_stBISTgtInfo_;
    }

    void stBISTgtInfo(const ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& value) {
        m_stBISTgtInfo_ = value;
    }

    void stBISTgtInfo(::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>&& value) {
        m_stBISTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& other_) const;
    bool operator != (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& other_) const;

    void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L> m_stBISTgtInfo_;

};

inline void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& a, TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& sample);

class NDDSUSERDllExport ST_EO_LOCAL_TARGET {
  public:
    ST_EO_LOCAL_TARGET();

    ST_EO_LOCAL_TARGET(uint16_t usTargetType,const ST_DATE_TIME& stUpdateTime,float fElevation,float fAzimuth,uint16_t usEOSensorType,uint16_t usTrackingStatus,const ST_DATE_TIME& stDistanceMeasureTime,const ST_DATE_TIME& stRegistrationTime,float fDistanceInfo,double dLatitude,double dLongitude,float fPosXOnGlobalCoordinate,float fPosYOnGlobalCoordinate,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_EO_LOCAL_TARGET (ST_EO_LOCAL_TARGET&&) = default;
    ST_EO_LOCAL_TARGET& operator=(ST_EO_LOCAL_TARGET&&) = default;
    ST_EO_LOCAL_TARGET& operator=(const ST_EO_LOCAL_TARGET&) = default;
    ST_EO_LOCAL_TARGET(const ST_EO_LOCAL_TARGET&) = default;
    #else
    ST_EO_LOCAL_TARGET(ST_EO_LOCAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_EO_LOCAL_TARGET& operator=(ST_EO_LOCAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTargetType() OMG_NOEXCEPT {
        return m_usTargetType_;
    }

    const uint16_t& usTargetType() const OMG_NOEXCEPT {
        return m_usTargetType_;
    }

    void usTargetType(uint16_t value) {
        m_usTargetType_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    float& fElevation() OMG_NOEXCEPT {
        return m_fElevation_;
    }

    const float& fElevation() const OMG_NOEXCEPT {
        return m_fElevation_;
    }

    void fElevation(float value) {
        m_fElevation_ = value;
    }

    float& fAzimuth() OMG_NOEXCEPT {
        return m_fAzimuth_;
    }

    const float& fAzimuth() const OMG_NOEXCEPT {
        return m_fAzimuth_;
    }

    void fAzimuth(float value) {
        m_fAzimuth_ = value;
    }

    uint16_t& usEOSensorType() OMG_NOEXCEPT {
        return m_usEOSensorType_;
    }

    const uint16_t& usEOSensorType() const OMG_NOEXCEPT {
        return m_usEOSensorType_;
    }

    void usEOSensorType(uint16_t value) {
        m_usEOSensorType_ = value;
    }

    uint16_t& usTrackingStatus() OMG_NOEXCEPT {
        return m_usTrackingStatus_;
    }

    const uint16_t& usTrackingStatus() const OMG_NOEXCEPT {
        return m_usTrackingStatus_;
    }

    void usTrackingStatus(uint16_t value) {
        m_usTrackingStatus_ = value;
    }

    ST_DATE_TIME& stDistanceMeasureTime() OMG_NOEXCEPT {
        return m_stDistanceMeasureTime_;
    }

    const ST_DATE_TIME& stDistanceMeasureTime() const OMG_NOEXCEPT {
        return m_stDistanceMeasureTime_;
    }

    void stDistanceMeasureTime(const ST_DATE_TIME& value) {
        m_stDistanceMeasureTime_ = value;
    }

    void stDistanceMeasureTime(ST_DATE_TIME&& value) {
        m_stDistanceMeasureTime_ = std::move(value);
    }
    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    float& fDistanceInfo() OMG_NOEXCEPT {
        return m_fDistanceInfo_;
    }

    const float& fDistanceInfo() const OMG_NOEXCEPT {
        return m_fDistanceInfo_;
    }

    void fDistanceInfo(float value) {
        m_fDistanceInfo_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fPosXOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    const float& fPosXOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    void fPosXOnGlobalCoordinate(float value) {
        m_fPosXOnGlobalCoordinate_ = value;
    }

    float& fPosYOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    const float& fPosYOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    void fPosYOnGlobalCoordinate(float value) {
        m_fPosYOnGlobalCoordinate_ = value;
    }

    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    bool operator == (const ST_EO_LOCAL_TARGET& other_) const;
    bool operator != (const ST_EO_LOCAL_TARGET& other_) const;

    void swap(ST_EO_LOCAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTargetType_;
    ST_DATE_TIME m_stUpdateTime_;
    float m_fElevation_;
    float m_fAzimuth_;
    uint16_t m_usEOSensorType_;
    uint16_t m_usTrackingStatus_;
    ST_DATE_TIME m_stDistanceMeasureTime_;
    ST_DATE_TIME m_stRegistrationTime_;
    float m_fDistanceInfo_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fPosXOnGlobalCoordinate_;
    float m_fPosYOnGlobalCoordinate_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;

};

inline void swap(ST_EO_LOCAL_TARGET& a, ST_EO_LOCAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_EO_LOCAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO {
  public:
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO();

    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,const ST_EO_LOCAL_TARGET& stEOTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO (TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& operator=(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO&) = default;
    #else
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ST_EO_LOCAL_TARGET& stEOTgtInfo() OMG_NOEXCEPT {
        return m_stEOTgtInfo_;
    }

    const ST_EO_LOCAL_TARGET& stEOTgtInfo() const OMG_NOEXCEPT {
        return m_stEOTgtInfo_;
    }

    void stEOTgtInfo(const ST_EO_LOCAL_TARGET& value) {
        m_stEOTgtInfo_ = value;
    }

    void stEOTgtInfo(ST_EO_LOCAL_TARGET&& value) {
        m_stEOTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& other_) const;
    bool operator != (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& other_) const;

    void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    ST_EO_LOCAL_TARGET m_stEOTgtInfo_;

};

inline void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& a, TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& sample);

class NDDSUSERDllExport ST_KNTDS_NETWORK_TARGET {
  public:
    ST_KNTDS_NETWORK_TARGET();

    ST_KNTDS_NETWORK_TARGET(uint32_t ulTgtNumber,uint8_t ucTrackStat,uint8_t ucTrackQuality,uint8_t ucTrackSize,uint8_t ucKind,uint8_t ucClass,uint8_t ucCategory,uint8_t ucIdentify,float fDistance,float fBearing,float fCourse,float fVelocity,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint32_t ulMaintainTime,const ::dds::core::array< uint8_t, 6L>& ucTag,double dLatitude,double dLongitude,float fPosXOnGlobalCoordinate,float fPosYOnGlobalCoordinate,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_KNTDS_NETWORK_TARGET (ST_KNTDS_NETWORK_TARGET&&) = default;
    ST_KNTDS_NETWORK_TARGET& operator=(ST_KNTDS_NETWORK_TARGET&&) = default;
    ST_KNTDS_NETWORK_TARGET& operator=(const ST_KNTDS_NETWORK_TARGET&) = default;
    ST_KNTDS_NETWORK_TARGET(const ST_KNTDS_NETWORK_TARGET&) = default;
    #else
    ST_KNTDS_NETWORK_TARGET(ST_KNTDS_NETWORK_TARGET&& other_) OMG_NOEXCEPT;  
    ST_KNTDS_NETWORK_TARGET& operator=(ST_KNTDS_NETWORK_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulTgtNumber() OMG_NOEXCEPT {
        return m_ulTgtNumber_;
    }

    const uint32_t& ulTgtNumber() const OMG_NOEXCEPT {
        return m_ulTgtNumber_;
    }

    void ulTgtNumber(uint32_t value) {
        m_ulTgtNumber_ = value;
    }

    uint8_t& ucTrackStat() OMG_NOEXCEPT {
        return m_ucTrackStat_;
    }

    const uint8_t& ucTrackStat() const OMG_NOEXCEPT {
        return m_ucTrackStat_;
    }

    void ucTrackStat(uint8_t value) {
        m_ucTrackStat_ = value;
    }

    uint8_t& ucTrackQuality() OMG_NOEXCEPT {
        return m_ucTrackQuality_;
    }

    const uint8_t& ucTrackQuality() const OMG_NOEXCEPT {
        return m_ucTrackQuality_;
    }

    void ucTrackQuality(uint8_t value) {
        m_ucTrackQuality_ = value;
    }

    uint8_t& ucTrackSize() OMG_NOEXCEPT {
        return m_ucTrackSize_;
    }

    const uint8_t& ucTrackSize() const OMG_NOEXCEPT {
        return m_ucTrackSize_;
    }

    void ucTrackSize(uint8_t value) {
        m_ucTrackSize_ = value;
    }

    uint8_t& ucKind() OMG_NOEXCEPT {
        return m_ucKind_;
    }

    const uint8_t& ucKind() const OMG_NOEXCEPT {
        return m_ucKind_;
    }

    void ucKind(uint8_t value) {
        m_ucKind_ = value;
    }

    uint8_t& ucClass() OMG_NOEXCEPT {
        return m_ucClass_;
    }

    const uint8_t& ucClass() const OMG_NOEXCEPT {
        return m_ucClass_;
    }

    void ucClass(uint8_t value) {
        m_ucClass_ = value;
    }

    uint8_t& ucCategory() OMG_NOEXCEPT {
        return m_ucCategory_;
    }

    const uint8_t& ucCategory() const OMG_NOEXCEPT {
        return m_ucCategory_;
    }

    void ucCategory(uint8_t value) {
        m_ucCategory_ = value;
    }

    uint8_t& ucIdentify() OMG_NOEXCEPT {
        return m_ucIdentify_;
    }

    const uint8_t& ucIdentify() const OMG_NOEXCEPT {
        return m_ucIdentify_;
    }

    void ucIdentify(uint8_t value) {
        m_ucIdentify_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint32_t& ulMaintainTime() OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    const uint32_t& ulMaintainTime() const OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    void ulMaintainTime(uint32_t value) {
        m_ulMaintainTime_ = value;
    }

    ::dds::core::array< uint8_t, 6L>& ucTag() OMG_NOEXCEPT {
        return m_ucTag_;
    }

    const ::dds::core::array< uint8_t, 6L>& ucTag() const OMG_NOEXCEPT {
        return m_ucTag_;
    }

    void ucTag(const ::dds::core::array< uint8_t, 6L>& value) {
        m_ucTag_ = value;
    }

    void ucTag(::dds::core::array< uint8_t, 6L>&& value) {
        m_ucTag_ = std::move(value);
    }
    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fPosXOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    const float& fPosXOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    void fPosXOnGlobalCoordinate(float value) {
        m_fPosXOnGlobalCoordinate_ = value;
    }

    float& fPosYOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    const float& fPosYOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    void fPosYOnGlobalCoordinate(float value) {
        m_fPosYOnGlobalCoordinate_ = value;
    }

    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    bool operator == (const ST_KNTDS_NETWORK_TARGET& other_) const;
    bool operator != (const ST_KNTDS_NETWORK_TARGET& other_) const;

    void swap(ST_KNTDS_NETWORK_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulTgtNumber_;
    uint8_t m_ucTrackStat_;
    uint8_t m_ucTrackQuality_;
    uint8_t m_ucTrackSize_;
    uint8_t m_ucKind_;
    uint8_t m_ucClass_;
    uint8_t m_ucCategory_;
    uint8_t m_ucIdentify_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fCourse_;
    float m_fVelocity_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint32_t m_ulMaintainTime_;
    ::dds::core::array< uint8_t, 6L> m_ucTag_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fPosXOnGlobalCoordinate_;
    float m_fPosYOnGlobalCoordinate_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;

};

inline void swap(ST_KNTDS_NETWORK_TARGET& a, ST_KNTDS_NETWORK_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_KNTDS_NETWORK_TARGET& sample);

class NDDSUSERDllExport TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO {
  public:
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO();

    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& stKNTDSTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO (TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& operator=(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO&) = default;
    #else
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& stKNTDSTgtInfo() OMG_NOEXCEPT {
        return m_stKNTDSTgtInfo_;
    }

    const ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& stKNTDSTgtInfo() const OMG_NOEXCEPT {
        return m_stKNTDSTgtInfo_;
    }

    void stKNTDSTgtInfo(const ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& value) {
        m_stKNTDSTgtInfo_ = value;
    }

    void stKNTDSTgtInfo(::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>&& value) {
        m_stKNTDSTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& other_) const;
    bool operator != (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& other_) const;

    void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L> m_stKNTDSTgtInfo_;

};

inline void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& a, TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& sample);

class NDDSUSERDllExport ST_LAS_FREQ_INFO {
  public:
    ST_LAS_FREQ_INFO();

    ST_LAS_FREQ_INFO(uint8_t oFreqTrackStatus,float fTonalFreq,uint8_t oOitUserID,uint16_t usTmpTgtNo,float fSNR,uint8_t oTrackInitType,uint16_t aIsThreatFreq,float fFreqRate,const ::dds::core::array< float, 4L>& aFreqCovArry);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_FREQ_INFO (ST_LAS_FREQ_INFO&&) = default;
    ST_LAS_FREQ_INFO& operator=(ST_LAS_FREQ_INFO&&) = default;
    ST_LAS_FREQ_INFO& operator=(const ST_LAS_FREQ_INFO&) = default;
    ST_LAS_FREQ_INFO(const ST_LAS_FREQ_INFO&) = default;
    #else
    ST_LAS_FREQ_INFO(ST_LAS_FREQ_INFO&& other_) OMG_NOEXCEPT;  
    ST_LAS_FREQ_INFO& operator=(ST_LAS_FREQ_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oFreqTrackStatus() OMG_NOEXCEPT {
        return m_oFreqTrackStatus_;
    }

    const uint8_t& oFreqTrackStatus() const OMG_NOEXCEPT {
        return m_oFreqTrackStatus_;
    }

    void oFreqTrackStatus(uint8_t value) {
        m_oFreqTrackStatus_ = value;
    }

    float& fTonalFreq() OMG_NOEXCEPT {
        return m_fTonalFreq_;
    }

    const float& fTonalFreq() const OMG_NOEXCEPT {
        return m_fTonalFreq_;
    }

    void fTonalFreq(float value) {
        m_fTonalFreq_ = value;
    }

    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    float& fSNR() OMG_NOEXCEPT {
        return m_fSNR_;
    }

    const float& fSNR() const OMG_NOEXCEPT {
        return m_fSNR_;
    }

    void fSNR(float value) {
        m_fSNR_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    uint16_t& aIsThreatFreq() OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    const uint16_t& aIsThreatFreq() const OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    void aIsThreatFreq(uint16_t value) {
        m_aIsThreatFreq_ = value;
    }

    float& fFreqRate() OMG_NOEXCEPT {
        return m_fFreqRate_;
    }

    const float& fFreqRate() const OMG_NOEXCEPT {
        return m_fFreqRate_;
    }

    void fFreqRate(float value) {
        m_fFreqRate_ = value;
    }

    ::dds::core::array< float, 4L>& aFreqCovArry() OMG_NOEXCEPT {
        return m_aFreqCovArry_;
    }

    const ::dds::core::array< float, 4L>& aFreqCovArry() const OMG_NOEXCEPT {
        return m_aFreqCovArry_;
    }

    void aFreqCovArry(const ::dds::core::array< float, 4L>& value) {
        m_aFreqCovArry_ = value;
    }

    void aFreqCovArry(::dds::core::array< float, 4L>&& value) {
        m_aFreqCovArry_ = std::move(value);
    }

    bool operator == (const ST_LAS_FREQ_INFO& other_) const;
    bool operator != (const ST_LAS_FREQ_INFO& other_) const;

    void swap(ST_LAS_FREQ_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oFreqTrackStatus_;
    float m_fTonalFreq_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;
    float m_fSNR_;
    uint8_t m_oTrackInitType_;
    uint16_t m_aIsThreatFreq_;
    float m_fFreqRate_;
    ::dds::core::array< float, 4L> m_aFreqCovArry_;

};

inline void swap(ST_LAS_FREQ_INFO& a, ST_LAS_FREQ_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_FREQ_INFO& sample);

class NDDSUSERDllExport ST_LAS_TARGET {
  public:
    ST_LAS_TARGET();

    ST_LAS_TARGET(uint16_t usTgtNumber,const ST_DATE_TIME& stRegistrationTime,uint16_t usTrackMainCnt,uint8_t oTrackStatus,uint16_t usBeamNo,uint8_t oTrackInitType,uint8_t oFusionStatus,uint8_t oTrackReliability,uint16_t usNoOfAssociatedTgts,const ::dds::core::array< uint16_t, 5L>& aAssociatedTgtNo,const ::dds::core::array< float, 5L>& aAssociatedBearing,float fBearing,float fBearingRate,const ::dds::core::array< float, 4L>& aBearingCovArray,uint8_t oLofarTonalFreqCnt,const ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& aLofarFreqInfo,uint8_t oDemonTonalFreqCnt,const ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& aDemonFreqInfo,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo,uint16_t usPairTgtNo,uint8_t IsInitByUserAssociation,uint8_t oOriginSensorAxis,uint16_t usOriginTargetNo,const ::dds::core::array< uint16_t, 2L>& usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_TARGET (ST_LAS_TARGET&&) = default;
    ST_LAS_TARGET& operator=(ST_LAS_TARGET&&) = default;
    ST_LAS_TARGET& operator=(const ST_LAS_TARGET&) = default;
    ST_LAS_TARGET(const ST_LAS_TARGET&) = default;
    #else
    ST_LAS_TARGET(ST_LAS_TARGET&& other_) OMG_NOEXCEPT;  
    ST_LAS_TARGET& operator=(ST_LAS_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    uint16_t& usTrackMainCnt() OMG_NOEXCEPT {
        return m_usTrackMainCnt_;
    }

    const uint16_t& usTrackMainCnt() const OMG_NOEXCEPT {
        return m_usTrackMainCnt_;
    }

    void usTrackMainCnt(uint16_t value) {
        m_usTrackMainCnt_ = value;
    }

    uint8_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint8_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint8_t value) {
        m_oTrackStatus_ = value;
    }

    uint16_t& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const uint16_t& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(uint16_t value) {
        m_usBeamNo_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    uint8_t& oFusionStatus() OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    const uint8_t& oFusionStatus() const OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    void oFusionStatus(uint8_t value) {
        m_oFusionStatus_ = value;
    }

    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    uint16_t& usNoOfAssociatedTgts() OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    const uint16_t& usNoOfAssociatedTgts() const OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    void usNoOfAssociatedTgts(uint16_t value) {
        m_usNoOfAssociatedTgts_ = value;
    }

    ::dds::core::array< uint16_t, 5L>& aAssociatedTgtNo() OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    const ::dds::core::array< uint16_t, 5L>& aAssociatedTgtNo() const OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    void aAssociatedTgtNo(const ::dds::core::array< uint16_t, 5L>& value) {
        m_aAssociatedTgtNo_ = value;
    }

    void aAssociatedTgtNo(::dds::core::array< uint16_t, 5L>&& value) {
        m_aAssociatedTgtNo_ = std::move(value);
    }
    ::dds::core::array< float, 5L>& aAssociatedBearing() OMG_NOEXCEPT {
        return m_aAssociatedBearing_;
    }

    const ::dds::core::array< float, 5L>& aAssociatedBearing() const OMG_NOEXCEPT {
        return m_aAssociatedBearing_;
    }

    void aAssociatedBearing(const ::dds::core::array< float, 5L>& value) {
        m_aAssociatedBearing_ = value;
    }

    void aAssociatedBearing(::dds::core::array< float, 5L>&& value) {
        m_aAssociatedBearing_ = std::move(value);
    }
    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fBearingRate() OMG_NOEXCEPT {
        return m_fBearingRate_;
    }

    const float& fBearingRate() const OMG_NOEXCEPT {
        return m_fBearingRate_;
    }

    void fBearingRate(float value) {
        m_fBearingRate_ = value;
    }

    ::dds::core::array< float, 4L>& aBearingCovArray() OMG_NOEXCEPT {
        return m_aBearingCovArray_;
    }

    const ::dds::core::array< float, 4L>& aBearingCovArray() const OMG_NOEXCEPT {
        return m_aBearingCovArray_;
    }

    void aBearingCovArray(const ::dds::core::array< float, 4L>& value) {
        m_aBearingCovArray_ = value;
    }

    void aBearingCovArray(::dds::core::array< float, 4L>&& value) {
        m_aBearingCovArray_ = std::move(value);
    }
    uint8_t& oLofarTonalFreqCnt() OMG_NOEXCEPT {
        return m_oLofarTonalFreqCnt_;
    }

    const uint8_t& oLofarTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oLofarTonalFreqCnt_;
    }

    void oLofarTonalFreqCnt(uint8_t value) {
        m_oLofarTonalFreqCnt_ = value;
    }

    ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& aLofarFreqInfo() OMG_NOEXCEPT {
        return m_aLofarFreqInfo_;
    }

    const ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& aLofarFreqInfo() const OMG_NOEXCEPT {
        return m_aLofarFreqInfo_;
    }

    void aLofarFreqInfo(const ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& value) {
        m_aLofarFreqInfo_ = value;
    }

    void aLofarFreqInfo(::dds::core::array< ST_LAS_FREQ_INFO, 24L>&& value) {
        m_aLofarFreqInfo_ = std::move(value);
    }
    uint8_t& oDemonTonalFreqCnt() OMG_NOEXCEPT {
        return m_oDemonTonalFreqCnt_;
    }

    const uint8_t& oDemonTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oDemonTonalFreqCnt_;
    }

    void oDemonTonalFreqCnt(uint8_t value) {
        m_oDemonTonalFreqCnt_ = value;
    }

    ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& aDemonFreqInfo() OMG_NOEXCEPT {
        return m_aDemonFreqInfo_;
    }

    const ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& aDemonFreqInfo() const OMG_NOEXCEPT {
        return m_aDemonFreqInfo_;
    }

    void aDemonFreqInfo(const ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& value) {
        m_aDemonFreqInfo_ = value;
    }

    void aDemonFreqInfo(::dds::core::array< ST_LAS_FREQ_INFO, 8L>&& value) {
        m_aDemonFreqInfo_ = std::move(value);
    }
    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    uint16_t& usPairTgtNo() OMG_NOEXCEPT {
        return m_usPairTgtNo_;
    }

    const uint16_t& usPairTgtNo() const OMG_NOEXCEPT {
        return m_usPairTgtNo_;
    }

    void usPairTgtNo(uint16_t value) {
        m_usPairTgtNo_ = value;
    }

    uint8_t& IsInitByUserAssociation() OMG_NOEXCEPT {
        return m_IsInitByUserAssociation_;
    }

    const uint8_t& IsInitByUserAssociation() const OMG_NOEXCEPT {
        return m_IsInitByUserAssociation_;
    }

    void IsInitByUserAssociation(uint8_t value) {
        m_IsInitByUserAssociation_ = value;
    }

    uint8_t& oOriginSensorAxis() OMG_NOEXCEPT {
        return m_oOriginSensorAxis_;
    }

    const uint8_t& oOriginSensorAxis() const OMG_NOEXCEPT {
        return m_oOriginSensorAxis_;
    }

    void oOriginSensorAxis(uint8_t value) {
        m_oOriginSensorAxis_ = value;
    }

    uint16_t& usOriginTargetNo() OMG_NOEXCEPT {
        return m_usOriginTargetNo_;
    }

    const uint16_t& usOriginTargetNo() const OMG_NOEXCEPT {
        return m_usOriginTargetNo_;
    }

    void usOriginTargetNo(uint16_t value) {
        m_usOriginTargetNo_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usReserved_ = value;
    }

    void usReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_usReserved_ = std::move(value);
    }

    bool operator == (const ST_LAS_TARGET& other_) const;
    bool operator != (const ST_LAS_TARGET& other_) const;

    void swap(ST_LAS_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNumber_;
    ST_DATE_TIME m_stRegistrationTime_;
    uint16_t m_usTrackMainCnt_;
    uint8_t m_oTrackStatus_;
    uint16_t m_usBeamNo_;
    uint8_t m_oTrackInitType_;
    uint8_t m_oFusionStatus_;
    uint8_t m_oTrackReliability_;
    uint16_t m_usNoOfAssociatedTgts_;
    ::dds::core::array< uint16_t, 5L> m_aAssociatedTgtNo_;
    ::dds::core::array< float, 5L> m_aAssociatedBearing_;
    float m_fBearing_;
    float m_fBearingRate_;
    ::dds::core::array< float, 4L> m_aBearingCovArray_;
    uint8_t m_oLofarTonalFreqCnt_;
    ::dds::core::array< ST_LAS_FREQ_INFO, 24L> m_aLofarFreqInfo_;
    uint8_t m_oDemonTonalFreqCnt_;
    ::dds::core::array< ST_LAS_FREQ_INFO, 8L> m_aDemonFreqInfo_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;
    uint16_t m_usPairTgtNo_;
    uint8_t m_IsInitByUserAssociation_;
    uint8_t m_oOriginSensorAxis_;
    uint16_t m_usOriginTargetNo_;
    ::dds::core::array< uint16_t, 2L> m_usReserved_;

};

inline void swap(ST_LAS_TARGET& a, ST_LAS_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_TARGET& sample);

class NDDSUSERDllExport ST_LAS_LOCAL_TARGET {
  public:
    ST_LAS_LOCAL_TARGET();

    ST_LAS_LOCAL_TARGET(uint16_t usSensorID,uint16_t usNumOfTargets,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_LAS_TARGET, 320L>& stLasTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_LOCAL_TARGET (ST_LAS_LOCAL_TARGET&&) = default;
    ST_LAS_LOCAL_TARGET& operator=(ST_LAS_LOCAL_TARGET&&) = default;
    ST_LAS_LOCAL_TARGET& operator=(const ST_LAS_LOCAL_TARGET&) = default;
    ST_LAS_LOCAL_TARGET(const ST_LAS_LOCAL_TARGET&) = default;
    #else
    ST_LAS_LOCAL_TARGET(ST_LAS_LOCAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_LAS_LOCAL_TARGET& operator=(ST_LAS_LOCAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_LAS_TARGET, 320L>& stLasTargetLocal() OMG_NOEXCEPT {
        return m_stLasTargetLocal_;
    }

    const ::dds::core::array< ST_LAS_TARGET, 320L>& stLasTargetLocal() const OMG_NOEXCEPT {
        return m_stLasTargetLocal_;
    }

    void stLasTargetLocal(const ::dds::core::array< ST_LAS_TARGET, 320L>& value) {
        m_stLasTargetLocal_ = value;
    }

    void stLasTargetLocal(::dds::core::array< ST_LAS_TARGET, 320L>&& value) {
        m_stLasTargetLocal_ = std::move(value);
    }

    bool operator == (const ST_LAS_LOCAL_TARGET& other_) const;
    bool operator != (const ST_LAS_LOCAL_TARGET& other_) const;

    void swap(ST_LAS_LOCAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_LAS_TARGET, 320L> m_stLasTargetLocal_;

};

inline void swap(ST_LAS_LOCAL_TARGET& a, ST_LAS_LOCAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_LOCAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO {
  public:
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO();

    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,const ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& stLASTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO (TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& operator=(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO&) = default;
    #else
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& stLASTgtInfo() OMG_NOEXCEPT {
        return m_stLASTgtInfo_;
    }

    const ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& stLASTgtInfo() const OMG_NOEXCEPT {
        return m_stLASTgtInfo_;
    }

    void stLASTgtInfo(const ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& value) {
        m_stLASTgtInfo_ = value;
    }

    void stLASTgtInfo(::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>&& value) {
        m_stLASTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& other_) const;
    bool operator != (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& other_) const;

    void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L> m_stLASTgtInfo_;

};

inline void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& a, TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& sample);

class NDDSUSERDllExport ST_MAS_TARGET {
  public:
    ST_MAS_TARGET();

    ST_MAS_TARGET(uint16_t usTgtNumber,const ST_DATE_TIME& stRegistrationTime,uint16_t usTrackMainCnt,uint8_t oTrackStatus,uint8_t oTrackInitType,float fTrackReliabiliy,uint16_t usMASDetectionType,uint16_t usFusionStatus,uint16_t usAllFusedSectorNo,uint16_t usMagSectorNo,uint16_t usAcoSectorNo,uint16_t usBbdSectorNo,uint16_t usNbdSectorNo,uint16_t usMagSensorNo,uint16_t usAcoSensorNo,float fLineMagSyntheSig,double dLatitude,double dLongitude,float fPosXOnGlobalCoordinate,float fPosYOnGlobalCoordinate,uint8_t oTgtAssoFlag,uint16_t usAssoTgtNo,uint16_t usAcoLofFreqNo,const ::dds::core::array< float, 24L>& aAcoLofFreqInfo,uint16_t usAcoDemFreqNo,const ::dds::core::array< float, 8L>& aAcoDemFreqInfo,uint16_t usInOutInfo,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_TARGET (ST_MAS_TARGET&&) = default;
    ST_MAS_TARGET& operator=(ST_MAS_TARGET&&) = default;
    ST_MAS_TARGET& operator=(const ST_MAS_TARGET&) = default;
    ST_MAS_TARGET(const ST_MAS_TARGET&) = default;
    #else
    ST_MAS_TARGET(ST_MAS_TARGET&& other_) OMG_NOEXCEPT;  
    ST_MAS_TARGET& operator=(ST_MAS_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    uint16_t& usTrackMainCnt() OMG_NOEXCEPT {
        return m_usTrackMainCnt_;
    }

    const uint16_t& usTrackMainCnt() const OMG_NOEXCEPT {
        return m_usTrackMainCnt_;
    }

    void usTrackMainCnt(uint16_t value) {
        m_usTrackMainCnt_ = value;
    }

    uint8_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint8_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint8_t value) {
        m_oTrackStatus_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    float& fTrackReliabiliy() OMG_NOEXCEPT {
        return m_fTrackReliabiliy_;
    }

    const float& fTrackReliabiliy() const OMG_NOEXCEPT {
        return m_fTrackReliabiliy_;
    }

    void fTrackReliabiliy(float value) {
        m_fTrackReliabiliy_ = value;
    }

    uint16_t& usMASDetectionType() OMG_NOEXCEPT {
        return m_usMASDetectionType_;
    }

    const uint16_t& usMASDetectionType() const OMG_NOEXCEPT {
        return m_usMASDetectionType_;
    }

    void usMASDetectionType(uint16_t value) {
        m_usMASDetectionType_ = value;
    }

    uint16_t& usFusionStatus() OMG_NOEXCEPT {
        return m_usFusionStatus_;
    }

    const uint16_t& usFusionStatus() const OMG_NOEXCEPT {
        return m_usFusionStatus_;
    }

    void usFusionStatus(uint16_t value) {
        m_usFusionStatus_ = value;
    }

    uint16_t& usAllFusedSectorNo() OMG_NOEXCEPT {
        return m_usAllFusedSectorNo_;
    }

    const uint16_t& usAllFusedSectorNo() const OMG_NOEXCEPT {
        return m_usAllFusedSectorNo_;
    }

    void usAllFusedSectorNo(uint16_t value) {
        m_usAllFusedSectorNo_ = value;
    }

    uint16_t& usMagSectorNo() OMG_NOEXCEPT {
        return m_usMagSectorNo_;
    }

    const uint16_t& usMagSectorNo() const OMG_NOEXCEPT {
        return m_usMagSectorNo_;
    }

    void usMagSectorNo(uint16_t value) {
        m_usMagSectorNo_ = value;
    }

    uint16_t& usAcoSectorNo() OMG_NOEXCEPT {
        return m_usAcoSectorNo_;
    }

    const uint16_t& usAcoSectorNo() const OMG_NOEXCEPT {
        return m_usAcoSectorNo_;
    }

    void usAcoSectorNo(uint16_t value) {
        m_usAcoSectorNo_ = value;
    }

    uint16_t& usBbdSectorNo() OMG_NOEXCEPT {
        return m_usBbdSectorNo_;
    }

    const uint16_t& usBbdSectorNo() const OMG_NOEXCEPT {
        return m_usBbdSectorNo_;
    }

    void usBbdSectorNo(uint16_t value) {
        m_usBbdSectorNo_ = value;
    }

    uint16_t& usNbdSectorNo() OMG_NOEXCEPT {
        return m_usNbdSectorNo_;
    }

    const uint16_t& usNbdSectorNo() const OMG_NOEXCEPT {
        return m_usNbdSectorNo_;
    }

    void usNbdSectorNo(uint16_t value) {
        m_usNbdSectorNo_ = value;
    }

    uint16_t& usMagSensorNo() OMG_NOEXCEPT {
        return m_usMagSensorNo_;
    }

    const uint16_t& usMagSensorNo() const OMG_NOEXCEPT {
        return m_usMagSensorNo_;
    }

    void usMagSensorNo(uint16_t value) {
        m_usMagSensorNo_ = value;
    }

    uint16_t& usAcoSensorNo() OMG_NOEXCEPT {
        return m_usAcoSensorNo_;
    }

    const uint16_t& usAcoSensorNo() const OMG_NOEXCEPT {
        return m_usAcoSensorNo_;
    }

    void usAcoSensorNo(uint16_t value) {
        m_usAcoSensorNo_ = value;
    }

    float& fLineMagSyntheSig() OMG_NOEXCEPT {
        return m_fLineMagSyntheSig_;
    }

    const float& fLineMagSyntheSig() const OMG_NOEXCEPT {
        return m_fLineMagSyntheSig_;
    }

    void fLineMagSyntheSig(float value) {
        m_fLineMagSyntheSig_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fPosXOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    const float& fPosXOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    void fPosXOnGlobalCoordinate(float value) {
        m_fPosXOnGlobalCoordinate_ = value;
    }

    float& fPosYOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    const float& fPosYOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    void fPosYOnGlobalCoordinate(float value) {
        m_fPosYOnGlobalCoordinate_ = value;
    }

    uint8_t& oTgtAssoFlag() OMG_NOEXCEPT {
        return m_oTgtAssoFlag_;
    }

    const uint8_t& oTgtAssoFlag() const OMG_NOEXCEPT {
        return m_oTgtAssoFlag_;
    }

    void oTgtAssoFlag(uint8_t value) {
        m_oTgtAssoFlag_ = value;
    }

    uint16_t& usAssoTgtNo() OMG_NOEXCEPT {
        return m_usAssoTgtNo_;
    }

    const uint16_t& usAssoTgtNo() const OMG_NOEXCEPT {
        return m_usAssoTgtNo_;
    }

    void usAssoTgtNo(uint16_t value) {
        m_usAssoTgtNo_ = value;
    }

    uint16_t& usAcoLofFreqNo() OMG_NOEXCEPT {
        return m_usAcoLofFreqNo_;
    }

    const uint16_t& usAcoLofFreqNo() const OMG_NOEXCEPT {
        return m_usAcoLofFreqNo_;
    }

    void usAcoLofFreqNo(uint16_t value) {
        m_usAcoLofFreqNo_ = value;
    }

    ::dds::core::array< float, 24L>& aAcoLofFreqInfo() OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    const ::dds::core::array< float, 24L>& aAcoLofFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    void aAcoLofFreqInfo(const ::dds::core::array< float, 24L>& value) {
        m_aAcoLofFreqInfo_ = value;
    }

    void aAcoLofFreqInfo(::dds::core::array< float, 24L>&& value) {
        m_aAcoLofFreqInfo_ = std::move(value);
    }
    uint16_t& usAcoDemFreqNo() OMG_NOEXCEPT {
        return m_usAcoDemFreqNo_;
    }

    const uint16_t& usAcoDemFreqNo() const OMG_NOEXCEPT {
        return m_usAcoDemFreqNo_;
    }

    void usAcoDemFreqNo(uint16_t value) {
        m_usAcoDemFreqNo_ = value;
    }

    ::dds::core::array< float, 8L>& aAcoDemFreqInfo() OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    const ::dds::core::array< float, 8L>& aAcoDemFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    void aAcoDemFreqInfo(const ::dds::core::array< float, 8L>& value) {
        m_aAcoDemFreqInfo_ = value;
    }

    void aAcoDemFreqInfo(::dds::core::array< float, 8L>&& value) {
        m_aAcoDemFreqInfo_ = std::move(value);
    }
    uint16_t& usInOutInfo() OMG_NOEXCEPT {
        return m_usInOutInfo_;
    }

    const uint16_t& usInOutInfo() const OMG_NOEXCEPT {
        return m_usInOutInfo_;
    }

    void usInOutInfo(uint16_t value) {
        m_usInOutInfo_ = value;
    }

    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    bool operator == (const ST_MAS_TARGET& other_) const;
    bool operator != (const ST_MAS_TARGET& other_) const;

    void swap(ST_MAS_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNumber_;
    ST_DATE_TIME m_stRegistrationTime_;
    uint16_t m_usTrackMainCnt_;
    uint8_t m_oTrackStatus_;
    uint8_t m_oTrackInitType_;
    float m_fTrackReliabiliy_;
    uint16_t m_usMASDetectionType_;
    uint16_t m_usFusionStatus_;
    uint16_t m_usAllFusedSectorNo_;
    uint16_t m_usMagSectorNo_;
    uint16_t m_usAcoSectorNo_;
    uint16_t m_usBbdSectorNo_;
    uint16_t m_usNbdSectorNo_;
    uint16_t m_usMagSensorNo_;
    uint16_t m_usAcoSensorNo_;
    float m_fLineMagSyntheSig_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fPosXOnGlobalCoordinate_;
    float m_fPosYOnGlobalCoordinate_;
    uint8_t m_oTgtAssoFlag_;
    uint16_t m_usAssoTgtNo_;
    uint16_t m_usAcoLofFreqNo_;
    ::dds::core::array< float, 24L> m_aAcoLofFreqInfo_;
    uint16_t m_usAcoDemFreqNo_;
    ::dds::core::array< float, 8L> m_aAcoDemFreqInfo_;
    uint16_t m_usInOutInfo_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;

};

inline void swap(ST_MAS_TARGET& a, ST_MAS_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_TARGET& sample);

class NDDSUSERDllExport ST_MAS_LOCAL_TARGET {
  public:
    ST_MAS_LOCAL_TARGET();

    ST_MAS_LOCAL_TARGET(uint16_t usSensorID,uint16_t usNumOfTargets,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_MAS_TARGET, 50L>& stMasTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_LOCAL_TARGET (ST_MAS_LOCAL_TARGET&&) = default;
    ST_MAS_LOCAL_TARGET& operator=(ST_MAS_LOCAL_TARGET&&) = default;
    ST_MAS_LOCAL_TARGET& operator=(const ST_MAS_LOCAL_TARGET&) = default;
    ST_MAS_LOCAL_TARGET(const ST_MAS_LOCAL_TARGET&) = default;
    #else
    ST_MAS_LOCAL_TARGET(ST_MAS_LOCAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_MAS_LOCAL_TARGET& operator=(ST_MAS_LOCAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_MAS_TARGET, 50L>& stMasTargetLocal() OMG_NOEXCEPT {
        return m_stMasTargetLocal_;
    }

    const ::dds::core::array< ST_MAS_TARGET, 50L>& stMasTargetLocal() const OMG_NOEXCEPT {
        return m_stMasTargetLocal_;
    }

    void stMasTargetLocal(const ::dds::core::array< ST_MAS_TARGET, 50L>& value) {
        m_stMasTargetLocal_ = value;
    }

    void stMasTargetLocal(::dds::core::array< ST_MAS_TARGET, 50L>&& value) {
        m_stMasTargetLocal_ = std::move(value);
    }

    bool operator == (const ST_MAS_LOCAL_TARGET& other_) const;
    bool operator != (const ST_MAS_LOCAL_TARGET& other_) const;

    void swap(ST_MAS_LOCAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_MAS_TARGET, 50L> m_stMasTargetLocal_;

};

inline void swap(ST_MAS_LOCAL_TARGET& a, ST_MAS_LOCAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_LOCAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO {
  public:
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO();

    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,const ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& stMASTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO (TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& operator=(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO&) = default;
    #else
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& stMASTgtInfo() OMG_NOEXCEPT {
        return m_stMASTgtInfo_;
    }

    const ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& stMASTgtInfo() const OMG_NOEXCEPT {
        return m_stMASTgtInfo_;
    }

    void stMASTgtInfo(const ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& value) {
        m_stMASTgtInfo_ = value;
    }

    void stMASTgtInfo(::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>&& value) {
        m_stMASTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& other_) const;
    bool operator != (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& other_) const;

    void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L> m_stMASTgtInfo_;

};

inline void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& a, TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& sample);

class NDDSUSERDllExport ST_RADAR_LOCAL_TARGET {
  public:
    ST_RADAR_LOCAL_TARGET();

    ST_RADAR_LOCAL_TARGET(uint16_t usTgtNumber,const ::dds::core::array< uint16_t, 2L>& usTrackReliability,uint16_t usTrackStatus,uint16_t usAutoOrSemi,float fDistance,float fBearing,float fCourse,float fVelocity,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< float, 4L>& aStateVector,const ::dds::core::array< float, 4L>& aMatP,double dLatitude,double dLongitude,float fPosXOnGlobalCoordinate,float fPosYOnGlobalCoordinate,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_RADAR_LOCAL_TARGET (ST_RADAR_LOCAL_TARGET&&) = default;
    ST_RADAR_LOCAL_TARGET& operator=(ST_RADAR_LOCAL_TARGET&&) = default;
    ST_RADAR_LOCAL_TARGET& operator=(const ST_RADAR_LOCAL_TARGET&) = default;
    ST_RADAR_LOCAL_TARGET(const ST_RADAR_LOCAL_TARGET&) = default;
    #else
    ST_RADAR_LOCAL_TARGET(ST_RADAR_LOCAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_RADAR_LOCAL_TARGET& operator=(ST_RADAR_LOCAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& usTrackReliability() OMG_NOEXCEPT {
        return m_usTrackReliability_;
    }

    const ::dds::core::array< uint16_t, 2L>& usTrackReliability() const OMG_NOEXCEPT {
        return m_usTrackReliability_;
    }

    void usTrackReliability(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usTrackReliability_ = value;
    }

    void usTrackReliability(::dds::core::array< uint16_t, 2L>&& value) {
        m_usTrackReliability_ = std::move(value);
    }
    uint16_t& usTrackStatus() OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    const uint16_t& usTrackStatus() const OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    void usTrackStatus(uint16_t value) {
        m_usTrackStatus_ = value;
    }

    uint16_t& usAutoOrSemi() OMG_NOEXCEPT {
        return m_usAutoOrSemi_;
    }

    const uint16_t& usAutoOrSemi() const OMG_NOEXCEPT {
        return m_usAutoOrSemi_;
    }

    void usAutoOrSemi(uint16_t value) {
        m_usAutoOrSemi_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& aStateVector() OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    const ::dds::core::array< float, 4L>& aStateVector() const OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    void aStateVector(const ::dds::core::array< float, 4L>& value) {
        m_aStateVector_ = value;
    }

    void aStateVector(::dds::core::array< float, 4L>&& value) {
        m_aStateVector_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& aMatP() OMG_NOEXCEPT {
        return m_aMatP_;
    }

    const ::dds::core::array< float, 4L>& aMatP() const OMG_NOEXCEPT {
        return m_aMatP_;
    }

    void aMatP(const ::dds::core::array< float, 4L>& value) {
        m_aMatP_ = value;
    }

    void aMatP(::dds::core::array< float, 4L>&& value) {
        m_aMatP_ = std::move(value);
    }
    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fPosXOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    const float& fPosXOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    void fPosXOnGlobalCoordinate(float value) {
        m_fPosXOnGlobalCoordinate_ = value;
    }

    float& fPosYOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    const float& fPosYOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    void fPosYOnGlobalCoordinate(float value) {
        m_fPosYOnGlobalCoordinate_ = value;
    }

    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    bool operator == (const ST_RADAR_LOCAL_TARGET& other_) const;
    bool operator != (const ST_RADAR_LOCAL_TARGET& other_) const;

    void swap(ST_RADAR_LOCAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNumber_;
    ::dds::core::array< uint16_t, 2L> m_usTrackReliability_;
    uint16_t m_usTrackStatus_;
    uint16_t m_usAutoOrSemi_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fCourse_;
    float m_fVelocity_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< float, 4L> m_aStateVector_;
    ::dds::core::array< float, 4L> m_aMatP_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fPosXOnGlobalCoordinate_;
    float m_fPosYOnGlobalCoordinate_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;

};

inline void swap(ST_RADAR_LOCAL_TARGET& a, ST_RADAR_LOCAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_RADAR_LOCAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO {
  public:
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO();

    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& stRDTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO (TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO&&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& operator=(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO&) = default;
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO(const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO&) = default;
    #else
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& operator=(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& stRDTgtInfo() OMG_NOEXCEPT {
        return m_stRDTgtInfo_;
    }

    const ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& stRDTgtInfo() const OMG_NOEXCEPT {
        return m_stRDTgtInfo_;
    }

    void stRDTgtInfo(const ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& value) {
        m_stRDTgtInfo_ = value;
    }

    void stRDTgtInfo(::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>&& value) {
        m_stRDTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& other_) const;
    bool operator != (const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& other_) const;

    void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L> m_stRDTgtInfo_;

};

inline void swap(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& a, TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& sample);

class NDDSUSERDllExport ST_BIS_SOURCE_INFO {
  public:
    ST_BIS_SOURCE_INFO();

    ST_BIS_SOURCE_INFO(uint16_t usPulseID,uint8_t oPulseType,uint8_t oSourceType,const ST_DATE_TIME& stRegistrationTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_SOURCE_INFO (ST_BIS_SOURCE_INFO&&) = default;
    ST_BIS_SOURCE_INFO& operator=(ST_BIS_SOURCE_INFO&&) = default;
    ST_BIS_SOURCE_INFO& operator=(const ST_BIS_SOURCE_INFO&) = default;
    ST_BIS_SOURCE_INFO(const ST_BIS_SOURCE_INFO&) = default;
    #else
    ST_BIS_SOURCE_INFO(ST_BIS_SOURCE_INFO&& other_) OMG_NOEXCEPT;  
    ST_BIS_SOURCE_INFO& operator=(ST_BIS_SOURCE_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usPulseID() OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    const uint16_t& usPulseID() const OMG_NOEXCEPT {
        return m_usPulseID_;
    }

    void usPulseID(uint16_t value) {
        m_usPulseID_ = value;
    }

    uint8_t& oPulseType() OMG_NOEXCEPT {
        return m_oPulseType_;
    }

    const uint8_t& oPulseType() const OMG_NOEXCEPT {
        return m_oPulseType_;
    }

    void oPulseType(uint8_t value) {
        m_oPulseType_ = value;
    }

    uint8_t& oSourceType() OMG_NOEXCEPT {
        return m_oSourceType_;
    }

    const uint8_t& oSourceType() const OMG_NOEXCEPT {
        return m_oSourceType_;
    }

    void oSourceType(uint8_t value) {
        m_oSourceType_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }

    bool operator == (const ST_BIS_SOURCE_INFO& other_) const;
    bool operator != (const ST_BIS_SOURCE_INFO& other_) const;

    void swap(ST_BIS_SOURCE_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usPulseID_;
    uint8_t m_oPulseType_;
    uint8_t m_oSourceType_;
    ST_DATE_TIME m_stRegistrationTime_;

};

inline void swap(ST_BIS_SOURCE_INFO& a, ST_BIS_SOURCE_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_SOURCE_INFO& sample);

class NDDSUSERDllExport ST_RD_TARGET_ASSOCIATED {
  public:
    ST_RD_TARGET_ASSOCIATED();

    ST_RD_TARGET_ASSOCIATED(uint8_t oAssociatedSensorID,uint16_t usTgtNumber,float fAssociationReliability,float fBearing,float fDistance,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint8_t oRegistCnt,uint8_t oProcessCnt,uint8_t oUserChange,uint8_t oIsTrainingTgt);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_RD_TARGET_ASSOCIATED (ST_RD_TARGET_ASSOCIATED&&) = default;
    ST_RD_TARGET_ASSOCIATED& operator=(ST_RD_TARGET_ASSOCIATED&&) = default;
    ST_RD_TARGET_ASSOCIATED& operator=(const ST_RD_TARGET_ASSOCIATED&) = default;
    ST_RD_TARGET_ASSOCIATED(const ST_RD_TARGET_ASSOCIATED&) = default;
    #else
    ST_RD_TARGET_ASSOCIATED(ST_RD_TARGET_ASSOCIATED&& other_) OMG_NOEXCEPT;  
    ST_RD_TARGET_ASSOCIATED& operator=(ST_RD_TARGET_ASSOCIATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    uint8_t& oIsTrainingTgt() OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    const uint8_t& oIsTrainingTgt() const OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    void oIsTrainingTgt(uint8_t value) {
        m_oIsTrainingTgt_ = value;
    }

    bool operator == (const ST_RD_TARGET_ASSOCIATED& other_) const;
    bool operator != (const ST_RD_TARGET_ASSOCIATED& other_) const;

    void swap(ST_RD_TARGET_ASSOCIATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    uint16_t m_usTgtNumber_;
    float m_fAssociationReliability_;
    float m_fBearing_;
    float m_fDistance_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    uint8_t m_oUserChange_;
    uint8_t m_oIsTrainingTgt_;

};

inline void swap(ST_RD_TARGET_ASSOCIATED& a, ST_RD_TARGET_ASSOCIATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_RD_TARGET_ASSOCIATED& sample);

class NDDSUSERDllExport ST_LAS_TARGET_ASSOICATED {
  public:
    ST_LAS_TARGET_ASSOICATED();

    ST_LAS_TARGET_ASSOICATED(uint8_t oAssociatedSensorID,const ::dds::core::array< uint16_t, 2L>& aTgtNumber,uint16_t usRealTgtNumber,uint16_t usAssociatedTrackID,float fAssociationReliability,float fBearing,uint16_t usBeamNo,uint8_t oTrackInitType,uint8_t oTrackReliability,uint8_t oFusionStatus,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint8_t oLOFARFreqCnt,const ::dds::core::array< float, 24L>& aLOFARFreq,const ::dds::core::array< uint8_t, 24L>& aLOFARTrackInitType,const ::dds::core::array< uint8_t, 24L>& aIsThreatFreq,uint8_t oDEMONFreqCnt,const ::dds::core::array< float, 8L>& aDEMONFreq,const ::dds::core::array< uint8_t, 8L>& aDEMONTrackInitType,uint8_t oRegistCnt,uint8_t oProcessCnt,uint8_t oUserChange,uint8_t oIsTrainingTgt);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_TARGET_ASSOICATED (ST_LAS_TARGET_ASSOICATED&&) = default;
    ST_LAS_TARGET_ASSOICATED& operator=(ST_LAS_TARGET_ASSOICATED&&) = default;
    ST_LAS_TARGET_ASSOICATED& operator=(const ST_LAS_TARGET_ASSOICATED&) = default;
    ST_LAS_TARGET_ASSOICATED(const ST_LAS_TARGET_ASSOICATED&) = default;
    #else
    ST_LAS_TARGET_ASSOICATED(ST_LAS_TARGET_ASSOICATED&& other_) OMG_NOEXCEPT;  
    ST_LAS_TARGET_ASSOICATED& operator=(ST_LAS_TARGET_ASSOICATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aTgtNumber() OMG_NOEXCEPT {
        return m_aTgtNumber_;
    }

    const ::dds::core::array< uint16_t, 2L>& aTgtNumber() const OMG_NOEXCEPT {
        return m_aTgtNumber_;
    }

    void aTgtNumber(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aTgtNumber_ = value;
    }

    void aTgtNumber(::dds::core::array< uint16_t, 2L>&& value) {
        m_aTgtNumber_ = std::move(value);
    }
    uint16_t& usRealTgtNumber() OMG_NOEXCEPT {
        return m_usRealTgtNumber_;
    }

    const uint16_t& usRealTgtNumber() const OMG_NOEXCEPT {
        return m_usRealTgtNumber_;
    }

    void usRealTgtNumber(uint16_t value) {
        m_usRealTgtNumber_ = value;
    }

    uint16_t& usAssociatedTrackID() OMG_NOEXCEPT {
        return m_usAssociatedTrackID_;
    }

    const uint16_t& usAssociatedTrackID() const OMG_NOEXCEPT {
        return m_usAssociatedTrackID_;
    }

    void usAssociatedTrackID(uint16_t value) {
        m_usAssociatedTrackID_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    uint16_t& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const uint16_t& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(uint16_t value) {
        m_usBeamNo_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    uint8_t& oFusionStatus() OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    const uint8_t& oFusionStatus() const OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    void oFusionStatus(uint8_t value) {
        m_oFusionStatus_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint8_t& oLOFARFreqCnt() OMG_NOEXCEPT {
        return m_oLOFARFreqCnt_;
    }

    const uint8_t& oLOFARFreqCnt() const OMG_NOEXCEPT {
        return m_oLOFARFreqCnt_;
    }

    void oLOFARFreqCnt(uint8_t value) {
        m_oLOFARFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aLOFARFreq() OMG_NOEXCEPT {
        return m_aLOFARFreq_;
    }

    const ::dds::core::array< float, 24L>& aLOFARFreq() const OMG_NOEXCEPT {
        return m_aLOFARFreq_;
    }

    void aLOFARFreq(const ::dds::core::array< float, 24L>& value) {
        m_aLOFARFreq_ = value;
    }

    void aLOFARFreq(::dds::core::array< float, 24L>&& value) {
        m_aLOFARFreq_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 24L>& aLOFARTrackInitType() OMG_NOEXCEPT {
        return m_aLOFARTrackInitType_;
    }

    const ::dds::core::array< uint8_t, 24L>& aLOFARTrackInitType() const OMG_NOEXCEPT {
        return m_aLOFARTrackInitType_;
    }

    void aLOFARTrackInitType(const ::dds::core::array< uint8_t, 24L>& value) {
        m_aLOFARTrackInitType_ = value;
    }

    void aLOFARTrackInitType(::dds::core::array< uint8_t, 24L>&& value) {
        m_aLOFARTrackInitType_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 24L>& aIsThreatFreq() OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    const ::dds::core::array< uint8_t, 24L>& aIsThreatFreq() const OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    void aIsThreatFreq(const ::dds::core::array< uint8_t, 24L>& value) {
        m_aIsThreatFreq_ = value;
    }

    void aIsThreatFreq(::dds::core::array< uint8_t, 24L>&& value) {
        m_aIsThreatFreq_ = std::move(value);
    }
    uint8_t& oDEMONFreqCnt() OMG_NOEXCEPT {
        return m_oDEMONFreqCnt_;
    }

    const uint8_t& oDEMONFreqCnt() const OMG_NOEXCEPT {
        return m_oDEMONFreqCnt_;
    }

    void oDEMONFreqCnt(uint8_t value) {
        m_oDEMONFreqCnt_ = value;
    }

    ::dds::core::array< float, 8L>& aDEMONFreq() OMG_NOEXCEPT {
        return m_aDEMONFreq_;
    }

    const ::dds::core::array< float, 8L>& aDEMONFreq() const OMG_NOEXCEPT {
        return m_aDEMONFreq_;
    }

    void aDEMONFreq(const ::dds::core::array< float, 8L>& value) {
        m_aDEMONFreq_ = value;
    }

    void aDEMONFreq(::dds::core::array< float, 8L>&& value) {
        m_aDEMONFreq_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 8L>& aDEMONTrackInitType() OMG_NOEXCEPT {
        return m_aDEMONTrackInitType_;
    }

    const ::dds::core::array< uint8_t, 8L>& aDEMONTrackInitType() const OMG_NOEXCEPT {
        return m_aDEMONTrackInitType_;
    }

    void aDEMONTrackInitType(const ::dds::core::array< uint8_t, 8L>& value) {
        m_aDEMONTrackInitType_ = value;
    }

    void aDEMONTrackInitType(::dds::core::array< uint8_t, 8L>&& value) {
        m_aDEMONTrackInitType_ = std::move(value);
    }
    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    uint8_t& oIsTrainingTgt() OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    const uint8_t& oIsTrainingTgt() const OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    void oIsTrainingTgt(uint8_t value) {
        m_oIsTrainingTgt_ = value;
    }

    bool operator == (const ST_LAS_TARGET_ASSOICATED& other_) const;
    bool operator != (const ST_LAS_TARGET_ASSOICATED& other_) const;

    void swap(ST_LAS_TARGET_ASSOICATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    ::dds::core::array< uint16_t, 2L> m_aTgtNumber_;
    uint16_t m_usRealTgtNumber_;
    uint16_t m_usAssociatedTrackID_;
    float m_fAssociationReliability_;
    float m_fBearing_;
    uint16_t m_usBeamNo_;
    uint8_t m_oTrackInitType_;
    uint8_t m_oTrackReliability_;
    uint8_t m_oFusionStatus_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint8_t m_oLOFARFreqCnt_;
    ::dds::core::array< float, 24L> m_aLOFARFreq_;
    ::dds::core::array< uint8_t, 24L> m_aLOFARTrackInitType_;
    ::dds::core::array< uint8_t, 24L> m_aIsThreatFreq_;
    uint8_t m_oDEMONFreqCnt_;
    ::dds::core::array< float, 8L> m_aDEMONFreq_;
    ::dds::core::array< uint8_t, 8L> m_aDEMONTrackInitType_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    uint8_t m_oUserChange_;
    uint8_t m_oIsTrainingTgt_;

};

inline void swap(ST_LAS_TARGET_ASSOICATED& a, ST_LAS_TARGET_ASSOICATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_TARGET_ASSOICATED& sample);

class NDDSUSERDllExport ST_MAS_TARGET_ASSOCIATED {
  public:
    ST_MAS_TARGET_ASSOCIATED();

    ST_MAS_TARGET_ASSOCIATED(uint8_t oAssociatedSensorID,uint16_t usTgtNumber,uint8_t oDetectColumn,uint8_t oDetectType,uint8_t oTrackReliability,uint8_t oMagneticSensor,uint8_t oAcousticSensor,uint8_t oAcoLofFreqNo,const ::dds::core::array< float, 24L>& aAcoLofFreqInfo,uint8_t oAcoDemFreqNo,const ::dds::core::array< float, 8L>& aAcoDemFreqInfo,float fLineMagSyntheSig,float fAssociationReliability,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint8_t oRegistCnt,uint8_t oProcessCnt,uint8_t oUserChange,uint8_t oIsTrainingTgt);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_TARGET_ASSOCIATED (ST_MAS_TARGET_ASSOCIATED&&) = default;
    ST_MAS_TARGET_ASSOCIATED& operator=(ST_MAS_TARGET_ASSOCIATED&&) = default;
    ST_MAS_TARGET_ASSOCIATED& operator=(const ST_MAS_TARGET_ASSOCIATED&) = default;
    ST_MAS_TARGET_ASSOCIATED(const ST_MAS_TARGET_ASSOCIATED&) = default;
    #else
    ST_MAS_TARGET_ASSOCIATED(ST_MAS_TARGET_ASSOCIATED&& other_) OMG_NOEXCEPT;  
    ST_MAS_TARGET_ASSOCIATED& operator=(ST_MAS_TARGET_ASSOCIATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    uint8_t& oDetectColumn() OMG_NOEXCEPT {
        return m_oDetectColumn_;
    }

    const uint8_t& oDetectColumn() const OMG_NOEXCEPT {
        return m_oDetectColumn_;
    }

    void oDetectColumn(uint8_t value) {
        m_oDetectColumn_ = value;
    }

    uint8_t& oDetectType() OMG_NOEXCEPT {
        return m_oDetectType_;
    }

    const uint8_t& oDetectType() const OMG_NOEXCEPT {
        return m_oDetectType_;
    }

    void oDetectType(uint8_t value) {
        m_oDetectType_ = value;
    }

    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    uint8_t& oMagneticSensor() OMG_NOEXCEPT {
        return m_oMagneticSensor_;
    }

    const uint8_t& oMagneticSensor() const OMG_NOEXCEPT {
        return m_oMagneticSensor_;
    }

    void oMagneticSensor(uint8_t value) {
        m_oMagneticSensor_ = value;
    }

    uint8_t& oAcousticSensor() OMG_NOEXCEPT {
        return m_oAcousticSensor_;
    }

    const uint8_t& oAcousticSensor() const OMG_NOEXCEPT {
        return m_oAcousticSensor_;
    }

    void oAcousticSensor(uint8_t value) {
        m_oAcousticSensor_ = value;
    }

    uint8_t& oAcoLofFreqNo() OMG_NOEXCEPT {
        return m_oAcoLofFreqNo_;
    }

    const uint8_t& oAcoLofFreqNo() const OMG_NOEXCEPT {
        return m_oAcoLofFreqNo_;
    }

    void oAcoLofFreqNo(uint8_t value) {
        m_oAcoLofFreqNo_ = value;
    }

    ::dds::core::array< float, 24L>& aAcoLofFreqInfo() OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    const ::dds::core::array< float, 24L>& aAcoLofFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    void aAcoLofFreqInfo(const ::dds::core::array< float, 24L>& value) {
        m_aAcoLofFreqInfo_ = value;
    }

    void aAcoLofFreqInfo(::dds::core::array< float, 24L>&& value) {
        m_aAcoLofFreqInfo_ = std::move(value);
    }
    uint8_t& oAcoDemFreqNo() OMG_NOEXCEPT {
        return m_oAcoDemFreqNo_;
    }

    const uint8_t& oAcoDemFreqNo() const OMG_NOEXCEPT {
        return m_oAcoDemFreqNo_;
    }

    void oAcoDemFreqNo(uint8_t value) {
        m_oAcoDemFreqNo_ = value;
    }

    ::dds::core::array< float, 8L>& aAcoDemFreqInfo() OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    const ::dds::core::array< float, 8L>& aAcoDemFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    void aAcoDemFreqInfo(const ::dds::core::array< float, 8L>& value) {
        m_aAcoDemFreqInfo_ = value;
    }

    void aAcoDemFreqInfo(::dds::core::array< float, 8L>&& value) {
        m_aAcoDemFreqInfo_ = std::move(value);
    }
    float& fLineMagSyntheSig() OMG_NOEXCEPT {
        return m_fLineMagSyntheSig_;
    }

    const float& fLineMagSyntheSig() const OMG_NOEXCEPT {
        return m_fLineMagSyntheSig_;
    }

    void fLineMagSyntheSig(float value) {
        m_fLineMagSyntheSig_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    uint8_t& oIsTrainingTgt() OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    const uint8_t& oIsTrainingTgt() const OMG_NOEXCEPT {
        return m_oIsTrainingTgt_;
    }

    void oIsTrainingTgt(uint8_t value) {
        m_oIsTrainingTgt_ = value;
    }

    bool operator == (const ST_MAS_TARGET_ASSOCIATED& other_) const;
    bool operator != (const ST_MAS_TARGET_ASSOCIATED& other_) const;

    void swap(ST_MAS_TARGET_ASSOCIATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    uint16_t m_usTgtNumber_;
    uint8_t m_oDetectColumn_;
    uint8_t m_oDetectType_;
    uint8_t m_oTrackReliability_;
    uint8_t m_oMagneticSensor_;
    uint8_t m_oAcousticSensor_;
    uint8_t m_oAcoLofFreqNo_;
    ::dds::core::array< float, 24L> m_aAcoLofFreqInfo_;
    uint8_t m_oAcoDemFreqNo_;
    ::dds::core::array< float, 8L> m_aAcoDemFreqInfo_;
    float m_fLineMagSyntheSig_;
    float m_fAssociationReliability_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    uint8_t m_oUserChange_;
    uint8_t m_oIsTrainingTgt_;

};

inline void swap(ST_MAS_TARGET_ASSOCIATED& a, ST_MAS_TARGET_ASSOCIATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_TARGET_ASSOCIATED& sample);

class NDDSUSERDllExport ST_KNTDS_TARGET_ASSOCIATED {
  public:
    ST_KNTDS_TARGET_ASSOCIATED();

    ST_KNTDS_TARGET_ASSOCIATED(uint8_t oAssociatedSensorID,uint32_t ulTrackNo,uint8_t ucKind,uint8_t ucClass,uint8_t ucCategory,uint8_t ucIdentify,const ::dds::core::array< uint8_t, 6L>& ucTag,const ST_DATE_TIME& stTrackDetectTime,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint8_t oUserChange,uint8_t oRegistCnt,uint8_t oProcessCnt,float fAssociationReliability);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_KNTDS_TARGET_ASSOCIATED (ST_KNTDS_TARGET_ASSOCIATED&&) = default;
    ST_KNTDS_TARGET_ASSOCIATED& operator=(ST_KNTDS_TARGET_ASSOCIATED&&) = default;
    ST_KNTDS_TARGET_ASSOCIATED& operator=(const ST_KNTDS_TARGET_ASSOCIATED&) = default;
    ST_KNTDS_TARGET_ASSOCIATED(const ST_KNTDS_TARGET_ASSOCIATED&) = default;
    #else
    ST_KNTDS_TARGET_ASSOCIATED(ST_KNTDS_TARGET_ASSOCIATED&& other_) OMG_NOEXCEPT;  
    ST_KNTDS_TARGET_ASSOCIATED& operator=(ST_KNTDS_TARGET_ASSOCIATED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oAssociatedSensorID() OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    const uint8_t& oAssociatedSensorID() const OMG_NOEXCEPT {
        return m_oAssociatedSensorID_;
    }

    void oAssociatedSensorID(uint8_t value) {
        m_oAssociatedSensorID_ = value;
    }

    uint32_t& ulTrackNo() OMG_NOEXCEPT {
        return m_ulTrackNo_;
    }

    const uint32_t& ulTrackNo() const OMG_NOEXCEPT {
        return m_ulTrackNo_;
    }

    void ulTrackNo(uint32_t value) {
        m_ulTrackNo_ = value;
    }

    uint8_t& ucKind() OMG_NOEXCEPT {
        return m_ucKind_;
    }

    const uint8_t& ucKind() const OMG_NOEXCEPT {
        return m_ucKind_;
    }

    void ucKind(uint8_t value) {
        m_ucKind_ = value;
    }

    uint8_t& ucClass() OMG_NOEXCEPT {
        return m_ucClass_;
    }

    const uint8_t& ucClass() const OMG_NOEXCEPT {
        return m_ucClass_;
    }

    void ucClass(uint8_t value) {
        m_ucClass_ = value;
    }

    uint8_t& ucCategory() OMG_NOEXCEPT {
        return m_ucCategory_;
    }

    const uint8_t& ucCategory() const OMG_NOEXCEPT {
        return m_ucCategory_;
    }

    void ucCategory(uint8_t value) {
        m_ucCategory_ = value;
    }

    uint8_t& ucIdentify() OMG_NOEXCEPT {
        return m_ucIdentify_;
    }

    const uint8_t& ucIdentify() const OMG_NOEXCEPT {
        return m_ucIdentify_;
    }

    void ucIdentify(uint8_t value) {
        m_ucIdentify_ = value;
    }

    ::dds::core::array< uint8_t, 6L>& ucTag() OMG_NOEXCEPT {
        return m_ucTag_;
    }

    const ::dds::core::array< uint8_t, 6L>& ucTag() const OMG_NOEXCEPT {
        return m_ucTag_;
    }

    void ucTag(const ::dds::core::array< uint8_t, 6L>& value) {
        m_ucTag_ = value;
    }

    void ucTag(::dds::core::array< uint8_t, 6L>&& value) {
        m_ucTag_ = std::move(value);
    }
    ST_DATE_TIME& stTrackDetectTime() OMG_NOEXCEPT {
        return m_stTrackDetectTime_;
    }

    const ST_DATE_TIME& stTrackDetectTime() const OMG_NOEXCEPT {
        return m_stTrackDetectTime_;
    }

    void stTrackDetectTime(const ST_DATE_TIME& value) {
        m_stTrackDetectTime_ = value;
    }

    void stTrackDetectTime(ST_DATE_TIME&& value) {
        m_stTrackDetectTime_ = std::move(value);
    }
    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint8_t& oUserChange() OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    const uint8_t& oUserChange() const OMG_NOEXCEPT {
        return m_oUserChange_;
    }

    void oUserChange(uint8_t value) {
        m_oUserChange_ = value;
    }

    uint8_t& oRegistCnt() OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    const uint8_t& oRegistCnt() const OMG_NOEXCEPT {
        return m_oRegistCnt_;
    }

    void oRegistCnt(uint8_t value) {
        m_oRegistCnt_ = value;
    }

    uint8_t& oProcessCnt() OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    const uint8_t& oProcessCnt() const OMG_NOEXCEPT {
        return m_oProcessCnt_;
    }

    void oProcessCnt(uint8_t value) {
        m_oProcessCnt_ = value;
    }

    float& fAssociationReliability() OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    const float& fAssociationReliability() const OMG_NOEXCEPT {
        return m_fAssociationReliability_;
    }

    void fAssociationReliability(float value) {
        m_fAssociationReliability_ = value;
    }

    bool operator == (const ST_KNTDS_TARGET_ASSOCIATED& other_) const;
    bool operator != (const ST_KNTDS_TARGET_ASSOCIATED& other_) const;

    void swap(ST_KNTDS_TARGET_ASSOCIATED& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oAssociatedSensorID_;
    uint32_t m_ulTrackNo_;
    uint8_t m_ucKind_;
    uint8_t m_ucClass_;
    uint8_t m_ucCategory_;
    uint8_t m_ucIdentify_;
    ::dds::core::array< uint8_t, 6L> m_ucTag_;
    ST_DATE_TIME m_stTrackDetectTime_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint8_t m_oUserChange_;
    uint8_t m_oRegistCnt_;
    uint8_t m_oProcessCnt_;
    float m_fAssociationReliability_;

};

inline void swap(ST_KNTDS_TARGET_ASSOCIATED& a, ST_KNTDS_TARGET_ASSOCIATED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_KNTDS_TARGET_ASSOCIATED& sample);

class NDDSUSERDllExport ST_CPA_INFO {
  public:
    ST_CPA_INFO();

    ST_CPA_INFO(const ST_DATE_TIME& stReqTime,uint16_t usRelativeTgtNo,uint16_t usCPAResultType,double dDestinationLatitude,double dDestinationLongitude,double dCPAPointLat,double dCPAPointLon,float fRelativeBearing,float fRelativeDistance,uint32_t ulCPATime,float fCPADistance);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_CPA_INFO (ST_CPA_INFO&&) = default;
    ST_CPA_INFO& operator=(ST_CPA_INFO&&) = default;
    ST_CPA_INFO& operator=(const ST_CPA_INFO&) = default;
    ST_CPA_INFO(const ST_CPA_INFO&) = default;
    #else
    ST_CPA_INFO(ST_CPA_INFO&& other_) OMG_NOEXCEPT;  
    ST_CPA_INFO& operator=(ST_CPA_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    uint16_t& usRelativeTgtNo() OMG_NOEXCEPT {
        return m_usRelativeTgtNo_;
    }

    const uint16_t& usRelativeTgtNo() const OMG_NOEXCEPT {
        return m_usRelativeTgtNo_;
    }

    void usRelativeTgtNo(uint16_t value) {
        m_usRelativeTgtNo_ = value;
    }

    uint16_t& usCPAResultType() OMG_NOEXCEPT {
        return m_usCPAResultType_;
    }

    const uint16_t& usCPAResultType() const OMG_NOEXCEPT {
        return m_usCPAResultType_;
    }

    void usCPAResultType(uint16_t value) {
        m_usCPAResultType_ = value;
    }

    double& dDestinationLatitude() OMG_NOEXCEPT {
        return m_dDestinationLatitude_;
    }

    const double& dDestinationLatitude() const OMG_NOEXCEPT {
        return m_dDestinationLatitude_;
    }

    void dDestinationLatitude(double value) {
        m_dDestinationLatitude_ = value;
    }

    double& dDestinationLongitude() OMG_NOEXCEPT {
        return m_dDestinationLongitude_;
    }

    const double& dDestinationLongitude() const OMG_NOEXCEPT {
        return m_dDestinationLongitude_;
    }

    void dDestinationLongitude(double value) {
        m_dDestinationLongitude_ = value;
    }

    double& dCPAPointLat() OMG_NOEXCEPT {
        return m_dCPAPointLat_;
    }

    const double& dCPAPointLat() const OMG_NOEXCEPT {
        return m_dCPAPointLat_;
    }

    void dCPAPointLat(double value) {
        m_dCPAPointLat_ = value;
    }

    double& dCPAPointLon() OMG_NOEXCEPT {
        return m_dCPAPointLon_;
    }

    const double& dCPAPointLon() const OMG_NOEXCEPT {
        return m_dCPAPointLon_;
    }

    void dCPAPointLon(double value) {
        m_dCPAPointLon_ = value;
    }

    float& fRelativeBearing() OMG_NOEXCEPT {
        return m_fRelativeBearing_;
    }

    const float& fRelativeBearing() const OMG_NOEXCEPT {
        return m_fRelativeBearing_;
    }

    void fRelativeBearing(float value) {
        m_fRelativeBearing_ = value;
    }

    float& fRelativeDistance() OMG_NOEXCEPT {
        return m_fRelativeDistance_;
    }

    const float& fRelativeDistance() const OMG_NOEXCEPT {
        return m_fRelativeDistance_;
    }

    void fRelativeDistance(float value) {
        m_fRelativeDistance_ = value;
    }

    uint32_t& ulCPATime() OMG_NOEXCEPT {
        return m_ulCPATime_;
    }

    const uint32_t& ulCPATime() const OMG_NOEXCEPT {
        return m_ulCPATime_;
    }

    void ulCPATime(uint32_t value) {
        m_ulCPATime_ = value;
    }

    float& fCPADistance() OMG_NOEXCEPT {
        return m_fCPADistance_;
    }

    const float& fCPADistance() const OMG_NOEXCEPT {
        return m_fCPADistance_;
    }

    void fCPADistance(float value) {
        m_fCPADistance_ = value;
    }

    bool operator == (const ST_CPA_INFO& other_) const;
    bool operator != (const ST_CPA_INFO& other_) const;

    void swap(ST_CPA_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_DATE_TIME m_stReqTime_;
    uint16_t m_usRelativeTgtNo_;
    uint16_t m_usCPAResultType_;
    double m_dDestinationLatitude_;
    double m_dDestinationLongitude_;
    double m_dCPAPointLat_;
    double m_dCPAPointLon_;
    float m_fRelativeBearing_;
    float m_fRelativeDistance_;
    uint32_t m_ulCPATime_;
    float m_fCPADistance_;

};

inline void swap(ST_CPA_INFO& a, ST_CPA_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_CPA_INFO& sample);

class NDDSUSERDllExport ST_PREDICT_PATH_INFO {
  public:
    ST_PREDICT_PATH_INFO();

    ST_PREDICT_PATH_INFO(const ST_DATE_TIME& stReqTime,uint16_t usPredictionTime,double dPredictedPointLatitude,double dPredictedPointLongitude);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_PREDICT_PATH_INFO (ST_PREDICT_PATH_INFO&&) = default;
    ST_PREDICT_PATH_INFO& operator=(ST_PREDICT_PATH_INFO&&) = default;
    ST_PREDICT_PATH_INFO& operator=(const ST_PREDICT_PATH_INFO&) = default;
    ST_PREDICT_PATH_INFO(const ST_PREDICT_PATH_INFO&) = default;
    #else
    ST_PREDICT_PATH_INFO(ST_PREDICT_PATH_INFO&& other_) OMG_NOEXCEPT;  
    ST_PREDICT_PATH_INFO& operator=(ST_PREDICT_PATH_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    uint16_t& usPredictionTime() OMG_NOEXCEPT {
        return m_usPredictionTime_;
    }

    const uint16_t& usPredictionTime() const OMG_NOEXCEPT {
        return m_usPredictionTime_;
    }

    void usPredictionTime(uint16_t value) {
        m_usPredictionTime_ = value;
    }

    double& dPredictedPointLatitude() OMG_NOEXCEPT {
        return m_dPredictedPointLatitude_;
    }

    const double& dPredictedPointLatitude() const OMG_NOEXCEPT {
        return m_dPredictedPointLatitude_;
    }

    void dPredictedPointLatitude(double value) {
        m_dPredictedPointLatitude_ = value;
    }

    double& dPredictedPointLongitude() OMG_NOEXCEPT {
        return m_dPredictedPointLongitude_;
    }

    const double& dPredictedPointLongitude() const OMG_NOEXCEPT {
        return m_dPredictedPointLongitude_;
    }

    void dPredictedPointLongitude(double value) {
        m_dPredictedPointLongitude_ = value;
    }

    bool operator == (const ST_PREDICT_PATH_INFO& other_) const;
    bool operator != (const ST_PREDICT_PATH_INFO& other_) const;

    void swap(ST_PREDICT_PATH_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_DATE_TIME m_stReqTime_;
    uint16_t m_usPredictionTime_;
    double m_dPredictedPointLatitude_;
    double m_dPredictedPointLongitude_;

};

inline void swap(ST_PREDICT_PATH_INFO& a, ST_PREDICT_PATH_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_PREDICT_PATH_INFO& sample);

class NDDSUSERDllExport ST_GLOBAL_TARGET {
  public:
    ST_GLOBAL_TARGET();

    ST_GLOBAL_TARGET(uint16_t usTgtNumber,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint32_t ulMaintainTime,uint16_t usTrackStatus,uint32_t ulTrackUpdateCount,uint8_t oFriendlyInfo,uint8_t oClassInfo,float fClassificationScore,uint8_t oClassificationStatus,uint8_t bIsClassificationPossible,uint8_t oAutoClassificationProgress,uint8_t oLOFARTonalFreqCnt,const ::dds::core::array< float, 24L>& aLOFARTonalFreq,const ::dds::core::array< uint8_t, 24L>& aIsThreatFreq,uint8_t oDEMONTonalFreqCnt,const ::dds::core::array< float, 8L>& aDEMONTonalFreq,uint8_t oIsInSurveillanceArea,uint8_t oThreatGrade,uint16_t usThreatScore,uint8_t oAlarmGrade,uint8_t oInOutInfo,uint8_t oThreatTgt,const ST_DATE_TIME& stThreatTgtRegistrationTime,uint8_t oConcernedTgt,const ST_DATE_TIME& stConcernedTgtRegistrationTime,uint8_t oAnchoredThreatTgt,const ::dds::core::array< uint8_t, 20L>& aTgtInfo,const ::dds::core::array< float, 4L>& aStateVector,float fBearing,float fDistance,double dLatitude,double dLongitude,float fCourse,float fVelocity,const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aMatP,const ::dds::core::array< float, 4L>& aBearingCovArry,uint8_t oNoOfAssociatedSensors,const ::dds::core::array< uint8_t, 32L>& aAssociatedSensors,const ::dds::core::array< uint32_t, 32L>& aAssociatedLocalTgtID,uint8_t oOriginSensorID,const ST_DATE_TIME& stInitialDetectionTime,uint8_t oTrackReliability,bool bIsBISSourceTgt,uint8_t oKNTDSSendStatus,const ST_DATE_TIME& stClassificationReqTime,const ST_DATE_TIME& stClassificationResponseTime,const ::dds::core::array< float, 32L>& aRelativeBearingFromSensors,const ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors,const ST_BIS_SOURCE_INFO& stBISSourceInfo,uint8_t oFusionProcessed,const ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& stRDTgtInfoAssociated,const ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& stLASTgtInfoAssociated,const ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& stBISTgtInfoAssociated,const ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& stMASTgtInfoAssociated,const ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& stASTgtInfoAssociated,const ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& stEOTgtInfoAssociated,const ST_KNTDS_TARGET_ASSOCIATED& stKNTDSTgtInfoAssociated,const ST_AIS_TARGET_ASSOICATED& stAISTgtInfoAssociated,uint8_t oCPAStatus,const ST_CPA_INFO& stCPAInfo,uint8_t oPredictPathStatus,const ST_PREDICT_PATH_INFO& stPredictPathInfo,uint8_t oTargetType,uint8_t oRefSensorIDForBearingTgt,float fAzimuthForBearingTgt,uint8_t oIsClassifiedAsEnemyAutomatically,uint16_t usNoOfTrkHistory,const ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& aTgtTrkHistory,uint8_t oAssociatedStatus,uint16_t usAssociatedMasterTgtID,uint8_t oNoOfAssociatedSystemTgts,const ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID,uint8_t oAssociationReliability,const ST_DATE_TIME& stAssociationTime,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_GLOBAL_TARGET (ST_GLOBAL_TARGET&&) = default;
    ST_GLOBAL_TARGET& operator=(ST_GLOBAL_TARGET&&) = default;
    ST_GLOBAL_TARGET& operator=(const ST_GLOBAL_TARGET&) = default;
    ST_GLOBAL_TARGET(const ST_GLOBAL_TARGET&) = default;
    #else
    ST_GLOBAL_TARGET(ST_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_GLOBAL_TARGET& operator=(ST_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint32_t& ulMaintainTime() OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    const uint32_t& ulMaintainTime() const OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    void ulMaintainTime(uint32_t value) {
        m_ulMaintainTime_ = value;
    }

    uint16_t& usTrackStatus() OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    const uint16_t& usTrackStatus() const OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    void usTrackStatus(uint16_t value) {
        m_usTrackStatus_ = value;
    }

    uint32_t& ulTrackUpdateCount() OMG_NOEXCEPT {
        return m_ulTrackUpdateCount_;
    }

    const uint32_t& ulTrackUpdateCount() const OMG_NOEXCEPT {
        return m_ulTrackUpdateCount_;
    }

    void ulTrackUpdateCount(uint32_t value) {
        m_ulTrackUpdateCount_ = value;
    }

    uint8_t& oFriendlyInfo() OMG_NOEXCEPT {
        return m_oFriendlyInfo_;
    }

    const uint8_t& oFriendlyInfo() const OMG_NOEXCEPT {
        return m_oFriendlyInfo_;
    }

    void oFriendlyInfo(uint8_t value) {
        m_oFriendlyInfo_ = value;
    }

    uint8_t& oClassInfo() OMG_NOEXCEPT {
        return m_oClassInfo_;
    }

    const uint8_t& oClassInfo() const OMG_NOEXCEPT {
        return m_oClassInfo_;
    }

    void oClassInfo(uint8_t value) {
        m_oClassInfo_ = value;
    }

    float& fClassificationScore() OMG_NOEXCEPT {
        return m_fClassificationScore_;
    }

    const float& fClassificationScore() const OMG_NOEXCEPT {
        return m_fClassificationScore_;
    }

    void fClassificationScore(float value) {
        m_fClassificationScore_ = value;
    }

    uint8_t& oClassificationStatus() OMG_NOEXCEPT {
        return m_oClassificationStatus_;
    }

    const uint8_t& oClassificationStatus() const OMG_NOEXCEPT {
        return m_oClassificationStatus_;
    }

    void oClassificationStatus(uint8_t value) {
        m_oClassificationStatus_ = value;
    }

    uint8_t& bIsClassificationPossible() OMG_NOEXCEPT {
        return m_bIsClassificationPossible_;
    }

    const uint8_t& bIsClassificationPossible() const OMG_NOEXCEPT {
        return m_bIsClassificationPossible_;
    }

    void bIsClassificationPossible(uint8_t value) {
        m_bIsClassificationPossible_ = value;
    }

    uint8_t& oAutoClassificationProgress() OMG_NOEXCEPT {
        return m_oAutoClassificationProgress_;
    }

    const uint8_t& oAutoClassificationProgress() const OMG_NOEXCEPT {
        return m_oAutoClassificationProgress_;
    }

    void oAutoClassificationProgress(uint8_t value) {
        m_oAutoClassificationProgress_ = value;
    }

    uint8_t& oLOFARTonalFreqCnt() OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    const uint8_t& oLOFARTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    void oLOFARTonalFreqCnt(uint8_t value) {
        m_oLOFARTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aLOFARTonalFreq() OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    const ::dds::core::array< float, 24L>& aLOFARTonalFreq() const OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    void aLOFARTonalFreq(const ::dds::core::array< float, 24L>& value) {
        m_aLOFARTonalFreq_ = value;
    }

    void aLOFARTonalFreq(::dds::core::array< float, 24L>&& value) {
        m_aLOFARTonalFreq_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 24L>& aIsThreatFreq() OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    const ::dds::core::array< uint8_t, 24L>& aIsThreatFreq() const OMG_NOEXCEPT {
        return m_aIsThreatFreq_;
    }

    void aIsThreatFreq(const ::dds::core::array< uint8_t, 24L>& value) {
        m_aIsThreatFreq_ = value;
    }

    void aIsThreatFreq(::dds::core::array< uint8_t, 24L>&& value) {
        m_aIsThreatFreq_ = std::move(value);
    }
    uint8_t& oDEMONTonalFreqCnt() OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    const uint8_t& oDEMONTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    void oDEMONTonalFreqCnt(uint8_t value) {
        m_oDEMONTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 8L>& aDEMONTonalFreq() OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    const ::dds::core::array< float, 8L>& aDEMONTonalFreq() const OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    void aDEMONTonalFreq(const ::dds::core::array< float, 8L>& value) {
        m_aDEMONTonalFreq_ = value;
    }

    void aDEMONTonalFreq(::dds::core::array< float, 8L>&& value) {
        m_aDEMONTonalFreq_ = std::move(value);
    }
    uint8_t& oIsInSurveillanceArea() OMG_NOEXCEPT {
        return m_oIsInSurveillanceArea_;
    }

    const uint8_t& oIsInSurveillanceArea() const OMG_NOEXCEPT {
        return m_oIsInSurveillanceArea_;
    }

    void oIsInSurveillanceArea(uint8_t value) {
        m_oIsInSurveillanceArea_ = value;
    }

    uint8_t& oThreatGrade() OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    const uint8_t& oThreatGrade() const OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    void oThreatGrade(uint8_t value) {
        m_oThreatGrade_ = value;
    }

    uint16_t& usThreatScore() OMG_NOEXCEPT {
        return m_usThreatScore_;
    }

    const uint16_t& usThreatScore() const OMG_NOEXCEPT {
        return m_usThreatScore_;
    }

    void usThreatScore(uint16_t value) {
        m_usThreatScore_ = value;
    }

    uint8_t& oAlarmGrade() OMG_NOEXCEPT {
        return m_oAlarmGrade_;
    }

    const uint8_t& oAlarmGrade() const OMG_NOEXCEPT {
        return m_oAlarmGrade_;
    }

    void oAlarmGrade(uint8_t value) {
        m_oAlarmGrade_ = value;
    }

    uint8_t& oInOutInfo() OMG_NOEXCEPT {
        return m_oInOutInfo_;
    }

    const uint8_t& oInOutInfo() const OMG_NOEXCEPT {
        return m_oInOutInfo_;
    }

    void oInOutInfo(uint8_t value) {
        m_oInOutInfo_ = value;
    }

    uint8_t& oThreatTgt() OMG_NOEXCEPT {
        return m_oThreatTgt_;
    }

    const uint8_t& oThreatTgt() const OMG_NOEXCEPT {
        return m_oThreatTgt_;
    }

    void oThreatTgt(uint8_t value) {
        m_oThreatTgt_ = value;
    }

    ST_DATE_TIME& stThreatTgtRegistrationTime() OMG_NOEXCEPT {
        return m_stThreatTgtRegistrationTime_;
    }

    const ST_DATE_TIME& stThreatTgtRegistrationTime() const OMG_NOEXCEPT {
        return m_stThreatTgtRegistrationTime_;
    }

    void stThreatTgtRegistrationTime(const ST_DATE_TIME& value) {
        m_stThreatTgtRegistrationTime_ = value;
    }

    void stThreatTgtRegistrationTime(ST_DATE_TIME&& value) {
        m_stThreatTgtRegistrationTime_ = std::move(value);
    }
    uint8_t& oConcernedTgt() OMG_NOEXCEPT {
        return m_oConcernedTgt_;
    }

    const uint8_t& oConcernedTgt() const OMG_NOEXCEPT {
        return m_oConcernedTgt_;
    }

    void oConcernedTgt(uint8_t value) {
        m_oConcernedTgt_ = value;
    }

    ST_DATE_TIME& stConcernedTgtRegistrationTime() OMG_NOEXCEPT {
        return m_stConcernedTgtRegistrationTime_;
    }

    const ST_DATE_TIME& stConcernedTgtRegistrationTime() const OMG_NOEXCEPT {
        return m_stConcernedTgtRegistrationTime_;
    }

    void stConcernedTgtRegistrationTime(const ST_DATE_TIME& value) {
        m_stConcernedTgtRegistrationTime_ = value;
    }

    void stConcernedTgtRegistrationTime(ST_DATE_TIME&& value) {
        m_stConcernedTgtRegistrationTime_ = std::move(value);
    }
    uint8_t& oAnchoredThreatTgt() OMG_NOEXCEPT {
        return m_oAnchoredThreatTgt_;
    }

    const uint8_t& oAnchoredThreatTgt() const OMG_NOEXCEPT {
        return m_oAnchoredThreatTgt_;
    }

    void oAnchoredThreatTgt(uint8_t value) {
        m_oAnchoredThreatTgt_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& aTgtInfo() OMG_NOEXCEPT {
        return m_aTgtInfo_;
    }

    const ::dds::core::array< uint8_t, 20L>& aTgtInfo() const OMG_NOEXCEPT {
        return m_aTgtInfo_;
    }

    void aTgtInfo(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aTgtInfo_ = value;
    }

    void aTgtInfo(::dds::core::array< uint8_t, 20L>&& value) {
        m_aTgtInfo_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& aStateVector() OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    const ::dds::core::array< float, 4L>& aStateVector() const OMG_NOEXCEPT {
        return m_aStateVector_;
    }

    void aStateVector(const ::dds::core::array< float, 4L>& value) {
        m_aStateVector_ = value;
    }

    void aStateVector(::dds::core::array< float, 4L>&& value) {
        m_aStateVector_ = std::move(value);
    }
    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aMatP() OMG_NOEXCEPT {
        return m_aMatP_;
    }

    const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& aMatP() const OMG_NOEXCEPT {
        return m_aMatP_;
    }

    void aMatP(const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& value) {
        m_aMatP_ = value;
    }

    void aMatP(::dds::core::array< ::dds::core::array< float, 4L>, 4L>&& value) {
        m_aMatP_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& aBearingCovArry() OMG_NOEXCEPT {
        return m_aBearingCovArry_;
    }

    const ::dds::core::array< float, 4L>& aBearingCovArry() const OMG_NOEXCEPT {
        return m_aBearingCovArry_;
    }

    void aBearingCovArry(const ::dds::core::array< float, 4L>& value) {
        m_aBearingCovArry_ = value;
    }

    void aBearingCovArry(::dds::core::array< float, 4L>&& value) {
        m_aBearingCovArry_ = std::move(value);
    }
    uint8_t& oNoOfAssociatedSensors() OMG_NOEXCEPT {
        return m_oNoOfAssociatedSensors_;
    }

    const uint8_t& oNoOfAssociatedSensors() const OMG_NOEXCEPT {
        return m_oNoOfAssociatedSensors_;
    }

    void oNoOfAssociatedSensors(uint8_t value) {
        m_oNoOfAssociatedSensors_ = value;
    }

    ::dds::core::array< uint8_t, 32L>& aAssociatedSensors() OMG_NOEXCEPT {
        return m_aAssociatedSensors_;
    }

    const ::dds::core::array< uint8_t, 32L>& aAssociatedSensors() const OMG_NOEXCEPT {
        return m_aAssociatedSensors_;
    }

    void aAssociatedSensors(const ::dds::core::array< uint8_t, 32L>& value) {
        m_aAssociatedSensors_ = value;
    }

    void aAssociatedSensors(::dds::core::array< uint8_t, 32L>&& value) {
        m_aAssociatedSensors_ = std::move(value);
    }
    ::dds::core::array< uint32_t, 32L>& aAssociatedLocalTgtID() OMG_NOEXCEPT {
        return m_aAssociatedLocalTgtID_;
    }

    const ::dds::core::array< uint32_t, 32L>& aAssociatedLocalTgtID() const OMG_NOEXCEPT {
        return m_aAssociatedLocalTgtID_;
    }

    void aAssociatedLocalTgtID(const ::dds::core::array< uint32_t, 32L>& value) {
        m_aAssociatedLocalTgtID_ = value;
    }

    void aAssociatedLocalTgtID(::dds::core::array< uint32_t, 32L>&& value) {
        m_aAssociatedLocalTgtID_ = std::move(value);
    }
    uint8_t& oOriginSensorID() OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    const uint8_t& oOriginSensorID() const OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    void oOriginSensorID(uint8_t value) {
        m_oOriginSensorID_ = value;
    }

    ST_DATE_TIME& stInitialDetectionTime() OMG_NOEXCEPT {
        return m_stInitialDetectionTime_;
    }

    const ST_DATE_TIME& stInitialDetectionTime() const OMG_NOEXCEPT {
        return m_stInitialDetectionTime_;
    }

    void stInitialDetectionTime(const ST_DATE_TIME& value) {
        m_stInitialDetectionTime_ = value;
    }

    void stInitialDetectionTime(ST_DATE_TIME&& value) {
        m_stInitialDetectionTime_ = std::move(value);
    }
    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    bool& bIsBISSourceTgt() OMG_NOEXCEPT {
        return m_bIsBISSourceTgt_;
    }

    const bool& bIsBISSourceTgt() const OMG_NOEXCEPT {
        return m_bIsBISSourceTgt_;
    }

    void bIsBISSourceTgt(bool value) {
        m_bIsBISSourceTgt_ = value;
    }

    uint8_t& oKNTDSSendStatus() OMG_NOEXCEPT {
        return m_oKNTDSSendStatus_;
    }

    const uint8_t& oKNTDSSendStatus() const OMG_NOEXCEPT {
        return m_oKNTDSSendStatus_;
    }

    void oKNTDSSendStatus(uint8_t value) {
        m_oKNTDSSendStatus_ = value;
    }

    ST_DATE_TIME& stClassificationReqTime() OMG_NOEXCEPT {
        return m_stClassificationReqTime_;
    }

    const ST_DATE_TIME& stClassificationReqTime() const OMG_NOEXCEPT {
        return m_stClassificationReqTime_;
    }

    void stClassificationReqTime(const ST_DATE_TIME& value) {
        m_stClassificationReqTime_ = value;
    }

    void stClassificationReqTime(ST_DATE_TIME&& value) {
        m_stClassificationReqTime_ = std::move(value);
    }
    ST_DATE_TIME& stClassificationResponseTime() OMG_NOEXCEPT {
        return m_stClassificationResponseTime_;
    }

    const ST_DATE_TIME& stClassificationResponseTime() const OMG_NOEXCEPT {
        return m_stClassificationResponseTime_;
    }

    void stClassificationResponseTime(const ST_DATE_TIME& value) {
        m_stClassificationResponseTime_ = value;
    }

    void stClassificationResponseTime(ST_DATE_TIME&& value) {
        m_stClassificationResponseTime_ = std::move(value);
    }
    ::dds::core::array< float, 32L>& aRelativeBearingFromSensors() OMG_NOEXCEPT {
        return m_aRelativeBearingFromSensors_;
    }

    const ::dds::core::array< float, 32L>& aRelativeBearingFromSensors() const OMG_NOEXCEPT {
        return m_aRelativeBearingFromSensors_;
    }

    void aRelativeBearingFromSensors(const ::dds::core::array< float, 32L>& value) {
        m_aRelativeBearingFromSensors_ = value;
    }

    void aRelativeBearingFromSensors(::dds::core::array< float, 32L>&& value) {
        m_aRelativeBearingFromSensors_ = std::move(value);
    }
    ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors() OMG_NOEXCEPT {
        return m_aRelativeDistanceFromSensors_;
    }

    const ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors() const OMG_NOEXCEPT {
        return m_aRelativeDistanceFromSensors_;
    }

    void aRelativeDistanceFromSensors(const ::dds::core::array< float, 32L>& value) {
        m_aRelativeDistanceFromSensors_ = value;
    }

    void aRelativeDistanceFromSensors(::dds::core::array< float, 32L>&& value) {
        m_aRelativeDistanceFromSensors_ = std::move(value);
    }
    ST_BIS_SOURCE_INFO& stBISSourceInfo() OMG_NOEXCEPT {
        return m_stBISSourceInfo_;
    }

    const ST_BIS_SOURCE_INFO& stBISSourceInfo() const OMG_NOEXCEPT {
        return m_stBISSourceInfo_;
    }

    void stBISSourceInfo(const ST_BIS_SOURCE_INFO& value) {
        m_stBISSourceInfo_ = value;
    }

    void stBISSourceInfo(ST_BIS_SOURCE_INFO&& value) {
        m_stBISSourceInfo_ = std::move(value);
    }
    uint8_t& oFusionProcessed() OMG_NOEXCEPT {
        return m_oFusionProcessed_;
    }

    const uint8_t& oFusionProcessed() const OMG_NOEXCEPT {
        return m_oFusionProcessed_;
    }

    void oFusionProcessed(uint8_t value) {
        m_oFusionProcessed_ = value;
    }

    ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& stRDTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stRDTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& stRDTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stRDTgtInfoAssociated_;
    }

    void stRDTgtInfoAssociated(const ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& value) {
        m_stRDTgtInfoAssociated_ = value;
    }

    void stRDTgtInfoAssociated(::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>&& value) {
        m_stRDTgtInfoAssociated_ = std::move(value);
    }
    ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& stLASTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stLASTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& stLASTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stLASTgtInfoAssociated_;
    }

    void stLASTgtInfoAssociated(const ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& value) {
        m_stLASTgtInfoAssociated_ = value;
    }

    void stLASTgtInfoAssociated(::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>&& value) {
        m_stLASTgtInfoAssociated_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& stBISTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stBISTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& stBISTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stBISTgtInfoAssociated_;
    }

    void stBISTgtInfoAssociated(const ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>& value) {
        m_stBISTgtInfoAssociated_ = value;
    }

    void stBISTgtInfoAssociated(::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L>&& value) {
        m_stBISTgtInfoAssociated_ = std::move(value);
    }
    ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& stMASTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stMASTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& stMASTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stMASTgtInfoAssociated_;
    }

    void stMASTgtInfoAssociated(const ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& value) {
        m_stMASTgtInfoAssociated_ = value;
    }

    void stMASTgtInfoAssociated(::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>&& value) {
        m_stMASTgtInfoAssociated_ = std::move(value);
    }
    ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& stASTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stASTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& stASTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stASTgtInfoAssociated_;
    }

    void stASTgtInfoAssociated(const ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>& value) {
        m_stASTgtInfoAssociated_ = value;
    }

    void stASTgtInfoAssociated(::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L>&& value) {
        m_stASTgtInfoAssociated_ = std::move(value);
    }
    ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& stEOTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stEOTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& stEOTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stEOTgtInfoAssociated_;
    }

    void stEOTgtInfoAssociated(const ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>& value) {
        m_stEOTgtInfoAssociated_ = value;
    }

    void stEOTgtInfoAssociated(::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L>&& value) {
        m_stEOTgtInfoAssociated_ = std::move(value);
    }
    ST_KNTDS_TARGET_ASSOCIATED& stKNTDSTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stKNTDSTgtInfoAssociated_;
    }

    const ST_KNTDS_TARGET_ASSOCIATED& stKNTDSTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stKNTDSTgtInfoAssociated_;
    }

    void stKNTDSTgtInfoAssociated(const ST_KNTDS_TARGET_ASSOCIATED& value) {
        m_stKNTDSTgtInfoAssociated_ = value;
    }

    void stKNTDSTgtInfoAssociated(ST_KNTDS_TARGET_ASSOCIATED&& value) {
        m_stKNTDSTgtInfoAssociated_ = std::move(value);
    }
    ST_AIS_TARGET_ASSOICATED& stAISTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stAISTgtInfoAssociated_;
    }

    const ST_AIS_TARGET_ASSOICATED& stAISTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stAISTgtInfoAssociated_;
    }

    void stAISTgtInfoAssociated(const ST_AIS_TARGET_ASSOICATED& value) {
        m_stAISTgtInfoAssociated_ = value;
    }

    void stAISTgtInfoAssociated(ST_AIS_TARGET_ASSOICATED&& value) {
        m_stAISTgtInfoAssociated_ = std::move(value);
    }
    uint8_t& oCPAStatus() OMG_NOEXCEPT {
        return m_oCPAStatus_;
    }

    const uint8_t& oCPAStatus() const OMG_NOEXCEPT {
        return m_oCPAStatus_;
    }

    void oCPAStatus(uint8_t value) {
        m_oCPAStatus_ = value;
    }

    ST_CPA_INFO& stCPAInfo() OMG_NOEXCEPT {
        return m_stCPAInfo_;
    }

    const ST_CPA_INFO& stCPAInfo() const OMG_NOEXCEPT {
        return m_stCPAInfo_;
    }

    void stCPAInfo(const ST_CPA_INFO& value) {
        m_stCPAInfo_ = value;
    }

    void stCPAInfo(ST_CPA_INFO&& value) {
        m_stCPAInfo_ = std::move(value);
    }
    uint8_t& oPredictPathStatus() OMG_NOEXCEPT {
        return m_oPredictPathStatus_;
    }

    const uint8_t& oPredictPathStatus() const OMG_NOEXCEPT {
        return m_oPredictPathStatus_;
    }

    void oPredictPathStatus(uint8_t value) {
        m_oPredictPathStatus_ = value;
    }

    ST_PREDICT_PATH_INFO& stPredictPathInfo() OMG_NOEXCEPT {
        return m_stPredictPathInfo_;
    }

    const ST_PREDICT_PATH_INFO& stPredictPathInfo() const OMG_NOEXCEPT {
        return m_stPredictPathInfo_;
    }

    void stPredictPathInfo(const ST_PREDICT_PATH_INFO& value) {
        m_stPredictPathInfo_ = value;
    }

    void stPredictPathInfo(ST_PREDICT_PATH_INFO&& value) {
        m_stPredictPathInfo_ = std::move(value);
    }
    uint8_t& oTargetType() OMG_NOEXCEPT {
        return m_oTargetType_;
    }

    const uint8_t& oTargetType() const OMG_NOEXCEPT {
        return m_oTargetType_;
    }

    void oTargetType(uint8_t value) {
        m_oTargetType_ = value;
    }

    uint8_t& oRefSensorIDForBearingTgt() OMG_NOEXCEPT {
        return m_oRefSensorIDForBearingTgt_;
    }

    const uint8_t& oRefSensorIDForBearingTgt() const OMG_NOEXCEPT {
        return m_oRefSensorIDForBearingTgt_;
    }

    void oRefSensorIDForBearingTgt(uint8_t value) {
        m_oRefSensorIDForBearingTgt_ = value;
    }

    float& fAzimuthForBearingTgt() OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    const float& fAzimuthForBearingTgt() const OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    void fAzimuthForBearingTgt(float value) {
        m_fAzimuthForBearingTgt_ = value;
    }

    uint8_t& oIsClassifiedAsEnemyAutomatically() OMG_NOEXCEPT {
        return m_oIsClassifiedAsEnemyAutomatically_;
    }

    const uint8_t& oIsClassifiedAsEnemyAutomatically() const OMG_NOEXCEPT {
        return m_oIsClassifiedAsEnemyAutomatically_;
    }

    void oIsClassifiedAsEnemyAutomatically(uint8_t value) {
        m_oIsClassifiedAsEnemyAutomatically_ = value;
    }

    uint16_t& usNoOfTrkHistory() OMG_NOEXCEPT {
        return m_usNoOfTrkHistory_;
    }

    const uint16_t& usNoOfTrkHistory() const OMG_NOEXCEPT {
        return m_usNoOfTrkHistory_;
    }

    void usNoOfTrkHistory(uint16_t value) {
        m_usNoOfTrkHistory_ = value;
    }

    ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& aTgtTrkHistory() OMG_NOEXCEPT {
        return m_aTgtTrkHistory_;
    }

    const ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& aTgtTrkHistory() const OMG_NOEXCEPT {
        return m_aTgtTrkHistory_;
    }

    void aTgtTrkHistory(const ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>& value) {
        m_aTgtTrkHistory_ = value;
    }

    void aTgtTrkHistory(::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L>&& value) {
        m_aTgtTrkHistory_ = std::move(value);
    }
    uint8_t& oAssociatedStatus() OMG_NOEXCEPT {
        return m_oAssociatedStatus_;
    }

    const uint8_t& oAssociatedStatus() const OMG_NOEXCEPT {
        return m_oAssociatedStatus_;
    }

    void oAssociatedStatus(uint8_t value) {
        m_oAssociatedStatus_ = value;
    }

    uint16_t& usAssociatedMasterTgtID() OMG_NOEXCEPT {
        return m_usAssociatedMasterTgtID_;
    }

    const uint16_t& usAssociatedMasterTgtID() const OMG_NOEXCEPT {
        return m_usAssociatedMasterTgtID_;
    }

    void usAssociatedMasterTgtID(uint16_t value) {
        m_usAssociatedMasterTgtID_ = value;
    }

    uint8_t& oNoOfAssociatedSystemTgts() OMG_NOEXCEPT {
        return m_oNoOfAssociatedSystemTgts_;
    }

    const uint8_t& oNoOfAssociatedSystemTgts() const OMG_NOEXCEPT {
        return m_oNoOfAssociatedSystemTgts_;
    }

    void oNoOfAssociatedSystemTgts(uint8_t value) {
        m_oNoOfAssociatedSystemTgts_ = value;
    }

    ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID() OMG_NOEXCEPT {
        return m_aAssociatedSystemTgtID_;
    }

    const ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID() const OMG_NOEXCEPT {
        return m_aAssociatedSystemTgtID_;
    }

    void aAssociatedSystemTgtID(const ::dds::core::array< uint16_t, 32L>& value) {
        m_aAssociatedSystemTgtID_ = value;
    }

    void aAssociatedSystemTgtID(::dds::core::array< uint16_t, 32L>&& value) {
        m_aAssociatedSystemTgtID_ = std::move(value);
    }
    uint8_t& oAssociationReliability() OMG_NOEXCEPT {
        return m_oAssociationReliability_;
    }

    const uint8_t& oAssociationReliability() const OMG_NOEXCEPT {
        return m_oAssociationReliability_;
    }

    void oAssociationReliability(uint8_t value) {
        m_oAssociationReliability_ = value;
    }

    ST_DATE_TIME& stAssociationTime() OMG_NOEXCEPT {
        return m_stAssociationTime_;
    }

    const ST_DATE_TIME& stAssociationTime() const OMG_NOEXCEPT {
        return m_stAssociationTime_;
    }

    void stAssociationTime(const ST_DATE_TIME& value) {
        m_stAssociationTime_ = value;
    }

    void stAssociationTime(ST_DATE_TIME&& value) {
        m_stAssociationTime_ = std::move(value);
    }
    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const ST_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_GLOBAL_TARGET& other_) const;

    void swap(ST_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNumber_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint32_t m_ulMaintainTime_;
    uint16_t m_usTrackStatus_;
    uint32_t m_ulTrackUpdateCount_;
    uint8_t m_oFriendlyInfo_;
    uint8_t m_oClassInfo_;
    float m_fClassificationScore_;
    uint8_t m_oClassificationStatus_;
    uint8_t m_bIsClassificationPossible_;
    uint8_t m_oAutoClassificationProgress_;
    uint8_t m_oLOFARTonalFreqCnt_;
    ::dds::core::array< float, 24L> m_aLOFARTonalFreq_;
    ::dds::core::array< uint8_t, 24L> m_aIsThreatFreq_;
    uint8_t m_oDEMONTonalFreqCnt_;
    ::dds::core::array< float, 8L> m_aDEMONTonalFreq_;
    uint8_t m_oIsInSurveillanceArea_;
    uint8_t m_oThreatGrade_;
    uint16_t m_usThreatScore_;
    uint8_t m_oAlarmGrade_;
    uint8_t m_oInOutInfo_;
    uint8_t m_oThreatTgt_;
    ST_DATE_TIME m_stThreatTgtRegistrationTime_;
    uint8_t m_oConcernedTgt_;
    ST_DATE_TIME m_stConcernedTgtRegistrationTime_;
    uint8_t m_oAnchoredThreatTgt_;
    ::dds::core::array< uint8_t, 20L> m_aTgtInfo_;
    ::dds::core::array< float, 4L> m_aStateVector_;
    float m_fBearing_;
    float m_fDistance_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fCourse_;
    float m_fVelocity_;
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L> m_aMatP_;
    ::dds::core::array< float, 4L> m_aBearingCovArry_;
    uint8_t m_oNoOfAssociatedSensors_;
    ::dds::core::array< uint8_t, 32L> m_aAssociatedSensors_;
    ::dds::core::array< uint32_t, 32L> m_aAssociatedLocalTgtID_;
    uint8_t m_oOriginSensorID_;
    ST_DATE_TIME m_stInitialDetectionTime_;
    uint8_t m_oTrackReliability_;
    bool m_bIsBISSourceTgt_;
    uint8_t m_oKNTDSSendStatus_;
    ST_DATE_TIME m_stClassificationReqTime_;
    ST_DATE_TIME m_stClassificationResponseTime_;
    ::dds::core::array< float, 32L> m_aRelativeBearingFromSensors_;
    ::dds::core::array< float, 32L> m_aRelativeDistanceFromSensors_;
    ST_BIS_SOURCE_INFO m_stBISSourceInfo_;
    uint8_t m_oFusionProcessed_;
    ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L> m_stRDTgtInfoAssociated_;
    ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L> m_stLASTgtInfoAssociated_;
    ::dds::core::array< ST_BIS_TARGET_ASSOCIATED, 3L> m_stBISTgtInfoAssociated_;
    ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L> m_stMASTgtInfoAssociated_;
    ::dds::core::array< ST_AS_TARGET_ASSOCIATED, 3L> m_stASTgtInfoAssociated_;
    ::dds::core::array< ST_EO_TARGET_ASSOCIATED, 2L> m_stEOTgtInfoAssociated_;
    ST_KNTDS_TARGET_ASSOCIATED m_stKNTDSTgtInfoAssociated_;
    ST_AIS_TARGET_ASSOICATED m_stAISTgtInfoAssociated_;
    uint8_t m_oCPAStatus_;
    ST_CPA_INFO m_stCPAInfo_;
    uint8_t m_oPredictPathStatus_;
    ST_PREDICT_PATH_INFO m_stPredictPathInfo_;
    uint8_t m_oTargetType_;
    uint8_t m_oRefSensorIDForBearingTgt_;
    float m_fAzimuthForBearingTgt_;
    uint8_t m_oIsClassifiedAsEnemyAutomatically_;
    uint16_t m_usNoOfTrkHistory_;
    ::dds::core::array< ST_TARGET_TRACK_HISTORY, 225L> m_aTgtTrkHistory_;
    uint8_t m_oAssociatedStatus_;
    uint16_t m_usAssociatedMasterTgtID_;
    uint8_t m_oNoOfAssociatedSystemTgts_;
    ::dds::core::array< uint16_t, 32L> m_aAssociatedSystemTgtID_;
    uint8_t m_oAssociationReliability_;
    ST_DATE_TIME m_stAssociationTime_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(ST_GLOBAL_TARGET& a, ST_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO {
  public:
    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO();

    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO (TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO&&) = default;
    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& operator=(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO&&) = default;
    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& operator=(const TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO&) = default;
    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO(const TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO&) = default;
    #else
    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& operator=(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& other_) const;
    bool operator != (const TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& other_) const;

    void swap(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& a, TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& sample);

class NDDSUSERDllExport TGTMGR_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_GLOBAL_TARGET_INFO();

    TGTMGR_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,const ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_GLOBAL_TARGET_INFO (TGTMGR_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_GLOBAL_TARGET_INFO& operator=(TGTMGR_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_GLOBAL_TARGET_INFO& operator=(const TGTMGR_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_GLOBAL_TARGET_INFO(const TGTMGR_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_GLOBAL_TARGET_INFO(TGTMGR_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_GLOBAL_TARGET_INFO& operator=(TGTMGR_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_GLOBAL_TARGET_INFO& a, TGTMGR_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport ST_GLOBAL_TARGET_FOR_REMOTE {
  public:
    ST_GLOBAL_TARGET_FOR_REMOTE();

    ST_GLOBAL_TARGET_FOR_REMOTE(uint16_t usTgtNumber,uint8_t oClassInfo,const ST_DATE_TIME& stRegistrationTime,uint32_t ulMaintainTime,uint16_t usTrackStatus,uint8_t oFriendlyInfo,uint8_t oClassificationStatus,uint8_t oIsInSurveillanceArea,uint8_t oThreatGrade,uint8_t oAlarmGrade,uint8_t oInOutInfo,uint8_t oKNTDSSendStatus,uint8_t oThreatTgt,uint8_t oConcernedTgt,const ::dds::core::array< uint8_t, 20L>& aTgtInfo,float fBearing,float fDistance,double dLatitude,double dLongitude,float fCourse,float fVelocity,bool bIsBISSourceTgt,uint8_t oTargetType,uint8_t oRefSensorIDForBearingTgt,float fAzimuthForBearingTgt,const ::dds::core::array< float, 32L>& aRelativeBearingFromSensors,const ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors,uint8_t oAssociatedStatus,uint8_t oNoOfAssociatedSystemTgts,const ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_GLOBAL_TARGET_FOR_REMOTE (ST_GLOBAL_TARGET_FOR_REMOTE&&) = default;
    ST_GLOBAL_TARGET_FOR_REMOTE& operator=(ST_GLOBAL_TARGET_FOR_REMOTE&&) = default;
    ST_GLOBAL_TARGET_FOR_REMOTE& operator=(const ST_GLOBAL_TARGET_FOR_REMOTE&) = default;
    ST_GLOBAL_TARGET_FOR_REMOTE(const ST_GLOBAL_TARGET_FOR_REMOTE&) = default;
    #else
    ST_GLOBAL_TARGET_FOR_REMOTE(ST_GLOBAL_TARGET_FOR_REMOTE&& other_) OMG_NOEXCEPT;  
    ST_GLOBAL_TARGET_FOR_REMOTE& operator=(ST_GLOBAL_TARGET_FOR_REMOTE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNumber() OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    const uint16_t& usTgtNumber() const OMG_NOEXCEPT {
        return m_usTgtNumber_;
    }

    void usTgtNumber(uint16_t value) {
        m_usTgtNumber_ = value;
    }

    uint8_t& oClassInfo() OMG_NOEXCEPT {
        return m_oClassInfo_;
    }

    const uint8_t& oClassInfo() const OMG_NOEXCEPT {
        return m_oClassInfo_;
    }

    void oClassInfo(uint8_t value) {
        m_oClassInfo_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    uint32_t& ulMaintainTime() OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    const uint32_t& ulMaintainTime() const OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    void ulMaintainTime(uint32_t value) {
        m_ulMaintainTime_ = value;
    }

    uint16_t& usTrackStatus() OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    const uint16_t& usTrackStatus() const OMG_NOEXCEPT {
        return m_usTrackStatus_;
    }

    void usTrackStatus(uint16_t value) {
        m_usTrackStatus_ = value;
    }

    uint8_t& oFriendlyInfo() OMG_NOEXCEPT {
        return m_oFriendlyInfo_;
    }

    const uint8_t& oFriendlyInfo() const OMG_NOEXCEPT {
        return m_oFriendlyInfo_;
    }

    void oFriendlyInfo(uint8_t value) {
        m_oFriendlyInfo_ = value;
    }

    uint8_t& oClassificationStatus() OMG_NOEXCEPT {
        return m_oClassificationStatus_;
    }

    const uint8_t& oClassificationStatus() const OMG_NOEXCEPT {
        return m_oClassificationStatus_;
    }

    void oClassificationStatus(uint8_t value) {
        m_oClassificationStatus_ = value;
    }

    uint8_t& oIsInSurveillanceArea() OMG_NOEXCEPT {
        return m_oIsInSurveillanceArea_;
    }

    const uint8_t& oIsInSurveillanceArea() const OMG_NOEXCEPT {
        return m_oIsInSurveillanceArea_;
    }

    void oIsInSurveillanceArea(uint8_t value) {
        m_oIsInSurveillanceArea_ = value;
    }

    uint8_t& oThreatGrade() OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    const uint8_t& oThreatGrade() const OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    void oThreatGrade(uint8_t value) {
        m_oThreatGrade_ = value;
    }

    uint8_t& oAlarmGrade() OMG_NOEXCEPT {
        return m_oAlarmGrade_;
    }

    const uint8_t& oAlarmGrade() const OMG_NOEXCEPT {
        return m_oAlarmGrade_;
    }

    void oAlarmGrade(uint8_t value) {
        m_oAlarmGrade_ = value;
    }

    uint8_t& oInOutInfo() OMG_NOEXCEPT {
        return m_oInOutInfo_;
    }

    const uint8_t& oInOutInfo() const OMG_NOEXCEPT {
        return m_oInOutInfo_;
    }

    void oInOutInfo(uint8_t value) {
        m_oInOutInfo_ = value;
    }

    uint8_t& oKNTDSSendStatus() OMG_NOEXCEPT {
        return m_oKNTDSSendStatus_;
    }

    const uint8_t& oKNTDSSendStatus() const OMG_NOEXCEPT {
        return m_oKNTDSSendStatus_;
    }

    void oKNTDSSendStatus(uint8_t value) {
        m_oKNTDSSendStatus_ = value;
    }

    uint8_t& oThreatTgt() OMG_NOEXCEPT {
        return m_oThreatTgt_;
    }

    const uint8_t& oThreatTgt() const OMG_NOEXCEPT {
        return m_oThreatTgt_;
    }

    void oThreatTgt(uint8_t value) {
        m_oThreatTgt_ = value;
    }

    uint8_t& oConcernedTgt() OMG_NOEXCEPT {
        return m_oConcernedTgt_;
    }

    const uint8_t& oConcernedTgt() const OMG_NOEXCEPT {
        return m_oConcernedTgt_;
    }

    void oConcernedTgt(uint8_t value) {
        m_oConcernedTgt_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& aTgtInfo() OMG_NOEXCEPT {
        return m_aTgtInfo_;
    }

    const ::dds::core::array< uint8_t, 20L>& aTgtInfo() const OMG_NOEXCEPT {
        return m_aTgtInfo_;
    }

    void aTgtInfo(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aTgtInfo_ = value;
    }

    void aTgtInfo(::dds::core::array< uint8_t, 20L>&& value) {
        m_aTgtInfo_ = std::move(value);
    }
    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    bool& bIsBISSourceTgt() OMG_NOEXCEPT {
        return m_bIsBISSourceTgt_;
    }

    const bool& bIsBISSourceTgt() const OMG_NOEXCEPT {
        return m_bIsBISSourceTgt_;
    }

    void bIsBISSourceTgt(bool value) {
        m_bIsBISSourceTgt_ = value;
    }

    uint8_t& oTargetType() OMG_NOEXCEPT {
        return m_oTargetType_;
    }

    const uint8_t& oTargetType() const OMG_NOEXCEPT {
        return m_oTargetType_;
    }

    void oTargetType(uint8_t value) {
        m_oTargetType_ = value;
    }

    uint8_t& oRefSensorIDForBearingTgt() OMG_NOEXCEPT {
        return m_oRefSensorIDForBearingTgt_;
    }

    const uint8_t& oRefSensorIDForBearingTgt() const OMG_NOEXCEPT {
        return m_oRefSensorIDForBearingTgt_;
    }

    void oRefSensorIDForBearingTgt(uint8_t value) {
        m_oRefSensorIDForBearingTgt_ = value;
    }

    float& fAzimuthForBearingTgt() OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    const float& fAzimuthForBearingTgt() const OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    void fAzimuthForBearingTgt(float value) {
        m_fAzimuthForBearingTgt_ = value;
    }

    ::dds::core::array< float, 32L>& aRelativeBearingFromSensors() OMG_NOEXCEPT {
        return m_aRelativeBearingFromSensors_;
    }

    const ::dds::core::array< float, 32L>& aRelativeBearingFromSensors() const OMG_NOEXCEPT {
        return m_aRelativeBearingFromSensors_;
    }

    void aRelativeBearingFromSensors(const ::dds::core::array< float, 32L>& value) {
        m_aRelativeBearingFromSensors_ = value;
    }

    void aRelativeBearingFromSensors(::dds::core::array< float, 32L>&& value) {
        m_aRelativeBearingFromSensors_ = std::move(value);
    }
    ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors() OMG_NOEXCEPT {
        return m_aRelativeDistanceFromSensors_;
    }

    const ::dds::core::array< float, 32L>& aRelativeDistanceFromSensors() const OMG_NOEXCEPT {
        return m_aRelativeDistanceFromSensors_;
    }

    void aRelativeDistanceFromSensors(const ::dds::core::array< float, 32L>& value) {
        m_aRelativeDistanceFromSensors_ = value;
    }

    void aRelativeDistanceFromSensors(::dds::core::array< float, 32L>&& value) {
        m_aRelativeDistanceFromSensors_ = std::move(value);
    }
    uint8_t& oAssociatedStatus() OMG_NOEXCEPT {
        return m_oAssociatedStatus_;
    }

    const uint8_t& oAssociatedStatus() const OMG_NOEXCEPT {
        return m_oAssociatedStatus_;
    }

    void oAssociatedStatus(uint8_t value) {
        m_oAssociatedStatus_ = value;
    }

    uint8_t& oNoOfAssociatedSystemTgts() OMG_NOEXCEPT {
        return m_oNoOfAssociatedSystemTgts_;
    }

    const uint8_t& oNoOfAssociatedSystemTgts() const OMG_NOEXCEPT {
        return m_oNoOfAssociatedSystemTgts_;
    }

    void oNoOfAssociatedSystemTgts(uint8_t value) {
        m_oNoOfAssociatedSystemTgts_ = value;
    }

    ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID() OMG_NOEXCEPT {
        return m_aAssociatedSystemTgtID_;
    }

    const ::dds::core::array< uint16_t, 32L>& aAssociatedSystemTgtID() const OMG_NOEXCEPT {
        return m_aAssociatedSystemTgtID_;
    }

    void aAssociatedSystemTgtID(const ::dds::core::array< uint16_t, 32L>& value) {
        m_aAssociatedSystemTgtID_ = value;
    }

    void aAssociatedSystemTgtID(::dds::core::array< uint16_t, 32L>&& value) {
        m_aAssociatedSystemTgtID_ = std::move(value);
    }
    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const ST_GLOBAL_TARGET_FOR_REMOTE& other_) const;
    bool operator != (const ST_GLOBAL_TARGET_FOR_REMOTE& other_) const;

    void swap(ST_GLOBAL_TARGET_FOR_REMOTE& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNumber_;
    uint8_t m_oClassInfo_;
    ST_DATE_TIME m_stRegistrationTime_;
    uint32_t m_ulMaintainTime_;
    uint16_t m_usTrackStatus_;
    uint8_t m_oFriendlyInfo_;
    uint8_t m_oClassificationStatus_;
    uint8_t m_oIsInSurveillanceArea_;
    uint8_t m_oThreatGrade_;
    uint8_t m_oAlarmGrade_;
    uint8_t m_oInOutInfo_;
    uint8_t m_oKNTDSSendStatus_;
    uint8_t m_oThreatTgt_;
    uint8_t m_oConcernedTgt_;
    ::dds::core::array< uint8_t, 20L> m_aTgtInfo_;
    float m_fBearing_;
    float m_fDistance_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fCourse_;
    float m_fVelocity_;
    bool m_bIsBISSourceTgt_;
    uint8_t m_oTargetType_;
    uint8_t m_oRefSensorIDForBearingTgt_;
    float m_fAzimuthForBearingTgt_;
    ::dds::core::array< float, 32L> m_aRelativeBearingFromSensors_;
    ::dds::core::array< float, 32L> m_aRelativeDistanceFromSensors_;
    uint8_t m_oAssociatedStatus_;
    uint8_t m_oNoOfAssociatedSystemTgts_;
    ::dds::core::array< uint16_t, 32L> m_aAssociatedSystemTgtID_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(ST_GLOBAL_TARGET_FOR_REMOTE& a, ST_GLOBAL_TARGET_FOR_REMOTE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_GLOBAL_TARGET_FOR_REMOTE& sample);

class NDDSUSERDllExport TGTMGR_GLOBAL_TARGET_RMT_INFO {
  public:
    TGTMGR_GLOBAL_TARGET_RMT_INFO();

    TGTMGR_GLOBAL_TARGET_RMT_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulNumOfTargets,const ::dds::core::array< ST_GLOBAL_TARGET_FOR_REMOTE, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_GLOBAL_TARGET_RMT_INFO (TGTMGR_GLOBAL_TARGET_RMT_INFO&&) = default;
    TGTMGR_GLOBAL_TARGET_RMT_INFO& operator=(TGTMGR_GLOBAL_TARGET_RMT_INFO&&) = default;
    TGTMGR_GLOBAL_TARGET_RMT_INFO& operator=(const TGTMGR_GLOBAL_TARGET_RMT_INFO&) = default;
    TGTMGR_GLOBAL_TARGET_RMT_INFO(const TGTMGR_GLOBAL_TARGET_RMT_INFO&) = default;
    #else
    TGTMGR_GLOBAL_TARGET_RMT_INFO(TGTMGR_GLOBAL_TARGET_RMT_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_GLOBAL_TARGET_RMT_INFO& operator=(TGTMGR_GLOBAL_TARGET_RMT_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulNumOfTargets() OMG_NOEXCEPT {
        return m_ulNumOfTargets_;
    }

    const uint32_t& ulNumOfTargets() const OMG_NOEXCEPT {
        return m_ulNumOfTargets_;
    }

    void ulNumOfTargets(uint32_t value) {
        m_ulNumOfTargets_ = value;
    }

    ::dds::core::array< ST_GLOBAL_TARGET_FOR_REMOTE, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_GLOBAL_TARGET_FOR_REMOTE, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_GLOBAL_TARGET_FOR_REMOTE, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_GLOBAL_TARGET_FOR_REMOTE, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_GLOBAL_TARGET_RMT_INFO& other_) const;
    bool operator != (const TGTMGR_GLOBAL_TARGET_RMT_INFO& other_) const;

    void swap(TGTMGR_GLOBAL_TARGET_RMT_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulNumOfTargets_;
    ::dds::core::array< ST_GLOBAL_TARGET_FOR_REMOTE, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_GLOBAL_TARGET_RMT_INFO& a, TGTMGR_GLOBAL_TARGET_RMT_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_GLOBAL_TARGET_RMT_INFO& sample);

class NDDSUSERDllExport ST_KNTDS_FUSED_GLOBAL_TARGET {
  public:
    ST_KNTDS_FUSED_GLOBAL_TARGET();

    ST_KNTDS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ST_KNTDS_TARGET_ASSOCIATED& stKNTDSTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_KNTDS_FUSED_GLOBAL_TARGET (ST_KNTDS_FUSED_GLOBAL_TARGET&&) = default;
    ST_KNTDS_FUSED_GLOBAL_TARGET& operator=(ST_KNTDS_FUSED_GLOBAL_TARGET&&) = default;
    ST_KNTDS_FUSED_GLOBAL_TARGET& operator=(const ST_KNTDS_FUSED_GLOBAL_TARGET&) = default;
    ST_KNTDS_FUSED_GLOBAL_TARGET(const ST_KNTDS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_KNTDS_FUSED_GLOBAL_TARGET(ST_KNTDS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_KNTDS_FUSED_GLOBAL_TARGET& operator=(ST_KNTDS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ST_KNTDS_TARGET_ASSOCIATED& stKNTDSTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stKNTDSTgtInfoAssociated_;
    }

    const ST_KNTDS_TARGET_ASSOCIATED& stKNTDSTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stKNTDSTgtInfoAssociated_;
    }

    void stKNTDSTgtInfoAssociated(const ST_KNTDS_TARGET_ASSOCIATED& value) {
        m_stKNTDSTgtInfoAssociated_ = value;
    }

    void stKNTDSTgtInfoAssociated(ST_KNTDS_TARGET_ASSOCIATED&& value) {
        m_stKNTDSTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_KNTDS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_KNTDS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_KNTDS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ST_KNTDS_TARGET_ASSOCIATED m_stKNTDSTgtInfoAssociated_;

};

inline void swap(ST_KNTDS_FUSED_GLOBAL_TARGET& a, ST_KNTDS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_KNTDS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_KNTDS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_KNTDS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_KNTDS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_KNTDS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_KNTDS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_KNTDS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND {
  public:
    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND();

    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oSemiOITType,const ::dds::core::array< uint8_t, 3L>& aAxisValidFlag,const ::dds::core::array< uint8_t, 3L>& aAxisBearing,uint16_t usLASTgtNo,uint8_t oLOFARTonalFreqCnt,const ::dds::core::array< float, 24L>& aLOFARTonalFreq,uint8_t oDEMONTonalFreqCnt,const ::dds::core::array< float, 6L>& aDEMONTonalFreq,const ::dds::core::array< uint16_t, 2L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND (TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND&&) = default;
    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& operator=(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND&&) = default;
    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& operator=(const TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND&) = default;
    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND(const TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND&) = default;
    #else
    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& operator=(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSemiOITType() OMG_NOEXCEPT {
        return m_oSemiOITType_;
    }

    const uint8_t& oSemiOITType() const OMG_NOEXCEPT {
        return m_oSemiOITType_;
    }

    void oSemiOITType(uint8_t value) {
        m_oSemiOITType_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& aAxisValidFlag() OMG_NOEXCEPT {
        return m_aAxisValidFlag_;
    }

    const ::dds::core::array< uint8_t, 3L>& aAxisValidFlag() const OMG_NOEXCEPT {
        return m_aAxisValidFlag_;
    }

    void aAxisValidFlag(const ::dds::core::array< uint8_t, 3L>& value) {
        m_aAxisValidFlag_ = value;
    }

    void aAxisValidFlag(::dds::core::array< uint8_t, 3L>&& value) {
        m_aAxisValidFlag_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& aAxisBearing() OMG_NOEXCEPT {
        return m_aAxisBearing_;
    }

    const ::dds::core::array< uint8_t, 3L>& aAxisBearing() const OMG_NOEXCEPT {
        return m_aAxisBearing_;
    }

    void aAxisBearing(const ::dds::core::array< uint8_t, 3L>& value) {
        m_aAxisBearing_ = value;
    }

    void aAxisBearing(::dds::core::array< uint8_t, 3L>&& value) {
        m_aAxisBearing_ = std::move(value);
    }
    uint16_t& usLASTgtNo() OMG_NOEXCEPT {
        return m_usLASTgtNo_;
    }

    const uint16_t& usLASTgtNo() const OMG_NOEXCEPT {
        return m_usLASTgtNo_;
    }

    void usLASTgtNo(uint16_t value) {
        m_usLASTgtNo_ = value;
    }

    uint8_t& oLOFARTonalFreqCnt() OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    const uint8_t& oLOFARTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oLOFARTonalFreqCnt_;
    }

    void oLOFARTonalFreqCnt(uint8_t value) {
        m_oLOFARTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aLOFARTonalFreq() OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    const ::dds::core::array< float, 24L>& aLOFARTonalFreq() const OMG_NOEXCEPT {
        return m_aLOFARTonalFreq_;
    }

    void aLOFARTonalFreq(const ::dds::core::array< float, 24L>& value) {
        m_aLOFARTonalFreq_ = value;
    }

    void aLOFARTonalFreq(::dds::core::array< float, 24L>&& value) {
        m_aLOFARTonalFreq_ = std::move(value);
    }
    uint8_t& oDEMONTonalFreqCnt() OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    const uint8_t& oDEMONTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oDEMONTonalFreqCnt_;
    }

    void oDEMONTonalFreqCnt(uint8_t value) {
        m_oDEMONTonalFreqCnt_ = value;
    }

    ::dds::core::array< float, 6L>& aDEMONTonalFreq() OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    const ::dds::core::array< float, 6L>& aDEMONTonalFreq() const OMG_NOEXCEPT {
        return m_aDEMONTonalFreq_;
    }

    void aDEMONTonalFreq(const ::dds::core::array< float, 6L>& value) {
        m_aDEMONTonalFreq_ = value;
    }

    void aDEMONTonalFreq(::dds::core::array< float, 6L>&& value) {
        m_aDEMONTonalFreq_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& other_) const;
    bool operator != (const TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& other_) const;

    void swap(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSemiOITType_;
    ::dds::core::array< uint8_t, 3L> m_aAxisValidFlag_;
    ::dds::core::array< uint8_t, 3L> m_aAxisBearing_;
    uint16_t m_usLASTgtNo_;
    uint8_t m_oLOFARTonalFreqCnt_;
    ::dds::core::array< float, 24L> m_aLOFARTonalFreq_;
    uint8_t m_oDEMONTonalFreqCnt_;
    ::dds::core::array< float, 6L> m_aDEMONTonalFreq_;
    ::dds::core::array< uint16_t, 2L> m_aReserved_;

};

inline void swap(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& a, TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample);

class NDDSUSERDllExport ST_LAS_FUSED_GLOBAL_TARGET {
  public:
    ST_LAS_FUSED_GLOBAL_TARGET();

    ST_LAS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& stLASTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_FUSED_GLOBAL_TARGET (ST_LAS_FUSED_GLOBAL_TARGET&&) = default;
    ST_LAS_FUSED_GLOBAL_TARGET& operator=(ST_LAS_FUSED_GLOBAL_TARGET&&) = default;
    ST_LAS_FUSED_GLOBAL_TARGET& operator=(const ST_LAS_FUSED_GLOBAL_TARGET&) = default;
    ST_LAS_FUSED_GLOBAL_TARGET(const ST_LAS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_LAS_FUSED_GLOBAL_TARGET(ST_LAS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_LAS_FUSED_GLOBAL_TARGET& operator=(ST_LAS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& stLASTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stLASTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& stLASTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stLASTgtInfoAssociated_;
    }

    void stLASTgtInfoAssociated(const ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>& value) {
        m_stLASTgtInfoAssociated_ = value;
    }

    void stLASTgtInfoAssociated(::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L>&& value) {
        m_stLASTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_LAS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_LAS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_LAS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ::dds::core::array< ST_LAS_TARGET_ASSOICATED, 3L> m_stLASTgtInfoAssociated_;

};

inline void swap(ST_LAS_FUSED_GLOBAL_TARGET& a, ST_LAS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_LAS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_LAS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_LAS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_LAS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_LAS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_LAS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport TGTMGR_LAS_TRACK_DELETE_CONTROL {
  public:
    TGTMGR_LAS_TRACK_DELETE_CONTROL();

    TGTMGR_LAS_TRACK_DELETE_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint16_t usTgtNo,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LAS_TRACK_DELETE_CONTROL (TGTMGR_LAS_TRACK_DELETE_CONTROL&&) = default;
    TGTMGR_LAS_TRACK_DELETE_CONTROL& operator=(TGTMGR_LAS_TRACK_DELETE_CONTROL&&) = default;
    TGTMGR_LAS_TRACK_DELETE_CONTROL& operator=(const TGTMGR_LAS_TRACK_DELETE_CONTROL&) = default;
    TGTMGR_LAS_TRACK_DELETE_CONTROL(const TGTMGR_LAS_TRACK_DELETE_CONTROL&) = default;
    #else
    TGTMGR_LAS_TRACK_DELETE_CONTROL(TGTMGR_LAS_TRACK_DELETE_CONTROL&& other_) OMG_NOEXCEPT;  
    TGTMGR_LAS_TRACK_DELETE_CONTROL& operator=(TGTMGR_LAS_TRACK_DELETE_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint16_t& usTgtNo() OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    const uint16_t& usTgtNo() const OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    void usTgtNo(uint16_t value) {
        m_usTgtNo_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const TGTMGR_LAS_TRACK_DELETE_CONTROL& other_) const;
    bool operator != (const TGTMGR_LAS_TRACK_DELETE_CONTROL& other_) const;

    void swap(TGTMGR_LAS_TRACK_DELETE_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint16_t m_usTgtNo_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(TGTMGR_LAS_TRACK_DELETE_CONTROL& a, TGTMGR_LAS_TRACK_DELETE_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LAS_TRACK_DELETE_CONTROL& sample);

class NDDSUSERDllExport TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL {
  public:
    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL();

    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint16_t usTgtNo,uint8_t oDetectionType,uint8_t oSFLIndex,float fFreq,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL (TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL&&) = default;
    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& operator=(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL&&) = default;
    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& operator=(const TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL&) = default;
    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL(const TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL&) = default;
    #else
    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL&& other_) OMG_NOEXCEPT;  
    TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& operator=(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint16_t& usTgtNo() OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    const uint16_t& usTgtNo() const OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    void usTgtNo(uint16_t value) {
        m_usTgtNo_ = value;
    }

    uint8_t& oDetectionType() OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    const uint8_t& oDetectionType() const OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    void oDetectionType(uint8_t value) {
        m_oDetectionType_ = value;
    }

    uint8_t& oSFLIndex() OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    const uint8_t& oSFLIndex() const OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    void oSFLIndex(uint8_t value) {
        m_oSFLIndex_ = value;
    }

    float& fFreq() OMG_NOEXCEPT {
        return m_fFreq_;
    }

    const float& fFreq() const OMG_NOEXCEPT {
        return m_fFreq_;
    }

    void fFreq(float value) {
        m_fFreq_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& other_) const;
    bool operator != (const TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& other_) const;

    void swap(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint16_t m_usTgtNo_;
    uint8_t m_oDetectionType_;
    uint8_t m_oSFLIndex_;
    float m_fFreq_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& a, TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& sample);

class NDDSUSERDllExport TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND {
  public:
    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND();

    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usCommandID,uint16_t usConfirmType,uint8_t oAxis,uint16_t usTgtID,uint8_t oDetectionType,float fFreq,uint8_t oSFLIndex,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND (TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& operator=(const TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND(const TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint16_t& usConfirmType() OMG_NOEXCEPT {
        return m_usConfirmType_;
    }

    const uint16_t& usConfirmType() const OMG_NOEXCEPT {
        return m_usConfirmType_;
    }

    void usConfirmType(uint16_t value) {
        m_usConfirmType_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& usTgtID() OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    const uint16_t& usTgtID() const OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    void usTgtID(uint16_t value) {
        m_usTgtID_ = value;
    }

    uint8_t& oDetectionType() OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    const uint8_t& oDetectionType() const OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    void oDetectionType(uint8_t value) {
        m_oDetectionType_ = value;
    }

    float& fFreq() OMG_NOEXCEPT {
        return m_fFreq_;
    }

    const float& fFreq() const OMG_NOEXCEPT {
        return m_fFreq_;
    }

    void fFreq(float value) {
        m_fFreq_ = value;
    }

    uint8_t& oSFLIndex() OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    const uint8_t& oSFLIndex() const OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    void oSFLIndex(uint8_t value) {
        m_oSFLIndex_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usCommandID_;
    uint16_t m_usConfirmType_;
    uint8_t m_oAxis_;
    uint16_t m_usTgtID_;
    uint8_t m_oDetectionType_;
    float m_fFreq_;
    uint8_t m_oSFLIndex_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& a, TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport ST_AIS_NETWORK_TARGET {
  public:
    ST_AIS_NETWORK_TARGET();

    ST_AIS_NETWORK_TARGET(uint32_t ulTgtNumber,float fDistance,float fBearing,float fCourse,float fVelocity,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,uint32_t ulMaintainTime,double dLatitude,double dLongitude,float fPosXOnGlobalCoordinate,float fPosYOnGlobalCoordinate,uint16_t usUserChange,uint16_t usGTRegistered,uint16_t usGTTgtNo,uint16_t usConcernedTargetInfo,float fShipWidth,float fShipLength,uint16_t usNationalityCode,const ST_AIS_TARGET& stAISTargetInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AIS_NETWORK_TARGET (ST_AIS_NETWORK_TARGET&&) = default;
    ST_AIS_NETWORK_TARGET& operator=(ST_AIS_NETWORK_TARGET&&) = default;
    ST_AIS_NETWORK_TARGET& operator=(const ST_AIS_NETWORK_TARGET&) = default;
    ST_AIS_NETWORK_TARGET(const ST_AIS_NETWORK_TARGET&) = default;
    #else
    ST_AIS_NETWORK_TARGET(ST_AIS_NETWORK_TARGET&& other_) OMG_NOEXCEPT;  
    ST_AIS_NETWORK_TARGET& operator=(ST_AIS_NETWORK_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulTgtNumber() OMG_NOEXCEPT {
        return m_ulTgtNumber_;
    }

    const uint32_t& ulTgtNumber() const OMG_NOEXCEPT {
        return m_ulTgtNumber_;
    }

    void ulTgtNumber(uint32_t value) {
        m_ulTgtNumber_ = value;
    }

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    uint32_t& ulMaintainTime() OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    const uint32_t& ulMaintainTime() const OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    void ulMaintainTime(uint32_t value) {
        m_ulMaintainTime_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fPosXOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    const float& fPosXOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosXOnGlobalCoordinate_;
    }

    void fPosXOnGlobalCoordinate(float value) {
        m_fPosXOnGlobalCoordinate_ = value;
    }

    float& fPosYOnGlobalCoordinate() OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    const float& fPosYOnGlobalCoordinate() const OMG_NOEXCEPT {
        return m_fPosYOnGlobalCoordinate_;
    }

    void fPosYOnGlobalCoordinate(float value) {
        m_fPosYOnGlobalCoordinate_ = value;
    }

    uint16_t& usUserChange() OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    const uint16_t& usUserChange() const OMG_NOEXCEPT {
        return m_usUserChange_;
    }

    void usUserChange(uint16_t value) {
        m_usUserChange_ = value;
    }

    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    uint16_t& usConcernedTargetInfo() OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    const uint16_t& usConcernedTargetInfo() const OMG_NOEXCEPT {
        return m_usConcernedTargetInfo_;
    }

    void usConcernedTargetInfo(uint16_t value) {
        m_usConcernedTargetInfo_ = value;
    }

    float& fShipWidth() OMG_NOEXCEPT {
        return m_fShipWidth_;
    }

    const float& fShipWidth() const OMG_NOEXCEPT {
        return m_fShipWidth_;
    }

    void fShipWidth(float value) {
        m_fShipWidth_ = value;
    }

    float& fShipLength() OMG_NOEXCEPT {
        return m_fShipLength_;
    }

    const float& fShipLength() const OMG_NOEXCEPT {
        return m_fShipLength_;
    }

    void fShipLength(float value) {
        m_fShipLength_ = value;
    }

    uint16_t& usNationalityCode() OMG_NOEXCEPT {
        return m_usNationalityCode_;
    }

    const uint16_t& usNationalityCode() const OMG_NOEXCEPT {
        return m_usNationalityCode_;
    }

    void usNationalityCode(uint16_t value) {
        m_usNationalityCode_ = value;
    }

    ST_AIS_TARGET& stAISTargetInfo() OMG_NOEXCEPT {
        return m_stAISTargetInfo_;
    }

    const ST_AIS_TARGET& stAISTargetInfo() const OMG_NOEXCEPT {
        return m_stAISTargetInfo_;
    }

    void stAISTargetInfo(const ST_AIS_TARGET& value) {
        m_stAISTargetInfo_ = value;
    }

    void stAISTargetInfo(ST_AIS_TARGET&& value) {
        m_stAISTargetInfo_ = std::move(value);
    }

    bool operator == (const ST_AIS_NETWORK_TARGET& other_) const;
    bool operator != (const ST_AIS_NETWORK_TARGET& other_) const;

    void swap(ST_AIS_NETWORK_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulTgtNumber_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fCourse_;
    float m_fVelocity_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    uint32_t m_ulMaintainTime_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fPosXOnGlobalCoordinate_;
    float m_fPosYOnGlobalCoordinate_;
    uint16_t m_usUserChange_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;
    uint16_t m_usConcernedTargetInfo_;
    float m_fShipWidth_;
    float m_fShipLength_;
    uint16_t m_usNationalityCode_;
    ST_AIS_TARGET m_stAISTargetInfo_;

};

inline void swap(ST_AIS_NETWORK_TARGET& a, ST_AIS_NETWORK_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AIS_NETWORK_TARGET& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_AIS_INFO {
  public:
    TGTMGR_LOCAL_TARGET_AIS_INFO();

    TGTMGR_LOCAL_TARGET_AIS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ::dds::core::array< ST_AIS_NETWORK_TARGET, 1000L>& stAISTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_AIS_INFO (TGTMGR_LOCAL_TARGET_AIS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_AIS_INFO& operator=(TGTMGR_LOCAL_TARGET_AIS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_AIS_INFO& operator=(const TGTMGR_LOCAL_TARGET_AIS_INFO&) = default;
    TGTMGR_LOCAL_TARGET_AIS_INFO(const TGTMGR_LOCAL_TARGET_AIS_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_AIS_INFO(TGTMGR_LOCAL_TARGET_AIS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_AIS_INFO& operator=(TGTMGR_LOCAL_TARGET_AIS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_AIS_NETWORK_TARGET, 1000L>& stAISTgtInfo() OMG_NOEXCEPT {
        return m_stAISTgtInfo_;
    }

    const ::dds::core::array< ST_AIS_NETWORK_TARGET, 1000L>& stAISTgtInfo() const OMG_NOEXCEPT {
        return m_stAISTgtInfo_;
    }

    void stAISTgtInfo(const ::dds::core::array< ST_AIS_NETWORK_TARGET, 1000L>& value) {
        m_stAISTgtInfo_ = value;
    }

    void stAISTgtInfo(::dds::core::array< ST_AIS_NETWORK_TARGET, 1000L>&& value) {
        m_stAISTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_AIS_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_AIS_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_AIS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_AIS_NETWORK_TARGET, 1000L> m_stAISTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_AIS_INFO& a, TGTMGR_LOCAL_TARGET_AIS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_AIS_INFO& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_AS_INFO {
  public:
    TGTMGR_LOCAL_TARGET_AS_INFO();

    TGTMGR_LOCAL_TARGET_AS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ::dds::core::array< ST_AS_LOCAL_TARGET, 120L>& stASTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_AS_INFO (TGTMGR_LOCAL_TARGET_AS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_AS_INFO& operator=(TGTMGR_LOCAL_TARGET_AS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_AS_INFO& operator=(const TGTMGR_LOCAL_TARGET_AS_INFO&) = default;
    TGTMGR_LOCAL_TARGET_AS_INFO(const TGTMGR_LOCAL_TARGET_AS_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_AS_INFO(TGTMGR_LOCAL_TARGET_AS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_AS_INFO& operator=(TGTMGR_LOCAL_TARGET_AS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_AS_LOCAL_TARGET, 120L>& stASTgtInfo() OMG_NOEXCEPT {
        return m_stASTgtInfo_;
    }

    const ::dds::core::array< ST_AS_LOCAL_TARGET, 120L>& stASTgtInfo() const OMG_NOEXCEPT {
        return m_stASTgtInfo_;
    }

    void stASTgtInfo(const ::dds::core::array< ST_AS_LOCAL_TARGET, 120L>& value) {
        m_stASTgtInfo_ = value;
    }

    void stASTgtInfo(::dds::core::array< ST_AS_LOCAL_TARGET, 120L>&& value) {
        m_stASTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_AS_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_AS_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_AS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_AS_LOCAL_TARGET, 120L> m_stASTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_AS_INFO& a, TGTMGR_LOCAL_TARGET_AS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_AS_INFO& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_BIS_INFO {
  public:
    TGTMGR_LOCAL_TARGET_BIS_INFO();

    TGTMGR_LOCAL_TARGET_BIS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,const ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& stBISTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_BIS_INFO (TGTMGR_LOCAL_TARGET_BIS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_BIS_INFO& operator=(TGTMGR_LOCAL_TARGET_BIS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_BIS_INFO& operator=(const TGTMGR_LOCAL_TARGET_BIS_INFO&) = default;
    TGTMGR_LOCAL_TARGET_BIS_INFO(const TGTMGR_LOCAL_TARGET_BIS_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_BIS_INFO(TGTMGR_LOCAL_TARGET_BIS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_BIS_INFO& operator=(TGTMGR_LOCAL_TARGET_BIS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& stBISTgtInfo() OMG_NOEXCEPT {
        return m_stBISTgtInfo_;
    }

    const ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& stBISTgtInfo() const OMG_NOEXCEPT {
        return m_stBISTgtInfo_;
    }

    void stBISTgtInfo(const ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>& value) {
        m_stBISTgtInfo_ = value;
    }

    void stBISTgtInfo(::dds::core::array< ST_BIS_LOCAL_TARGET, 3L>&& value) {
        m_stBISTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_BIS_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_BIS_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_BIS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    ::dds::core::array< ST_BIS_LOCAL_TARGET, 3L> m_stBISTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_BIS_INFO& a, TGTMGR_LOCAL_TARGET_BIS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_BIS_INFO& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_EO_INFO {
  public:
    TGTMGR_LOCAL_TARGET_EO_INFO();

    TGTMGR_LOCAL_TARGET_EO_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ST_EO_LOCAL_TARGET& stEOTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_EO_INFO (TGTMGR_LOCAL_TARGET_EO_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_EO_INFO& operator=(TGTMGR_LOCAL_TARGET_EO_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_EO_INFO& operator=(const TGTMGR_LOCAL_TARGET_EO_INFO&) = default;
    TGTMGR_LOCAL_TARGET_EO_INFO(const TGTMGR_LOCAL_TARGET_EO_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_EO_INFO(TGTMGR_LOCAL_TARGET_EO_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_EO_INFO& operator=(TGTMGR_LOCAL_TARGET_EO_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ST_EO_LOCAL_TARGET& stEOTgtInfo() OMG_NOEXCEPT {
        return m_stEOTgtInfo_;
    }

    const ST_EO_LOCAL_TARGET& stEOTgtInfo() const OMG_NOEXCEPT {
        return m_stEOTgtInfo_;
    }

    void stEOTgtInfo(const ST_EO_LOCAL_TARGET& value) {
        m_stEOTgtInfo_ = value;
    }

    void stEOTgtInfo(ST_EO_LOCAL_TARGET&& value) {
        m_stEOTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_EO_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_EO_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_EO_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ST_EO_LOCAL_TARGET m_stEOTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_EO_INFO& a, TGTMGR_LOCAL_TARGET_EO_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_EO_INFO& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_KNTDS_INFO {
  public:
    TGTMGR_LOCAL_TARGET_KNTDS_INFO();

    TGTMGR_LOCAL_TARGET_KNTDS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& stKNTDSTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_KNTDS_INFO (TGTMGR_LOCAL_TARGET_KNTDS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_KNTDS_INFO& operator=(TGTMGR_LOCAL_TARGET_KNTDS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_KNTDS_INFO& operator=(const TGTMGR_LOCAL_TARGET_KNTDS_INFO&) = default;
    TGTMGR_LOCAL_TARGET_KNTDS_INFO(const TGTMGR_LOCAL_TARGET_KNTDS_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_KNTDS_INFO(TGTMGR_LOCAL_TARGET_KNTDS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_KNTDS_INFO& operator=(TGTMGR_LOCAL_TARGET_KNTDS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& stKNTDSTgtInfo() OMG_NOEXCEPT {
        return m_stKNTDSTgtInfo_;
    }

    const ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& stKNTDSTgtInfo() const OMG_NOEXCEPT {
        return m_stKNTDSTgtInfo_;
    }

    void stKNTDSTgtInfo(const ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>& value) {
        m_stKNTDSTgtInfo_ = value;
    }

    void stKNTDSTgtInfo(::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L>&& value) {
        m_stKNTDSTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_KNTDS_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_KNTDS_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_KNTDS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_KNTDS_NETWORK_TARGET, 1000L> m_stKNTDSTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_KNTDS_INFO& a, TGTMGR_LOCAL_TARGET_KNTDS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_KNTDS_INFO& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_LAS_INFO {
  public:
    TGTMGR_LOCAL_TARGET_LAS_INFO();

    TGTMGR_LOCAL_TARGET_LAS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,const ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& stLASTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_LAS_INFO (TGTMGR_LOCAL_TARGET_LAS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_LAS_INFO& operator=(TGTMGR_LOCAL_TARGET_LAS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_LAS_INFO& operator=(const TGTMGR_LOCAL_TARGET_LAS_INFO&) = default;
    TGTMGR_LOCAL_TARGET_LAS_INFO(const TGTMGR_LOCAL_TARGET_LAS_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_LAS_INFO(TGTMGR_LOCAL_TARGET_LAS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_LAS_INFO& operator=(TGTMGR_LOCAL_TARGET_LAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& stLASTgtInfo() OMG_NOEXCEPT {
        return m_stLASTgtInfo_;
    }

    const ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& stLASTgtInfo() const OMG_NOEXCEPT {
        return m_stLASTgtInfo_;
    }

    void stLASTgtInfo(const ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>& value) {
        m_stLASTgtInfo_ = value;
    }

    void stLASTgtInfo(::dds::core::array< ST_LAS_LOCAL_TARGET, 3L>&& value) {
        m_stLASTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_LAS_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_LAS_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_LAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    ::dds::core::array< ST_LAS_LOCAL_TARGET, 3L> m_stLASTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_LAS_INFO& a, TGTMGR_LOCAL_TARGET_LAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_LAS_INFO& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_MAS_INFO {
  public:
    TGTMGR_LOCAL_TARGET_MAS_INFO();

    TGTMGR_LOCAL_TARGET_MAS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,const ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& stMASTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_MAS_INFO (TGTMGR_LOCAL_TARGET_MAS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_MAS_INFO& operator=(TGTMGR_LOCAL_TARGET_MAS_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_MAS_INFO& operator=(const TGTMGR_LOCAL_TARGET_MAS_INFO&) = default;
    TGTMGR_LOCAL_TARGET_MAS_INFO(const TGTMGR_LOCAL_TARGET_MAS_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_MAS_INFO(TGTMGR_LOCAL_TARGET_MAS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_MAS_INFO& operator=(TGTMGR_LOCAL_TARGET_MAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& stMASTgtInfo() OMG_NOEXCEPT {
        return m_stMASTgtInfo_;
    }

    const ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& stMASTgtInfo() const OMG_NOEXCEPT {
        return m_stMASTgtInfo_;
    }

    void stMASTgtInfo(const ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>& value) {
        m_stMASTgtInfo_ = value;
    }

    void stMASTgtInfo(::dds::core::array< ST_MAS_LOCAL_TARGET, 2L>&& value) {
        m_stMASTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_MAS_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_MAS_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_MAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    ::dds::core::array< ST_MAS_LOCAL_TARGET, 2L> m_stMASTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_MAS_INFO& a, TGTMGR_LOCAL_TARGET_MAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_MAS_INFO& sample);

class NDDSUSERDllExport TGTMGR_LOCAL_TARGET_RD_INFO {
  public:
    TGTMGR_LOCAL_TARGET_RD_INFO();

    TGTMGR_LOCAL_TARGET_RD_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usSensorID,uint16_t usNumOfTargets,const ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& stRDTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_LOCAL_TARGET_RD_INFO (TGTMGR_LOCAL_TARGET_RD_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_RD_INFO& operator=(TGTMGR_LOCAL_TARGET_RD_INFO&&) = default;
    TGTMGR_LOCAL_TARGET_RD_INFO& operator=(const TGTMGR_LOCAL_TARGET_RD_INFO&) = default;
    TGTMGR_LOCAL_TARGET_RD_INFO(const TGTMGR_LOCAL_TARGET_RD_INFO&) = default;
    #else
    TGTMGR_LOCAL_TARGET_RD_INFO(TGTMGR_LOCAL_TARGET_RD_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_LOCAL_TARGET_RD_INFO& operator=(TGTMGR_LOCAL_TARGET_RD_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& stRDTgtInfo() OMG_NOEXCEPT {
        return m_stRDTgtInfo_;
    }

    const ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& stRDTgtInfo() const OMG_NOEXCEPT {
        return m_stRDTgtInfo_;
    }

    void stRDTgtInfo(const ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>& value) {
        m_stRDTgtInfo_ = value;
    }

    void stRDTgtInfo(::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L>&& value) {
        m_stRDTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_LOCAL_TARGET_RD_INFO& other_) const;
    bool operator != (const TGTMGR_LOCAL_TARGET_RD_INFO& other_) const;

    void swap(TGTMGR_LOCAL_TARGET_RD_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSensorID_;
    uint16_t m_usNumOfTargets_;
    ::dds::core::array< ST_RADAR_LOCAL_TARGET, 1000L> m_stRDTgtInfo_;

};

inline void swap(TGTMGR_LOCAL_TARGET_RD_INFO& a, TGTMGR_LOCAL_TARGET_RD_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_LOCAL_TARGET_RD_INFO& sample);

class NDDSUSERDllExport ST_MAS_FUSED_GLOBAL_TARGET {
  public:
    ST_MAS_FUSED_GLOBAL_TARGET();

    ST_MAS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& stMASTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_FUSED_GLOBAL_TARGET (ST_MAS_FUSED_GLOBAL_TARGET&&) = default;
    ST_MAS_FUSED_GLOBAL_TARGET& operator=(ST_MAS_FUSED_GLOBAL_TARGET&&) = default;
    ST_MAS_FUSED_GLOBAL_TARGET& operator=(const ST_MAS_FUSED_GLOBAL_TARGET&) = default;
    ST_MAS_FUSED_GLOBAL_TARGET(const ST_MAS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_MAS_FUSED_GLOBAL_TARGET(ST_MAS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_MAS_FUSED_GLOBAL_TARGET& operator=(ST_MAS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& stMASTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stMASTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& stMASTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stMASTgtInfoAssociated_;
    }

    void stMASTgtInfoAssociated(const ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>& value) {
        m_stMASTgtInfoAssociated_ = value;
    }

    void stMASTgtInfoAssociated(::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L>&& value) {
        m_stMASTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_MAS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_MAS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_MAS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ::dds::core::array< ST_MAS_TARGET_ASSOCIATED, 2L> m_stMASTgtInfoAssociated_;

};

inline void swap(ST_MAS_FUSED_GLOBAL_TARGET& a, ST_MAS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_MAS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_MAS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_MAS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_MAS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_MAS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_MAS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND {
  public:
    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND();

    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usCommandID,uint8_t oAxis,uint16_t usTgtID,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND (TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& operator=(const TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND(const TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& operator=(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& usTgtID() OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    const uint16_t& usTgtID() const OMG_NOEXCEPT {
        return m_usTgtID_;
    }

    void usTgtID(uint16_t value) {
        m_usTgtID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usCommandID_;
    uint8_t m_oAxis_;
    uint16_t m_usTgtID_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& a, TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport ST_OUM_TARGET {
  public:
    ST_OUM_TARGET();

    ST_OUM_TARGET(uint16_t usTgtNo,uint16_t usConsoleID,const ST_DATE_TIME& stRegistrationTime,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< uint8_t, 20L>& aTagInfo,uint8_t oOriginSensorID,double dLatitude,double dLongitude,float fCourse,float fVelocity,uint16_t usTargetNo,uint16_t usActivePulseSourceTgtType,const ST_BIS_SOURCE_INFO& stBISSourceInfo,uint16_t usGTRegistered,uint16_t usGTTgtNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_OUM_TARGET (ST_OUM_TARGET&&) = default;
    ST_OUM_TARGET& operator=(ST_OUM_TARGET&&) = default;
    ST_OUM_TARGET& operator=(const ST_OUM_TARGET&) = default;
    ST_OUM_TARGET(const ST_OUM_TARGET&) = default;
    #else
    ST_OUM_TARGET(ST_OUM_TARGET&& other_) OMG_NOEXCEPT;  
    ST_OUM_TARGET& operator=(ST_OUM_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTgtNo() OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    const uint16_t& usTgtNo() const OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    void usTgtNo(uint16_t value) {
        m_usTgtNo_ = value;
    }

    uint16_t& usConsoleID() OMG_NOEXCEPT {
        return m_usConsoleID_;
    }

    const uint16_t& usConsoleID() const OMG_NOEXCEPT {
        return m_usConsoleID_;
    }

    void usConsoleID(uint16_t value) {
        m_usConsoleID_ = value;
    }

    ST_DATE_TIME& stRegistrationTime() OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    const ST_DATE_TIME& stRegistrationTime() const OMG_NOEXCEPT {
        return m_stRegistrationTime_;
    }

    void stRegistrationTime(const ST_DATE_TIME& value) {
        m_stRegistrationTime_ = value;
    }

    void stRegistrationTime(ST_DATE_TIME&& value) {
        m_stRegistrationTime_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 20L>& aTagInfo() OMG_NOEXCEPT {
        return m_aTagInfo_;
    }

    const ::dds::core::array< uint8_t, 20L>& aTagInfo() const OMG_NOEXCEPT {
        return m_aTagInfo_;
    }

    void aTagInfo(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aTagInfo_ = value;
    }

    void aTagInfo(::dds::core::array< uint8_t, 20L>&& value) {
        m_aTagInfo_ = std::move(value);
    }
    uint8_t& oOriginSensorID() OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    const uint8_t& oOriginSensorID() const OMG_NOEXCEPT {
        return m_oOriginSensorID_;
    }

    void oOriginSensorID(uint8_t value) {
        m_oOriginSensorID_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    float& fCourse() OMG_NOEXCEPT {
        return m_fCourse_;
    }

    const float& fCourse() const OMG_NOEXCEPT {
        return m_fCourse_;
    }

    void fCourse(float value) {
        m_fCourse_ = value;
    }

    float& fVelocity() OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    const float& fVelocity() const OMG_NOEXCEPT {
        return m_fVelocity_;
    }

    void fVelocity(float value) {
        m_fVelocity_ = value;
    }

    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    uint16_t& usActivePulseSourceTgtType() OMG_NOEXCEPT {
        return m_usActivePulseSourceTgtType_;
    }

    const uint16_t& usActivePulseSourceTgtType() const OMG_NOEXCEPT {
        return m_usActivePulseSourceTgtType_;
    }

    void usActivePulseSourceTgtType(uint16_t value) {
        m_usActivePulseSourceTgtType_ = value;
    }

    ST_BIS_SOURCE_INFO& stBISSourceInfo() OMG_NOEXCEPT {
        return m_stBISSourceInfo_;
    }

    const ST_BIS_SOURCE_INFO& stBISSourceInfo() const OMG_NOEXCEPT {
        return m_stBISSourceInfo_;
    }

    void stBISSourceInfo(const ST_BIS_SOURCE_INFO& value) {
        m_stBISSourceInfo_ = value;
    }

    void stBISSourceInfo(ST_BIS_SOURCE_INFO&& value) {
        m_stBISSourceInfo_ = std::move(value);
    }
    uint16_t& usGTRegistered() OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    const uint16_t& usGTRegistered() const OMG_NOEXCEPT {
        return m_usGTRegistered_;
    }

    void usGTRegistered(uint16_t value) {
        m_usGTRegistered_ = value;
    }

    uint16_t& usGTTgtNo() OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    const uint16_t& usGTTgtNo() const OMG_NOEXCEPT {
        return m_usGTTgtNo_;
    }

    void usGTTgtNo(uint16_t value) {
        m_usGTTgtNo_ = value;
    }

    bool operator == (const ST_OUM_TARGET& other_) const;
    bool operator != (const ST_OUM_TARGET& other_) const;

    void swap(ST_OUM_TARGET& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTgtNo_;
    uint16_t m_usConsoleID_;
    ST_DATE_TIME m_stRegistrationTime_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< uint8_t, 20L> m_aTagInfo_;
    uint8_t m_oOriginSensorID_;
    double m_dLatitude_;
    double m_dLongitude_;
    float m_fCourse_;
    float m_fVelocity_;
    uint16_t m_usTargetNo_;
    uint16_t m_usActivePulseSourceTgtType_;
    ST_BIS_SOURCE_INFO m_stBISSourceInfo_;
    uint16_t m_usGTRegistered_;
    uint16_t m_usGTTgtNo_;

};

inline void swap(ST_OUM_TARGET& a, ST_OUM_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_OUM_TARGET& sample);

class NDDSUSERDllExport TGTMGR_OUM_TARGET_INFO {
  public:
    TGTMGR_OUM_TARGET_INFO();

    TGTMGR_OUM_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 4L>& aNumOfTargets,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ::dds::core::array< ST_OUM_TARGET, 16L>, 4L>& stOUMTgtInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_OUM_TARGET_INFO (TGTMGR_OUM_TARGET_INFO&&) = default;
    TGTMGR_OUM_TARGET_INFO& operator=(TGTMGR_OUM_TARGET_INFO&&) = default;
    TGTMGR_OUM_TARGET_INFO& operator=(const TGTMGR_OUM_TARGET_INFO&) = default;
    TGTMGR_OUM_TARGET_INFO(const TGTMGR_OUM_TARGET_INFO&) = default;
    #else
    TGTMGR_OUM_TARGET_INFO(TGTMGR_OUM_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_OUM_TARGET_INFO& operator=(TGTMGR_OUM_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 4L>& aNumOfTargets() OMG_NOEXCEPT {
        return m_aNumOfTargets_;
    }

    const ::dds::core::array< uint16_t, 4L>& aNumOfTargets() const OMG_NOEXCEPT {
        return m_aNumOfTargets_;
    }

    void aNumOfTargets(const ::dds::core::array< uint16_t, 4L>& value) {
        m_aNumOfTargets_ = value;
    }

    void aNumOfTargets(::dds::core::array< uint16_t, 4L>&& value) {
        m_aNumOfTargets_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ST_OUM_TARGET, 16L>, 4L>& stOUMTgtInfo() OMG_NOEXCEPT {
        return m_stOUMTgtInfo_;
    }

    const ::dds::core::array< ::dds::core::array< ST_OUM_TARGET, 16L>, 4L>& stOUMTgtInfo() const OMG_NOEXCEPT {
        return m_stOUMTgtInfo_;
    }

    void stOUMTgtInfo(const ::dds::core::array< ::dds::core::array< ST_OUM_TARGET, 16L>, 4L>& value) {
        m_stOUMTgtInfo_ = value;
    }

    void stOUMTgtInfo(::dds::core::array< ::dds::core::array< ST_OUM_TARGET, 16L>, 4L>&& value) {
        m_stOUMTgtInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_OUM_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_OUM_TARGET_INFO& other_) const;

    void swap(TGTMGR_OUM_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 4L> m_aNumOfTargets_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ::dds::core::array< ST_OUM_TARGET, 16L>, 4L> m_stOUMTgtInfo_;

};

inline void swap(TGTMGR_OUM_TARGET_INFO& a, TGTMGR_OUM_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_OUM_TARGET_INFO& sample);

class NDDSUSERDllExport ST_RDS_FUSED_GLOBAL_TARGET {
  public:
    ST_RDS_FUSED_GLOBAL_TARGET();

    ST_RDS_FUSED_GLOBAL_TARGET(const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt,const ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& stRDTgtInfoAssociated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_RDS_FUSED_GLOBAL_TARGET (ST_RDS_FUSED_GLOBAL_TARGET&&) = default;
    ST_RDS_FUSED_GLOBAL_TARGET& operator=(ST_RDS_FUSED_GLOBAL_TARGET&&) = default;
    ST_RDS_FUSED_GLOBAL_TARGET& operator=(const ST_RDS_FUSED_GLOBAL_TARGET&) = default;
    ST_RDS_FUSED_GLOBAL_TARGET(const ST_RDS_FUSED_GLOBAL_TARGET&) = default;
    #else
    ST_RDS_FUSED_GLOBAL_TARGET(ST_RDS_FUSED_GLOBAL_TARGET&& other_) OMG_NOEXCEPT;  
    ST_RDS_FUSED_GLOBAL_TARGET& operator=(ST_RDS_FUSED_GLOBAL_TARGET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    const ST_FUSED_GLOBAL_TARGET& stFusedGlobalTgt() const OMG_NOEXCEPT {
        return m_stFusedGlobalTgt_;
    }

    void stFusedGlobalTgt(const ST_FUSED_GLOBAL_TARGET& value) {
        m_stFusedGlobalTgt_ = value;
    }

    void stFusedGlobalTgt(ST_FUSED_GLOBAL_TARGET&& value) {
        m_stFusedGlobalTgt_ = std::move(value);
    }
    ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& stRDTgtInfoAssociated() OMG_NOEXCEPT {
        return m_stRDTgtInfoAssociated_;
    }

    const ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& stRDTgtInfoAssociated() const OMG_NOEXCEPT {
        return m_stRDTgtInfoAssociated_;
    }

    void stRDTgtInfoAssociated(const ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>& value) {
        m_stRDTgtInfoAssociated_ = value;
    }

    void stRDTgtInfoAssociated(::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L>&& value) {
        m_stRDTgtInfoAssociated_ = std::move(value);
    }

    bool operator == (const ST_RDS_FUSED_GLOBAL_TARGET& other_) const;
    bool operator != (const ST_RDS_FUSED_GLOBAL_TARGET& other_) const;

    void swap(ST_RDS_FUSED_GLOBAL_TARGET& other_) OMG_NOEXCEPT ;

  private:

    ST_FUSED_GLOBAL_TARGET m_stFusedGlobalTgt_;
    ::dds::core::array< ST_RD_TARGET_ASSOCIATED, 2L> m_stRDTgtInfoAssociated_;

};

inline void swap(ST_RDS_FUSED_GLOBAL_TARGET& a, ST_RDS_FUSED_GLOBAL_TARGET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_RDS_FUSED_GLOBAL_TARGET& sample);

class NDDSUSERDllExport TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO {
  public:
    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO();

    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t usNumOfTargets,uint16_t usLocalSensorID,uint32_t ulFrameCnt,const ::dds::core::array< ST_RDS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO (TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO&&) = default;
    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& operator=(const TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO&) = default;
    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO(const TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO&) = default;
    #else
    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& operator=(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNumOfTargets() OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    const uint16_t& usNumOfTargets() const OMG_NOEXCEPT {
        return m_usNumOfTargets_;
    }

    void usNumOfTargets(uint16_t value) {
        m_usNumOfTargets_ = value;
    }

    uint16_t& usLocalSensorID() OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    const uint16_t& usLocalSensorID() const OMG_NOEXCEPT {
        return m_usLocalSensorID_;
    }

    void usLocalSensorID(uint16_t value) {
        m_usLocalSensorID_ = value;
    }

    uint32_t& ulFrameCnt() OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    const uint32_t& ulFrameCnt() const OMG_NOEXCEPT {
        return m_ulFrameCnt_;
    }

    void ulFrameCnt(uint32_t value) {
        m_ulFrameCnt_ = value;
    }

    ::dds::core::array< ST_RDS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    const ::dds::core::array< ST_RDS_FUSED_GLOBAL_TARGET, 2000L>& stGTInfo() const OMG_NOEXCEPT {
        return m_stGTInfo_;
    }

    void stGTInfo(const ::dds::core::array< ST_RDS_FUSED_GLOBAL_TARGET, 2000L>& value) {
        m_stGTInfo_ = value;
    }

    void stGTInfo(::dds::core::array< ST_RDS_FUSED_GLOBAL_TARGET, 2000L>&& value) {
        m_stGTInfo_ = std::move(value);
    }

    bool operator == (const TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& other_) const;

    void swap(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNumOfTargets_;
    uint16_t m_usLocalSensorID_;
    uint32_t m_ulFrameCnt_;
    ::dds::core::array< ST_RDS_FUSED_GLOBAL_TARGET, 2000L> m_stGTInfo_;

};

inline void swap(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& a, TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& sample);

class NDDSUSERDllExport TGTMGR_SENSOR_CONFIG_PARAM_REQ {
  public:
    TGTMGR_SENSOR_CONFIG_PARAM_REQ();

    TGTMGR_SENSOR_CONFIG_PARAM_REQ(const ST_MSG_HEADER& stMsgHeader,uint16_t usReqParamGrpID,uint16_t usReqParamValueInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_SENSOR_CONFIG_PARAM_REQ (TGTMGR_SENSOR_CONFIG_PARAM_REQ&&) = default;
    TGTMGR_SENSOR_CONFIG_PARAM_REQ& operator=(TGTMGR_SENSOR_CONFIG_PARAM_REQ&&) = default;
    TGTMGR_SENSOR_CONFIG_PARAM_REQ& operator=(const TGTMGR_SENSOR_CONFIG_PARAM_REQ&) = default;
    TGTMGR_SENSOR_CONFIG_PARAM_REQ(const TGTMGR_SENSOR_CONFIG_PARAM_REQ&) = default;
    #else
    TGTMGR_SENSOR_CONFIG_PARAM_REQ(TGTMGR_SENSOR_CONFIG_PARAM_REQ&& other_) OMG_NOEXCEPT;  
    TGTMGR_SENSOR_CONFIG_PARAM_REQ& operator=(TGTMGR_SENSOR_CONFIG_PARAM_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usReqParamGrpID() OMG_NOEXCEPT {
        return m_usReqParamGrpID_;
    }

    const uint16_t& usReqParamGrpID() const OMG_NOEXCEPT {
        return m_usReqParamGrpID_;
    }

    void usReqParamGrpID(uint16_t value) {
        m_usReqParamGrpID_ = value;
    }

    uint16_t& usReqParamValueInfo() OMG_NOEXCEPT {
        return m_usReqParamValueInfo_;
    }

    const uint16_t& usReqParamValueInfo() const OMG_NOEXCEPT {
        return m_usReqParamValueInfo_;
    }

    void usReqParamValueInfo(uint16_t value) {
        m_usReqParamValueInfo_ = value;
    }

    bool operator == (const TGTMGR_SENSOR_CONFIG_PARAM_REQ& other_) const;
    bool operator != (const TGTMGR_SENSOR_CONFIG_PARAM_REQ& other_) const;

    void swap(TGTMGR_SENSOR_CONFIG_PARAM_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usReqParamGrpID_;
    uint16_t m_usReqParamValueInfo_;

};

inline void swap(TGTMGR_SENSOR_CONFIG_PARAM_REQ& a, TGTMGR_SENSOR_CONFIG_PARAM_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_SENSOR_CONFIG_PARAM_REQ& sample);

class NDDSUSERDllExport TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO {
  public:
    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO();

    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oLasActivationStatus,uint8_t oBisActivationStatus,uint8_t oMasActivationStatus,uint8_t oAsEosActivationStatus,uint8_t oRdsKntdsActivationStatus,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO (TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO&&) = default;
    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& operator=(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO&&) = default;
    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& operator=(const TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO&) = default;
    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO(const TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO&) = default;
    #else
    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& operator=(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oLasActivationStatus() OMG_NOEXCEPT {
        return m_oLasActivationStatus_;
    }

    const uint8_t& oLasActivationStatus() const OMG_NOEXCEPT {
        return m_oLasActivationStatus_;
    }

    void oLasActivationStatus(uint8_t value) {
        m_oLasActivationStatus_ = value;
    }

    uint8_t& oBisActivationStatus() OMG_NOEXCEPT {
        return m_oBisActivationStatus_;
    }

    const uint8_t& oBisActivationStatus() const OMG_NOEXCEPT {
        return m_oBisActivationStatus_;
    }

    void oBisActivationStatus(uint8_t value) {
        m_oBisActivationStatus_ = value;
    }

    uint8_t& oMasActivationStatus() OMG_NOEXCEPT {
        return m_oMasActivationStatus_;
    }

    const uint8_t& oMasActivationStatus() const OMG_NOEXCEPT {
        return m_oMasActivationStatus_;
    }

    void oMasActivationStatus(uint8_t value) {
        m_oMasActivationStatus_ = value;
    }

    uint8_t& oAsEosActivationStatus() OMG_NOEXCEPT {
        return m_oAsEosActivationStatus_;
    }

    const uint8_t& oAsEosActivationStatus() const OMG_NOEXCEPT {
        return m_oAsEosActivationStatus_;
    }

    void oAsEosActivationStatus(uint8_t value) {
        m_oAsEosActivationStatus_ = value;
    }

    uint8_t& oRdsKntdsActivationStatus() OMG_NOEXCEPT {
        return m_oRdsKntdsActivationStatus_;
    }

    const uint8_t& oRdsKntdsActivationStatus() const OMG_NOEXCEPT {
        return m_oRdsKntdsActivationStatus_;
    }

    void oRdsKntdsActivationStatus(uint8_t value) {
        m_oRdsKntdsActivationStatus_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& other_) const;
    bool operator != (const TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& other_) const;

    void swap(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oLasActivationStatus_;
    uint8_t m_oBisActivationStatus_;
    uint8_t m_oMasActivationStatus_;
    uint8_t m_oAsEosActivationStatus_;
    uint8_t m_oRdsKntdsActivationStatus_;
    uint16_t m_usReserved_;

};

inline void swap(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& a, TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& sample);

class NDDSUSERDllExport TGTMGR_TGT_CLASSIFICATION_CONTROL {
  public:
    TGTMGR_TGT_CLASSIFICATION_CONTROL();

    TGTMGR_TGT_CLASSIFICATION_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usGlobalTgtNo,float fSpeed,uint16_t usLOFARFreqCnt,const ::dds::core::array< float, 24L>& aLOFARFreq,uint16_t usDEMONFreqCnt,const ::dds::core::array< float, 24L>& aDEMONFreq,uint16_t usSensorID,uint16_t usLocalTgtNo,uint16_t usShipType,uint16_t usFriendlyInfo,uint32_t ulMaintainTime,uint16_t usAutoManualMode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_TGT_CLASSIFICATION_CONTROL (TGTMGR_TGT_CLASSIFICATION_CONTROL&&) = default;
    TGTMGR_TGT_CLASSIFICATION_CONTROL& operator=(TGTMGR_TGT_CLASSIFICATION_CONTROL&&) = default;
    TGTMGR_TGT_CLASSIFICATION_CONTROL& operator=(const TGTMGR_TGT_CLASSIFICATION_CONTROL&) = default;
    TGTMGR_TGT_CLASSIFICATION_CONTROL(const TGTMGR_TGT_CLASSIFICATION_CONTROL&) = default;
    #else
    TGTMGR_TGT_CLASSIFICATION_CONTROL(TGTMGR_TGT_CLASSIFICATION_CONTROL&& other_) OMG_NOEXCEPT;  
    TGTMGR_TGT_CLASSIFICATION_CONTROL& operator=(TGTMGR_TGT_CLASSIFICATION_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usGlobalTgtNo() OMG_NOEXCEPT {
        return m_usGlobalTgtNo_;
    }

    const uint16_t& usGlobalTgtNo() const OMG_NOEXCEPT {
        return m_usGlobalTgtNo_;
    }

    void usGlobalTgtNo(uint16_t value) {
        m_usGlobalTgtNo_ = value;
    }

    float& fSpeed() OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    const float& fSpeed() const OMG_NOEXCEPT {
        return m_fSpeed_;
    }

    void fSpeed(float value) {
        m_fSpeed_ = value;
    }

    uint16_t& usLOFARFreqCnt() OMG_NOEXCEPT {
        return m_usLOFARFreqCnt_;
    }

    const uint16_t& usLOFARFreqCnt() const OMG_NOEXCEPT {
        return m_usLOFARFreqCnt_;
    }

    void usLOFARFreqCnt(uint16_t value) {
        m_usLOFARFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aLOFARFreq() OMG_NOEXCEPT {
        return m_aLOFARFreq_;
    }

    const ::dds::core::array< float, 24L>& aLOFARFreq() const OMG_NOEXCEPT {
        return m_aLOFARFreq_;
    }

    void aLOFARFreq(const ::dds::core::array< float, 24L>& value) {
        m_aLOFARFreq_ = value;
    }

    void aLOFARFreq(::dds::core::array< float, 24L>&& value) {
        m_aLOFARFreq_ = std::move(value);
    }
    uint16_t& usDEMONFreqCnt() OMG_NOEXCEPT {
        return m_usDEMONFreqCnt_;
    }

    const uint16_t& usDEMONFreqCnt() const OMG_NOEXCEPT {
        return m_usDEMONFreqCnt_;
    }

    void usDEMONFreqCnt(uint16_t value) {
        m_usDEMONFreqCnt_ = value;
    }

    ::dds::core::array< float, 24L>& aDEMONFreq() OMG_NOEXCEPT {
        return m_aDEMONFreq_;
    }

    const ::dds::core::array< float, 24L>& aDEMONFreq() const OMG_NOEXCEPT {
        return m_aDEMONFreq_;
    }

    void aDEMONFreq(const ::dds::core::array< float, 24L>& value) {
        m_aDEMONFreq_ = value;
    }

    void aDEMONFreq(::dds::core::array< float, 24L>&& value) {
        m_aDEMONFreq_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usLocalTgtNo() OMG_NOEXCEPT {
        return m_usLocalTgtNo_;
    }

    const uint16_t& usLocalTgtNo() const OMG_NOEXCEPT {
        return m_usLocalTgtNo_;
    }

    void usLocalTgtNo(uint16_t value) {
        m_usLocalTgtNo_ = value;
    }

    uint16_t& usShipType() OMG_NOEXCEPT {
        return m_usShipType_;
    }

    const uint16_t& usShipType() const OMG_NOEXCEPT {
        return m_usShipType_;
    }

    void usShipType(uint16_t value) {
        m_usShipType_ = value;
    }

    uint16_t& usFriendlyInfo() OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    const uint16_t& usFriendlyInfo() const OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    void usFriendlyInfo(uint16_t value) {
        m_usFriendlyInfo_ = value;
    }

    uint32_t& ulMaintainTime() OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    const uint32_t& ulMaintainTime() const OMG_NOEXCEPT {
        return m_ulMaintainTime_;
    }

    void ulMaintainTime(uint32_t value) {
        m_ulMaintainTime_ = value;
    }

    uint16_t& usAutoManualMode() OMG_NOEXCEPT {
        return m_usAutoManualMode_;
    }

    const uint16_t& usAutoManualMode() const OMG_NOEXCEPT {
        return m_usAutoManualMode_;
    }

    void usAutoManualMode(uint16_t value) {
        m_usAutoManualMode_ = value;
    }

    bool operator == (const TGTMGR_TGT_CLASSIFICATION_CONTROL& other_) const;
    bool operator != (const TGTMGR_TGT_CLASSIFICATION_CONTROL& other_) const;

    void swap(TGTMGR_TGT_CLASSIFICATION_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usGlobalTgtNo_;
    float m_fSpeed_;
    uint16_t m_usLOFARFreqCnt_;
    ::dds::core::array< float, 24L> m_aLOFARFreq_;
    uint16_t m_usDEMONFreqCnt_;
    ::dds::core::array< float, 24L> m_aDEMONFreq_;
    uint16_t m_usSensorID_;
    uint16_t m_usLocalTgtNo_;
    uint16_t m_usShipType_;
    uint16_t m_usFriendlyInfo_;
    uint32_t m_ulMaintainTime_;
    uint16_t m_usAutoManualMode_;

};

inline void swap(TGTMGR_TGT_CLASSIFICATION_CONTROL& a, TGTMGR_TGT_CLASSIFICATION_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_TGT_CLASSIFICATION_CONTROL& sample);

class NDDSUSERDllExport ST_THREAT_TARGET_FOR_KNTDS {
  public:
    ST_THREAT_TARGET_FOR_KNTDS();

    ST_THREAT_TARGET_FOR_KNTDS(uint8_t usKNTDSPropagationStatus,uint32_t ulGTTgtNo,uint32_t ulLatitude_Int,uint32_t ulLatitude_Dec,uint32_t ulLongitude_Int,uint32_t ulLongitude_Dec,float fVelocityX,float fVelocityY,uint8_t usTgtKind,uint8_t usTgtFriendlyGrade,const ST_DATE_TIME& stDetectionTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_THREAT_TARGET_FOR_KNTDS (ST_THREAT_TARGET_FOR_KNTDS&&) = default;
    ST_THREAT_TARGET_FOR_KNTDS& operator=(ST_THREAT_TARGET_FOR_KNTDS&&) = default;
    ST_THREAT_TARGET_FOR_KNTDS& operator=(const ST_THREAT_TARGET_FOR_KNTDS&) = default;
    ST_THREAT_TARGET_FOR_KNTDS(const ST_THREAT_TARGET_FOR_KNTDS&) = default;
    #else
    ST_THREAT_TARGET_FOR_KNTDS(ST_THREAT_TARGET_FOR_KNTDS&& other_) OMG_NOEXCEPT;  
    ST_THREAT_TARGET_FOR_KNTDS& operator=(ST_THREAT_TARGET_FOR_KNTDS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& usKNTDSPropagationStatus() OMG_NOEXCEPT {
        return m_usKNTDSPropagationStatus_;
    }

    const uint8_t& usKNTDSPropagationStatus() const OMG_NOEXCEPT {
        return m_usKNTDSPropagationStatus_;
    }

    void usKNTDSPropagationStatus(uint8_t value) {
        m_usKNTDSPropagationStatus_ = value;
    }

    uint32_t& ulGTTgtNo() OMG_NOEXCEPT {
        return m_ulGTTgtNo_;
    }

    const uint32_t& ulGTTgtNo() const OMG_NOEXCEPT {
        return m_ulGTTgtNo_;
    }

    void ulGTTgtNo(uint32_t value) {
        m_ulGTTgtNo_ = value;
    }

    uint32_t& ulLatitude_Int() OMG_NOEXCEPT {
        return m_ulLatitude_Int_;
    }

    const uint32_t& ulLatitude_Int() const OMG_NOEXCEPT {
        return m_ulLatitude_Int_;
    }

    void ulLatitude_Int(uint32_t value) {
        m_ulLatitude_Int_ = value;
    }

    uint32_t& ulLatitude_Dec() OMG_NOEXCEPT {
        return m_ulLatitude_Dec_;
    }

    const uint32_t& ulLatitude_Dec() const OMG_NOEXCEPT {
        return m_ulLatitude_Dec_;
    }

    void ulLatitude_Dec(uint32_t value) {
        m_ulLatitude_Dec_ = value;
    }

    uint32_t& ulLongitude_Int() OMG_NOEXCEPT {
        return m_ulLongitude_Int_;
    }

    const uint32_t& ulLongitude_Int() const OMG_NOEXCEPT {
        return m_ulLongitude_Int_;
    }

    void ulLongitude_Int(uint32_t value) {
        m_ulLongitude_Int_ = value;
    }

    uint32_t& ulLongitude_Dec() OMG_NOEXCEPT {
        return m_ulLongitude_Dec_;
    }

    const uint32_t& ulLongitude_Dec() const OMG_NOEXCEPT {
        return m_ulLongitude_Dec_;
    }

    void ulLongitude_Dec(uint32_t value) {
        m_ulLongitude_Dec_ = value;
    }

    float& fVelocityX() OMG_NOEXCEPT {
        return m_fVelocityX_;
    }

    const float& fVelocityX() const OMG_NOEXCEPT {
        return m_fVelocityX_;
    }

    void fVelocityX(float value) {
        m_fVelocityX_ = value;
    }

    float& fVelocityY() OMG_NOEXCEPT {
        return m_fVelocityY_;
    }

    const float& fVelocityY() const OMG_NOEXCEPT {
        return m_fVelocityY_;
    }

    void fVelocityY(float value) {
        m_fVelocityY_ = value;
    }

    uint8_t& usTgtKind() OMG_NOEXCEPT {
        return m_usTgtKind_;
    }

    const uint8_t& usTgtKind() const OMG_NOEXCEPT {
        return m_usTgtKind_;
    }

    void usTgtKind(uint8_t value) {
        m_usTgtKind_ = value;
    }

    uint8_t& usTgtFriendlyGrade() OMG_NOEXCEPT {
        return m_usTgtFriendlyGrade_;
    }

    const uint8_t& usTgtFriendlyGrade() const OMG_NOEXCEPT {
        return m_usTgtFriendlyGrade_;
    }

    void usTgtFriendlyGrade(uint8_t value) {
        m_usTgtFriendlyGrade_ = value;
    }

    ST_DATE_TIME& stDetectionTime() OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    const ST_DATE_TIME& stDetectionTime() const OMG_NOEXCEPT {
        return m_stDetectionTime_;
    }

    void stDetectionTime(const ST_DATE_TIME& value) {
        m_stDetectionTime_ = value;
    }

    void stDetectionTime(ST_DATE_TIME&& value) {
        m_stDetectionTime_ = std::move(value);
    }

    bool operator == (const ST_THREAT_TARGET_FOR_KNTDS& other_) const;
    bool operator != (const ST_THREAT_TARGET_FOR_KNTDS& other_) const;

    void swap(ST_THREAT_TARGET_FOR_KNTDS& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_usKNTDSPropagationStatus_;
    uint32_t m_ulGTTgtNo_;
    uint32_t m_ulLatitude_Int_;
    uint32_t m_ulLatitude_Dec_;
    uint32_t m_ulLongitude_Int_;
    uint32_t m_ulLongitude_Dec_;
    float m_fVelocityX_;
    float m_fVelocityY_;
    uint8_t m_usTgtKind_;
    uint8_t m_usTgtFriendlyGrade_;
    ST_DATE_TIME m_stDetectionTime_;

};

inline void swap(ST_THREAT_TARGET_FOR_KNTDS& a, ST_THREAT_TARGET_FOR_KNTDS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_THREAT_TARGET_FOR_KNTDS& sample);

class NDDSUSERDllExport TGTMGR_THREAT_TARGET_INFO {
  public:
    TGTMGR_THREAT_TARGET_INFO();

    TGTMGR_THREAT_TARGET_INFO(const ST_MSG_HEADER& stMsgHeader,uint32_t ulNumOfTargets,const ::dds::core::array< ST_THREAT_TARGET_FOR_KNTDS, 500L>& ThreatTarget);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTMGR_THREAT_TARGET_INFO (TGTMGR_THREAT_TARGET_INFO&&) = default;
    TGTMGR_THREAT_TARGET_INFO& operator=(TGTMGR_THREAT_TARGET_INFO&&) = default;
    TGTMGR_THREAT_TARGET_INFO& operator=(const TGTMGR_THREAT_TARGET_INFO&) = default;
    TGTMGR_THREAT_TARGET_INFO(const TGTMGR_THREAT_TARGET_INFO&) = default;
    #else
    TGTMGR_THREAT_TARGET_INFO(TGTMGR_THREAT_TARGET_INFO&& other_) OMG_NOEXCEPT;  
    TGTMGR_THREAT_TARGET_INFO& operator=(TGTMGR_THREAT_TARGET_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulNumOfTargets() OMG_NOEXCEPT {
        return m_ulNumOfTargets_;
    }

    const uint32_t& ulNumOfTargets() const OMG_NOEXCEPT {
        return m_ulNumOfTargets_;
    }

    void ulNumOfTargets(uint32_t value) {
        m_ulNumOfTargets_ = value;
    }

    ::dds::core::array< ST_THREAT_TARGET_FOR_KNTDS, 500L>& ThreatTarget() OMG_NOEXCEPT {
        return m_ThreatTarget_;
    }

    const ::dds::core::array< ST_THREAT_TARGET_FOR_KNTDS, 500L>& ThreatTarget() const OMG_NOEXCEPT {
        return m_ThreatTarget_;
    }

    void ThreatTarget(const ::dds::core::array< ST_THREAT_TARGET_FOR_KNTDS, 500L>& value) {
        m_ThreatTarget_ = value;
    }

    void ThreatTarget(::dds::core::array< ST_THREAT_TARGET_FOR_KNTDS, 500L>&& value) {
        m_ThreatTarget_ = std::move(value);
    }

    bool operator == (const TGTMGR_THREAT_TARGET_INFO& other_) const;
    bool operator != (const TGTMGR_THREAT_TARGET_INFO& other_) const;

    void swap(TGTMGR_THREAT_TARGET_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulNumOfTargets_;
    ::dds::core::array< ST_THREAT_TARGET_FOR_KNTDS, 500L> m_ThreatTarget_;

};

inline void swap(TGTMGR_THREAT_TARGET_INFO& a, TGTMGR_THREAT_TARGET_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTMGR_THREAT_TARGET_INFO& sample);

class NDDSUSERDllExport ST_BIS_MEAS {
  public:
    ST_BIS_MEAS();

    ST_BIS_MEAS(float fDistance,float fBearing,float fSNR,float fDopplerInfo,const ::dds::core::array< uint16_t, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_MEAS (ST_BIS_MEAS&&) = default;
    ST_BIS_MEAS& operator=(ST_BIS_MEAS&&) = default;
    ST_BIS_MEAS& operator=(const ST_BIS_MEAS&) = default;
    ST_BIS_MEAS(const ST_BIS_MEAS&) = default;
    #else
    ST_BIS_MEAS(ST_BIS_MEAS&& other_) OMG_NOEXCEPT;  
    ST_BIS_MEAS& operator=(ST_BIS_MEAS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fSNR() OMG_NOEXCEPT {
        return m_fSNR_;
    }

    const float& fSNR() const OMG_NOEXCEPT {
        return m_fSNR_;
    }

    void fSNR(float value) {
        m_fSNR_ = value;
    }

    float& fDopplerInfo() OMG_NOEXCEPT {
        return m_fDopplerInfo_;
    }

    const float& fDopplerInfo() const OMG_NOEXCEPT {
        return m_fDopplerInfo_;
    }

    void fDopplerInfo(float value) {
        m_fDopplerInfo_ = value;
    }

    ::dds::core::array< uint16_t, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_BIS_MEAS& other_) const;
    bool operator != (const ST_BIS_MEAS& other_) const;

    void swap(ST_BIS_MEAS& other_) OMG_NOEXCEPT ;

  private:

    float m_fDistance_;
    float m_fBearing_;
    float m_fSNR_;
    float m_fDopplerInfo_;
    ::dds::core::array< uint16_t, 4L> m_aReserved_;

};

inline void swap(ST_BIS_MEAS& a, ST_BIS_MEAS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_MEAS& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_MEAS_INFO_A {
  public:
    TGTTRK_BISTRK_MEAS_INFO_A();

    TGTTRK_BISTRK_MEAS_INFO_A(const ST_MSG_HEADER& stMsgHeader,uint16_t usNoOfCWMeas,const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo,uint16_t usNoOfFMMeas,const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_MEAS_INFO_A (TGTTRK_BISTRK_MEAS_INFO_A&&) = default;
    TGTTRK_BISTRK_MEAS_INFO_A& operator=(TGTTRK_BISTRK_MEAS_INFO_A&&) = default;
    TGTTRK_BISTRK_MEAS_INFO_A& operator=(const TGTTRK_BISTRK_MEAS_INFO_A&) = default;
    TGTTRK_BISTRK_MEAS_INFO_A(const TGTTRK_BISTRK_MEAS_INFO_A&) = default;
    #else
    TGTTRK_BISTRK_MEAS_INFO_A(TGTTRK_BISTRK_MEAS_INFO_A&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_MEAS_INFO_A& operator=(TGTTRK_BISTRK_MEAS_INFO_A&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNoOfCWMeas() OMG_NOEXCEPT {
        return m_usNoOfCWMeas_;
    }

    const uint16_t& usNoOfCWMeas() const OMG_NOEXCEPT {
        return m_usNoOfCWMeas_;
    }

    void usNoOfCWMeas(uint16_t value) {
        m_usNoOfCWMeas_ = value;
    }

    ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo() OMG_NOEXCEPT {
        return m_stBisCWMeasInfo_;
    }

    const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo() const OMG_NOEXCEPT {
        return m_stBisCWMeasInfo_;
    }

    void stBisCWMeasInfo(const ::dds::core::array< ST_BIS_MEAS, 1920L>& value) {
        m_stBisCWMeasInfo_ = value;
    }

    void stBisCWMeasInfo(::dds::core::array< ST_BIS_MEAS, 1920L>&& value) {
        m_stBisCWMeasInfo_ = std::move(value);
    }
    uint16_t& usNoOfFMMeas() OMG_NOEXCEPT {
        return m_usNoOfFMMeas_;
    }

    const uint16_t& usNoOfFMMeas() const OMG_NOEXCEPT {
        return m_usNoOfFMMeas_;
    }

    void usNoOfFMMeas(uint16_t value) {
        m_usNoOfFMMeas_ = value;
    }

    ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo() OMG_NOEXCEPT {
        return m_stBisFMMeasInfo_;
    }

    const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo() const OMG_NOEXCEPT {
        return m_stBisFMMeasInfo_;
    }

    void stBisFMMeasInfo(const ::dds::core::array< ST_BIS_MEAS, 1920L>& value) {
        m_stBisFMMeasInfo_ = value;
    }

    void stBisFMMeasInfo(::dds::core::array< ST_BIS_MEAS, 1920L>&& value) {
        m_stBisFMMeasInfo_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_MEAS_INFO_A& other_) const;
    bool operator != (const TGTTRK_BISTRK_MEAS_INFO_A& other_) const;

    void swap(TGTTRK_BISTRK_MEAS_INFO_A& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNoOfCWMeas_;
    ::dds::core::array< ST_BIS_MEAS, 1920L> m_stBisCWMeasInfo_;
    uint16_t m_usNoOfFMMeas_;
    ::dds::core::array< ST_BIS_MEAS, 1920L> m_stBisFMMeasInfo_;

};

inline void swap(TGTTRK_BISTRK_MEAS_INFO_A& a, TGTTRK_BISTRK_MEAS_INFO_A& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_MEAS_INFO_A& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_MEAS_INFO_B {
  public:
    TGTTRK_BISTRK_MEAS_INFO_B();

    TGTTRK_BISTRK_MEAS_INFO_B(const ST_MSG_HEADER& stMsgHeader,uint16_t unNoOfCWMeas,const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo,uint16_t usNoOfFMMeas,const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_MEAS_INFO_B (TGTTRK_BISTRK_MEAS_INFO_B&&) = default;
    TGTTRK_BISTRK_MEAS_INFO_B& operator=(TGTTRK_BISTRK_MEAS_INFO_B&&) = default;
    TGTTRK_BISTRK_MEAS_INFO_B& operator=(const TGTTRK_BISTRK_MEAS_INFO_B&) = default;
    TGTTRK_BISTRK_MEAS_INFO_B(const TGTTRK_BISTRK_MEAS_INFO_B&) = default;
    #else
    TGTTRK_BISTRK_MEAS_INFO_B(TGTTRK_BISTRK_MEAS_INFO_B&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_MEAS_INFO_B& operator=(TGTTRK_BISTRK_MEAS_INFO_B&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unNoOfCWMeas() OMG_NOEXCEPT {
        return m_unNoOfCWMeas_;
    }

    const uint16_t& unNoOfCWMeas() const OMG_NOEXCEPT {
        return m_unNoOfCWMeas_;
    }

    void unNoOfCWMeas(uint16_t value) {
        m_unNoOfCWMeas_ = value;
    }

    ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo() OMG_NOEXCEPT {
        return m_stBisCWMeasInfo_;
    }

    const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo() const OMG_NOEXCEPT {
        return m_stBisCWMeasInfo_;
    }

    void stBisCWMeasInfo(const ::dds::core::array< ST_BIS_MEAS, 1920L>& value) {
        m_stBisCWMeasInfo_ = value;
    }

    void stBisCWMeasInfo(::dds::core::array< ST_BIS_MEAS, 1920L>&& value) {
        m_stBisCWMeasInfo_ = std::move(value);
    }
    uint16_t& usNoOfFMMeas() OMG_NOEXCEPT {
        return m_usNoOfFMMeas_;
    }

    const uint16_t& usNoOfFMMeas() const OMG_NOEXCEPT {
        return m_usNoOfFMMeas_;
    }

    void usNoOfFMMeas(uint16_t value) {
        m_usNoOfFMMeas_ = value;
    }

    ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo() OMG_NOEXCEPT {
        return m_stBisFMMeasInfo_;
    }

    const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo() const OMG_NOEXCEPT {
        return m_stBisFMMeasInfo_;
    }

    void stBisFMMeasInfo(const ::dds::core::array< ST_BIS_MEAS, 1920L>& value) {
        m_stBisFMMeasInfo_ = value;
    }

    void stBisFMMeasInfo(::dds::core::array< ST_BIS_MEAS, 1920L>&& value) {
        m_stBisFMMeasInfo_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_MEAS_INFO_B& other_) const;
    bool operator != (const TGTTRK_BISTRK_MEAS_INFO_B& other_) const;

    void swap(TGTTRK_BISTRK_MEAS_INFO_B& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unNoOfCWMeas_;
    ::dds::core::array< ST_BIS_MEAS, 1920L> m_stBisCWMeasInfo_;
    uint16_t m_usNoOfFMMeas_;
    ::dds::core::array< ST_BIS_MEAS, 1920L> m_stBisFMMeasInfo_;

};

inline void swap(TGTTRK_BISTRK_MEAS_INFO_B& a, TGTTRK_BISTRK_MEAS_INFO_B& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_MEAS_INFO_B& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_MEAS_INFO_C {
  public:
    TGTTRK_BISTRK_MEAS_INFO_C();

    TGTTRK_BISTRK_MEAS_INFO_C(const ST_MSG_HEADER& stMsgHeader,uint16_t usNoOfCWMeas,const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo,uint16_t usNoOfFMMeas,const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_MEAS_INFO_C (TGTTRK_BISTRK_MEAS_INFO_C&&) = default;
    TGTTRK_BISTRK_MEAS_INFO_C& operator=(TGTTRK_BISTRK_MEAS_INFO_C&&) = default;
    TGTTRK_BISTRK_MEAS_INFO_C& operator=(const TGTTRK_BISTRK_MEAS_INFO_C&) = default;
    TGTTRK_BISTRK_MEAS_INFO_C(const TGTTRK_BISTRK_MEAS_INFO_C&) = default;
    #else
    TGTTRK_BISTRK_MEAS_INFO_C(TGTTRK_BISTRK_MEAS_INFO_C&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_MEAS_INFO_C& operator=(TGTTRK_BISTRK_MEAS_INFO_C&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNoOfCWMeas() OMG_NOEXCEPT {
        return m_usNoOfCWMeas_;
    }

    const uint16_t& usNoOfCWMeas() const OMG_NOEXCEPT {
        return m_usNoOfCWMeas_;
    }

    void usNoOfCWMeas(uint16_t value) {
        m_usNoOfCWMeas_ = value;
    }

    ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo() OMG_NOEXCEPT {
        return m_stBisCWMeasInfo_;
    }

    const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisCWMeasInfo() const OMG_NOEXCEPT {
        return m_stBisCWMeasInfo_;
    }

    void stBisCWMeasInfo(const ::dds::core::array< ST_BIS_MEAS, 1920L>& value) {
        m_stBisCWMeasInfo_ = value;
    }

    void stBisCWMeasInfo(::dds::core::array< ST_BIS_MEAS, 1920L>&& value) {
        m_stBisCWMeasInfo_ = std::move(value);
    }
    uint16_t& usNoOfFMMeas() OMG_NOEXCEPT {
        return m_usNoOfFMMeas_;
    }

    const uint16_t& usNoOfFMMeas() const OMG_NOEXCEPT {
        return m_usNoOfFMMeas_;
    }

    void usNoOfFMMeas(uint16_t value) {
        m_usNoOfFMMeas_ = value;
    }

    ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo() OMG_NOEXCEPT {
        return m_stBisFMMeasInfo_;
    }

    const ::dds::core::array< ST_BIS_MEAS, 1920L>& stBisFMMeasInfo() const OMG_NOEXCEPT {
        return m_stBisFMMeasInfo_;
    }

    void stBisFMMeasInfo(const ::dds::core::array< ST_BIS_MEAS, 1920L>& value) {
        m_stBisFMMeasInfo_ = value;
    }

    void stBisFMMeasInfo(::dds::core::array< ST_BIS_MEAS, 1920L>&& value) {
        m_stBisFMMeasInfo_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_MEAS_INFO_C& other_) const;
    bool operator != (const TGTTRK_BISTRK_MEAS_INFO_C& other_) const;

    void swap(TGTTRK_BISTRK_MEAS_INFO_C& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNoOfCWMeas_;
    ::dds::core::array< ST_BIS_MEAS, 1920L> m_stBisCWMeasInfo_;
    uint16_t m_usNoOfFMMeas_;
    ::dds::core::array< ST_BIS_MEAS, 1920L> m_stBisFMMeasInfo_;

};

inline void swap(TGTTRK_BISTRK_MEAS_INFO_C& a, TGTTRK_BISTRK_MEAS_INFO_C& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_MEAS_INFO_C& sample);

class NDDSUSERDllExport ST_BIS_TARGET_LOCAL {
  public:
    ST_BIS_TARGET_LOCAL();

    ST_BIS_TARGET_LOCAL(uint16_t usTargetNo,const ST_DATE_TIME& stInitTime,uint32_t ulTrackMainCnt,uint8_t oTrackStatus,uint16_t usBeamNo,uint8_t oTrackInitType,uint8_t oTrackReliability,uint8_t oTrackStrength,uint8_t oCwOitUserID,uint16_t usCwTmpTgtNo,uint8_t oFmOitUserID,uint16_t usFmTmpTgtNo,float fSNR,float fPulsePRI,uint16_t usDetectSourceTgtNo,uint8_t oFusionStatus,uint16_t usNoOfAssociatedTgts,const ::dds::core::array< uint16_t, 2L>& aAssociatedTgtNo,float fDistance,float fBearing,float fDistanceVar,float fBearingVar,float fPosX,float fPosY,float fPosXVar,float fPosYVar,const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& fPosCovArry,const ::dds::core::array< float, 4L>& fBearingCovArry,const ::dds::core::array< float, 4L>& fDistanceCovArry,uint8_t oUserConcFlag,uint8_t oPairTgtFlag,uint16_t usPairTgtNo,const ::dds::core::array< uint8_t, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BIS_TARGET_LOCAL (ST_BIS_TARGET_LOCAL&&) = default;
    ST_BIS_TARGET_LOCAL& operator=(ST_BIS_TARGET_LOCAL&&) = default;
    ST_BIS_TARGET_LOCAL& operator=(const ST_BIS_TARGET_LOCAL&) = default;
    ST_BIS_TARGET_LOCAL(const ST_BIS_TARGET_LOCAL&) = default;
    #else
    ST_BIS_TARGET_LOCAL(ST_BIS_TARGET_LOCAL&& other_) OMG_NOEXCEPT;  
    ST_BIS_TARGET_LOCAL& operator=(ST_BIS_TARGET_LOCAL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    ST_DATE_TIME& stInitTime() OMG_NOEXCEPT {
        return m_stInitTime_;
    }

    const ST_DATE_TIME& stInitTime() const OMG_NOEXCEPT {
        return m_stInitTime_;
    }

    void stInitTime(const ST_DATE_TIME& value) {
        m_stInitTime_ = value;
    }

    void stInitTime(ST_DATE_TIME&& value) {
        m_stInitTime_ = std::move(value);
    }
    uint32_t& ulTrackMainCnt() OMG_NOEXCEPT {
        return m_ulTrackMainCnt_;
    }

    const uint32_t& ulTrackMainCnt() const OMG_NOEXCEPT {
        return m_ulTrackMainCnt_;
    }

    void ulTrackMainCnt(uint32_t value) {
        m_ulTrackMainCnt_ = value;
    }

    uint8_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint8_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint8_t value) {
        m_oTrackStatus_ = value;
    }

    uint16_t& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const uint16_t& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(uint16_t value) {
        m_usBeamNo_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    uint8_t& oTrackStrength() OMG_NOEXCEPT {
        return m_oTrackStrength_;
    }

    const uint8_t& oTrackStrength() const OMG_NOEXCEPT {
        return m_oTrackStrength_;
    }

    void oTrackStrength(uint8_t value) {
        m_oTrackStrength_ = value;
    }

    uint8_t& oCwOitUserID() OMG_NOEXCEPT {
        return m_oCwOitUserID_;
    }

    const uint8_t& oCwOitUserID() const OMG_NOEXCEPT {
        return m_oCwOitUserID_;
    }

    void oCwOitUserID(uint8_t value) {
        m_oCwOitUserID_ = value;
    }

    uint16_t& usCwTmpTgtNo() OMG_NOEXCEPT {
        return m_usCwTmpTgtNo_;
    }

    const uint16_t& usCwTmpTgtNo() const OMG_NOEXCEPT {
        return m_usCwTmpTgtNo_;
    }

    void usCwTmpTgtNo(uint16_t value) {
        m_usCwTmpTgtNo_ = value;
    }

    uint8_t& oFmOitUserID() OMG_NOEXCEPT {
        return m_oFmOitUserID_;
    }

    const uint8_t& oFmOitUserID() const OMG_NOEXCEPT {
        return m_oFmOitUserID_;
    }

    void oFmOitUserID(uint8_t value) {
        m_oFmOitUserID_ = value;
    }

    uint16_t& usFmTmpTgtNo() OMG_NOEXCEPT {
        return m_usFmTmpTgtNo_;
    }

    const uint16_t& usFmTmpTgtNo() const OMG_NOEXCEPT {
        return m_usFmTmpTgtNo_;
    }

    void usFmTmpTgtNo(uint16_t value) {
        m_usFmTmpTgtNo_ = value;
    }

    float& fSNR() OMG_NOEXCEPT {
        return m_fSNR_;
    }

    const float& fSNR() const OMG_NOEXCEPT {
        return m_fSNR_;
    }

    void fSNR(float value) {
        m_fSNR_ = value;
    }

    float& fPulsePRI() OMG_NOEXCEPT {
        return m_fPulsePRI_;
    }

    const float& fPulsePRI() const OMG_NOEXCEPT {
        return m_fPulsePRI_;
    }

    void fPulsePRI(float value) {
        m_fPulsePRI_ = value;
    }

    uint16_t& usDetectSourceTgtNo() OMG_NOEXCEPT {
        return m_usDetectSourceTgtNo_;
    }

    const uint16_t& usDetectSourceTgtNo() const OMG_NOEXCEPT {
        return m_usDetectSourceTgtNo_;
    }

    void usDetectSourceTgtNo(uint16_t value) {
        m_usDetectSourceTgtNo_ = value;
    }

    uint8_t& oFusionStatus() OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    const uint8_t& oFusionStatus() const OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    void oFusionStatus(uint8_t value) {
        m_oFusionStatus_ = value;
    }

    uint16_t& usNoOfAssociatedTgts() OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    const uint16_t& usNoOfAssociatedTgts() const OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    void usNoOfAssociatedTgts(uint16_t value) {
        m_usNoOfAssociatedTgts_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aAssociatedTgtNo() OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    const ::dds::core::array< uint16_t, 2L>& aAssociatedTgtNo() const OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    void aAssociatedTgtNo(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aAssociatedTgtNo_ = value;
    }

    void aAssociatedTgtNo(::dds::core::array< uint16_t, 2L>&& value) {
        m_aAssociatedTgtNo_ = std::move(value);
    }
    float& fDistance() OMG_NOEXCEPT {
        return m_fDistance_;
    }

    const float& fDistance() const OMG_NOEXCEPT {
        return m_fDistance_;
    }

    void fDistance(float value) {
        m_fDistance_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fDistanceVar() OMG_NOEXCEPT {
        return m_fDistanceVar_;
    }

    const float& fDistanceVar() const OMG_NOEXCEPT {
        return m_fDistanceVar_;
    }

    void fDistanceVar(float value) {
        m_fDistanceVar_ = value;
    }

    float& fBearingVar() OMG_NOEXCEPT {
        return m_fBearingVar_;
    }

    const float& fBearingVar() const OMG_NOEXCEPT {
        return m_fBearingVar_;
    }

    void fBearingVar(float value) {
        m_fBearingVar_ = value;
    }

    float& fPosX() OMG_NOEXCEPT {
        return m_fPosX_;
    }

    const float& fPosX() const OMG_NOEXCEPT {
        return m_fPosX_;
    }

    void fPosX(float value) {
        m_fPosX_ = value;
    }

    float& fPosY() OMG_NOEXCEPT {
        return m_fPosY_;
    }

    const float& fPosY() const OMG_NOEXCEPT {
        return m_fPosY_;
    }

    void fPosY(float value) {
        m_fPosY_ = value;
    }

    float& fPosXVar() OMG_NOEXCEPT {
        return m_fPosXVar_;
    }

    const float& fPosXVar() const OMG_NOEXCEPT {
        return m_fPosXVar_;
    }

    void fPosXVar(float value) {
        m_fPosXVar_ = value;
    }

    float& fPosYVar() OMG_NOEXCEPT {
        return m_fPosYVar_;
    }

    const float& fPosYVar() const OMG_NOEXCEPT {
        return m_fPosYVar_;
    }

    void fPosYVar(float value) {
        m_fPosYVar_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& fPosCovArry() OMG_NOEXCEPT {
        return m_fPosCovArry_;
    }

    const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& fPosCovArry() const OMG_NOEXCEPT {
        return m_fPosCovArry_;
    }

    void fPosCovArry(const ::dds::core::array< ::dds::core::array< float, 4L>, 4L>& value) {
        m_fPosCovArry_ = value;
    }

    void fPosCovArry(::dds::core::array< ::dds::core::array< float, 4L>, 4L>&& value) {
        m_fPosCovArry_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fBearingCovArry() OMG_NOEXCEPT {
        return m_fBearingCovArry_;
    }

    const ::dds::core::array< float, 4L>& fBearingCovArry() const OMG_NOEXCEPT {
        return m_fBearingCovArry_;
    }

    void fBearingCovArry(const ::dds::core::array< float, 4L>& value) {
        m_fBearingCovArry_ = value;
    }

    void fBearingCovArry(::dds::core::array< float, 4L>&& value) {
        m_fBearingCovArry_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fDistanceCovArry() OMG_NOEXCEPT {
        return m_fDistanceCovArry_;
    }

    const ::dds::core::array< float, 4L>& fDistanceCovArry() const OMG_NOEXCEPT {
        return m_fDistanceCovArry_;
    }

    void fDistanceCovArry(const ::dds::core::array< float, 4L>& value) {
        m_fDistanceCovArry_ = value;
    }

    void fDistanceCovArry(::dds::core::array< float, 4L>&& value) {
        m_fDistanceCovArry_ = std::move(value);
    }
    uint8_t& oUserConcFlag() OMG_NOEXCEPT {
        return m_oUserConcFlag_;
    }

    const uint8_t& oUserConcFlag() const OMG_NOEXCEPT {
        return m_oUserConcFlag_;
    }

    void oUserConcFlag(uint8_t value) {
        m_oUserConcFlag_ = value;
    }

    uint8_t& oPairTgtFlag() OMG_NOEXCEPT {
        return m_oPairTgtFlag_;
    }

    const uint8_t& oPairTgtFlag() const OMG_NOEXCEPT {
        return m_oPairTgtFlag_;
    }

    void oPairTgtFlag(uint8_t value) {
        m_oPairTgtFlag_ = value;
    }

    uint16_t& usPairTgtNo() OMG_NOEXCEPT {
        return m_usPairTgtNo_;
    }

    const uint16_t& usPairTgtNo() const OMG_NOEXCEPT {
        return m_usPairTgtNo_;
    }

    void usPairTgtNo(uint16_t value) {
        m_usPairTgtNo_ = value;
    }

    ::dds::core::array< uint8_t, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint8_t, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint8_t, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint8_t, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_BIS_TARGET_LOCAL& other_) const;
    bool operator != (const ST_BIS_TARGET_LOCAL& other_) const;

    void swap(ST_BIS_TARGET_LOCAL& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTargetNo_;
    ST_DATE_TIME m_stInitTime_;
    uint32_t m_ulTrackMainCnt_;
    uint8_t m_oTrackStatus_;
    uint16_t m_usBeamNo_;
    uint8_t m_oTrackInitType_;
    uint8_t m_oTrackReliability_;
    uint8_t m_oTrackStrength_;
    uint8_t m_oCwOitUserID_;
    uint16_t m_usCwTmpTgtNo_;
    uint8_t m_oFmOitUserID_;
    uint16_t m_usFmTmpTgtNo_;
    float m_fSNR_;
    float m_fPulsePRI_;
    uint16_t m_usDetectSourceTgtNo_;
    uint8_t m_oFusionStatus_;
    uint16_t m_usNoOfAssociatedTgts_;
    ::dds::core::array< uint16_t, 2L> m_aAssociatedTgtNo_;
    float m_fDistance_;
    float m_fBearing_;
    float m_fDistanceVar_;
    float m_fBearingVar_;
    float m_fPosX_;
    float m_fPosY_;
    float m_fPosXVar_;
    float m_fPosYVar_;
    ::dds::core::array< ::dds::core::array< float, 4L>, 4L> m_fPosCovArry_;
    ::dds::core::array< float, 4L> m_fBearingCovArry_;
    ::dds::core::array< float, 4L> m_fDistanceCovArry_;
    uint8_t m_oUserConcFlag_;
    uint8_t m_oPairTgtFlag_;
    uint16_t m_usPairTgtNo_;
    ::dds::core::array< uint8_t, 4L> m_aReserved_;

};

inline void swap(ST_BIS_TARGET_LOCAL& a, ST_BIS_TARGET_LOCAL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BIS_TARGET_LOCAL& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_TARGET_TRACKING_INFO_A {
  public:
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A();

    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A(const ST_MSG_HEADER& stMsgHeader,uint16_t usNoOfTgts,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A (TGTTRK_BISTRK_TARGET_TRACKING_INFO_A&&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& operator=(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A&&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& operator=(const TGTTRK_BISTRK_TARGET_TRACKING_INFO_A&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A(const TGTTRK_BISTRK_TARGET_TRACKING_INFO_A&) = default;
    #else
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& operator=(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const uint16_t& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(uint16_t value) {
        m_usNoOfTgts_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal() OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal() const OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    void stBisTargetLocal(const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& value) {
        m_stBisTargetLocal_ = value;
    }

    void stBisTargetLocal(::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>&& value) {
        m_stBisTargetLocal_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& other_) const;
    bool operator != (const TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& other_) const;

    void swap(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNoOfTgts_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L> m_stBisTargetLocal_;

};

inline void swap(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& a, TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_TARGET_TRACKING_INFO_B {
  public:
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B();

    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B(const ST_MSG_HEADER& stMsgHeader,uint16_t usNoOfTgts,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B (TGTTRK_BISTRK_TARGET_TRACKING_INFO_B&&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& operator=(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B&&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& operator=(const TGTTRK_BISTRK_TARGET_TRACKING_INFO_B&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B(const TGTTRK_BISTRK_TARGET_TRACKING_INFO_B&) = default;
    #else
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& operator=(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const uint16_t& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(uint16_t value) {
        m_usNoOfTgts_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal() OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal() const OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    void stBisTargetLocal(const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& value) {
        m_stBisTargetLocal_ = value;
    }

    void stBisTargetLocal(::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>&& value) {
        m_stBisTargetLocal_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& other_) const;
    bool operator != (const TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& other_) const;

    void swap(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNoOfTgts_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L> m_stBisTargetLocal_;

};

inline void swap(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& a, TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_TARGET_TRACKING_INFO_C {
  public:
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C();

    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C(const ST_MSG_HEADER& stMsgHeader,uint16_t usNoOfTgts,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C (TGTTRK_BISTRK_TARGET_TRACKING_INFO_C&&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& operator=(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C&&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& operator=(const TGTTRK_BISTRK_TARGET_TRACKING_INFO_C&) = default;
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C(const TGTTRK_BISTRK_TARGET_TRACKING_INFO_C&) = default;
    #else
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& operator=(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const uint16_t& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(uint16_t value) {
        m_usNoOfTgts_ = value;
    }

    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal() OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& stBisTargetLocal() const OMG_NOEXCEPT {
        return m_stBisTargetLocal_;
    }

    void stBisTargetLocal(const ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>& value) {
        m_stBisTargetLocal_ = value;
    }

    void stBisTargetLocal(::dds::core::array< ST_BIS_TARGET_LOCAL, 192L>&& value) {
        m_stBisTargetLocal_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& other_) const;
    bool operator != (const TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& other_) const;

    void swap(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usNoOfTgts_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ST_BIS_TARGET_LOCAL, 192L> m_stBisTargetLocal_;

};

inline void swap(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& a, TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A {
  public:
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A();

    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsBisCitThrshAuto,const ST_BIS_THRESH_INFO& stBisThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A (TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A&&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& operator=(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A&&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& operator=(const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A(const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A&) = default;
    #else
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& operator=(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsBisCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    const uint8_t& oIsBisCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    void oIsBisCitThrshAuto(uint8_t value) {
        m_oIsBisCitThrshAuto_ = value;
    }

    ST_BIS_THRESH_INFO& stBisThresh() OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    const ST_BIS_THRESH_INFO& stBisThresh() const OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    void stBisThresh(const ST_BIS_THRESH_INFO& value) {
        m_stBisThresh_ = value;
    }

    void stBisThresh(ST_BIS_THRESH_INFO&& value) {
        m_stBisThresh_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& other_) const;
    bool operator != (const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& other_) const;

    void swap(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsBisCitThrshAuto_;
    ST_BIS_THRESH_INFO m_stBisThresh_;

};

inline void swap(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& a, TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B {
  public:
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B();

    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsBisCitThrshAuto,const ST_BIS_THRESH_INFO& stBisThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B (TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B&&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& operator=(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B&&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& operator=(const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B(const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B&) = default;
    #else
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& operator=(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsBisCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    const uint8_t& oIsBisCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    void oIsBisCitThrshAuto(uint8_t value) {
        m_oIsBisCitThrshAuto_ = value;
    }

    ST_BIS_THRESH_INFO& stBisThresh() OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    const ST_BIS_THRESH_INFO& stBisThresh() const OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    void stBisThresh(const ST_BIS_THRESH_INFO& value) {
        m_stBisThresh_ = value;
    }

    void stBisThresh(ST_BIS_THRESH_INFO&& value) {
        m_stBisThresh_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& other_) const;
    bool operator != (const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& other_) const;

    void swap(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsBisCitThrshAuto_;
    ST_BIS_THRESH_INFO m_stBisThresh_;

};

inline void swap(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& a, TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& sample);

class NDDSUSERDllExport TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C {
  public:
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C();

    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsBisCitThrshAuto,const ST_BIS_THRESH_INFO& stBisThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C (TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C&&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& operator=(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C&&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& operator=(const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C&) = default;
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C(const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C&) = default;
    #else
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C&& other_) OMG_NOEXCEPT;  
    TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& operator=(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsBisCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    const uint8_t& oIsBisCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    void oIsBisCitThrshAuto(uint8_t value) {
        m_oIsBisCitThrshAuto_ = value;
    }

    ST_BIS_THRESH_INFO& stBisThresh() OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    const ST_BIS_THRESH_INFO& stBisThresh() const OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    void stBisThresh(const ST_BIS_THRESH_INFO& value) {
        m_stBisThresh_ = value;
    }

    void stBisThresh(ST_BIS_THRESH_INFO&& value) {
        m_stBisThresh_ = std::move(value);
    }

    bool operator == (const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& other_) const;
    bool operator != (const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& other_) const;

    void swap(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsBisCitThrshAuto_;
    ST_BIS_THRESH_INFO m_stBisThresh_;

};

inline void swap(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& a, TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& sample);

class NDDSUSERDllExport TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK {
  public:
    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK();

    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK(const ST_MSG_HEADER& stMsgHeader,uint8_t oBisAxisID,uint8_t oBisPulseType,uint8_t oOitUserID,uint16_t usTmpTgtNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK (TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& operator=(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& operator=(const TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK&) = default;
    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK(const TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK&) = default;
    #else
    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK&& other_) OMG_NOEXCEPT;  
    TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& operator=(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oBisAxisID() OMG_NOEXCEPT {
        return m_oBisAxisID_;
    }

    const uint8_t& oBisAxisID() const OMG_NOEXCEPT {
        return m_oBisAxisID_;
    }

    void oBisAxisID(uint8_t value) {
        m_oBisAxisID_ = value;
    }

    uint8_t& oBisPulseType() OMG_NOEXCEPT {
        return m_oBisPulseType_;
    }

    const uint8_t& oBisPulseType() const OMG_NOEXCEPT {
        return m_oBisPulseType_;
    }

    void oBisPulseType(uint8_t value) {
        m_oBisPulseType_ = value;
    }

    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    bool operator == (const TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& other_) const;
    bool operator != (const TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& other_) const;

    void swap(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oBisAxisID_;
    uint8_t m_oBisPulseType_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;

};

inline void swap(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& a, TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& sample);

class NDDSUSERDllExport TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST {
  public:
    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST();

    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oParGroupID,uint8_t oParValSort);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST (TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST&&) = default;
    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& operator=(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST&&) = default;
    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& operator=(const TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST&) = default;
    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST(const TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST&) = default;
    #else
    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST&& other_) OMG_NOEXCEPT;  
    TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& operator=(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oParGroupID() OMG_NOEXCEPT {
        return m_oParGroupID_;
    }

    const uint8_t& oParGroupID() const OMG_NOEXCEPT {
        return m_oParGroupID_;
    }

    void oParGroupID(uint8_t value) {
        m_oParGroupID_ = value;
    }

    uint8_t& oParValSort() OMG_NOEXCEPT {
        return m_oParValSort_;
    }

    const uint8_t& oParValSort() const OMG_NOEXCEPT {
        return m_oParValSort_;
    }

    void oParValSort(uint8_t value) {
        m_oParValSort_ = value;
    }

    bool operator == (const TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& other_) const;
    bool operator != (const TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& other_) const;

    void swap(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oParGroupID_;
    uint8_t m_oParValSort_;

};

inline void swap(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& a, TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& sample);

class NDDSUSERDllExport ST_LAS_LOFAR_MEAS {
  public:
    ST_LAS_LOFAR_MEAS();

    ST_LAS_LOFAR_MEAS(float fBearing,float fFreq,float fSNR,const ::dds::core::array< uint8_t, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_LOFAR_MEAS (ST_LAS_LOFAR_MEAS&&) = default;
    ST_LAS_LOFAR_MEAS& operator=(ST_LAS_LOFAR_MEAS&&) = default;
    ST_LAS_LOFAR_MEAS& operator=(const ST_LAS_LOFAR_MEAS&) = default;
    ST_LAS_LOFAR_MEAS(const ST_LAS_LOFAR_MEAS&) = default;
    #else
    ST_LAS_LOFAR_MEAS(ST_LAS_LOFAR_MEAS&& other_) OMG_NOEXCEPT;  
    ST_LAS_LOFAR_MEAS& operator=(ST_LAS_LOFAR_MEAS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fFreq() OMG_NOEXCEPT {
        return m_fFreq_;
    }

    const float& fFreq() const OMG_NOEXCEPT {
        return m_fFreq_;
    }

    void fFreq(float value) {
        m_fFreq_ = value;
    }

    float& fSNR() OMG_NOEXCEPT {
        return m_fSNR_;
    }

    const float& fSNR() const OMG_NOEXCEPT {
        return m_fSNR_;
    }

    void fSNR(float value) {
        m_fSNR_ = value;
    }

    ::dds::core::array< uint8_t, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint8_t, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint8_t, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint8_t, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_LAS_LOFAR_MEAS& other_) const;
    bool operator != (const ST_LAS_LOFAR_MEAS& other_) const;

    void swap(ST_LAS_LOFAR_MEAS& other_) OMG_NOEXCEPT ;

  private:

    float m_fBearing_;
    float m_fFreq_;
    float m_fSNR_;
    ::dds::core::array< uint8_t, 4L> m_aReserved_;

};

inline void swap(ST_LAS_LOFAR_MEAS& a, ST_LAS_LOFAR_MEAS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_LOFAR_MEAS& sample);

class NDDSUSERDllExport TGTTRK_LASTRK_LOFAR_MEAS_INFO {
  public:
    TGTTRK_LASTRK_LOFAR_MEAS_INFO();

    TGTTRK_LASTRK_LOFAR_MEAS_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 3L>& usNoOfLofCbfMeas,const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasLofCbfMeasInfo,const ::dds::core::array< uint16_t, 3L>& usNoOfLofAbfMeas,const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasLofAbfMeasInfo,const ::dds::core::array< uint16_t, 3L>& usNoOfDemMeas,const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasDemMeasInfo,const ::dds::core::array< float, 24L>& aThreatFrequency,const ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& aExclusFrequency);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_LASTRK_LOFAR_MEAS_INFO (TGTTRK_LASTRK_LOFAR_MEAS_INFO&&) = default;
    TGTTRK_LASTRK_LOFAR_MEAS_INFO& operator=(TGTTRK_LASTRK_LOFAR_MEAS_INFO&&) = default;
    TGTTRK_LASTRK_LOFAR_MEAS_INFO& operator=(const TGTTRK_LASTRK_LOFAR_MEAS_INFO&) = default;
    TGTTRK_LASTRK_LOFAR_MEAS_INFO(const TGTTRK_LASTRK_LOFAR_MEAS_INFO&) = default;
    #else
    TGTTRK_LASTRK_LOFAR_MEAS_INFO(TGTTRK_LASTRK_LOFAR_MEAS_INFO&& other_) OMG_NOEXCEPT;  
    TGTTRK_LASTRK_LOFAR_MEAS_INFO& operator=(TGTTRK_LASTRK_LOFAR_MEAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 3L>& usNoOfLofCbfMeas() OMG_NOEXCEPT {
        return m_usNoOfLofCbfMeas_;
    }

    const ::dds::core::array< uint16_t, 3L>& usNoOfLofCbfMeas() const OMG_NOEXCEPT {
        return m_usNoOfLofCbfMeas_;
    }

    void usNoOfLofCbfMeas(const ::dds::core::array< uint16_t, 3L>& value) {
        m_usNoOfLofCbfMeas_ = value;
    }

    void usNoOfLofCbfMeas(::dds::core::array< uint16_t, 3L>&& value) {
        m_usNoOfLofCbfMeas_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasLofCbfMeasInfo() OMG_NOEXCEPT {
        return m_stLasLofCbfMeasInfo_;
    }

    const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasLofCbfMeasInfo() const OMG_NOEXCEPT {
        return m_stLasLofCbfMeasInfo_;
    }

    void stLasLofCbfMeasInfo(const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& value) {
        m_stLasLofCbfMeasInfo_ = value;
    }

    void stLasLofCbfMeasInfo(::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>&& value) {
        m_stLasLofCbfMeasInfo_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 3L>& usNoOfLofAbfMeas() OMG_NOEXCEPT {
        return m_usNoOfLofAbfMeas_;
    }

    const ::dds::core::array< uint16_t, 3L>& usNoOfLofAbfMeas() const OMG_NOEXCEPT {
        return m_usNoOfLofAbfMeas_;
    }

    void usNoOfLofAbfMeas(const ::dds::core::array< uint16_t, 3L>& value) {
        m_usNoOfLofAbfMeas_ = value;
    }

    void usNoOfLofAbfMeas(::dds::core::array< uint16_t, 3L>&& value) {
        m_usNoOfLofAbfMeas_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasLofAbfMeasInfo() OMG_NOEXCEPT {
        return m_stLasLofAbfMeasInfo_;
    }

    const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasLofAbfMeasInfo() const OMG_NOEXCEPT {
        return m_stLasLofAbfMeasInfo_;
    }

    void stLasLofAbfMeasInfo(const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& value) {
        m_stLasLofAbfMeasInfo_ = value;
    }

    void stLasLofAbfMeasInfo(::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>&& value) {
        m_stLasLofAbfMeasInfo_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 3L>& usNoOfDemMeas() OMG_NOEXCEPT {
        return m_usNoOfDemMeas_;
    }

    const ::dds::core::array< uint16_t, 3L>& usNoOfDemMeas() const OMG_NOEXCEPT {
        return m_usNoOfDemMeas_;
    }

    void usNoOfDemMeas(const ::dds::core::array< uint16_t, 3L>& value) {
        m_usNoOfDemMeas_ = value;
    }

    void usNoOfDemMeas(::dds::core::array< uint16_t, 3L>&& value) {
        m_usNoOfDemMeas_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasDemMeasInfo() OMG_NOEXCEPT {
        return m_stLasDemMeasInfo_;
    }

    const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& stLasDemMeasInfo() const OMG_NOEXCEPT {
        return m_stLasDemMeasInfo_;
    }

    void stLasDemMeasInfo(const ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>& value) {
        m_stLasDemMeasInfo_ = value;
    }

    void stLasDemMeasInfo(::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L>&& value) {
        m_stLasDemMeasInfo_ = std::move(value);
    }
    ::dds::core::array< float, 24L>& aThreatFrequency() OMG_NOEXCEPT {
        return m_aThreatFrequency_;
    }

    const ::dds::core::array< float, 24L>& aThreatFrequency() const OMG_NOEXCEPT {
        return m_aThreatFrequency_;
    }

    void aThreatFrequency(const ::dds::core::array< float, 24L>& value) {
        m_aThreatFrequency_ = value;
    }

    void aThreatFrequency(::dds::core::array< float, 24L>&& value) {
        m_aThreatFrequency_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& aExclusFrequency() OMG_NOEXCEPT {
        return m_aExclusFrequency_;
    }

    const ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& aExclusFrequency() const OMG_NOEXCEPT {
        return m_aExclusFrequency_;
    }

    void aExclusFrequency(const ::dds::core::array< ::dds::core::array< float, 24L>, 3L>& value) {
        m_aExclusFrequency_ = value;
    }

    void aExclusFrequency(::dds::core::array< ::dds::core::array< float, 24L>, 3L>&& value) {
        m_aExclusFrequency_ = std::move(value);
    }

    bool operator == (const TGTTRK_LASTRK_LOFAR_MEAS_INFO& other_) const;
    bool operator != (const TGTTRK_LASTRK_LOFAR_MEAS_INFO& other_) const;

    void swap(TGTTRK_LASTRK_LOFAR_MEAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 3L> m_usNoOfLofCbfMeas_;
    ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L> m_stLasLofCbfMeasInfo_;
    ::dds::core::array< uint16_t, 3L> m_usNoOfLofAbfMeas_;
    ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L> m_stLasLofAbfMeasInfo_;
    ::dds::core::array< uint16_t, 3L> m_usNoOfDemMeas_;
    ::dds::core::array< ::dds::core::array< ST_LAS_LOFAR_MEAS, 1600L>, 3L> m_stLasDemMeasInfo_;
    ::dds::core::array< float, 24L> m_aThreatFrequency_;
    ::dds::core::array< ::dds::core::array< float, 24L>, 3L> m_aExclusFrequency_;

};

inline void swap(TGTTRK_LASTRK_LOFAR_MEAS_INFO& a, TGTTRK_LASTRK_LOFAR_MEAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_LASTRK_LOFAR_MEAS_INFO& sample);

class NDDSUSERDllExport ST_LAS_TARGET_LOCAL {
  public:
    ST_LAS_TARGET_LOCAL();

    ST_LAS_TARGET_LOCAL(uint16_t usTargetNo,const ST_DATE_TIME& stInitTime,uint32_t ulTrackMainCnt,uint8_t oTrackStatus,uint16_t usBeamNo,uint8_t oTrackInitType,uint8_t oTrackReliability,uint8_t oTrackStrength,uint8_t oFusionStatus,uint16_t usNoOfAssociatedTgts,const ::dds::core::array< uint16_t, 5L>& aAssociatedTgtNo,const ::dds::core::array< float, 5L>& aAssociatedBearing,float fSNR,uint8_t oBbdOitUserID,uint16_t usBbdTmpTgtNo,float fBearing,float fBearingRate,const ::dds::core::array< float, 4L>& fBearingCovArry,uint8_t oLofarTonalFreqCnt,const ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& aLofarFreqInfo,uint8_t oDemonTonalFreqCnt,const ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& aDemonFreqInfo,uint8_t oUserConcStatus,uint8_t IsInitByUserAssociation,uint8_t oOriginSensorAxis,uint16_t usOriginTargetNo,const ::dds::core::array< uint8_t, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_TARGET_LOCAL (ST_LAS_TARGET_LOCAL&&) = default;
    ST_LAS_TARGET_LOCAL& operator=(ST_LAS_TARGET_LOCAL&&) = default;
    ST_LAS_TARGET_LOCAL& operator=(const ST_LAS_TARGET_LOCAL&) = default;
    ST_LAS_TARGET_LOCAL(const ST_LAS_TARGET_LOCAL&) = default;
    #else
    ST_LAS_TARGET_LOCAL(ST_LAS_TARGET_LOCAL&& other_) OMG_NOEXCEPT;  
    ST_LAS_TARGET_LOCAL& operator=(ST_LAS_TARGET_LOCAL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    ST_DATE_TIME& stInitTime() OMG_NOEXCEPT {
        return m_stInitTime_;
    }

    const ST_DATE_TIME& stInitTime() const OMG_NOEXCEPT {
        return m_stInitTime_;
    }

    void stInitTime(const ST_DATE_TIME& value) {
        m_stInitTime_ = value;
    }

    void stInitTime(ST_DATE_TIME&& value) {
        m_stInitTime_ = std::move(value);
    }
    uint32_t& ulTrackMainCnt() OMG_NOEXCEPT {
        return m_ulTrackMainCnt_;
    }

    const uint32_t& ulTrackMainCnt() const OMG_NOEXCEPT {
        return m_ulTrackMainCnt_;
    }

    void ulTrackMainCnt(uint32_t value) {
        m_ulTrackMainCnt_ = value;
    }

    uint8_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint8_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint8_t value) {
        m_oTrackStatus_ = value;
    }

    uint16_t& usBeamNo() OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    const uint16_t& usBeamNo() const OMG_NOEXCEPT {
        return m_usBeamNo_;
    }

    void usBeamNo(uint16_t value) {
        m_usBeamNo_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    uint8_t& oTrackReliability() OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    const uint8_t& oTrackReliability() const OMG_NOEXCEPT {
        return m_oTrackReliability_;
    }

    void oTrackReliability(uint8_t value) {
        m_oTrackReliability_ = value;
    }

    uint8_t& oTrackStrength() OMG_NOEXCEPT {
        return m_oTrackStrength_;
    }

    const uint8_t& oTrackStrength() const OMG_NOEXCEPT {
        return m_oTrackStrength_;
    }

    void oTrackStrength(uint8_t value) {
        m_oTrackStrength_ = value;
    }

    uint8_t& oFusionStatus() OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    const uint8_t& oFusionStatus() const OMG_NOEXCEPT {
        return m_oFusionStatus_;
    }

    void oFusionStatus(uint8_t value) {
        m_oFusionStatus_ = value;
    }

    uint16_t& usNoOfAssociatedTgts() OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    const uint16_t& usNoOfAssociatedTgts() const OMG_NOEXCEPT {
        return m_usNoOfAssociatedTgts_;
    }

    void usNoOfAssociatedTgts(uint16_t value) {
        m_usNoOfAssociatedTgts_ = value;
    }

    ::dds::core::array< uint16_t, 5L>& aAssociatedTgtNo() OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    const ::dds::core::array< uint16_t, 5L>& aAssociatedTgtNo() const OMG_NOEXCEPT {
        return m_aAssociatedTgtNo_;
    }

    void aAssociatedTgtNo(const ::dds::core::array< uint16_t, 5L>& value) {
        m_aAssociatedTgtNo_ = value;
    }

    void aAssociatedTgtNo(::dds::core::array< uint16_t, 5L>&& value) {
        m_aAssociatedTgtNo_ = std::move(value);
    }
    ::dds::core::array< float, 5L>& aAssociatedBearing() OMG_NOEXCEPT {
        return m_aAssociatedBearing_;
    }

    const ::dds::core::array< float, 5L>& aAssociatedBearing() const OMG_NOEXCEPT {
        return m_aAssociatedBearing_;
    }

    void aAssociatedBearing(const ::dds::core::array< float, 5L>& value) {
        m_aAssociatedBearing_ = value;
    }

    void aAssociatedBearing(::dds::core::array< float, 5L>&& value) {
        m_aAssociatedBearing_ = std::move(value);
    }
    float& fSNR() OMG_NOEXCEPT {
        return m_fSNR_;
    }

    const float& fSNR() const OMG_NOEXCEPT {
        return m_fSNR_;
    }

    void fSNR(float value) {
        m_fSNR_ = value;
    }

    uint8_t& oBbdOitUserID() OMG_NOEXCEPT {
        return m_oBbdOitUserID_;
    }

    const uint8_t& oBbdOitUserID() const OMG_NOEXCEPT {
        return m_oBbdOitUserID_;
    }

    void oBbdOitUserID(uint8_t value) {
        m_oBbdOitUserID_ = value;
    }

    uint16_t& usBbdTmpTgtNo() OMG_NOEXCEPT {
        return m_usBbdTmpTgtNo_;
    }

    const uint16_t& usBbdTmpTgtNo() const OMG_NOEXCEPT {
        return m_usBbdTmpTgtNo_;
    }

    void usBbdTmpTgtNo(uint16_t value) {
        m_usBbdTmpTgtNo_ = value;
    }

    float& fBearing() OMG_NOEXCEPT {
        return m_fBearing_;
    }

    const float& fBearing() const OMG_NOEXCEPT {
        return m_fBearing_;
    }

    void fBearing(float value) {
        m_fBearing_ = value;
    }

    float& fBearingRate() OMG_NOEXCEPT {
        return m_fBearingRate_;
    }

    const float& fBearingRate() const OMG_NOEXCEPT {
        return m_fBearingRate_;
    }

    void fBearingRate(float value) {
        m_fBearingRate_ = value;
    }

    ::dds::core::array< float, 4L>& fBearingCovArry() OMG_NOEXCEPT {
        return m_fBearingCovArry_;
    }

    const ::dds::core::array< float, 4L>& fBearingCovArry() const OMG_NOEXCEPT {
        return m_fBearingCovArry_;
    }

    void fBearingCovArry(const ::dds::core::array< float, 4L>& value) {
        m_fBearingCovArry_ = value;
    }

    void fBearingCovArry(::dds::core::array< float, 4L>&& value) {
        m_fBearingCovArry_ = std::move(value);
    }
    uint8_t& oLofarTonalFreqCnt() OMG_NOEXCEPT {
        return m_oLofarTonalFreqCnt_;
    }

    const uint8_t& oLofarTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oLofarTonalFreqCnt_;
    }

    void oLofarTonalFreqCnt(uint8_t value) {
        m_oLofarTonalFreqCnt_ = value;
    }

    ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& aLofarFreqInfo() OMG_NOEXCEPT {
        return m_aLofarFreqInfo_;
    }

    const ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& aLofarFreqInfo() const OMG_NOEXCEPT {
        return m_aLofarFreqInfo_;
    }

    void aLofarFreqInfo(const ::dds::core::array< ST_LAS_FREQ_INFO, 24L>& value) {
        m_aLofarFreqInfo_ = value;
    }

    void aLofarFreqInfo(::dds::core::array< ST_LAS_FREQ_INFO, 24L>&& value) {
        m_aLofarFreqInfo_ = std::move(value);
    }
    uint8_t& oDemonTonalFreqCnt() OMG_NOEXCEPT {
        return m_oDemonTonalFreqCnt_;
    }

    const uint8_t& oDemonTonalFreqCnt() const OMG_NOEXCEPT {
        return m_oDemonTonalFreqCnt_;
    }

    void oDemonTonalFreqCnt(uint8_t value) {
        m_oDemonTonalFreqCnt_ = value;
    }

    ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& aDemonFreqInfo() OMG_NOEXCEPT {
        return m_aDemonFreqInfo_;
    }

    const ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& aDemonFreqInfo() const OMG_NOEXCEPT {
        return m_aDemonFreqInfo_;
    }

    void aDemonFreqInfo(const ::dds::core::array< ST_LAS_FREQ_INFO, 8L>& value) {
        m_aDemonFreqInfo_ = value;
    }

    void aDemonFreqInfo(::dds::core::array< ST_LAS_FREQ_INFO, 8L>&& value) {
        m_aDemonFreqInfo_ = std::move(value);
    }
    uint8_t& oUserConcStatus() OMG_NOEXCEPT {
        return m_oUserConcStatus_;
    }

    const uint8_t& oUserConcStatus() const OMG_NOEXCEPT {
        return m_oUserConcStatus_;
    }

    void oUserConcStatus(uint8_t value) {
        m_oUserConcStatus_ = value;
    }

    uint8_t& IsInitByUserAssociation() OMG_NOEXCEPT {
        return m_IsInitByUserAssociation_;
    }

    const uint8_t& IsInitByUserAssociation() const OMG_NOEXCEPT {
        return m_IsInitByUserAssociation_;
    }

    void IsInitByUserAssociation(uint8_t value) {
        m_IsInitByUserAssociation_ = value;
    }

    uint8_t& oOriginSensorAxis() OMG_NOEXCEPT {
        return m_oOriginSensorAxis_;
    }

    const uint8_t& oOriginSensorAxis() const OMG_NOEXCEPT {
        return m_oOriginSensorAxis_;
    }

    void oOriginSensorAxis(uint8_t value) {
        m_oOriginSensorAxis_ = value;
    }

    uint16_t& usOriginTargetNo() OMG_NOEXCEPT {
        return m_usOriginTargetNo_;
    }

    const uint16_t& usOriginTargetNo() const OMG_NOEXCEPT {
        return m_usOriginTargetNo_;
    }

    void usOriginTargetNo(uint16_t value) {
        m_usOriginTargetNo_ = value;
    }

    ::dds::core::array< uint8_t, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint8_t, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint8_t, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint8_t, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_LAS_TARGET_LOCAL& other_) const;
    bool operator != (const ST_LAS_TARGET_LOCAL& other_) const;

    void swap(ST_LAS_TARGET_LOCAL& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTargetNo_;
    ST_DATE_TIME m_stInitTime_;
    uint32_t m_ulTrackMainCnt_;
    uint8_t m_oTrackStatus_;
    uint16_t m_usBeamNo_;
    uint8_t m_oTrackInitType_;
    uint8_t m_oTrackReliability_;
    uint8_t m_oTrackStrength_;
    uint8_t m_oFusionStatus_;
    uint16_t m_usNoOfAssociatedTgts_;
    ::dds::core::array< uint16_t, 5L> m_aAssociatedTgtNo_;
    ::dds::core::array< float, 5L> m_aAssociatedBearing_;
    float m_fSNR_;
    uint8_t m_oBbdOitUserID_;
    uint16_t m_usBbdTmpTgtNo_;
    float m_fBearing_;
    float m_fBearingRate_;
    ::dds::core::array< float, 4L> m_fBearingCovArry_;
    uint8_t m_oLofarTonalFreqCnt_;
    ::dds::core::array< ST_LAS_FREQ_INFO, 24L> m_aLofarFreqInfo_;
    uint8_t m_oDemonTonalFreqCnt_;
    ::dds::core::array< ST_LAS_FREQ_INFO, 8L> m_aDemonFreqInfo_;
    uint8_t m_oUserConcStatus_;
    uint8_t m_IsInitByUserAssociation_;
    uint8_t m_oOriginSensorAxis_;
    uint16_t m_usOriginTargetNo_;
    ::dds::core::array< uint8_t, 4L> m_aReserved_;

};

inline void swap(ST_LAS_TARGET_LOCAL& a, ST_LAS_TARGET_LOCAL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_TARGET_LOCAL& sample);

class NDDSUSERDllExport TGTTRK_LASTRK_TARGET_TRACKING_INFO {
  public:
    TGTTRK_LASTRK_TARGET_TRACKING_INFO();

    TGTTRK_LASTRK_TARGET_TRACKING_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 3L>& usNoOfTgts,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ::dds::core::array< ST_LAS_TARGET_LOCAL, 320L>, 3L>& stLasTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_LASTRK_TARGET_TRACKING_INFO (TGTTRK_LASTRK_TARGET_TRACKING_INFO&&) = default;
    TGTTRK_LASTRK_TARGET_TRACKING_INFO& operator=(TGTTRK_LASTRK_TARGET_TRACKING_INFO&&) = default;
    TGTTRK_LASTRK_TARGET_TRACKING_INFO& operator=(const TGTTRK_LASTRK_TARGET_TRACKING_INFO&) = default;
    TGTTRK_LASTRK_TARGET_TRACKING_INFO(const TGTTRK_LASTRK_TARGET_TRACKING_INFO&) = default;
    #else
    TGTTRK_LASTRK_TARGET_TRACKING_INFO(TGTTRK_LASTRK_TARGET_TRACKING_INFO&& other_) OMG_NOEXCEPT;  
    TGTTRK_LASTRK_TARGET_TRACKING_INFO& operator=(TGTTRK_LASTRK_TARGET_TRACKING_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 3L>& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const ::dds::core::array< uint16_t, 3L>& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(const ::dds::core::array< uint16_t, 3L>& value) {
        m_usNoOfTgts_ = value;
    }

    void usNoOfTgts(::dds::core::array< uint16_t, 3L>&& value) {
        m_usNoOfTgts_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ST_LAS_TARGET_LOCAL, 320L>, 3L>& stLasTargetLocal() OMG_NOEXCEPT {
        return m_stLasTargetLocal_;
    }

    const ::dds::core::array< ::dds::core::array< ST_LAS_TARGET_LOCAL, 320L>, 3L>& stLasTargetLocal() const OMG_NOEXCEPT {
        return m_stLasTargetLocal_;
    }

    void stLasTargetLocal(const ::dds::core::array< ::dds::core::array< ST_LAS_TARGET_LOCAL, 320L>, 3L>& value) {
        m_stLasTargetLocal_ = value;
    }

    void stLasTargetLocal(::dds::core::array< ::dds::core::array< ST_LAS_TARGET_LOCAL, 320L>, 3L>&& value) {
        m_stLasTargetLocal_ = std::move(value);
    }

    bool operator == (const TGTTRK_LASTRK_TARGET_TRACKING_INFO& other_) const;
    bool operator != (const TGTTRK_LASTRK_TARGET_TRACKING_INFO& other_) const;

    void swap(TGTTRK_LASTRK_TARGET_TRACKING_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 3L> m_usNoOfTgts_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ::dds::core::array< ST_LAS_TARGET_LOCAL, 320L>, 3L> m_stLasTargetLocal_;

};

inline void swap(TGTTRK_LASTRK_TARGET_TRACKING_INFO& a, TGTTRK_LASTRK_TARGET_TRACKING_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_LASTRK_TARGET_TRACKING_INFO& sample);

class NDDSUSERDllExport TGTTRK_LASTRK_THRESHOLD_INFO_ACK {
  public:
    TGTTRK_LASTRK_THRESHOLD_INFO_ACK();

    TGTTRK_LASTRK_THRESHOLD_INFO_ACK(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsLasCitThrshAuto,const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_LASTRK_THRESHOLD_INFO_ACK (TGTTRK_LASTRK_THRESHOLD_INFO_ACK&&) = default;
    TGTTRK_LASTRK_THRESHOLD_INFO_ACK& operator=(TGTTRK_LASTRK_THRESHOLD_INFO_ACK&&) = default;
    TGTTRK_LASTRK_THRESHOLD_INFO_ACK& operator=(const TGTTRK_LASTRK_THRESHOLD_INFO_ACK&) = default;
    TGTTRK_LASTRK_THRESHOLD_INFO_ACK(const TGTTRK_LASTRK_THRESHOLD_INFO_ACK&) = default;
    #else
    TGTTRK_LASTRK_THRESHOLD_INFO_ACK(TGTTRK_LASTRK_THRESHOLD_INFO_ACK&& other_) OMG_NOEXCEPT;  
    TGTTRK_LASTRK_THRESHOLD_INFO_ACK& operator=(TGTTRK_LASTRK_THRESHOLD_INFO_ACK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsLasCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsLasCitThrshAuto_;
    }

    const uint8_t& oIsLasCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsLasCitThrshAuto_;
    }

    void oIsLasCitThrshAuto(uint8_t value) {
        m_oIsLasCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh() OMG_NOEXCEPT {
        return m_stLasThresh_;
    }

    const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh() const OMG_NOEXCEPT {
        return m_stLasThresh_;
    }

    void stLasThresh(const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& value) {
        m_stLasThresh_ = value;
    }

    void stLasThresh(::dds::core::array< ST_LAS_THRESH_INFO, 3L>&& value) {
        m_stLasThresh_ = std::move(value);
    }

    bool operator == (const TGTTRK_LASTRK_THRESHOLD_INFO_ACK& other_) const;
    bool operator != (const TGTTRK_LASTRK_THRESHOLD_INFO_ACK& other_) const;

    void swap(TGTTRK_LASTRK_THRESHOLD_INFO_ACK& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsLasCitThrshAuto_;
    ::dds::core::array< ST_LAS_THRESH_INFO, 3L> m_stLasThresh_;

};

inline void swap(TGTTRK_LASTRK_THRESHOLD_INFO_ACK& a, TGTTRK_LASTRK_THRESHOLD_INFO_ACK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_LASTRK_THRESHOLD_INFO_ACK& sample);

class NDDSUSERDllExport TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK {
  public:
    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK();

    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint8_t oBFType,uint8_t oOitUserID,uint16_t usTmpTgtNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK (TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& operator=(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& operator=(const TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK&) = default;
    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK(const TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK&) = default;
    #else
    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK&& other_) OMG_NOEXCEPT;  
    TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& operator=(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oBFType() OMG_NOEXCEPT {
        return m_oBFType_;
    }

    const uint8_t& oBFType() const OMG_NOEXCEPT {
        return m_oBFType_;
    }

    void oBFType(uint8_t value) {
        m_oBFType_ = value;
    }

    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    bool operator == (const TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& other_) const;
    bool operator != (const TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& other_) const;

    void swap(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint8_t m_oBFType_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;

};

inline void swap(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& a, TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& sample);

class NDDSUSERDllExport TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK {
  public:
    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK();

    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint8_t oOitUserID,uint16_t usTmpTgtNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK (TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& operator=(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& operator=(const TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK&) = default;
    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK(const TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK&) = default;
    #else
    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK&& other_) OMG_NOEXCEPT;  
    TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& operator=(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    bool operator == (const TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& other_) const;
    bool operator != (const TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& other_) const;

    void swap(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;

};

inline void swap(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& a, TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& sample);

class NDDSUSERDllExport TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK {
  public:
    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK();

    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint8_t oBFType,uint8_t oOitUserID,uint16_t usTmpTgtNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK (TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& operator=(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK&&) = default;
    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& operator=(const TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK&) = default;
    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK(const TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK&) = default;
    #else
    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK&& other_) OMG_NOEXCEPT;  
    TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& operator=(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oBFType() OMG_NOEXCEPT {
        return m_oBFType_;
    }

    const uint8_t& oBFType() const OMG_NOEXCEPT {
        return m_oBFType_;
    }

    void oBFType(uint8_t value) {
        m_oBFType_ = value;
    }

    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    bool operator == (const TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& other_) const;
    bool operator != (const TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& other_) const;

    void swap(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint8_t m_oBFType_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;

};

inline void swap(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& a, TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& sample);

class NDDSUSERDllExport TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST {
  public:
    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST();

    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oParGroupID,uint8_t oParValSort);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST (TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST&&) = default;
    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& operator=(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST&&) = default;
    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& operator=(const TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST&) = default;
    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST(const TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST&) = default;
    #else
    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST&& other_) OMG_NOEXCEPT;  
    TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& operator=(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oParGroupID() OMG_NOEXCEPT {
        return m_oParGroupID_;
    }

    const uint8_t& oParGroupID() const OMG_NOEXCEPT {
        return m_oParGroupID_;
    }

    void oParGroupID(uint8_t value) {
        m_oParGroupID_ = value;
    }

    uint8_t& oParValSort() OMG_NOEXCEPT {
        return m_oParValSort_;
    }

    const uint8_t& oParValSort() const OMG_NOEXCEPT {
        return m_oParValSort_;
    }

    void oParValSort(uint8_t value) {
        m_oParValSort_ = value;
    }

    bool operator == (const TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& other_) const;
    bool operator != (const TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& other_) const;

    void swap(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oParGroupID_;
    uint8_t m_oParValSort_;

};

inline void swap(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& a, TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& sample);

class NDDSUSERDllExport TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO {
  public:
    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO();

    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& aAcoLofFreqNo,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& aAcoLofFreqInfo,const ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& usAcoDemFreqNo,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& aAcoDemFreqInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO (TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO&&) = default;
    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& operator=(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO&&) = default;
    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& operator=(const TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO&) = default;
    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO(const TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO&) = default;
    #else
    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO&& other_) OMG_NOEXCEPT;  
    TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& operator=(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& aAcoLofFreqNo() OMG_NOEXCEPT {
        return m_aAcoLofFreqNo_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& aAcoLofFreqNo() const OMG_NOEXCEPT {
        return m_aAcoLofFreqNo_;
    }

    void aAcoLofFreqNo(const ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& value) {
        m_aAcoLofFreqNo_ = value;
    }

    void aAcoLofFreqNo(::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>&& value) {
        m_aAcoLofFreqNo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& aAcoLofFreqInfo() OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& aAcoLofFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    void aAcoLofFreqInfo(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& value) {
        m_aAcoLofFreqInfo_ = value;
    }

    void aAcoLofFreqInfo(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>&& value) {
        m_aAcoLofFreqInfo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& usAcoDemFreqNo() OMG_NOEXCEPT {
        return m_usAcoDemFreqNo_;
    }

    const ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& usAcoDemFreqNo() const OMG_NOEXCEPT {
        return m_usAcoDemFreqNo_;
    }

    void usAcoDemFreqNo(const ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>& value) {
        m_usAcoDemFreqNo_ = value;
    }

    void usAcoDemFreqNo(::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L>&& value) {
        m_usAcoDemFreqNo_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& aAcoDemFreqInfo() OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& aAcoDemFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    void aAcoDemFreqInfo(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>& value) {
        m_aAcoDemFreqInfo_ = value;
    }

    void aAcoDemFreqInfo(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L>&& value) {
        m_aAcoDemFreqInfo_ = std::move(value);
    }

    bool operator == (const TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& other_) const;
    bool operator != (const TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& other_) const;

    void swap(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L> m_aAcoLofFreqNo_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L> m_aAcoLofFreqInfo_;
    ::dds::core::array< ::dds::core::array< uint16_t, 25L>, 2L> m_usAcoDemFreqNo_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 50L>, 25L>, 2L> m_aAcoDemFreqInfo_;

};

inline void swap(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& a, TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& sample);

class NDDSUSERDllExport ST_MAS_TARGET_LOCAL {
  public:
    ST_MAS_TARGET_LOCAL();

    ST_MAS_TARGET_LOCAL(uint16_t usTargetNo,const ST_DATE_TIME& stInitTime,uint32_t ulTrackMainCnt,uint8_t oTrackStatus,uint8_t oTrackInitType,float fTrackReliability,uint8_t oTrackStrength,uint16_t usMASDetectionType,uint16_t usFusionStatus,uint16_t usAllFusedSectorNo,uint16_t usMagSectorNo,uint16_t usAcoSectorNo,uint16_t usBbdSectorNo,uint16_t usNbdSectorNo,uint16_t usMagSensorNo,uint16_t usAcoSensorNo,uint16_t usInOut,uint8_t oTgtAssoFlag,uint16_t usAssoTgtNo,uint16_t usAcoLofFreqNo,const ::dds::core::array< float, 24L>& aAcoLofFreqInfo,uint16_t usAcoDemFreqNo,const ::dds::core::array< float, 8L>& aAcoDemFreqInfo,float fLineMagSyntheSig,uint8_t oUserConcFlag,const ::dds::core::array< uint16_t, 4L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MAS_TARGET_LOCAL (ST_MAS_TARGET_LOCAL&&) = default;
    ST_MAS_TARGET_LOCAL& operator=(ST_MAS_TARGET_LOCAL&&) = default;
    ST_MAS_TARGET_LOCAL& operator=(const ST_MAS_TARGET_LOCAL&) = default;
    ST_MAS_TARGET_LOCAL(const ST_MAS_TARGET_LOCAL&) = default;
    #else
    ST_MAS_TARGET_LOCAL(ST_MAS_TARGET_LOCAL&& other_) OMG_NOEXCEPT;  
    ST_MAS_TARGET_LOCAL& operator=(ST_MAS_TARGET_LOCAL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    ST_DATE_TIME& stInitTime() OMG_NOEXCEPT {
        return m_stInitTime_;
    }

    const ST_DATE_TIME& stInitTime() const OMG_NOEXCEPT {
        return m_stInitTime_;
    }

    void stInitTime(const ST_DATE_TIME& value) {
        m_stInitTime_ = value;
    }

    void stInitTime(ST_DATE_TIME&& value) {
        m_stInitTime_ = std::move(value);
    }
    uint32_t& ulTrackMainCnt() OMG_NOEXCEPT {
        return m_ulTrackMainCnt_;
    }

    const uint32_t& ulTrackMainCnt() const OMG_NOEXCEPT {
        return m_ulTrackMainCnt_;
    }

    void ulTrackMainCnt(uint32_t value) {
        m_ulTrackMainCnt_ = value;
    }

    uint8_t& oTrackStatus() OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    const uint8_t& oTrackStatus() const OMG_NOEXCEPT {
        return m_oTrackStatus_;
    }

    void oTrackStatus(uint8_t value) {
        m_oTrackStatus_ = value;
    }

    uint8_t& oTrackInitType() OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    const uint8_t& oTrackInitType() const OMG_NOEXCEPT {
        return m_oTrackInitType_;
    }

    void oTrackInitType(uint8_t value) {
        m_oTrackInitType_ = value;
    }

    float& fTrackReliability() OMG_NOEXCEPT {
        return m_fTrackReliability_;
    }

    const float& fTrackReliability() const OMG_NOEXCEPT {
        return m_fTrackReliability_;
    }

    void fTrackReliability(float value) {
        m_fTrackReliability_ = value;
    }

    uint8_t& oTrackStrength() OMG_NOEXCEPT {
        return m_oTrackStrength_;
    }

    const uint8_t& oTrackStrength() const OMG_NOEXCEPT {
        return m_oTrackStrength_;
    }

    void oTrackStrength(uint8_t value) {
        m_oTrackStrength_ = value;
    }

    uint16_t& usMASDetectionType() OMG_NOEXCEPT {
        return m_usMASDetectionType_;
    }

    const uint16_t& usMASDetectionType() const OMG_NOEXCEPT {
        return m_usMASDetectionType_;
    }

    void usMASDetectionType(uint16_t value) {
        m_usMASDetectionType_ = value;
    }

    uint16_t& usFusionStatus() OMG_NOEXCEPT {
        return m_usFusionStatus_;
    }

    const uint16_t& usFusionStatus() const OMG_NOEXCEPT {
        return m_usFusionStatus_;
    }

    void usFusionStatus(uint16_t value) {
        m_usFusionStatus_ = value;
    }

    uint16_t& usAllFusedSectorNo() OMG_NOEXCEPT {
        return m_usAllFusedSectorNo_;
    }

    const uint16_t& usAllFusedSectorNo() const OMG_NOEXCEPT {
        return m_usAllFusedSectorNo_;
    }

    void usAllFusedSectorNo(uint16_t value) {
        m_usAllFusedSectorNo_ = value;
    }

    uint16_t& usMagSectorNo() OMG_NOEXCEPT {
        return m_usMagSectorNo_;
    }

    const uint16_t& usMagSectorNo() const OMG_NOEXCEPT {
        return m_usMagSectorNo_;
    }

    void usMagSectorNo(uint16_t value) {
        m_usMagSectorNo_ = value;
    }

    uint16_t& usAcoSectorNo() OMG_NOEXCEPT {
        return m_usAcoSectorNo_;
    }

    const uint16_t& usAcoSectorNo() const OMG_NOEXCEPT {
        return m_usAcoSectorNo_;
    }

    void usAcoSectorNo(uint16_t value) {
        m_usAcoSectorNo_ = value;
    }

    uint16_t& usBbdSectorNo() OMG_NOEXCEPT {
        return m_usBbdSectorNo_;
    }

    const uint16_t& usBbdSectorNo() const OMG_NOEXCEPT {
        return m_usBbdSectorNo_;
    }

    void usBbdSectorNo(uint16_t value) {
        m_usBbdSectorNo_ = value;
    }

    uint16_t& usNbdSectorNo() OMG_NOEXCEPT {
        return m_usNbdSectorNo_;
    }

    const uint16_t& usNbdSectorNo() const OMG_NOEXCEPT {
        return m_usNbdSectorNo_;
    }

    void usNbdSectorNo(uint16_t value) {
        m_usNbdSectorNo_ = value;
    }

    uint16_t& usMagSensorNo() OMG_NOEXCEPT {
        return m_usMagSensorNo_;
    }

    const uint16_t& usMagSensorNo() const OMG_NOEXCEPT {
        return m_usMagSensorNo_;
    }

    void usMagSensorNo(uint16_t value) {
        m_usMagSensorNo_ = value;
    }

    uint16_t& usAcoSensorNo() OMG_NOEXCEPT {
        return m_usAcoSensorNo_;
    }

    const uint16_t& usAcoSensorNo() const OMG_NOEXCEPT {
        return m_usAcoSensorNo_;
    }

    void usAcoSensorNo(uint16_t value) {
        m_usAcoSensorNo_ = value;
    }

    uint16_t& usInOut() OMG_NOEXCEPT {
        return m_usInOut_;
    }

    const uint16_t& usInOut() const OMG_NOEXCEPT {
        return m_usInOut_;
    }

    void usInOut(uint16_t value) {
        m_usInOut_ = value;
    }

    uint8_t& oTgtAssoFlag() OMG_NOEXCEPT {
        return m_oTgtAssoFlag_;
    }

    const uint8_t& oTgtAssoFlag() const OMG_NOEXCEPT {
        return m_oTgtAssoFlag_;
    }

    void oTgtAssoFlag(uint8_t value) {
        m_oTgtAssoFlag_ = value;
    }

    uint16_t& usAssoTgtNo() OMG_NOEXCEPT {
        return m_usAssoTgtNo_;
    }

    const uint16_t& usAssoTgtNo() const OMG_NOEXCEPT {
        return m_usAssoTgtNo_;
    }

    void usAssoTgtNo(uint16_t value) {
        m_usAssoTgtNo_ = value;
    }

    uint16_t& usAcoLofFreqNo() OMG_NOEXCEPT {
        return m_usAcoLofFreqNo_;
    }

    const uint16_t& usAcoLofFreqNo() const OMG_NOEXCEPT {
        return m_usAcoLofFreqNo_;
    }

    void usAcoLofFreqNo(uint16_t value) {
        m_usAcoLofFreqNo_ = value;
    }

    ::dds::core::array< float, 24L>& aAcoLofFreqInfo() OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    const ::dds::core::array< float, 24L>& aAcoLofFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoLofFreqInfo_;
    }

    void aAcoLofFreqInfo(const ::dds::core::array< float, 24L>& value) {
        m_aAcoLofFreqInfo_ = value;
    }

    void aAcoLofFreqInfo(::dds::core::array< float, 24L>&& value) {
        m_aAcoLofFreqInfo_ = std::move(value);
    }
    uint16_t& usAcoDemFreqNo() OMG_NOEXCEPT {
        return m_usAcoDemFreqNo_;
    }

    const uint16_t& usAcoDemFreqNo() const OMG_NOEXCEPT {
        return m_usAcoDemFreqNo_;
    }

    void usAcoDemFreqNo(uint16_t value) {
        m_usAcoDemFreqNo_ = value;
    }

    ::dds::core::array< float, 8L>& aAcoDemFreqInfo() OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    const ::dds::core::array< float, 8L>& aAcoDemFreqInfo() const OMG_NOEXCEPT {
        return m_aAcoDemFreqInfo_;
    }

    void aAcoDemFreqInfo(const ::dds::core::array< float, 8L>& value) {
        m_aAcoDemFreqInfo_ = value;
    }

    void aAcoDemFreqInfo(::dds::core::array< float, 8L>&& value) {
        m_aAcoDemFreqInfo_ = std::move(value);
    }
    float& fLineMagSyntheSig() OMG_NOEXCEPT {
        return m_fLineMagSyntheSig_;
    }

    const float& fLineMagSyntheSig() const OMG_NOEXCEPT {
        return m_fLineMagSyntheSig_;
    }

    void fLineMagSyntheSig(float value) {
        m_fLineMagSyntheSig_ = value;
    }

    uint8_t& oUserConcFlag() OMG_NOEXCEPT {
        return m_oUserConcFlag_;
    }

    const uint8_t& oUserConcFlag() const OMG_NOEXCEPT {
        return m_oUserConcFlag_;
    }

    void oUserConcFlag(uint8_t value) {
        m_oUserConcFlag_ = value;
    }

    ::dds::core::array< uint16_t, 4L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 4L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 4L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 4L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_MAS_TARGET_LOCAL& other_) const;
    bool operator != (const ST_MAS_TARGET_LOCAL& other_) const;

    void swap(ST_MAS_TARGET_LOCAL& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usTargetNo_;
    ST_DATE_TIME m_stInitTime_;
    uint32_t m_ulTrackMainCnt_;
    uint8_t m_oTrackStatus_;
    uint8_t m_oTrackInitType_;
    float m_fTrackReliability_;
    uint8_t m_oTrackStrength_;
    uint16_t m_usMASDetectionType_;
    uint16_t m_usFusionStatus_;
    uint16_t m_usAllFusedSectorNo_;
    uint16_t m_usMagSectorNo_;
    uint16_t m_usAcoSectorNo_;
    uint16_t m_usBbdSectorNo_;
    uint16_t m_usNbdSectorNo_;
    uint16_t m_usMagSensorNo_;
    uint16_t m_usAcoSensorNo_;
    uint16_t m_usInOut_;
    uint8_t m_oTgtAssoFlag_;
    uint16_t m_usAssoTgtNo_;
    uint16_t m_usAcoLofFreqNo_;
    ::dds::core::array< float, 24L> m_aAcoLofFreqInfo_;
    uint16_t m_usAcoDemFreqNo_;
    ::dds::core::array< float, 8L> m_aAcoDemFreqInfo_;
    float m_fLineMagSyntheSig_;
    uint8_t m_oUserConcFlag_;
    ::dds::core::array< uint16_t, 4L> m_aReserved_;

};

inline void swap(ST_MAS_TARGET_LOCAL& a, ST_MAS_TARGET_LOCAL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MAS_TARGET_LOCAL& sample);

class NDDSUSERDllExport TGTTRK_MASTRK_TARGET_TRACKING_INFO {
  public:
    TGTTRK_MASTRK_TARGET_TRACKING_INFO();

    TGTTRK_MASTRK_TARGET_TRACKING_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint16_t, 2L>& usNoOfTgts,const ST_DATE_TIME& stUpdateTime,const ::dds::core::array< ::dds::core::array< ST_MAS_TARGET_LOCAL, 50L>, 2L>& stMasTargetLocal);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_MASTRK_TARGET_TRACKING_INFO (TGTTRK_MASTRK_TARGET_TRACKING_INFO&&) = default;
    TGTTRK_MASTRK_TARGET_TRACKING_INFO& operator=(TGTTRK_MASTRK_TARGET_TRACKING_INFO&&) = default;
    TGTTRK_MASTRK_TARGET_TRACKING_INFO& operator=(const TGTTRK_MASTRK_TARGET_TRACKING_INFO&) = default;
    TGTTRK_MASTRK_TARGET_TRACKING_INFO(const TGTTRK_MASTRK_TARGET_TRACKING_INFO&) = default;
    #else
    TGTTRK_MASTRK_TARGET_TRACKING_INFO(TGTTRK_MASTRK_TARGET_TRACKING_INFO&& other_) OMG_NOEXCEPT;  
    TGTTRK_MASTRK_TARGET_TRACKING_INFO& operator=(TGTTRK_MASTRK_TARGET_TRACKING_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& usNoOfTgts() OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    const ::dds::core::array< uint16_t, 2L>& usNoOfTgts() const OMG_NOEXCEPT {
        return m_usNoOfTgts_;
    }

    void usNoOfTgts(const ::dds::core::array< uint16_t, 2L>& value) {
        m_usNoOfTgts_ = value;
    }

    void usNoOfTgts(::dds::core::array< uint16_t, 2L>&& value) {
        m_usNoOfTgts_ = std::move(value);
    }
    ST_DATE_TIME& stUpdateTime() OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    const ST_DATE_TIME& stUpdateTime() const OMG_NOEXCEPT {
        return m_stUpdateTime_;
    }

    void stUpdateTime(const ST_DATE_TIME& value) {
        m_stUpdateTime_ = value;
    }

    void stUpdateTime(ST_DATE_TIME&& value) {
        m_stUpdateTime_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< ST_MAS_TARGET_LOCAL, 50L>, 2L>& stMasTargetLocal() OMG_NOEXCEPT {
        return m_stMasTargetLocal_;
    }

    const ::dds::core::array< ::dds::core::array< ST_MAS_TARGET_LOCAL, 50L>, 2L>& stMasTargetLocal() const OMG_NOEXCEPT {
        return m_stMasTargetLocal_;
    }

    void stMasTargetLocal(const ::dds::core::array< ::dds::core::array< ST_MAS_TARGET_LOCAL, 50L>, 2L>& value) {
        m_stMasTargetLocal_ = value;
    }

    void stMasTargetLocal(::dds::core::array< ::dds::core::array< ST_MAS_TARGET_LOCAL, 50L>, 2L>&& value) {
        m_stMasTargetLocal_ = std::move(value);
    }

    bool operator == (const TGTTRK_MASTRK_TARGET_TRACKING_INFO& other_) const;
    bool operator != (const TGTTRK_MASTRK_TARGET_TRACKING_INFO& other_) const;

    void swap(TGTTRK_MASTRK_TARGET_TRACKING_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint16_t, 2L> m_usNoOfTgts_;
    ST_DATE_TIME m_stUpdateTime_;
    ::dds::core::array< ::dds::core::array< ST_MAS_TARGET_LOCAL, 50L>, 2L> m_stMasTargetLocal_;

};

inline void swap(TGTTRK_MASTRK_TARGET_TRACKING_INFO& a, TGTTRK_MASTRK_TARGET_TRACKING_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_MASTRK_TARGET_TRACKING_INFO& sample);

class NDDSUSERDllExport TGTTRK_MASTRK_THRESHOLD_INFO_ACK {
  public:
    TGTTRK_MASTRK_THRESHOLD_INFO_ACK();

    TGTTRK_MASTRK_THRESHOLD_INFO_ACK(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsMasCitThrshAuto,const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasCitThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_MASTRK_THRESHOLD_INFO_ACK (TGTTRK_MASTRK_THRESHOLD_INFO_ACK&&) = default;
    TGTTRK_MASTRK_THRESHOLD_INFO_ACK& operator=(TGTTRK_MASTRK_THRESHOLD_INFO_ACK&&) = default;
    TGTTRK_MASTRK_THRESHOLD_INFO_ACK& operator=(const TGTTRK_MASTRK_THRESHOLD_INFO_ACK&) = default;
    TGTTRK_MASTRK_THRESHOLD_INFO_ACK(const TGTTRK_MASTRK_THRESHOLD_INFO_ACK&) = default;
    #else
    TGTTRK_MASTRK_THRESHOLD_INFO_ACK(TGTTRK_MASTRK_THRESHOLD_INFO_ACK&& other_) OMG_NOEXCEPT;  
    TGTTRK_MASTRK_THRESHOLD_INFO_ACK& operator=(TGTTRK_MASTRK_THRESHOLD_INFO_ACK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsMasCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsMasCitThrshAuto_;
    }

    const uint8_t& oIsMasCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsMasCitThrshAuto_;
    }

    void oIsMasCitThrshAuto(uint8_t value) {
        m_oIsMasCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasCitThresh() OMG_NOEXCEPT {
        return m_stMasCitThresh_;
    }

    const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasCitThresh() const OMG_NOEXCEPT {
        return m_stMasCitThresh_;
    }

    void stMasCitThresh(const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& value) {
        m_stMasCitThresh_ = value;
    }

    void stMasCitThresh(::dds::core::array< ST_MAS_THRESH_INFO, 2L>&& value) {
        m_stMasCitThresh_ = std::move(value);
    }

    bool operator == (const TGTTRK_MASTRK_THRESHOLD_INFO_ACK& other_) const;
    bool operator != (const TGTTRK_MASTRK_THRESHOLD_INFO_ACK& other_) const;

    void swap(TGTTRK_MASTRK_THRESHOLD_INFO_ACK& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsMasCitThrshAuto_;
    ::dds::core::array< ST_MAS_THRESH_INFO, 2L> m_stMasCitThresh_;

};

inline void swap(TGTTRK_MASTRK_THRESHOLD_INFO_ACK& a, TGTTRK_MASTRK_THRESHOLD_INFO_ACK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_MASTRK_THRESHOLD_INFO_ACK& sample);

class NDDSUSERDllExport TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST {
  public:
    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST();

    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oParGroupID,uint8_t oParValSort);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST (TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST&&) = default;
    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& operator=(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST&&) = default;
    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& operator=(const TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST&) = default;
    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST(const TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST&) = default;
    #else
    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST&& other_) OMG_NOEXCEPT;  
    TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& operator=(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oParGroupID() OMG_NOEXCEPT {
        return m_oParGroupID_;
    }

    const uint8_t& oParGroupID() const OMG_NOEXCEPT {
        return m_oParGroupID_;
    }

    void oParGroupID(uint8_t value) {
        m_oParGroupID_ = value;
    }

    uint8_t& oParValSort() OMG_NOEXCEPT {
        return m_oParValSort_;
    }

    const uint8_t& oParValSort() const OMG_NOEXCEPT {
        return m_oParValSort_;
    }

    void oParValSort(uint8_t value) {
        m_oParValSort_ = value;
    }

    bool operator == (const TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& other_) const;
    bool operator != (const TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& other_) const;

    void swap(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oParGroupID_;
    uint8_t m_oParValSort_;

};

inline void swap(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& a, TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& sample);

class NDDSUSERDllExport TGTTRK_PARAM_INFO_REQ {
  public:
    TGTTRK_PARAM_INFO_REQ();

    TGTTRK_PARAM_INFO_REQ(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsReq);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    TGTTRK_PARAM_INFO_REQ (TGTTRK_PARAM_INFO_REQ&&) = default;
    TGTTRK_PARAM_INFO_REQ& operator=(TGTTRK_PARAM_INFO_REQ&&) = default;
    TGTTRK_PARAM_INFO_REQ& operator=(const TGTTRK_PARAM_INFO_REQ&) = default;
    TGTTRK_PARAM_INFO_REQ(const TGTTRK_PARAM_INFO_REQ&) = default;
    #else
    TGTTRK_PARAM_INFO_REQ(TGTTRK_PARAM_INFO_REQ&& other_) OMG_NOEXCEPT;  
    TGTTRK_PARAM_INFO_REQ& operator=(TGTTRK_PARAM_INFO_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsReq() OMG_NOEXCEPT {
        return m_oIsReq_;
    }

    const uint8_t& oIsReq() const OMG_NOEXCEPT {
        return m_oIsReq_;
    }

    void oIsReq(uint8_t value) {
        m_oIsReq_ = value;
    }

    bool operator == (const TGTTRK_PARAM_INFO_REQ& other_) const;
    bool operator != (const TGTTRK_PARAM_INFO_REQ& other_) const;

    void swap(TGTTRK_PARAM_INFO_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsReq_;

};

inline void swap(TGTTRK_PARAM_INFO_REQ& a, TGTTRK_PARAM_INFO_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const TGTTRK_PARAM_INFO_REQ& sample);

class NDDSUSERDllExport ST_PERIOD_PROC_PARAM_INFO {
  public:
    ST_PERIOD_PROC_PARAM_INFO();

    ST_PERIOD_PROC_PARAM_INFO(uint16_t usMonth,uint16_t usDay,const ::dds::core::array< float, 15L>& fNBTargetSourceLevel,const ::dds::core::array< float, 4L>& fBBTargetSourceLevel,float fASTargetSpeed,const ST_AS_TS_INFO& stASTSInfo,bool bASAutoNoiseFlag,const ::dds::core::array< float, 3L>& fASAmbientNoise,uint8_t oASSeaState,float fBISTargetSpeed,const ST_BI_TS_INFO& stBITSInfo,float fBISTransmitterDepth,const ST_SOUND_INFO& stBISSoundInfo,double dBISSrcPosLat,double dBISSrcPosLon);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_PERIOD_PROC_PARAM_INFO (ST_PERIOD_PROC_PARAM_INFO&&) = default;
    ST_PERIOD_PROC_PARAM_INFO& operator=(ST_PERIOD_PROC_PARAM_INFO&&) = default;
    ST_PERIOD_PROC_PARAM_INFO& operator=(const ST_PERIOD_PROC_PARAM_INFO&) = default;
    ST_PERIOD_PROC_PARAM_INFO(const ST_PERIOD_PROC_PARAM_INFO&) = default;
    #else
    ST_PERIOD_PROC_PARAM_INFO(ST_PERIOD_PROC_PARAM_INFO&& other_) OMG_NOEXCEPT;  
    ST_PERIOD_PROC_PARAM_INFO& operator=(ST_PERIOD_PROC_PARAM_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    ::dds::core::array< float, 15L>& fNBTargetSourceLevel() OMG_NOEXCEPT {
        return m_fNBTargetSourceLevel_;
    }

    const ::dds::core::array< float, 15L>& fNBTargetSourceLevel() const OMG_NOEXCEPT {
        return m_fNBTargetSourceLevel_;
    }

    void fNBTargetSourceLevel(const ::dds::core::array< float, 15L>& value) {
        m_fNBTargetSourceLevel_ = value;
    }

    void fNBTargetSourceLevel(::dds::core::array< float, 15L>&& value) {
        m_fNBTargetSourceLevel_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fBBTargetSourceLevel() OMG_NOEXCEPT {
        return m_fBBTargetSourceLevel_;
    }

    const ::dds::core::array< float, 4L>& fBBTargetSourceLevel() const OMG_NOEXCEPT {
        return m_fBBTargetSourceLevel_;
    }

    void fBBTargetSourceLevel(const ::dds::core::array< float, 4L>& value) {
        m_fBBTargetSourceLevel_ = value;
    }

    void fBBTargetSourceLevel(::dds::core::array< float, 4L>&& value) {
        m_fBBTargetSourceLevel_ = std::move(value);
    }
    float& fASTargetSpeed() OMG_NOEXCEPT {
        return m_fASTargetSpeed_;
    }

    const float& fASTargetSpeed() const OMG_NOEXCEPT {
        return m_fASTargetSpeed_;
    }

    void fASTargetSpeed(float value) {
        m_fASTargetSpeed_ = value;
    }

    ST_AS_TS_INFO& stASTSInfo() OMG_NOEXCEPT {
        return m_stASTSInfo_;
    }

    const ST_AS_TS_INFO& stASTSInfo() const OMG_NOEXCEPT {
        return m_stASTSInfo_;
    }

    void stASTSInfo(const ST_AS_TS_INFO& value) {
        m_stASTSInfo_ = value;
    }

    void stASTSInfo(ST_AS_TS_INFO&& value) {
        m_stASTSInfo_ = std::move(value);
    }
    bool& bASAutoNoiseFlag() OMG_NOEXCEPT {
        return m_bASAutoNoiseFlag_;
    }

    const bool& bASAutoNoiseFlag() const OMG_NOEXCEPT {
        return m_bASAutoNoiseFlag_;
    }

    void bASAutoNoiseFlag(bool value) {
        m_bASAutoNoiseFlag_ = value;
    }

    ::dds::core::array< float, 3L>& fASAmbientNoise() OMG_NOEXCEPT {
        return m_fASAmbientNoise_;
    }

    const ::dds::core::array< float, 3L>& fASAmbientNoise() const OMG_NOEXCEPT {
        return m_fASAmbientNoise_;
    }

    void fASAmbientNoise(const ::dds::core::array< float, 3L>& value) {
        m_fASAmbientNoise_ = value;
    }

    void fASAmbientNoise(::dds::core::array< float, 3L>&& value) {
        m_fASAmbientNoise_ = std::move(value);
    }
    uint8_t& oASSeaState() OMG_NOEXCEPT {
        return m_oASSeaState_;
    }

    const uint8_t& oASSeaState() const OMG_NOEXCEPT {
        return m_oASSeaState_;
    }

    void oASSeaState(uint8_t value) {
        m_oASSeaState_ = value;
    }

    float& fBISTargetSpeed() OMG_NOEXCEPT {
        return m_fBISTargetSpeed_;
    }

    const float& fBISTargetSpeed() const OMG_NOEXCEPT {
        return m_fBISTargetSpeed_;
    }

    void fBISTargetSpeed(float value) {
        m_fBISTargetSpeed_ = value;
    }

    ST_BI_TS_INFO& stBITSInfo() OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    const ST_BI_TS_INFO& stBITSInfo() const OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    void stBITSInfo(const ST_BI_TS_INFO& value) {
        m_stBITSInfo_ = value;
    }

    void stBITSInfo(ST_BI_TS_INFO&& value) {
        m_stBITSInfo_ = std::move(value);
    }
    float& fBISTransmitterDepth() OMG_NOEXCEPT {
        return m_fBISTransmitterDepth_;
    }

    const float& fBISTransmitterDepth() const OMG_NOEXCEPT {
        return m_fBISTransmitterDepth_;
    }

    void fBISTransmitterDepth(float value) {
        m_fBISTransmitterDepth_ = value;
    }

    ST_SOUND_INFO& stBISSoundInfo() OMG_NOEXCEPT {
        return m_stBISSoundInfo_;
    }

    const ST_SOUND_INFO& stBISSoundInfo() const OMG_NOEXCEPT {
        return m_stBISSoundInfo_;
    }

    void stBISSoundInfo(const ST_SOUND_INFO& value) {
        m_stBISSoundInfo_ = value;
    }

    void stBISSoundInfo(ST_SOUND_INFO&& value) {
        m_stBISSoundInfo_ = std::move(value);
    }
    double& dBISSrcPosLat() OMG_NOEXCEPT {
        return m_dBISSrcPosLat_;
    }

    const double& dBISSrcPosLat() const OMG_NOEXCEPT {
        return m_dBISSrcPosLat_;
    }

    void dBISSrcPosLat(double value) {
        m_dBISSrcPosLat_ = value;
    }

    double& dBISSrcPosLon() OMG_NOEXCEPT {
        return m_dBISSrcPosLon_;
    }

    const double& dBISSrcPosLon() const OMG_NOEXCEPT {
        return m_dBISSrcPosLon_;
    }

    void dBISSrcPosLon(double value) {
        m_dBISSrcPosLon_ = value;
    }

    bool operator == (const ST_PERIOD_PROC_PARAM_INFO& other_) const;
    bool operator != (const ST_PERIOD_PROC_PARAM_INFO& other_) const;

    void swap(ST_PERIOD_PROC_PARAM_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usMonth_;
    uint16_t m_usDay_;
    ::dds::core::array< float, 15L> m_fNBTargetSourceLevel_;
    ::dds::core::array< float, 4L> m_fBBTargetSourceLevel_;
    float m_fASTargetSpeed_;
    ST_AS_TS_INFO m_stASTSInfo_;
    bool m_bASAutoNoiseFlag_;
    ::dds::core::array< float, 3L> m_fASAmbientNoise_;
    uint8_t m_oASSeaState_;
    float m_fBISTargetSpeed_;
    ST_BI_TS_INFO m_stBITSInfo_;
    float m_fBISTransmitterDepth_;
    ST_SOUND_INFO m_stBISSoundInfo_;
    double m_dBISSrcPosLat_;
    double m_dBISSrcPosLon_;

};

inline void swap(ST_PERIOD_PROC_PARAM_INFO& a, ST_PERIOD_PROC_PARAM_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_PERIOD_PROC_PARAM_INFO& sample);

class NDDSUSERDllExport USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO {
  public:
    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO();

    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_PERIOD_PROC_PARAM_INFO& stPeriodParamInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO (USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO&&) = default;
    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& operator=(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO&&) = default;
    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& operator=(const USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO&) = default;
    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO(const USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO&) = default;
    #else
    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& operator=(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_PERIOD_PROC_PARAM_INFO& stPeriodParamInfo() OMG_NOEXCEPT {
        return m_stPeriodParamInfo_;
    }

    const ST_PERIOD_PROC_PARAM_INFO& stPeriodParamInfo() const OMG_NOEXCEPT {
        return m_stPeriodParamInfo_;
    }

    void stPeriodParamInfo(const ST_PERIOD_PROC_PARAM_INFO& value) {
        m_stPeriodParamInfo_ = value;
    }

    void stPeriodParamInfo(ST_PERIOD_PROC_PARAM_INFO&& value) {
        m_stPeriodParamInfo_ = std::move(value);
    }

    bool operator == (const USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& other_) const;
    bool operator != (const USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& other_) const;

    void swap(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_PERIOD_PROC_PARAM_INFO m_stPeriodParamInfo_;

};

inline void swap(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& a, USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& sample);

class NDDSUSERDllExport USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST {
  public:
    USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST();

    explicit USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST(const ST_MSG_HEADER& stMsgHeader);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST (USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST&&) = default;
    USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& operator=(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST&&) = default;
    USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& operator=(const USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST&) = default;
    USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST(const USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST&) = default;
    #else
    USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& operator=(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }

    bool operator == (const USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& other_) const;
    bool operator != (const USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& other_) const;

    void swap(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;

};

inline void swap(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& a, USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& sample);

class NDDSUSERDllExport USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST {
  public:
    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST();

    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usAnalType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST (USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&&) = default;
    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& operator=(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&&) = default;
    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& operator=(const USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&) = default;
    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST(const USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&) = default;
    #else
    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& operator=(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usAnalType() OMG_NOEXCEPT {
        return m_usAnalType_;
    }

    const uint16_t& usAnalType() const OMG_NOEXCEPT {
        return m_usAnalType_;
    }

    void usAnalType(uint16_t value) {
        m_usAnalType_ = value;
    }

    bool operator == (const USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& other_) const;
    bool operator != (const USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& other_) const;

    void swap(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usAnalType_;

};

inline void swap(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& a, USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample);

class NDDSUSERDllExport USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST {
  public:
    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST();

    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usDataNum,uint8_t oRequestCommand,const ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& stPeriodParamInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST (USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST&&) = default;
    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& operator=(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST&&) = default;
    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& operator=(const USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST&) = default;
    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST(const USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST&) = default;
    #else
    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& operator=(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& stPeriodParamInfo() OMG_NOEXCEPT {
        return m_stPeriodParamInfo_;
    }

    const ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& stPeriodParamInfo() const OMG_NOEXCEPT {
        return m_stPeriodParamInfo_;
    }

    void stPeriodParamInfo(const ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>& value) {
        m_stPeriodParamInfo_ = value;
    }

    void stPeriodParamInfo(::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L>&& value) {
        m_stPeriodParamInfo_ = std::move(value);
    }

    bool operator == (const USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& other_) const;

    void swap(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usDataNum_;
    uint8_t m_oRequestCommand_;
    ::dds::core::array< ST_PERIOD_PARAM_MNG_INFO, 100L> m_stPeriodParamInfo_;

};

inline void swap(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& a, USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_DETECT_TH_REQUEST {
  public:
    USERIF_ASE_DETECT_TH_REQUEST();

    USERIF_ASE_DETECT_TH_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ST_TH_INFO& stTThInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_DETECT_TH_REQUEST (USERIF_ASE_DETECT_TH_REQUEST&&) = default;
    USERIF_ASE_DETECT_TH_REQUEST& operator=(USERIF_ASE_DETECT_TH_REQUEST&&) = default;
    USERIF_ASE_DETECT_TH_REQUEST& operator=(const USERIF_ASE_DETECT_TH_REQUEST&) = default;
    USERIF_ASE_DETECT_TH_REQUEST(const USERIF_ASE_DETECT_TH_REQUEST&) = default;
    #else
    USERIF_ASE_DETECT_TH_REQUEST(USERIF_ASE_DETECT_TH_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_DETECT_TH_REQUEST& operator=(USERIF_ASE_DETECT_TH_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ST_TH_INFO& stTThInfo() OMG_NOEXCEPT {
        return m_stTThInfo_;
    }

    const ST_TH_INFO& stTThInfo() const OMG_NOEXCEPT {
        return m_stTThInfo_;
    }

    void stTThInfo(const ST_TH_INFO& value) {
        m_stTThInfo_ = value;
    }

    void stTThInfo(ST_TH_INFO&& value) {
        m_stTThInfo_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_DETECT_TH_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_DETECT_TH_REQUEST& other_) const;

    void swap(USERIF_ASE_DETECT_TH_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ST_TH_INFO m_stTThInfo_;

};

inline void swap(USERIF_ASE_DETECT_TH_REQUEST& a, USERIF_ASE_DETECT_TH_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_DETECT_TH_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_FISH_SUP_REQUEST {
  public:
    USERIF_ASE_FISH_SUP_REQUEST();

    USERIF_ASE_FISH_SUP_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oFishSup,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_FISH_SUP_REQUEST (USERIF_ASE_FISH_SUP_REQUEST&&) = default;
    USERIF_ASE_FISH_SUP_REQUEST& operator=(USERIF_ASE_FISH_SUP_REQUEST&&) = default;
    USERIF_ASE_FISH_SUP_REQUEST& operator=(const USERIF_ASE_FISH_SUP_REQUEST&) = default;
    USERIF_ASE_FISH_SUP_REQUEST(const USERIF_ASE_FISH_SUP_REQUEST&) = default;
    #else
    USERIF_ASE_FISH_SUP_REQUEST(USERIF_ASE_FISH_SUP_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_FISH_SUP_REQUEST& operator=(USERIF_ASE_FISH_SUP_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oFishSup() OMG_NOEXCEPT {
        return m_oFishSup_;
    }

    const uint8_t& oFishSup() const OMG_NOEXCEPT {
        return m_oFishSup_;
    }

    void oFishSup(uint8_t value) {
        m_oFishSup_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_FISH_SUP_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_FISH_SUP_REQUEST& other_) const;

    void swap(USERIF_ASE_FISH_SUP_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oFishSup_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_FISH_SUP_REQUEST& a, USERIF_ASE_FISH_SUP_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_FISH_SUP_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_FLOW_SUP_REQUEST {
  public:
    USERIF_ASE_FLOW_SUP_REQUEST();

    USERIF_ASE_FLOW_SUP_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oFlowSup,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_FLOW_SUP_REQUEST (USERIF_ASE_FLOW_SUP_REQUEST&&) = default;
    USERIF_ASE_FLOW_SUP_REQUEST& operator=(USERIF_ASE_FLOW_SUP_REQUEST&&) = default;
    USERIF_ASE_FLOW_SUP_REQUEST& operator=(const USERIF_ASE_FLOW_SUP_REQUEST&) = default;
    USERIF_ASE_FLOW_SUP_REQUEST(const USERIF_ASE_FLOW_SUP_REQUEST&) = default;
    #else
    USERIF_ASE_FLOW_SUP_REQUEST(USERIF_ASE_FLOW_SUP_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_FLOW_SUP_REQUEST& operator=(USERIF_ASE_FLOW_SUP_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oFlowSup() OMG_NOEXCEPT {
        return m_oFlowSup_;
    }

    const uint8_t& oFlowSup() const OMG_NOEXCEPT {
        return m_oFlowSup_;
    }

    void oFlowSup(uint8_t value) {
        m_oFlowSup_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_FLOW_SUP_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_FLOW_SUP_REQUEST& other_) const;

    void swap(USERIF_ASE_FLOW_SUP_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oFlowSup_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_FLOW_SUP_REQUEST& a, USERIF_ASE_FLOW_SUP_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_FLOW_SUP_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_MANUAL_AGC_REQUEST {
  public:
    USERIF_ASE_MANUAL_AGC_REQUEST();

    USERIF_ASE_MANUAL_AGC_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,uint8_t oAGC,uint8_t oTable,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_MANUAL_AGC_REQUEST (USERIF_ASE_MANUAL_AGC_REQUEST&&) = default;
    USERIF_ASE_MANUAL_AGC_REQUEST& operator=(USERIF_ASE_MANUAL_AGC_REQUEST&&) = default;
    USERIF_ASE_MANUAL_AGC_REQUEST& operator=(const USERIF_ASE_MANUAL_AGC_REQUEST&) = default;
    USERIF_ASE_MANUAL_AGC_REQUEST(const USERIF_ASE_MANUAL_AGC_REQUEST&) = default;
    #else
    USERIF_ASE_MANUAL_AGC_REQUEST(USERIF_ASE_MANUAL_AGC_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_MANUAL_AGC_REQUEST& operator=(USERIF_ASE_MANUAL_AGC_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    uint8_t& oAGC() OMG_NOEXCEPT {
        return m_oAGC_;
    }

    const uint8_t& oAGC() const OMG_NOEXCEPT {
        return m_oAGC_;
    }

    void oAGC(uint8_t value) {
        m_oAGC_ = value;
    }

    uint8_t& oTable() OMG_NOEXCEPT {
        return m_oTable_;
    }

    const uint8_t& oTable() const OMG_NOEXCEPT {
        return m_oTable_;
    }

    void oTable(uint8_t value) {
        m_oTable_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_MANUAL_AGC_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_MANUAL_AGC_REQUEST& other_) const;

    void swap(USERIF_ASE_MANUAL_AGC_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    uint8_t m_oAGC_;
    uint8_t m_oTable_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_MANUAL_AGC_REQUEST& a, USERIF_ASE_MANUAL_AGC_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_MANUAL_AGC_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_MAX_RANGE_REQUEST {
  public:
    USERIF_ASE_MAX_RANGE_REQUEST();

    USERIF_ASE_MAX_RANGE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,uint32_t ulMaxRange);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_MAX_RANGE_REQUEST (USERIF_ASE_MAX_RANGE_REQUEST&&) = default;
    USERIF_ASE_MAX_RANGE_REQUEST& operator=(USERIF_ASE_MAX_RANGE_REQUEST&&) = default;
    USERIF_ASE_MAX_RANGE_REQUEST& operator=(const USERIF_ASE_MAX_RANGE_REQUEST&) = default;
    USERIF_ASE_MAX_RANGE_REQUEST(const USERIF_ASE_MAX_RANGE_REQUEST&) = default;
    #else
    USERIF_ASE_MAX_RANGE_REQUEST(USERIF_ASE_MAX_RANGE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_MAX_RANGE_REQUEST& operator=(USERIF_ASE_MAX_RANGE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    uint32_t& ulMaxRange() OMG_NOEXCEPT {
        return m_ulMaxRange_;
    }

    const uint32_t& ulMaxRange() const OMG_NOEXCEPT {
        return m_ulMaxRange_;
    }

    void ulMaxRange(uint32_t value) {
        m_ulMaxRange_ = value;
    }

    bool operator == (const USERIF_ASE_MAX_RANGE_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_MAX_RANGE_REQUEST& other_) const;

    void swap(USERIF_ASE_MAX_RANGE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    uint32_t m_ulMaxRange_;

};

inline void swap(USERIF_ASE_MAX_RANGE_REQUEST& a, USERIF_ASE_MAX_RANGE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_MAX_RANGE_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_MAX_SPEED_REQUEST {
  public:
    USERIF_ASE_MAX_SPEED_REQUEST();

    USERIF_ASE_MAX_SPEED_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oSpeed,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_MAX_SPEED_REQUEST (USERIF_ASE_MAX_SPEED_REQUEST&&) = default;
    USERIF_ASE_MAX_SPEED_REQUEST& operator=(USERIF_ASE_MAX_SPEED_REQUEST&&) = default;
    USERIF_ASE_MAX_SPEED_REQUEST& operator=(const USERIF_ASE_MAX_SPEED_REQUEST&) = default;
    USERIF_ASE_MAX_SPEED_REQUEST(const USERIF_ASE_MAX_SPEED_REQUEST&) = default;
    #else
    USERIF_ASE_MAX_SPEED_REQUEST(USERIF_ASE_MAX_SPEED_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_MAX_SPEED_REQUEST& operator=(USERIF_ASE_MAX_SPEED_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oSpeed() OMG_NOEXCEPT {
        return m_oSpeed_;
    }

    const uint8_t& oSpeed() const OMG_NOEXCEPT {
        return m_oSpeed_;
    }

    void oSpeed(uint8_t value) {
        m_oSpeed_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_MAX_SPEED_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_MAX_SPEED_REQUEST& other_) const;

    void swap(USERIF_ASE_MAX_SPEED_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oSpeed_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_MAX_SPEED_REQUEST& a, USERIF_ASE_MAX_SPEED_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_MAX_SPEED_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_MODE_REQUEST {
  public:
    USERIF_ASE_MODE_REQUEST();

    USERIF_ASE_MODE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oMode,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_MODE_REQUEST (USERIF_ASE_MODE_REQUEST&&) = default;
    USERIF_ASE_MODE_REQUEST& operator=(USERIF_ASE_MODE_REQUEST&&) = default;
    USERIF_ASE_MODE_REQUEST& operator=(const USERIF_ASE_MODE_REQUEST&) = default;
    USERIF_ASE_MODE_REQUEST(const USERIF_ASE_MODE_REQUEST&) = default;
    #else
    USERIF_ASE_MODE_REQUEST(USERIF_ASE_MODE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_MODE_REQUEST& operator=(USERIF_ASE_MODE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oMode() OMG_NOEXCEPT {
        return m_oMode_;
    }

    const uint8_t& oMode() const OMG_NOEXCEPT {
        return m_oMode_;
    }

    void oMode(uint8_t value) {
        m_oMode_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_MODE_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_MODE_REQUEST& other_) const;

    void swap(USERIF_ASE_MODE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oMode_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_MODE_REQUEST& a, USERIF_ASE_MODE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_MODE_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_OIT_GEN_REQUEST {
  public:
    USERIF_ASE_OIT_GEN_REQUEST();

    USERIF_ASE_OIT_GEN_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,float fXmeter,float fYmeter);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_OIT_GEN_REQUEST (USERIF_ASE_OIT_GEN_REQUEST&&) = default;
    USERIF_ASE_OIT_GEN_REQUEST& operator=(USERIF_ASE_OIT_GEN_REQUEST&&) = default;
    USERIF_ASE_OIT_GEN_REQUEST& operator=(const USERIF_ASE_OIT_GEN_REQUEST&) = default;
    USERIF_ASE_OIT_GEN_REQUEST(const USERIF_ASE_OIT_GEN_REQUEST&) = default;
    #else
    USERIF_ASE_OIT_GEN_REQUEST(USERIF_ASE_OIT_GEN_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_OIT_GEN_REQUEST& operator=(USERIF_ASE_OIT_GEN_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    float& fXmeter() OMG_NOEXCEPT {
        return m_fXmeter_;
    }

    const float& fXmeter() const OMG_NOEXCEPT {
        return m_fXmeter_;
    }

    void fXmeter(float value) {
        m_fXmeter_ = value;
    }

    float& fYmeter() OMG_NOEXCEPT {
        return m_fYmeter_;
    }

    const float& fYmeter() const OMG_NOEXCEPT {
        return m_fYmeter_;
    }

    void fYmeter(float value) {
        m_fYmeter_ = value;
    }

    bool operator == (const USERIF_ASE_OIT_GEN_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_OIT_GEN_REQUEST& other_) const;

    void swap(USERIF_ASE_OIT_GEN_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    float m_fXmeter_;
    float m_fYmeter_;

};

inline void swap(USERIF_ASE_OIT_GEN_REQUEST& a, USERIF_ASE_OIT_GEN_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_OIT_GEN_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_POWER_CTRL_REQUEST {
  public:
    USERIF_ASE_POWER_CTRL_REQUEST();

    USERIF_ASE_POWER_CTRL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oPower,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_POWER_CTRL_REQUEST (USERIF_ASE_POWER_CTRL_REQUEST&&) = default;
    USERIF_ASE_POWER_CTRL_REQUEST& operator=(USERIF_ASE_POWER_CTRL_REQUEST&&) = default;
    USERIF_ASE_POWER_CTRL_REQUEST& operator=(const USERIF_ASE_POWER_CTRL_REQUEST&) = default;
    USERIF_ASE_POWER_CTRL_REQUEST(const USERIF_ASE_POWER_CTRL_REQUEST&) = default;
    #else
    USERIF_ASE_POWER_CTRL_REQUEST(USERIF_ASE_POWER_CTRL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_POWER_CTRL_REQUEST& operator=(USERIF_ASE_POWER_CTRL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oPower() OMG_NOEXCEPT {
        return m_oPower_;
    }

    const uint8_t& oPower() const OMG_NOEXCEPT {
        return m_oPower_;
    }

    void oPower(uint8_t value) {
        m_oPower_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_POWER_CTRL_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_POWER_CTRL_REQUEST& other_) const;

    void swap(USERIF_ASE_POWER_CTRL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oPower_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_POWER_CTRL_REQUEST& a, USERIF_ASE_POWER_CTRL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_POWER_CTRL_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST {
  public:
    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST();

    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ::dds::core::array< int32_t, 120L>& lSetDegree);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST (USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST&&) = default;
    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& operator=(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST&&) = default;
    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& operator=(const USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST&) = default;
    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST(const USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST&) = default;
    #else
    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& operator=(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ::dds::core::array< int32_t, 120L>& lSetDegree() OMG_NOEXCEPT {
        return m_lSetDegree_;
    }

    const ::dds::core::array< int32_t, 120L>& lSetDegree() const OMG_NOEXCEPT {
        return m_lSetDegree_;
    }

    void lSetDegree(const ::dds::core::array< int32_t, 120L>& value) {
        m_lSetDegree_ = value;
    }

    void lSetDegree(::dds::core::array< int32_t, 120L>&& value) {
        m_lSetDegree_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& other_) const;

    void swap(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ::dds::core::array< int32_t, 120L> m_lSetDegree_;

};

inline void swap(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& a, USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_SENSOR_FAIL_SET_REQUEST {
  public:
    USERIF_ASE_SENSOR_FAIL_SET_REQUEST();

    USERIF_ASE_SENSOR_FAIL_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,int32_t ulASID,const ::dds::core::array< uint8_t, 120L>& oSensorFail);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_SENSOR_FAIL_SET_REQUEST (USERIF_ASE_SENSOR_FAIL_SET_REQUEST&&) = default;
    USERIF_ASE_SENSOR_FAIL_SET_REQUEST& operator=(USERIF_ASE_SENSOR_FAIL_SET_REQUEST&&) = default;
    USERIF_ASE_SENSOR_FAIL_SET_REQUEST& operator=(const USERIF_ASE_SENSOR_FAIL_SET_REQUEST&) = default;
    USERIF_ASE_SENSOR_FAIL_SET_REQUEST(const USERIF_ASE_SENSOR_FAIL_SET_REQUEST&) = default;
    #else
    USERIF_ASE_SENSOR_FAIL_SET_REQUEST(USERIF_ASE_SENSOR_FAIL_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_SENSOR_FAIL_SET_REQUEST& operator=(USERIF_ASE_SENSOR_FAIL_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const int32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(int32_t value) {
        m_ulASID_ = value;
    }

    ::dds::core::array< uint8_t, 120L>& oSensorFail() OMG_NOEXCEPT {
        return m_oSensorFail_;
    }

    const ::dds::core::array< uint8_t, 120L>& oSensorFail() const OMG_NOEXCEPT {
        return m_oSensorFail_;
    }

    void oSensorFail(const ::dds::core::array< uint8_t, 120L>& value) {
        m_oSensorFail_ = value;
    }

    void oSensorFail(::dds::core::array< uint8_t, 120L>&& value) {
        m_oSensorFail_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_SENSOR_FAIL_SET_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_SENSOR_FAIL_SET_REQUEST& other_) const;

    void swap(USERIF_ASE_SENSOR_FAIL_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int32_t m_ulASID_;
    ::dds::core::array< uint8_t, 120L> m_oSensorFail_;

};

inline void swap(USERIF_ASE_SENSOR_FAIL_SET_REQUEST& a, USERIF_ASE_SENSOR_FAIL_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_SENSOR_FAIL_SET_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_SONARSPEED_REQUEST {
  public:
    USERIF_ASE_SONARSPEED_REQUEST();

    USERIF_ASE_SONARSPEED_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,int32_t lWaterSpeed);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_SONARSPEED_REQUEST (USERIF_ASE_SONARSPEED_REQUEST&&) = default;
    USERIF_ASE_SONARSPEED_REQUEST& operator=(USERIF_ASE_SONARSPEED_REQUEST&&) = default;
    USERIF_ASE_SONARSPEED_REQUEST& operator=(const USERIF_ASE_SONARSPEED_REQUEST&) = default;
    USERIF_ASE_SONARSPEED_REQUEST(const USERIF_ASE_SONARSPEED_REQUEST&) = default;
    #else
    USERIF_ASE_SONARSPEED_REQUEST(USERIF_ASE_SONARSPEED_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_SONARSPEED_REQUEST& operator=(USERIF_ASE_SONARSPEED_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    int32_t& lWaterSpeed() OMG_NOEXCEPT {
        return m_lWaterSpeed_;
    }

    const int32_t& lWaterSpeed() const OMG_NOEXCEPT {
        return m_lWaterSpeed_;
    }

    void lWaterSpeed(int32_t value) {
        m_lWaterSpeed_ = value;
    }

    bool operator == (const USERIF_ASE_SONARSPEED_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_SONARSPEED_REQUEST& other_) const;

    void swap(USERIF_ASE_SONARSPEED_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    int32_t m_lWaterSpeed_;

};

inline void swap(USERIF_ASE_SONARSPEED_REQUEST& a, USERIF_ASE_SONARSPEED_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_SONARSPEED_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_STAY_TARGET_MODE_REQ {
  public:
    USERIF_ASE_STAY_TARGET_MODE_REQ();

    USERIF_ASE_STAY_TARGET_MODE_REQ(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oStayTarget,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_STAY_TARGET_MODE_REQ (USERIF_ASE_STAY_TARGET_MODE_REQ&&) = default;
    USERIF_ASE_STAY_TARGET_MODE_REQ& operator=(USERIF_ASE_STAY_TARGET_MODE_REQ&&) = default;
    USERIF_ASE_STAY_TARGET_MODE_REQ& operator=(const USERIF_ASE_STAY_TARGET_MODE_REQ&) = default;
    USERIF_ASE_STAY_TARGET_MODE_REQ(const USERIF_ASE_STAY_TARGET_MODE_REQ&) = default;
    #else
    USERIF_ASE_STAY_TARGET_MODE_REQ(USERIF_ASE_STAY_TARGET_MODE_REQ&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_STAY_TARGET_MODE_REQ& operator=(USERIF_ASE_STAY_TARGET_MODE_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oStayTarget() OMG_NOEXCEPT {
        return m_oStayTarget_;
    }

    const uint8_t& oStayTarget() const OMG_NOEXCEPT {
        return m_oStayTarget_;
    }

    void oStayTarget(uint8_t value) {
        m_oStayTarget_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_STAY_TARGET_MODE_REQ& other_) const;
    bool operator != (const USERIF_ASE_STAY_TARGET_MODE_REQ& other_) const;

    void swap(USERIF_ASE_STAY_TARGET_MODE_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oStayTarget_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_STAY_TARGET_MODE_REQ& a, USERIF_ASE_STAY_TARGET_MODE_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_STAY_TARGET_MODE_REQ& sample);

class NDDSUSERDllExport USERIF_ASE_STEERING_CTRL_REQUEST {
  public:
    USERIF_ASE_STEERING_CTRL_REQUEST();

    USERIF_ASE_STEERING_CTRL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,char cSteering,const ::dds::core::array< char, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_STEERING_CTRL_REQUEST (USERIF_ASE_STEERING_CTRL_REQUEST&&) = default;
    USERIF_ASE_STEERING_CTRL_REQUEST& operator=(USERIF_ASE_STEERING_CTRL_REQUEST&&) = default;
    USERIF_ASE_STEERING_CTRL_REQUEST& operator=(const USERIF_ASE_STEERING_CTRL_REQUEST&) = default;
    USERIF_ASE_STEERING_CTRL_REQUEST(const USERIF_ASE_STEERING_CTRL_REQUEST&) = default;
    #else
    USERIF_ASE_STEERING_CTRL_REQUEST(USERIF_ASE_STEERING_CTRL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_STEERING_CTRL_REQUEST& operator=(USERIF_ASE_STEERING_CTRL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    char& cSteering() OMG_NOEXCEPT {
        return m_cSteering_;
    }

    const char& cSteering() const OMG_NOEXCEPT {
        return m_cSteering_;
    }

    void cSteering(char value) {
        m_cSteering_ = value;
    }

    ::dds::core::array< char, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< char, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< char, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< char, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_STEERING_CTRL_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_STEERING_CTRL_REQUEST& other_) const;

    void swap(USERIF_ASE_STEERING_CTRL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    char m_cSteering_;
    ::dds::core::array< char, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_STEERING_CTRL_REQUEST& a, USERIF_ASE_STEERING_CTRL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_STEERING_CTRL_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST {
  public:
    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST();

    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oActivation,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST (USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST&&) = default;
    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& operator=(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST&&) = default;
    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& operator=(const USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST&) = default;
    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST(const USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST&) = default;
    #else
    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& operator=(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oActivation() OMG_NOEXCEPT {
        return m_oActivation_;
    }

    const uint8_t& oActivation() const OMG_NOEXCEPT {
        return m_oActivation_;
    }

    void oActivation(uint8_t value) {
        m_oActivation_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& other_) const;

    void swap(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oActivation_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& a, USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_TRANSMIT_OPTION_REQUEST {
  public:
    USERIF_ASE_TRANSMIT_OPTION_REQUEST();

    USERIF_ASE_TRANSMIT_OPTION_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulASID,const ST_TX_INFO& stTTxInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_TRANSMIT_OPTION_REQUEST (USERIF_ASE_TRANSMIT_OPTION_REQUEST&&) = default;
    USERIF_ASE_TRANSMIT_OPTION_REQUEST& operator=(USERIF_ASE_TRANSMIT_OPTION_REQUEST&&) = default;
    USERIF_ASE_TRANSMIT_OPTION_REQUEST& operator=(const USERIF_ASE_TRANSMIT_OPTION_REQUEST&) = default;
    USERIF_ASE_TRANSMIT_OPTION_REQUEST(const USERIF_ASE_TRANSMIT_OPTION_REQUEST&) = default;
    #else
    USERIF_ASE_TRANSMIT_OPTION_REQUEST(USERIF_ASE_TRANSMIT_OPTION_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_TRANSMIT_OPTION_REQUEST& operator=(USERIF_ASE_TRANSMIT_OPTION_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulASID() OMG_NOEXCEPT {
        return m_ulASID_;
    }

    const uint32_t& ulASID() const OMG_NOEXCEPT {
        return m_ulASID_;
    }

    void ulASID(uint32_t value) {
        m_ulASID_ = value;
    }

    ST_TX_INFO& stTTxInfo() OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    const ST_TX_INFO& stTTxInfo() const OMG_NOEXCEPT {
        return m_stTTxInfo_;
    }

    void stTTxInfo(const ST_TX_INFO& value) {
        m_stTTxInfo_ = value;
    }

    void stTTxInfo(ST_TX_INFO&& value) {
        m_stTTxInfo_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_TRANSMIT_OPTION_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_TRANSMIT_OPTION_REQUEST& other_) const;

    void swap(USERIF_ASE_TRANSMIT_OPTION_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulASID_;
    ST_TX_INFO m_stTTxInfo_;

};

inline void swap(USERIF_ASE_TRANSMIT_OPTION_REQUEST& a, USERIF_ASE_TRANSMIT_OPTION_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_TRANSMIT_OPTION_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_TRK_SENSITIVE_REQUEST {
  public:
    USERIF_ASE_TRK_SENSITIVE_REQUEST();

    USERIF_ASE_TRK_SENSITIVE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oSenstive,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_TRK_SENSITIVE_REQUEST (USERIF_ASE_TRK_SENSITIVE_REQUEST&&) = default;
    USERIF_ASE_TRK_SENSITIVE_REQUEST& operator=(USERIF_ASE_TRK_SENSITIVE_REQUEST&&) = default;
    USERIF_ASE_TRK_SENSITIVE_REQUEST& operator=(const USERIF_ASE_TRK_SENSITIVE_REQUEST&) = default;
    USERIF_ASE_TRK_SENSITIVE_REQUEST(const USERIF_ASE_TRK_SENSITIVE_REQUEST&) = default;
    #else
    USERIF_ASE_TRK_SENSITIVE_REQUEST(USERIF_ASE_TRK_SENSITIVE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_TRK_SENSITIVE_REQUEST& operator=(USERIF_ASE_TRK_SENSITIVE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oSenstive() OMG_NOEXCEPT {
        return m_oSenstive_;
    }

    const uint8_t& oSenstive() const OMG_NOEXCEPT {
        return m_oSenstive_;
    }

    void oSenstive(uint8_t value) {
        m_oSenstive_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_TRK_SENSITIVE_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_TRK_SENSITIVE_REQUEST& other_) const;

    void swap(USERIF_ASE_TRK_SENSITIVE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oSenstive_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_TRK_SENSITIVE_REQUEST& a, USERIF_ASE_TRK_SENSITIVE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_TRK_SENSITIVE_REQUEST& sample);

class NDDSUSERDllExport USERIF_ASE_WAKE_SUP_REQUEST {
  public:
    USERIF_ASE_WAKE_SUP_REQUEST();

    USERIF_ASE_WAKE_SUP_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t ucASID,uint8_t oWakeSup,const ::dds::core::array< uint8_t, 2L>& oRes);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ASE_WAKE_SUP_REQUEST (USERIF_ASE_WAKE_SUP_REQUEST&&) = default;
    USERIF_ASE_WAKE_SUP_REQUEST& operator=(USERIF_ASE_WAKE_SUP_REQUEST&&) = default;
    USERIF_ASE_WAKE_SUP_REQUEST& operator=(const USERIF_ASE_WAKE_SUP_REQUEST&) = default;
    USERIF_ASE_WAKE_SUP_REQUEST(const USERIF_ASE_WAKE_SUP_REQUEST&) = default;
    #else
    USERIF_ASE_WAKE_SUP_REQUEST(USERIF_ASE_WAKE_SUP_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ASE_WAKE_SUP_REQUEST& operator=(USERIF_ASE_WAKE_SUP_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& ucASID() OMG_NOEXCEPT {
        return m_ucASID_;
    }

    const uint8_t& ucASID() const OMG_NOEXCEPT {
        return m_ucASID_;
    }

    void ucASID(uint8_t value) {
        m_ucASID_ = value;
    }

    uint8_t& oWakeSup() OMG_NOEXCEPT {
        return m_oWakeSup_;
    }

    const uint8_t& oWakeSup() const OMG_NOEXCEPT {
        return m_oWakeSup_;
    }

    void oWakeSup(uint8_t value) {
        m_oWakeSup_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oRes() OMG_NOEXCEPT {
        return m_oRes_;
    }

    const ::dds::core::array< uint8_t, 2L>& oRes() const OMG_NOEXCEPT {
        return m_oRes_;
    }

    void oRes(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oRes_ = value;
    }

    void oRes(::dds::core::array< uint8_t, 2L>&& value) {
        m_oRes_ = std::move(value);
    }

    bool operator == (const USERIF_ASE_WAKE_SUP_REQUEST& other_) const;
    bool operator != (const USERIF_ASE_WAKE_SUP_REQUEST& other_) const;

    void swap(USERIF_ASE_WAKE_SUP_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_ucASID_;
    uint8_t m_oWakeSup_;
    ::dds::core::array< uint8_t, 2L> m_oRes_;

};

inline void swap(USERIF_ASE_WAKE_SUP_REQUEST& a, USERIF_ASE_WAKE_SUP_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ASE_WAKE_SUP_REQUEST& sample);

class NDDSUSERDllExport ST_DEPTH_TEMP {
  public:
    ST_DEPTH_TEMP();

    ST_DEPTH_TEMP(double dLatitude,double dLongitude,uint16_t usDataNum,const ::dds::core::array< float, 100L>& fDepth,const ::dds::core::array< float, 100L>& fTemp);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_DEPTH_TEMP (ST_DEPTH_TEMP&&) = default;
    ST_DEPTH_TEMP& operator=(ST_DEPTH_TEMP&&) = default;
    ST_DEPTH_TEMP& operator=(const ST_DEPTH_TEMP&) = default;
    ST_DEPTH_TEMP(const ST_DEPTH_TEMP&) = default;
    #else
    ST_DEPTH_TEMP(ST_DEPTH_TEMP&& other_) OMG_NOEXCEPT;  
    ST_DEPTH_TEMP& operator=(ST_DEPTH_TEMP&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    ::dds::core::array< float, 100L>& fDepth() OMG_NOEXCEPT {
        return m_fDepth_;
    }

    const ::dds::core::array< float, 100L>& fDepth() const OMG_NOEXCEPT {
        return m_fDepth_;
    }

    void fDepth(const ::dds::core::array< float, 100L>& value) {
        m_fDepth_ = value;
    }

    void fDepth(::dds::core::array< float, 100L>&& value) {
        m_fDepth_ = std::move(value);
    }
    ::dds::core::array< float, 100L>& fTemp() OMG_NOEXCEPT {
        return m_fTemp_;
    }

    const ::dds::core::array< float, 100L>& fTemp() const OMG_NOEXCEPT {
        return m_fTemp_;
    }

    void fTemp(const ::dds::core::array< float, 100L>& value) {
        m_fTemp_ = value;
    }

    void fTemp(::dds::core::array< float, 100L>&& value) {
        m_fTemp_ = std::move(value);
    }

    bool operator == (const ST_DEPTH_TEMP& other_) const;
    bool operator != (const ST_DEPTH_TEMP& other_) const;

    void swap(ST_DEPTH_TEMP& other_) OMG_NOEXCEPT ;

  private:

    double m_dLatitude_;
    double m_dLongitude_;
    uint16_t m_usDataNum_;
    ::dds::core::array< float, 100L> m_fDepth_;
    ::dds::core::array< float, 100L> m_fTemp_;

};

inline void swap(ST_DEPTH_TEMP& a, ST_DEPTH_TEMP& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_DEPTH_TEMP& sample);

class NDDSUSERDllExport ST_USER_TEMP_INFO {
  public:
    ST_USER_TEMP_INFO();

    ST_USER_TEMP_INFO(const ST_DATE_TIME& stCreateTime,const ST_DEPTH_TEMP& stDepthTempInfo,const ::dds::core::array< char, 80L>& acComment);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_USER_TEMP_INFO (ST_USER_TEMP_INFO&&) = default;
    ST_USER_TEMP_INFO& operator=(ST_USER_TEMP_INFO&&) = default;
    ST_USER_TEMP_INFO& operator=(const ST_USER_TEMP_INFO&) = default;
    ST_USER_TEMP_INFO(const ST_USER_TEMP_INFO&) = default;
    #else
    ST_USER_TEMP_INFO(ST_USER_TEMP_INFO&& other_) OMG_NOEXCEPT;  
    ST_USER_TEMP_INFO& operator=(ST_USER_TEMP_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_DATE_TIME& stCreateTime() OMG_NOEXCEPT {
        return m_stCreateTime_;
    }

    const ST_DATE_TIME& stCreateTime() const OMG_NOEXCEPT {
        return m_stCreateTime_;
    }

    void stCreateTime(const ST_DATE_TIME& value) {
        m_stCreateTime_ = value;
    }

    void stCreateTime(ST_DATE_TIME&& value) {
        m_stCreateTime_ = std::move(value);
    }
    ST_DEPTH_TEMP& stDepthTempInfo() OMG_NOEXCEPT {
        return m_stDepthTempInfo_;
    }

    const ST_DEPTH_TEMP& stDepthTempInfo() const OMG_NOEXCEPT {
        return m_stDepthTempInfo_;
    }

    void stDepthTempInfo(const ST_DEPTH_TEMP& value) {
        m_stDepthTempInfo_ = value;
    }

    void stDepthTempInfo(ST_DEPTH_TEMP&& value) {
        m_stDepthTempInfo_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acComment() OMG_NOEXCEPT {
        return m_acComment_;
    }

    const ::dds::core::array< char, 80L>& acComment() const OMG_NOEXCEPT {
        return m_acComment_;
    }

    void acComment(const ::dds::core::array< char, 80L>& value) {
        m_acComment_ = value;
    }

    void acComment(::dds::core::array< char, 80L>&& value) {
        m_acComment_ = std::move(value);
    }

    bool operator == (const ST_USER_TEMP_INFO& other_) const;
    bool operator != (const ST_USER_TEMP_INFO& other_) const;

    void swap(ST_USER_TEMP_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_DATE_TIME m_stCreateTime_;
    ST_DEPTH_TEMP m_stDepthTempInfo_;
    ::dds::core::array< char, 80L> m_acComment_;

};

inline void swap(ST_USER_TEMP_INFO& a, ST_USER_TEMP_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_USER_TEMP_INFO& sample);

class NDDSUSERDllExport ST_AS_SENSOR_INFO {
  public:
    ST_AS_SENSOR_INFO();

    ST_AS_SENSOR_INFO(uint16_t usStartSoundFreq,uint16_t usEndSoundFreq,uint16_t usSoundPulselength,int32_t lVerticalAngle,float fASAmbientNoise);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_SENSOR_INFO (ST_AS_SENSOR_INFO&&) = default;
    ST_AS_SENSOR_INFO& operator=(ST_AS_SENSOR_INFO&&) = default;
    ST_AS_SENSOR_INFO& operator=(const ST_AS_SENSOR_INFO&) = default;
    ST_AS_SENSOR_INFO(const ST_AS_SENSOR_INFO&) = default;
    #else
    ST_AS_SENSOR_INFO(ST_AS_SENSOR_INFO&& other_) OMG_NOEXCEPT;  
    ST_AS_SENSOR_INFO& operator=(ST_AS_SENSOR_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usStartSoundFreq() OMG_NOEXCEPT {
        return m_usStartSoundFreq_;
    }

    const uint16_t& usStartSoundFreq() const OMG_NOEXCEPT {
        return m_usStartSoundFreq_;
    }

    void usStartSoundFreq(uint16_t value) {
        m_usStartSoundFreq_ = value;
    }

    uint16_t& usEndSoundFreq() OMG_NOEXCEPT {
        return m_usEndSoundFreq_;
    }

    const uint16_t& usEndSoundFreq() const OMG_NOEXCEPT {
        return m_usEndSoundFreq_;
    }

    void usEndSoundFreq(uint16_t value) {
        m_usEndSoundFreq_ = value;
    }

    uint16_t& usSoundPulselength() OMG_NOEXCEPT {
        return m_usSoundPulselength_;
    }

    const uint16_t& usSoundPulselength() const OMG_NOEXCEPT {
        return m_usSoundPulselength_;
    }

    void usSoundPulselength(uint16_t value) {
        m_usSoundPulselength_ = value;
    }

    int32_t& lVerticalAngle() OMG_NOEXCEPT {
        return m_lVerticalAngle_;
    }

    const int32_t& lVerticalAngle() const OMG_NOEXCEPT {
        return m_lVerticalAngle_;
    }

    void lVerticalAngle(int32_t value) {
        m_lVerticalAngle_ = value;
    }

    float& fASAmbientNoise() OMG_NOEXCEPT {
        return m_fASAmbientNoise_;
    }

    const float& fASAmbientNoise() const OMG_NOEXCEPT {
        return m_fASAmbientNoise_;
    }

    void fASAmbientNoise(float value) {
        m_fASAmbientNoise_ = value;
    }

    bool operator == (const ST_AS_SENSOR_INFO& other_) const;
    bool operator != (const ST_AS_SENSOR_INFO& other_) const;

    void swap(ST_AS_SENSOR_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usStartSoundFreq_;
    uint16_t m_usEndSoundFreq_;
    uint16_t m_usSoundPulselength_;
    int32_t m_lVerticalAngle_;
    float m_fASAmbientNoise_;

};

inline void swap(ST_AS_SENSOR_INFO& a, ST_AS_SENSOR_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_SENSOR_INFO& sample);

class NDDSUSERDllExport ST_AS_MODEL_INPUT_SET {
  public:
    ST_AS_MODEL_INPUT_SET();

    ST_AS_MODEL_INPUT_SET(uint8_t oTemperDBType,uint16_t usMonth,uint16_t usDay,const ST_USER_TEMP_INFO& stTempInfo,float fTargetSpeed,const ::dds::core::array< ST_AS_SENSOR_INFO, 3L>& stASSensorInfo,const ST_AS_TS_INFO& stASTSInfo,uint8_t oSeaState);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_AS_MODEL_INPUT_SET (ST_AS_MODEL_INPUT_SET&&) = default;
    ST_AS_MODEL_INPUT_SET& operator=(ST_AS_MODEL_INPUT_SET&&) = default;
    ST_AS_MODEL_INPUT_SET& operator=(const ST_AS_MODEL_INPUT_SET&) = default;
    ST_AS_MODEL_INPUT_SET(const ST_AS_MODEL_INPUT_SET&) = default;
    #else
    ST_AS_MODEL_INPUT_SET(ST_AS_MODEL_INPUT_SET&& other_) OMG_NOEXCEPT;  
    ST_AS_MODEL_INPUT_SET& operator=(ST_AS_MODEL_INPUT_SET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oTemperDBType() OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    const uint8_t& oTemperDBType() const OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    void oTemperDBType(uint8_t value) {
        m_oTemperDBType_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    ST_USER_TEMP_INFO& stTempInfo() OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    const ST_USER_TEMP_INFO& stTempInfo() const OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    void stTempInfo(const ST_USER_TEMP_INFO& value) {
        m_stTempInfo_ = value;
    }

    void stTempInfo(ST_USER_TEMP_INFO&& value) {
        m_stTempInfo_ = std::move(value);
    }
    float& fTargetSpeed() OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    const float& fTargetSpeed() const OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    void fTargetSpeed(float value) {
        m_fTargetSpeed_ = value;
    }

    ::dds::core::array< ST_AS_SENSOR_INFO, 3L>& stASSensorInfo() OMG_NOEXCEPT {
        return m_stASSensorInfo_;
    }

    const ::dds::core::array< ST_AS_SENSOR_INFO, 3L>& stASSensorInfo() const OMG_NOEXCEPT {
        return m_stASSensorInfo_;
    }

    void stASSensorInfo(const ::dds::core::array< ST_AS_SENSOR_INFO, 3L>& value) {
        m_stASSensorInfo_ = value;
    }

    void stASSensorInfo(::dds::core::array< ST_AS_SENSOR_INFO, 3L>&& value) {
        m_stASSensorInfo_ = std::move(value);
    }
    ST_AS_TS_INFO& stASTSInfo() OMG_NOEXCEPT {
        return m_stASTSInfo_;
    }

    const ST_AS_TS_INFO& stASTSInfo() const OMG_NOEXCEPT {
        return m_stASTSInfo_;
    }

    void stASTSInfo(const ST_AS_TS_INFO& value) {
        m_stASTSInfo_ = value;
    }

    void stASTSInfo(ST_AS_TS_INFO&& value) {
        m_stASTSInfo_ = std::move(value);
    }
    uint8_t& oSeaState() OMG_NOEXCEPT {
        return m_oSeaState_;
    }

    const uint8_t& oSeaState() const OMG_NOEXCEPT {
        return m_oSeaState_;
    }

    void oSeaState(uint8_t value) {
        m_oSeaState_ = value;
    }

    bool operator == (const ST_AS_MODEL_INPUT_SET& other_) const;
    bool operator != (const ST_AS_MODEL_INPUT_SET& other_) const;

    void swap(ST_AS_MODEL_INPUT_SET& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oTemperDBType_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;
    ST_USER_TEMP_INFO m_stTempInfo_;
    float m_fTargetSpeed_;
    ::dds::core::array< ST_AS_SENSOR_INFO, 3L> m_stASSensorInfo_;
    ST_AS_TS_INFO m_stASTSInfo_;
    uint8_t m_oSeaState_;

};

inline void swap(ST_AS_MODEL_INPUT_SET& a, ST_AS_MODEL_INPUT_SET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_AS_MODEL_INPUT_SET& sample);

class NDDSUSERDllExport USERIF_AS_DETECTION_PROBABILITY_REQUEST {
  public:
    USERIF_AS_DETECTION_PROBABILITY_REQUEST();

    USERIF_AS_DETECTION_PROBABILITY_REQUEST(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,const ST_AS_MODEL_INPUT_SET& stASModelInput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_AS_DETECTION_PROBABILITY_REQUEST (USERIF_AS_DETECTION_PROBABILITY_REQUEST&&) = default;
    USERIF_AS_DETECTION_PROBABILITY_REQUEST& operator=(USERIF_AS_DETECTION_PROBABILITY_REQUEST&&) = default;
    USERIF_AS_DETECTION_PROBABILITY_REQUEST& operator=(const USERIF_AS_DETECTION_PROBABILITY_REQUEST&) = default;
    USERIF_AS_DETECTION_PROBABILITY_REQUEST(const USERIF_AS_DETECTION_PROBABILITY_REQUEST&) = default;
    #else
    USERIF_AS_DETECTION_PROBABILITY_REQUEST(USERIF_AS_DETECTION_PROBABILITY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_AS_DETECTION_PROBABILITY_REQUEST& operator=(USERIF_AS_DETECTION_PROBABILITY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    ST_AS_MODEL_INPUT_SET& stASModelInput() OMG_NOEXCEPT {
        return m_stASModelInput_;
    }

    const ST_AS_MODEL_INPUT_SET& stASModelInput() const OMG_NOEXCEPT {
        return m_stASModelInput_;
    }

    void stASModelInput(const ST_AS_MODEL_INPUT_SET& value) {
        m_stASModelInput_ = value;
    }

    void stASModelInput(ST_AS_MODEL_INPUT_SET&& value) {
        m_stASModelInput_ = std::move(value);
    }

    bool operator == (const USERIF_AS_DETECTION_PROBABILITY_REQUEST& other_) const;
    bool operator != (const USERIF_AS_DETECTION_PROBABILITY_REQUEST& other_) const;

    void swap(USERIF_AS_DETECTION_PROBABILITY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    ST_AS_MODEL_INPUT_SET m_stASModelInput_;

};

inline void swap(USERIF_AS_DETECTION_PROBABILITY_REQUEST& a, USERIF_AS_DETECTION_PROBABILITY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_AS_DETECTION_PROBABILITY_REQUEST& sample);

class NDDSUSERDllExport USERIF_AS_THREAT_AREA_CONTROL_REQUEST {
  public:
    USERIF_AS_THREAT_AREA_CONTROL_REQUEST();

    USERIF_AS_THREAT_AREA_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint8_t oSensorID,float fRange);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_AS_THREAT_AREA_CONTROL_REQUEST (USERIF_AS_THREAT_AREA_CONTROL_REQUEST&&) = default;
    USERIF_AS_THREAT_AREA_CONTROL_REQUEST& operator=(USERIF_AS_THREAT_AREA_CONTROL_REQUEST&&) = default;
    USERIF_AS_THREAT_AREA_CONTROL_REQUEST& operator=(const USERIF_AS_THREAT_AREA_CONTROL_REQUEST&) = default;
    USERIF_AS_THREAT_AREA_CONTROL_REQUEST(const USERIF_AS_THREAT_AREA_CONTROL_REQUEST&) = default;
    #else
    USERIF_AS_THREAT_AREA_CONTROL_REQUEST(USERIF_AS_THREAT_AREA_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_AS_THREAT_AREA_CONTROL_REQUEST& operator=(USERIF_AS_THREAT_AREA_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint8_t& oSensorID() OMG_NOEXCEPT {
        return m_oSensorID_;
    }

    const uint8_t& oSensorID() const OMG_NOEXCEPT {
        return m_oSensorID_;
    }

    void oSensorID(uint8_t value) {
        m_oSensorID_ = value;
    }

    float& fRange() OMG_NOEXCEPT {
        return m_fRange_;
    }

    const float& fRange() const OMG_NOEXCEPT {
        return m_fRange_;
    }

    void fRange(float value) {
        m_fRange_ = value;
    }

    bool operator == (const USERIF_AS_THREAT_AREA_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_AS_THREAT_AREA_CONTROL_REQUEST& other_) const;

    void swap(USERIF_AS_THREAT_AREA_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint8_t m_oSensorID_;
    float m_fRange_;

};

inline void swap(USERIF_AS_THREAT_AREA_CONTROL_REQUEST& a, USERIF_AS_THREAT_AREA_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_AS_THREAT_AREA_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_AS_TRACK_USER_CONFIRM_COMMAND {
  public:
    USERIF_AS_TRACK_USER_CONFIRM_COMMAND();

    USERIF_AS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCommandID,uint16_t usGlobalID,uint8_t oSensorID,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_AS_TRACK_USER_CONFIRM_COMMAND (USERIF_AS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_AS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_AS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_AS_TRACK_USER_CONFIRM_COMMAND& operator=(const USERIF_AS_TRACK_USER_CONFIRM_COMMAND&) = default;
    USERIF_AS_TRACK_USER_CONFIRM_COMMAND(const USERIF_AS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    USERIF_AS_TRACK_USER_CONFIRM_COMMAND(USERIF_AS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_AS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_AS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint16_t& usGlobalID() OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    const uint16_t& usGlobalID() const OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    void usGlobalID(uint16_t value) {
        m_usGlobalID_ = value;
    }

    uint8_t& oSensorID() OMG_NOEXCEPT {
        return m_oSensorID_;
    }

    const uint8_t& oSensorID() const OMG_NOEXCEPT {
        return m_oSensorID_;
    }

    void oSensorID(uint8_t value) {
        m_oSensorID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_AS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const USERIF_AS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(USERIF_AS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCommandID_;
    uint16_t m_usGlobalID_;
    uint8_t m_oSensorID_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_AS_TRACK_USER_CONFIRM_COMMAND& a, USERIF_AS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_AS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport USERIF_AUDIO_CONTROL_REQUEST {
  public:
    USERIF_AUDIO_CONTROL_REQUEST();

    USERIF_AUDIO_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t unSensortype,uint8_t unCommandcode,uint16_t usTargetAudioMode,uint16_t usTargetNumber,uint8_t unLine,uint16_t usBeam,uint8_t unBandvalue,uint16_t usBISPulseType,float fBISCenterFreq,float fBISBandwidth,float fBISPulseLength,uint8_t unPlayMode,const ST_DATE_TIME& unReplayStartTime,uint16_t unReplayIndex,uint8_t oBISSyncFlag,uint32_t ulBISFrameNum);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_AUDIO_CONTROL_REQUEST (USERIF_AUDIO_CONTROL_REQUEST&&) = default;
    USERIF_AUDIO_CONTROL_REQUEST& operator=(USERIF_AUDIO_CONTROL_REQUEST&&) = default;
    USERIF_AUDIO_CONTROL_REQUEST& operator=(const USERIF_AUDIO_CONTROL_REQUEST&) = default;
    USERIF_AUDIO_CONTROL_REQUEST(const USERIF_AUDIO_CONTROL_REQUEST&) = default;
    #else
    USERIF_AUDIO_CONTROL_REQUEST(USERIF_AUDIO_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_AUDIO_CONTROL_REQUEST& operator=(USERIF_AUDIO_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& unSensortype() OMG_NOEXCEPT {
        return m_unSensortype_;
    }

    const uint8_t& unSensortype() const OMG_NOEXCEPT {
        return m_unSensortype_;
    }

    void unSensortype(uint8_t value) {
        m_unSensortype_ = value;
    }

    uint8_t& unCommandcode() OMG_NOEXCEPT {
        return m_unCommandcode_;
    }

    const uint8_t& unCommandcode() const OMG_NOEXCEPT {
        return m_unCommandcode_;
    }

    void unCommandcode(uint8_t value) {
        m_unCommandcode_ = value;
    }

    uint16_t& usTargetAudioMode() OMG_NOEXCEPT {
        return m_usTargetAudioMode_;
    }

    const uint16_t& usTargetAudioMode() const OMG_NOEXCEPT {
        return m_usTargetAudioMode_;
    }

    void usTargetAudioMode(uint16_t value) {
        m_usTargetAudioMode_ = value;
    }

    uint16_t& usTargetNumber() OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    const uint16_t& usTargetNumber() const OMG_NOEXCEPT {
        return m_usTargetNumber_;
    }

    void usTargetNumber(uint16_t value) {
        m_usTargetNumber_ = value;
    }

    uint8_t& unLine() OMG_NOEXCEPT {
        return m_unLine_;
    }

    const uint8_t& unLine() const OMG_NOEXCEPT {
        return m_unLine_;
    }

    void unLine(uint8_t value) {
        m_unLine_ = value;
    }

    uint16_t& usBeam() OMG_NOEXCEPT {
        return m_usBeam_;
    }

    const uint16_t& usBeam() const OMG_NOEXCEPT {
        return m_usBeam_;
    }

    void usBeam(uint16_t value) {
        m_usBeam_ = value;
    }

    uint8_t& unBandvalue() OMG_NOEXCEPT {
        return m_unBandvalue_;
    }

    const uint8_t& unBandvalue() const OMG_NOEXCEPT {
        return m_unBandvalue_;
    }

    void unBandvalue(uint8_t value) {
        m_unBandvalue_ = value;
    }

    uint16_t& usBISPulseType() OMG_NOEXCEPT {
        return m_usBISPulseType_;
    }

    const uint16_t& usBISPulseType() const OMG_NOEXCEPT {
        return m_usBISPulseType_;
    }

    void usBISPulseType(uint16_t value) {
        m_usBISPulseType_ = value;
    }

    float& fBISCenterFreq() OMG_NOEXCEPT {
        return m_fBISCenterFreq_;
    }

    const float& fBISCenterFreq() const OMG_NOEXCEPT {
        return m_fBISCenterFreq_;
    }

    void fBISCenterFreq(float value) {
        m_fBISCenterFreq_ = value;
    }

    float& fBISBandwidth() OMG_NOEXCEPT {
        return m_fBISBandwidth_;
    }

    const float& fBISBandwidth() const OMG_NOEXCEPT {
        return m_fBISBandwidth_;
    }

    void fBISBandwidth(float value) {
        m_fBISBandwidth_ = value;
    }

    float& fBISPulseLength() OMG_NOEXCEPT {
        return m_fBISPulseLength_;
    }

    const float& fBISPulseLength() const OMG_NOEXCEPT {
        return m_fBISPulseLength_;
    }

    void fBISPulseLength(float value) {
        m_fBISPulseLength_ = value;
    }

    uint8_t& unPlayMode() OMG_NOEXCEPT {
        return m_unPlayMode_;
    }

    const uint8_t& unPlayMode() const OMG_NOEXCEPT {
        return m_unPlayMode_;
    }

    void unPlayMode(uint8_t value) {
        m_unPlayMode_ = value;
    }

    ST_DATE_TIME& unReplayStartTime() OMG_NOEXCEPT {
        return m_unReplayStartTime_;
    }

    const ST_DATE_TIME& unReplayStartTime() const OMG_NOEXCEPT {
        return m_unReplayStartTime_;
    }

    void unReplayStartTime(const ST_DATE_TIME& value) {
        m_unReplayStartTime_ = value;
    }

    void unReplayStartTime(ST_DATE_TIME&& value) {
        m_unReplayStartTime_ = std::move(value);
    }
    uint16_t& unReplayIndex() OMG_NOEXCEPT {
        return m_unReplayIndex_;
    }

    const uint16_t& unReplayIndex() const OMG_NOEXCEPT {
        return m_unReplayIndex_;
    }

    void unReplayIndex(uint16_t value) {
        m_unReplayIndex_ = value;
    }

    uint8_t& oBISSyncFlag() OMG_NOEXCEPT {
        return m_oBISSyncFlag_;
    }

    const uint8_t& oBISSyncFlag() const OMG_NOEXCEPT {
        return m_oBISSyncFlag_;
    }

    void oBISSyncFlag(uint8_t value) {
        m_oBISSyncFlag_ = value;
    }

    uint32_t& ulBISFrameNum() OMG_NOEXCEPT {
        return m_ulBISFrameNum_;
    }

    const uint32_t& ulBISFrameNum() const OMG_NOEXCEPT {
        return m_ulBISFrameNum_;
    }

    void ulBISFrameNum(uint32_t value) {
        m_ulBISFrameNum_ = value;
    }

    bool operator == (const USERIF_AUDIO_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_AUDIO_CONTROL_REQUEST& other_) const;

    void swap(USERIF_AUDIO_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_unSensortype_;
    uint8_t m_unCommandcode_;
    uint16_t m_usTargetAudioMode_;
    uint16_t m_usTargetNumber_;
    uint8_t m_unLine_;
    uint16_t m_usBeam_;
    uint8_t m_unBandvalue_;
    uint16_t m_usBISPulseType_;
    float m_fBISCenterFreq_;
    float m_fBISBandwidth_;
    float m_fBISPulseLength_;
    uint8_t m_unPlayMode_;
    ST_DATE_TIME m_unReplayStartTime_;
    uint16_t m_unReplayIndex_;
    uint8_t m_oBISSyncFlag_;
    uint32_t m_ulBISFrameNum_;

};

inline void swap(USERIF_AUDIO_CONTROL_REQUEST& a, USERIF_AUDIO_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_AUDIO_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_BISTRK_CONC_TGT_REG_COMMAND {
  public:
    USERIF_BISTRK_CONC_TGT_REG_COMMAND();

    USERIF_BISTRK_CONC_TGT_REG_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint8_t oBisTrkType,uint16_t unTgtNo,const ::dds::core::array< uint16_t, 2L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BISTRK_CONC_TGT_REG_COMMAND (USERIF_BISTRK_CONC_TGT_REG_COMMAND&&) = default;
    USERIF_BISTRK_CONC_TGT_REG_COMMAND& operator=(USERIF_BISTRK_CONC_TGT_REG_COMMAND&&) = default;
    USERIF_BISTRK_CONC_TGT_REG_COMMAND& operator=(const USERIF_BISTRK_CONC_TGT_REG_COMMAND&) = default;
    USERIF_BISTRK_CONC_TGT_REG_COMMAND(const USERIF_BISTRK_CONC_TGT_REG_COMMAND&) = default;
    #else
    USERIF_BISTRK_CONC_TGT_REG_COMMAND(USERIF_BISTRK_CONC_TGT_REG_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_BISTRK_CONC_TGT_REG_COMMAND& operator=(USERIF_BISTRK_CONC_TGT_REG_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oBisTrkType() OMG_NOEXCEPT {
        return m_oBisTrkType_;
    }

    const uint8_t& oBisTrkType() const OMG_NOEXCEPT {
        return m_oBisTrkType_;
    }

    void oBisTrkType(uint8_t value) {
        m_oBisTrkType_ = value;
    }

    uint16_t& unTgtNo() OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    const uint16_t& unTgtNo() const OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    void unTgtNo(uint16_t value) {
        m_unTgtNo_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const USERIF_BISTRK_CONC_TGT_REG_COMMAND& other_) const;
    bool operator != (const USERIF_BISTRK_CONC_TGT_REG_COMMAND& other_) const;

    void swap(USERIF_BISTRK_CONC_TGT_REG_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint8_t m_oBisTrkType_;
    uint16_t m_unTgtNo_;
    ::dds::core::array< uint16_t, 2L> m_aReserved_;

};

inline void swap(USERIF_BISTRK_CONC_TGT_REG_COMMAND& a, USERIF_BISTRK_CONC_TGT_REG_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BISTRK_CONC_TGT_REG_COMMAND& sample);

class NDDSUSERDllExport USERIF_BISTRK_OIT_CONTROL_COMMAND {
  public:
    USERIF_BISTRK_OIT_CONTROL_COMMAND();

    USERIF_BISTRK_OIT_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oOitUserID,uint16_t usTmpTgtNo,uint8_t oBisAixsID,uint8_t oBisPulseType,uint8_t oIsAddOrDelete,uint16_t unBisOitBeamNo,uint16_t usBisOitSectorNo,uint16_t unBisOitBin,float fBisTgtDist,uint16_t unBisOitDelTrackNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BISTRK_OIT_CONTROL_COMMAND (USERIF_BISTRK_OIT_CONTROL_COMMAND&&) = default;
    USERIF_BISTRK_OIT_CONTROL_COMMAND& operator=(USERIF_BISTRK_OIT_CONTROL_COMMAND&&) = default;
    USERIF_BISTRK_OIT_CONTROL_COMMAND& operator=(const USERIF_BISTRK_OIT_CONTROL_COMMAND&) = default;
    USERIF_BISTRK_OIT_CONTROL_COMMAND(const USERIF_BISTRK_OIT_CONTROL_COMMAND&) = default;
    #else
    USERIF_BISTRK_OIT_CONTROL_COMMAND(USERIF_BISTRK_OIT_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_BISTRK_OIT_CONTROL_COMMAND& operator=(USERIF_BISTRK_OIT_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    uint8_t& oBisAixsID() OMG_NOEXCEPT {
        return m_oBisAixsID_;
    }

    const uint8_t& oBisAixsID() const OMG_NOEXCEPT {
        return m_oBisAixsID_;
    }

    void oBisAixsID(uint8_t value) {
        m_oBisAixsID_ = value;
    }

    uint8_t& oBisPulseType() OMG_NOEXCEPT {
        return m_oBisPulseType_;
    }

    const uint8_t& oBisPulseType() const OMG_NOEXCEPT {
        return m_oBisPulseType_;
    }

    void oBisPulseType(uint8_t value) {
        m_oBisPulseType_ = value;
    }

    uint8_t& oIsAddOrDelete() OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    const uint8_t& oIsAddOrDelete() const OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    void oIsAddOrDelete(uint8_t value) {
        m_oIsAddOrDelete_ = value;
    }

    uint16_t& unBisOitBeamNo() OMG_NOEXCEPT {
        return m_unBisOitBeamNo_;
    }

    const uint16_t& unBisOitBeamNo() const OMG_NOEXCEPT {
        return m_unBisOitBeamNo_;
    }

    void unBisOitBeamNo(uint16_t value) {
        m_unBisOitBeamNo_ = value;
    }

    uint16_t& usBisOitSectorNo() OMG_NOEXCEPT {
        return m_usBisOitSectorNo_;
    }

    const uint16_t& usBisOitSectorNo() const OMG_NOEXCEPT {
        return m_usBisOitSectorNo_;
    }

    void usBisOitSectorNo(uint16_t value) {
        m_usBisOitSectorNo_ = value;
    }

    uint16_t& unBisOitBin() OMG_NOEXCEPT {
        return m_unBisOitBin_;
    }

    const uint16_t& unBisOitBin() const OMG_NOEXCEPT {
        return m_unBisOitBin_;
    }

    void unBisOitBin(uint16_t value) {
        m_unBisOitBin_ = value;
    }

    float& fBisTgtDist() OMG_NOEXCEPT {
        return m_fBisTgtDist_;
    }

    const float& fBisTgtDist() const OMG_NOEXCEPT {
        return m_fBisTgtDist_;
    }

    void fBisTgtDist(float value) {
        m_fBisTgtDist_ = value;
    }

    uint16_t& unBisOitDelTrackNo() OMG_NOEXCEPT {
        return m_unBisOitDelTrackNo_;
    }

    const uint16_t& unBisOitDelTrackNo() const OMG_NOEXCEPT {
        return m_unBisOitDelTrackNo_;
    }

    void unBisOitDelTrackNo(uint16_t value) {
        m_unBisOitDelTrackNo_ = value;
    }

    bool operator == (const USERIF_BISTRK_OIT_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_BISTRK_OIT_CONTROL_COMMAND& other_) const;

    void swap(USERIF_BISTRK_OIT_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;
    uint8_t m_oBisAixsID_;
    uint8_t m_oBisPulseType_;
    uint8_t m_oIsAddOrDelete_;
    uint16_t m_unBisOitBeamNo_;
    uint16_t m_usBisOitSectorNo_;
    uint16_t m_unBisOitBin_;
    float m_fBisTgtDist_;
    uint16_t m_unBisOitDelTrackNo_;

};

inline void swap(USERIF_BISTRK_OIT_CONTROL_COMMAND& a, USERIF_BISTRK_OIT_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BISTRK_OIT_CONTROL_COMMAND& sample);

class NDDSUSERDllExport USERIF_BISTRK_THRESHOLD_INFO {
  public:
    USERIF_BISTRK_THRESHOLD_INFO();

    USERIF_BISTRK_THRESHOLD_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsBisCitThrshAuto,const ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& stBisThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BISTRK_THRESHOLD_INFO (USERIF_BISTRK_THRESHOLD_INFO&&) = default;
    USERIF_BISTRK_THRESHOLD_INFO& operator=(USERIF_BISTRK_THRESHOLD_INFO&&) = default;
    USERIF_BISTRK_THRESHOLD_INFO& operator=(const USERIF_BISTRK_THRESHOLD_INFO&) = default;
    USERIF_BISTRK_THRESHOLD_INFO(const USERIF_BISTRK_THRESHOLD_INFO&) = default;
    #else
    USERIF_BISTRK_THRESHOLD_INFO(USERIF_BISTRK_THRESHOLD_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_BISTRK_THRESHOLD_INFO& operator=(USERIF_BISTRK_THRESHOLD_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsBisCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    const uint8_t& oIsBisCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsBisCitThrshAuto_;
    }

    void oIsBisCitThrshAuto(uint8_t value) {
        m_oIsBisCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& stBisThresh() OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    const ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& stBisThresh() const OMG_NOEXCEPT {
        return m_stBisThresh_;
    }

    void stBisThresh(const ::dds::core::array< ST_BIS_THRESH_INFO, 3L>& value) {
        m_stBisThresh_ = value;
    }

    void stBisThresh(::dds::core::array< ST_BIS_THRESH_INFO, 3L>&& value) {
        m_stBisThresh_ = std::move(value);
    }

    bool operator == (const USERIF_BISTRK_THRESHOLD_INFO& other_) const;
    bool operator != (const USERIF_BISTRK_THRESHOLD_INFO& other_) const;

    void swap(USERIF_BISTRK_THRESHOLD_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsBisCitThrshAuto_;
    ::dds::core::array< ST_BIS_THRESH_INFO, 3L> m_stBisThresh_;

};

inline void swap(USERIF_BISTRK_THRESHOLD_INFO& a, USERIF_BISTRK_THRESHOLD_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BISTRK_THRESHOLD_INFO& sample);

class NDDSUSERDllExport USERIF_BIS_ACTIVE_PULSE_INFO {
  public:
    USERIF_BIS_ACTIVE_PULSE_INFO();

    USERIF_BIS_ACTIVE_PULSE_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t unpulsemode,const ::dds::core::array< float, 2L>& Cntrfrequency,const ::dds::core::array< float, 2L>& frequencyBndWdth,const ::dds::core::array< float, 2L>& fpulselength,const ::dds::core::array< float, 2L>& fpri,uint16_t usPulseSweep);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_ACTIVE_PULSE_INFO (USERIF_BIS_ACTIVE_PULSE_INFO&&) = default;
    USERIF_BIS_ACTIVE_PULSE_INFO& operator=(USERIF_BIS_ACTIVE_PULSE_INFO&&) = default;
    USERIF_BIS_ACTIVE_PULSE_INFO& operator=(const USERIF_BIS_ACTIVE_PULSE_INFO&) = default;
    USERIF_BIS_ACTIVE_PULSE_INFO(const USERIF_BIS_ACTIVE_PULSE_INFO&) = default;
    #else
    USERIF_BIS_ACTIVE_PULSE_INFO(USERIF_BIS_ACTIVE_PULSE_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_ACTIVE_PULSE_INFO& operator=(USERIF_BIS_ACTIVE_PULSE_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& unpulsemode() OMG_NOEXCEPT {
        return m_unpulsemode_;
    }

    const uint8_t& unpulsemode() const OMG_NOEXCEPT {
        return m_unpulsemode_;
    }

    void unpulsemode(uint8_t value) {
        m_unpulsemode_ = value;
    }

    ::dds::core::array< float, 2L>& Cntrfrequency() OMG_NOEXCEPT {
        return m_Cntrfrequency_;
    }

    const ::dds::core::array< float, 2L>& Cntrfrequency() const OMG_NOEXCEPT {
        return m_Cntrfrequency_;
    }

    void Cntrfrequency(const ::dds::core::array< float, 2L>& value) {
        m_Cntrfrequency_ = value;
    }

    void Cntrfrequency(::dds::core::array< float, 2L>&& value) {
        m_Cntrfrequency_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& frequencyBndWdth() OMG_NOEXCEPT {
        return m_frequencyBndWdth_;
    }

    const ::dds::core::array< float, 2L>& frequencyBndWdth() const OMG_NOEXCEPT {
        return m_frequencyBndWdth_;
    }

    void frequencyBndWdth(const ::dds::core::array< float, 2L>& value) {
        m_frequencyBndWdth_ = value;
    }

    void frequencyBndWdth(::dds::core::array< float, 2L>&& value) {
        m_frequencyBndWdth_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fpulselength() OMG_NOEXCEPT {
        return m_fpulselength_;
    }

    const ::dds::core::array< float, 2L>& fpulselength() const OMG_NOEXCEPT {
        return m_fpulselength_;
    }

    void fpulselength(const ::dds::core::array< float, 2L>& value) {
        m_fpulselength_ = value;
    }

    void fpulselength(::dds::core::array< float, 2L>&& value) {
        m_fpulselength_ = std::move(value);
    }
    ::dds::core::array< float, 2L>& fpri() OMG_NOEXCEPT {
        return m_fpri_;
    }

    const ::dds::core::array< float, 2L>& fpri() const OMG_NOEXCEPT {
        return m_fpri_;
    }

    void fpri(const ::dds::core::array< float, 2L>& value) {
        m_fpri_ = value;
    }

    void fpri(::dds::core::array< float, 2L>&& value) {
        m_fpri_ = std::move(value);
    }
    uint16_t& usPulseSweep() OMG_NOEXCEPT {
        return m_usPulseSweep_;
    }

    const uint16_t& usPulseSweep() const OMG_NOEXCEPT {
        return m_usPulseSweep_;
    }

    void usPulseSweep(uint16_t value) {
        m_usPulseSweep_ = value;
    }

    bool operator == (const USERIF_BIS_ACTIVE_PULSE_INFO& other_) const;
    bool operator != (const USERIF_BIS_ACTIVE_PULSE_INFO& other_) const;

    void swap(USERIF_BIS_ACTIVE_PULSE_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_unpulsemode_;
    ::dds::core::array< float, 2L> m_Cntrfrequency_;
    ::dds::core::array< float, 2L> m_frequencyBndWdth_;
    ::dds::core::array< float, 2L> m_fpulselength_;
    ::dds::core::array< float, 2L> m_fpri_;
    uint16_t m_usPulseSweep_;

};

inline void swap(USERIF_BIS_ACTIVE_PULSE_INFO& a, USERIF_BIS_ACTIVE_PULSE_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_ACTIVE_PULSE_INFO& sample);

class NDDSUSERDllExport USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST {
  public:
    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST();

    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,int32_t lRemoveClutterCtrlEnable,float fDopplerFreq,int32_t lAPDThresholdCtrlEnable,float fAPDThreshold,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST (USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST&&) = default;
    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& operator=(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST&&) = default;
    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& operator=(const USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST&) = default;
    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST(const USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST&) = default;
    #else
    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& operator=(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    int32_t& lRemoveClutterCtrlEnable() OMG_NOEXCEPT {
        return m_lRemoveClutterCtrlEnable_;
    }

    const int32_t& lRemoveClutterCtrlEnable() const OMG_NOEXCEPT {
        return m_lRemoveClutterCtrlEnable_;
    }

    void lRemoveClutterCtrlEnable(int32_t value) {
        m_lRemoveClutterCtrlEnable_ = value;
    }

    float& fDopplerFreq() OMG_NOEXCEPT {
        return m_fDopplerFreq_;
    }

    const float& fDopplerFreq() const OMG_NOEXCEPT {
        return m_fDopplerFreq_;
    }

    void fDopplerFreq(float value) {
        m_fDopplerFreq_ = value;
    }

    int32_t& lAPDThresholdCtrlEnable() OMG_NOEXCEPT {
        return m_lAPDThresholdCtrlEnable_;
    }

    const int32_t& lAPDThresholdCtrlEnable() const OMG_NOEXCEPT {
        return m_lAPDThresholdCtrlEnable_;
    }

    void lAPDThresholdCtrlEnable(int32_t value) {
        m_lAPDThresholdCtrlEnable_ = value;
    }

    float& fAPDThreshold() OMG_NOEXCEPT {
        return m_fAPDThreshold_;
    }

    const float& fAPDThreshold() const OMG_NOEXCEPT {
        return m_fAPDThreshold_;
    }

    void fAPDThreshold(float value) {
        m_fAPDThreshold_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& other_) const;

    void swap(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    int32_t m_lRemoveClutterCtrlEnable_;
    float m_fDopplerFreq_;
    int32_t m_lAPDThresholdCtrlEnable_;
    float m_fAPDThreshold_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& a, USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_BIS_DETECT_USERCONTROL_REQUEST {
  public:
    USERIF_BIS_DETECT_USERCONTROL_REQUEST();

    USERIF_BIS_DETECT_USERCONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 2L>& unStrtOn,uint8_t unActivepulsegainmode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_DETECT_USERCONTROL_REQUEST (USERIF_BIS_DETECT_USERCONTROL_REQUEST&&) = default;
    USERIF_BIS_DETECT_USERCONTROL_REQUEST& operator=(USERIF_BIS_DETECT_USERCONTROL_REQUEST&&) = default;
    USERIF_BIS_DETECT_USERCONTROL_REQUEST& operator=(const USERIF_BIS_DETECT_USERCONTROL_REQUEST&) = default;
    USERIF_BIS_DETECT_USERCONTROL_REQUEST(const USERIF_BIS_DETECT_USERCONTROL_REQUEST&) = default;
    #else
    USERIF_BIS_DETECT_USERCONTROL_REQUEST(USERIF_BIS_DETECT_USERCONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_DETECT_USERCONTROL_REQUEST& operator=(USERIF_BIS_DETECT_USERCONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& unStrtOn() OMG_NOEXCEPT {
        return m_unStrtOn_;
    }

    const ::dds::core::array< uint8_t, 2L>& unStrtOn() const OMG_NOEXCEPT {
        return m_unStrtOn_;
    }

    void unStrtOn(const ::dds::core::array< uint8_t, 2L>& value) {
        m_unStrtOn_ = value;
    }

    void unStrtOn(::dds::core::array< uint8_t, 2L>&& value) {
        m_unStrtOn_ = std::move(value);
    }
    uint8_t& unActivepulsegainmode() OMG_NOEXCEPT {
        return m_unActivepulsegainmode_;
    }

    const uint8_t& unActivepulsegainmode() const OMG_NOEXCEPT {
        return m_unActivepulsegainmode_;
    }

    void unActivepulsegainmode(uint8_t value) {
        m_unActivepulsegainmode_ = value;
    }

    bool operator == (const USERIF_BIS_DETECT_USERCONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_DETECT_USERCONTROL_REQUEST& other_) const;

    void swap(USERIF_BIS_DETECT_USERCONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 2L> m_unStrtOn_;
    uint8_t m_unActivepulsegainmode_;

};

inline void swap(USERIF_BIS_DETECT_USERCONTROL_REQUEST& a, USERIF_BIS_DETECT_USERCONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_DETECT_USERCONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_BIS_MOVINFO_CONTROL_REQUEST {
  public:
    USERIF_BIS_MOVINFO_CONTROL_REQUEST();

    USERIF_BIS_MOVINFO_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usTgtType,uint16_t usTgtNo,uint8_t unSend);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_MOVINFO_CONTROL_REQUEST (USERIF_BIS_MOVINFO_CONTROL_REQUEST&&) = default;
    USERIF_BIS_MOVINFO_CONTROL_REQUEST& operator=(USERIF_BIS_MOVINFO_CONTROL_REQUEST&&) = default;
    USERIF_BIS_MOVINFO_CONTROL_REQUEST& operator=(const USERIF_BIS_MOVINFO_CONTROL_REQUEST&) = default;
    USERIF_BIS_MOVINFO_CONTROL_REQUEST(const USERIF_BIS_MOVINFO_CONTROL_REQUEST&) = default;
    #else
    USERIF_BIS_MOVINFO_CONTROL_REQUEST(USERIF_BIS_MOVINFO_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_MOVINFO_CONTROL_REQUEST& operator=(USERIF_BIS_MOVINFO_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usTgtType() OMG_NOEXCEPT {
        return m_usTgtType_;
    }

    const uint16_t& usTgtType() const OMG_NOEXCEPT {
        return m_usTgtType_;
    }

    void usTgtType(uint16_t value) {
        m_usTgtType_ = value;
    }

    uint16_t& usTgtNo() OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    const uint16_t& usTgtNo() const OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    void usTgtNo(uint16_t value) {
        m_usTgtNo_ = value;
    }

    uint8_t& unSend() OMG_NOEXCEPT {
        return m_unSend_;
    }

    const uint8_t& unSend() const OMG_NOEXCEPT {
        return m_unSend_;
    }

    void unSend(uint8_t value) {
        m_unSend_ = value;
    }

    bool operator == (const USERIF_BIS_MOVINFO_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_MOVINFO_CONTROL_REQUEST& other_) const;

    void swap(USERIF_BIS_MOVINFO_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usTgtType_;
    uint16_t m_usTgtNo_;
    uint8_t m_unSend_;

};

inline void swap(USERIF_BIS_MOVINFO_CONTROL_REQUEST& a, USERIF_BIS_MOVINFO_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_MOVINFO_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST {
  public:
    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST();

    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerControl,uint8_t oReceiverPowerControl,uint8_t oProcessorPowerControl,uint8_t oNetworkPowerControl,uint8_t oDisplayPowerControl);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST (USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST&&) = default;
    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST&&) = default;
    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(const USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST&) = default;
    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST(const USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST&) = default;
    #else
    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerControl() OMG_NOEXCEPT {
        return m_oPowerSupplyPowerControl_;
    }

    const ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerControl() const OMG_NOEXCEPT {
        return m_oPowerSupplyPowerControl_;
    }

    void oPowerSupplyPowerControl(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oPowerSupplyPowerControl_ = value;
    }

    void oPowerSupplyPowerControl(::dds::core::array< uint8_t, 3L>&& value) {
        m_oPowerSupplyPowerControl_ = std::move(value);
    }
    uint8_t& oReceiverPowerControl() OMG_NOEXCEPT {
        return m_oReceiverPowerControl_;
    }

    const uint8_t& oReceiverPowerControl() const OMG_NOEXCEPT {
        return m_oReceiverPowerControl_;
    }

    void oReceiverPowerControl(uint8_t value) {
        m_oReceiverPowerControl_ = value;
    }

    uint8_t& oProcessorPowerControl() OMG_NOEXCEPT {
        return m_oProcessorPowerControl_;
    }

    const uint8_t& oProcessorPowerControl() const OMG_NOEXCEPT {
        return m_oProcessorPowerControl_;
    }

    void oProcessorPowerControl(uint8_t value) {
        m_oProcessorPowerControl_ = value;
    }

    uint8_t& oNetworkPowerControl() OMG_NOEXCEPT {
        return m_oNetworkPowerControl_;
    }

    const uint8_t& oNetworkPowerControl() const OMG_NOEXCEPT {
        return m_oNetworkPowerControl_;
    }

    void oNetworkPowerControl(uint8_t value) {
        m_oNetworkPowerControl_ = value;
    }

    uint8_t& oDisplayPowerControl() OMG_NOEXCEPT {
        return m_oDisplayPowerControl_;
    }

    const uint8_t& oDisplayPowerControl() const OMG_NOEXCEPT {
        return m_oDisplayPowerControl_;
    }

    void oDisplayPowerControl(uint8_t value) {
        m_oDisplayPowerControl_ = value;
    }

    bool operator == (const USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) const;

    void swap(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 3L> m_oPowerSupplyPowerControl_;
    uint8_t m_oReceiverPowerControl_;
    uint8_t m_oProcessorPowerControl_;
    uint8_t m_oNetworkPowerControl_;
    uint8_t m_oDisplayPowerControl_;

};

inline void swap(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& a, USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_BIS_SENSOR_CONTROL_REQUEST {
  public:
    USERIF_BIS_SENSOR_CONTROL_REQUEST();

    USERIF_BIS_SENSOR_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 3L>& oGainCtrlMode,const ::dds::core::array< uint8_t, 3L>& oAGCvalue_Main,const ::dds::core::array< uint8_t, 3L>& oAGCvalue_Sub,const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Tx,const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Rx,const ::dds::core::array< uint8_t, 3L>& oMainMuxSwitch);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_SENSOR_CONTROL_REQUEST (USERIF_BIS_SENSOR_CONTROL_REQUEST&&) = default;
    USERIF_BIS_SENSOR_CONTROL_REQUEST& operator=(USERIF_BIS_SENSOR_CONTROL_REQUEST&&) = default;
    USERIF_BIS_SENSOR_CONTROL_REQUEST& operator=(const USERIF_BIS_SENSOR_CONTROL_REQUEST&) = default;
    USERIF_BIS_SENSOR_CONTROL_REQUEST(const USERIF_BIS_SENSOR_CONTROL_REQUEST&) = default;
    #else
    USERIF_BIS_SENSOR_CONTROL_REQUEST(USERIF_BIS_SENSOR_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_SENSOR_CONTROL_REQUEST& operator=(USERIF_BIS_SENSOR_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oGainCtrlMode() OMG_NOEXCEPT {
        return m_oGainCtrlMode_;
    }

    const ::dds::core::array< uint8_t, 3L>& oGainCtrlMode() const OMG_NOEXCEPT {
        return m_oGainCtrlMode_;
    }

    void oGainCtrlMode(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oGainCtrlMode_ = value;
    }

    void oGainCtrlMode(::dds::core::array< uint8_t, 3L>&& value) {
        m_oGainCtrlMode_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oAGCvalue_Main() OMG_NOEXCEPT {
        return m_oAGCvalue_Main_;
    }

    const ::dds::core::array< uint8_t, 3L>& oAGCvalue_Main() const OMG_NOEXCEPT {
        return m_oAGCvalue_Main_;
    }

    void oAGCvalue_Main(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oAGCvalue_Main_ = value;
    }

    void oAGCvalue_Main(::dds::core::array< uint8_t, 3L>&& value) {
        m_oAGCvalue_Main_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oAGCvalue_Sub() OMG_NOEXCEPT {
        return m_oAGCvalue_Sub_;
    }

    const ::dds::core::array< uint8_t, 3L>& oAGCvalue_Sub() const OMG_NOEXCEPT {
        return m_oAGCvalue_Sub_;
    }

    void oAGCvalue_Sub(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oAGCvalue_Sub_ = value;
    }

    void oAGCvalue_Sub(::dds::core::array< uint8_t, 3L>&& value) {
        m_oAGCvalue_Sub_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oEOSwitch_Tx() OMG_NOEXCEPT {
        return m_oEOSwitch_Tx_;
    }

    const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Tx() const OMG_NOEXCEPT {
        return m_oEOSwitch_Tx_;
    }

    void oEOSwitch_Tx(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oEOSwitch_Tx_ = value;
    }

    void oEOSwitch_Tx(::dds::core::array< uint8_t, 3L>&& value) {
        m_oEOSwitch_Tx_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oEOSwitch_Rx() OMG_NOEXCEPT {
        return m_oEOSwitch_Rx_;
    }

    const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Rx() const OMG_NOEXCEPT {
        return m_oEOSwitch_Rx_;
    }

    void oEOSwitch_Rx(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oEOSwitch_Rx_ = value;
    }

    void oEOSwitch_Rx(::dds::core::array< uint8_t, 3L>&& value) {
        m_oEOSwitch_Rx_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oMainMuxSwitch() OMG_NOEXCEPT {
        return m_oMainMuxSwitch_;
    }

    const ::dds::core::array< uint8_t, 3L>& oMainMuxSwitch() const OMG_NOEXCEPT {
        return m_oMainMuxSwitch_;
    }

    void oMainMuxSwitch(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oMainMuxSwitch_ = value;
    }

    void oMainMuxSwitch(::dds::core::array< uint8_t, 3L>&& value) {
        m_oMainMuxSwitch_ = std::move(value);
    }

    bool operator == (const USERIF_BIS_SENSOR_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_SENSOR_CONTROL_REQUEST& other_) const;

    void swap(USERIF_BIS_SENSOR_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 3L> m_oGainCtrlMode_;
    ::dds::core::array< uint8_t, 3L> m_oAGCvalue_Main_;
    ::dds::core::array< uint8_t, 3L> m_oAGCvalue_Sub_;
    ::dds::core::array< uint8_t, 3L> m_oEOSwitch_Tx_;
    ::dds::core::array< uint8_t, 3L> m_oEOSwitch_Rx_;
    ::dds::core::array< uint8_t, 3L> m_oMainMuxSwitch_;

};

inline void swap(USERIF_BIS_SENSOR_CONTROL_REQUEST& a, USERIF_BIS_SENSOR_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_SENSOR_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST {
  public:
    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST();

    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ::dds::core::array< uint8_t, 144L>, 3L>& unSensorStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST (USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST&&) = default;
    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST&&) = default;
    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(const USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST&) = default;
    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST(const USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST&) = default;
    #else
    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint8_t, 144L>, 3L>& unSensorStatus() OMG_NOEXCEPT {
        return m_unSensorStatus_;
    }

    const ::dds::core::array< ::dds::core::array< uint8_t, 144L>, 3L>& unSensorStatus() const OMG_NOEXCEPT {
        return m_unSensorStatus_;
    }

    void unSensorStatus(const ::dds::core::array< ::dds::core::array< uint8_t, 144L>, 3L>& value) {
        m_unSensorStatus_ = value;
    }

    void unSensorStatus(::dds::core::array< ::dds::core::array< uint8_t, 144L>, 3L>&& value) {
        m_unSensorStatus_ = std::move(value);
    }

    bool operator == (const USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) const;

    void swap(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ::dds::core::array< uint8_t, 144L>, 3L> m_unSensorStatus_;

};

inline void swap(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& a, USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample);

class NDDSUSERDllExport ST_BI_SOURCE_CONFIRM_SET {
  public:
    ST_BI_SOURCE_CONFIRM_SET();

    ST_BI_SOURCE_CONFIRM_SET(uint8_t oTemperDBType,uint16_t usMonth,uint16_t usDay,const ST_USER_TEMP_INFO& stTempInfo,const ST_SOUND_INFO& stSoundInfo,float fMinTgtDepth,float fMaxTgtDepth,float fTargetSpeed,const ST_BI_TS_INFO& stBITSInfo,float fTransmitterDepth,int32_t lSoundArrivalTime,float fTgtCourseAngle,float fTgtMoveSpd,double dTgtPosLat,double dTgtPosLon);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BI_SOURCE_CONFIRM_SET (ST_BI_SOURCE_CONFIRM_SET&&) = default;
    ST_BI_SOURCE_CONFIRM_SET& operator=(ST_BI_SOURCE_CONFIRM_SET&&) = default;
    ST_BI_SOURCE_CONFIRM_SET& operator=(const ST_BI_SOURCE_CONFIRM_SET&) = default;
    ST_BI_SOURCE_CONFIRM_SET(const ST_BI_SOURCE_CONFIRM_SET&) = default;
    #else
    ST_BI_SOURCE_CONFIRM_SET(ST_BI_SOURCE_CONFIRM_SET&& other_) OMG_NOEXCEPT;  
    ST_BI_SOURCE_CONFIRM_SET& operator=(ST_BI_SOURCE_CONFIRM_SET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oTemperDBType() OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    const uint8_t& oTemperDBType() const OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    void oTemperDBType(uint8_t value) {
        m_oTemperDBType_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    ST_USER_TEMP_INFO& stTempInfo() OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    const ST_USER_TEMP_INFO& stTempInfo() const OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    void stTempInfo(const ST_USER_TEMP_INFO& value) {
        m_stTempInfo_ = value;
    }

    void stTempInfo(ST_USER_TEMP_INFO&& value) {
        m_stTempInfo_ = std::move(value);
    }
    ST_SOUND_INFO& stSoundInfo() OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    const ST_SOUND_INFO& stSoundInfo() const OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    void stSoundInfo(const ST_SOUND_INFO& value) {
        m_stSoundInfo_ = value;
    }

    void stSoundInfo(ST_SOUND_INFO&& value) {
        m_stSoundInfo_ = std::move(value);
    }
    float& fMinTgtDepth() OMG_NOEXCEPT {
        return m_fMinTgtDepth_;
    }

    const float& fMinTgtDepth() const OMG_NOEXCEPT {
        return m_fMinTgtDepth_;
    }

    void fMinTgtDepth(float value) {
        m_fMinTgtDepth_ = value;
    }

    float& fMaxTgtDepth() OMG_NOEXCEPT {
        return m_fMaxTgtDepth_;
    }

    const float& fMaxTgtDepth() const OMG_NOEXCEPT {
        return m_fMaxTgtDepth_;
    }

    void fMaxTgtDepth(float value) {
        m_fMaxTgtDepth_ = value;
    }

    float& fTargetSpeed() OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    const float& fTargetSpeed() const OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    void fTargetSpeed(float value) {
        m_fTargetSpeed_ = value;
    }

    ST_BI_TS_INFO& stBITSInfo() OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    const ST_BI_TS_INFO& stBITSInfo() const OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    void stBITSInfo(const ST_BI_TS_INFO& value) {
        m_stBITSInfo_ = value;
    }

    void stBITSInfo(ST_BI_TS_INFO&& value) {
        m_stBITSInfo_ = std::move(value);
    }
    float& fTransmitterDepth() OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    const float& fTransmitterDepth() const OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    void fTransmitterDepth(float value) {
        m_fTransmitterDepth_ = value;
    }

    int32_t& lSoundArrivalTime() OMG_NOEXCEPT {
        return m_lSoundArrivalTime_;
    }

    const int32_t& lSoundArrivalTime() const OMG_NOEXCEPT {
        return m_lSoundArrivalTime_;
    }

    void lSoundArrivalTime(int32_t value) {
        m_lSoundArrivalTime_ = value;
    }

    float& fTgtCourseAngle() OMG_NOEXCEPT {
        return m_fTgtCourseAngle_;
    }

    const float& fTgtCourseAngle() const OMG_NOEXCEPT {
        return m_fTgtCourseAngle_;
    }

    void fTgtCourseAngle(float value) {
        m_fTgtCourseAngle_ = value;
    }

    float& fTgtMoveSpd() OMG_NOEXCEPT {
        return m_fTgtMoveSpd_;
    }

    const float& fTgtMoveSpd() const OMG_NOEXCEPT {
        return m_fTgtMoveSpd_;
    }

    void fTgtMoveSpd(float value) {
        m_fTgtMoveSpd_ = value;
    }

    double& dTgtPosLat() OMG_NOEXCEPT {
        return m_dTgtPosLat_;
    }

    const double& dTgtPosLat() const OMG_NOEXCEPT {
        return m_dTgtPosLat_;
    }

    void dTgtPosLat(double value) {
        m_dTgtPosLat_ = value;
    }

    double& dTgtPosLon() OMG_NOEXCEPT {
        return m_dTgtPosLon_;
    }

    const double& dTgtPosLon() const OMG_NOEXCEPT {
        return m_dTgtPosLon_;
    }

    void dTgtPosLon(double value) {
        m_dTgtPosLon_ = value;
    }

    bool operator == (const ST_BI_SOURCE_CONFIRM_SET& other_) const;
    bool operator != (const ST_BI_SOURCE_CONFIRM_SET& other_) const;

    void swap(ST_BI_SOURCE_CONFIRM_SET& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oTemperDBType_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;
    ST_USER_TEMP_INFO m_stTempInfo_;
    ST_SOUND_INFO m_stSoundInfo_;
    float m_fMinTgtDepth_;
    float m_fMaxTgtDepth_;
    float m_fTargetSpeed_;
    ST_BI_TS_INFO m_stBITSInfo_;
    float m_fTransmitterDepth_;
    int32_t m_lSoundArrivalTime_;
    float m_fTgtCourseAngle_;
    float m_fTgtMoveSpd_;
    double m_dTgtPosLat_;
    double m_dTgtPosLon_;

};

inline void swap(ST_BI_SOURCE_CONFIRM_SET& a, ST_BI_SOURCE_CONFIRM_SET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BI_SOURCE_CONFIRM_SET& sample);

class NDDSUSERDllExport USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST {
  public:
    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST();

    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ST_BI_SOURCE_CONFIRM_SET& stBISrcPosConfirm);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST (USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST&&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& operator=(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST&&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& operator=(const USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST(const USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST&) = default;
    #else
    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& operator=(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_BI_SOURCE_CONFIRM_SET& stBISrcPosConfirm() OMG_NOEXCEPT {
        return m_stBISrcPosConfirm_;
    }

    const ST_BI_SOURCE_CONFIRM_SET& stBISrcPosConfirm() const OMG_NOEXCEPT {
        return m_stBISrcPosConfirm_;
    }

    void stBISrcPosConfirm(const ST_BI_SOURCE_CONFIRM_SET& value) {
        m_stBISrcPosConfirm_ = value;
    }

    void stBISrcPosConfirm(ST_BI_SOURCE_CONFIRM_SET&& value) {
        m_stBISrcPosConfirm_ = std::move(value);
    }

    bool operator == (const USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& other_) const;

    void swap(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_BI_SOURCE_CONFIRM_SET m_stBISrcPosConfirm_;

};

inline void swap(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& a, USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& sample);

class NDDSUSERDllExport ST_POSITION_INFO {
  public:
    ST_POSITION_INFO();

    ST_POSITION_INFO(double dLatitude,double dLongitude);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_POSITION_INFO (ST_POSITION_INFO&&) = default;
    ST_POSITION_INFO& operator=(ST_POSITION_INFO&&) = default;
    ST_POSITION_INFO& operator=(const ST_POSITION_INFO&) = default;
    ST_POSITION_INFO(const ST_POSITION_INFO&) = default;
    #else
    ST_POSITION_INFO(ST_POSITION_INFO&& other_) OMG_NOEXCEPT;  
    ST_POSITION_INFO& operator=(ST_POSITION_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    bool operator == (const ST_POSITION_INFO& other_) const;
    bool operator != (const ST_POSITION_INFO& other_) const;

    void swap(ST_POSITION_INFO& other_) OMG_NOEXCEPT ;

  private:

    double m_dLatitude_;
    double m_dLongitude_;

};

inline void swap(ST_POSITION_INFO& a, ST_POSITION_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_POSITION_INFO& sample);

class NDDSUSERDllExport ST_QROUTE_INFO {
  public:
    ST_QROUTE_INFO();

    ST_QROUTE_INFO(uint16_t usQrouteNum,const ::dds::core::array< ST_POSITION_INFO, 20L>& stQroute);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_QROUTE_INFO (ST_QROUTE_INFO&&) = default;
    ST_QROUTE_INFO& operator=(ST_QROUTE_INFO&&) = default;
    ST_QROUTE_INFO& operator=(const ST_QROUTE_INFO&) = default;
    ST_QROUTE_INFO(const ST_QROUTE_INFO&) = default;
    #else
    ST_QROUTE_INFO(ST_QROUTE_INFO&& other_) OMG_NOEXCEPT;  
    ST_QROUTE_INFO& operator=(ST_QROUTE_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint16_t& usQrouteNum() OMG_NOEXCEPT {
        return m_usQrouteNum_;
    }

    const uint16_t& usQrouteNum() const OMG_NOEXCEPT {
        return m_usQrouteNum_;
    }

    void usQrouteNum(uint16_t value) {
        m_usQrouteNum_ = value;
    }

    ::dds::core::array< ST_POSITION_INFO, 20L>& stQroute() OMG_NOEXCEPT {
        return m_stQroute_;
    }

    const ::dds::core::array< ST_POSITION_INFO, 20L>& stQroute() const OMG_NOEXCEPT {
        return m_stQroute_;
    }

    void stQroute(const ::dds::core::array< ST_POSITION_INFO, 20L>& value) {
        m_stQroute_ = value;
    }

    void stQroute(::dds::core::array< ST_POSITION_INFO, 20L>&& value) {
        m_stQroute_ = std::move(value);
    }

    bool operator == (const ST_QROUTE_INFO& other_) const;
    bool operator != (const ST_QROUTE_INFO& other_) const;

    void swap(ST_QROUTE_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint16_t m_usQrouteNum_;
    ::dds::core::array< ST_POSITION_INFO, 20L> m_stQroute_;

};

inline void swap(ST_QROUTE_INFO& a, ST_QROUTE_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_QROUTE_INFO& sample);

class NDDSUSERDllExport ST_BI_SOURCE_FIND_SET {
  public:
    ST_BI_SOURCE_FIND_SET();

    ST_BI_SOURCE_FIND_SET(const ::dds::core::array< ST_QROUTE_INFO, 3L>& stQroute,const ST_SOUND_INFO& stSoundInfo,float fMinTgtDepth,float fMaxTgtDepth,float fTargetSpeed,const ST_BI_TS_INFO& stBITSInfo,float fTransmitterDepth,uint16_t usRefSensorIDForBearingTgt,float fAzimuthForBearingTgt,float fTgtBearing);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BI_SOURCE_FIND_SET (ST_BI_SOURCE_FIND_SET&&) = default;
    ST_BI_SOURCE_FIND_SET& operator=(ST_BI_SOURCE_FIND_SET&&) = default;
    ST_BI_SOURCE_FIND_SET& operator=(const ST_BI_SOURCE_FIND_SET&) = default;
    ST_BI_SOURCE_FIND_SET(const ST_BI_SOURCE_FIND_SET&) = default;
    #else
    ST_BI_SOURCE_FIND_SET(ST_BI_SOURCE_FIND_SET&& other_) OMG_NOEXCEPT;  
    ST_BI_SOURCE_FIND_SET& operator=(ST_BI_SOURCE_FIND_SET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ::dds::core::array< ST_QROUTE_INFO, 3L>& stQroute() OMG_NOEXCEPT {
        return m_stQroute_;
    }

    const ::dds::core::array< ST_QROUTE_INFO, 3L>& stQroute() const OMG_NOEXCEPT {
        return m_stQroute_;
    }

    void stQroute(const ::dds::core::array< ST_QROUTE_INFO, 3L>& value) {
        m_stQroute_ = value;
    }

    void stQroute(::dds::core::array< ST_QROUTE_INFO, 3L>&& value) {
        m_stQroute_ = std::move(value);
    }
    ST_SOUND_INFO& stSoundInfo() OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    const ST_SOUND_INFO& stSoundInfo() const OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    void stSoundInfo(const ST_SOUND_INFO& value) {
        m_stSoundInfo_ = value;
    }

    void stSoundInfo(ST_SOUND_INFO&& value) {
        m_stSoundInfo_ = std::move(value);
    }
    float& fMinTgtDepth() OMG_NOEXCEPT {
        return m_fMinTgtDepth_;
    }

    const float& fMinTgtDepth() const OMG_NOEXCEPT {
        return m_fMinTgtDepth_;
    }

    void fMinTgtDepth(float value) {
        m_fMinTgtDepth_ = value;
    }

    float& fMaxTgtDepth() OMG_NOEXCEPT {
        return m_fMaxTgtDepth_;
    }

    const float& fMaxTgtDepth() const OMG_NOEXCEPT {
        return m_fMaxTgtDepth_;
    }

    void fMaxTgtDepth(float value) {
        m_fMaxTgtDepth_ = value;
    }

    float& fTargetSpeed() OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    const float& fTargetSpeed() const OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    void fTargetSpeed(float value) {
        m_fTargetSpeed_ = value;
    }

    ST_BI_TS_INFO& stBITSInfo() OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    const ST_BI_TS_INFO& stBITSInfo() const OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    void stBITSInfo(const ST_BI_TS_INFO& value) {
        m_stBITSInfo_ = value;
    }

    void stBITSInfo(ST_BI_TS_INFO&& value) {
        m_stBITSInfo_ = std::move(value);
    }
    float& fTransmitterDepth() OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    const float& fTransmitterDepth() const OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    void fTransmitterDepth(float value) {
        m_fTransmitterDepth_ = value;
    }

    uint16_t& usRefSensorIDForBearingTgt() OMG_NOEXCEPT {
        return m_usRefSensorIDForBearingTgt_;
    }

    const uint16_t& usRefSensorIDForBearingTgt() const OMG_NOEXCEPT {
        return m_usRefSensorIDForBearingTgt_;
    }

    void usRefSensorIDForBearingTgt(uint16_t value) {
        m_usRefSensorIDForBearingTgt_ = value;
    }

    float& fAzimuthForBearingTgt() OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    const float& fAzimuthForBearingTgt() const OMG_NOEXCEPT {
        return m_fAzimuthForBearingTgt_;
    }

    void fAzimuthForBearingTgt(float value) {
        m_fAzimuthForBearingTgt_ = value;
    }

    float& fTgtBearing() OMG_NOEXCEPT {
        return m_fTgtBearing_;
    }

    const float& fTgtBearing() const OMG_NOEXCEPT {
        return m_fTgtBearing_;
    }

    void fTgtBearing(float value) {
        m_fTgtBearing_ = value;
    }

    bool operator == (const ST_BI_SOURCE_FIND_SET& other_) const;
    bool operator != (const ST_BI_SOURCE_FIND_SET& other_) const;

    void swap(ST_BI_SOURCE_FIND_SET& other_) OMG_NOEXCEPT ;

  private:

    ::dds::core::array< ST_QROUTE_INFO, 3L> m_stQroute_;
    ST_SOUND_INFO m_stSoundInfo_;
    float m_fMinTgtDepth_;
    float m_fMaxTgtDepth_;
    float m_fTargetSpeed_;
    ST_BI_TS_INFO m_stBITSInfo_;
    float m_fTransmitterDepth_;
    uint16_t m_usRefSensorIDForBearingTgt_;
    float m_fAzimuthForBearingTgt_;
    float m_fTgtBearing_;

};

inline void swap(ST_BI_SOURCE_FIND_SET& a, ST_BI_SOURCE_FIND_SET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BI_SOURCE_FIND_SET& sample);

class NDDSUSERDllExport USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST {
  public:
    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST();

    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ST_BI_SOURCE_FIND_SET& stBISrcPosFind);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST (USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST&&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& operator=(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST&&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& operator=(const USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST(const USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST&) = default;
    #else
    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& operator=(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_BI_SOURCE_FIND_SET& stBISrcPosFind() OMG_NOEXCEPT {
        return m_stBISrcPosFind_;
    }

    const ST_BI_SOURCE_FIND_SET& stBISrcPosFind() const OMG_NOEXCEPT {
        return m_stBISrcPosFind_;
    }

    void stBISrcPosFind(const ST_BI_SOURCE_FIND_SET& value) {
        m_stBISrcPosFind_ = value;
    }

    void stBISrcPosFind(ST_BI_SOURCE_FIND_SET&& value) {
        m_stBISrcPosFind_ = std::move(value);
    }

    bool operator == (const USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& other_) const;

    void swap(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_BI_SOURCE_FIND_SET m_stBISrcPosFind_;

};

inline void swap(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& a, USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& sample);

class NDDSUSERDllExport ST_BI_SOURCE_SEARCH_SET {
  public:
    ST_BI_SOURCE_SEARCH_SET();

    ST_BI_SOURCE_SEARCH_SET(uint8_t oTemperDBType,uint16_t usMonth,uint16_t usDay,const ::dds::core::array< ST_POSITION_INFO, 2L>& stSearchArea,const ::dds::core::array< ST_QROUTE_INFO, 3L>& stQroute,const ST_SOUND_INFO& stSoundInfo,uint16_t usSoundNum,float fMinTgtDepth,float fMaxTgtDepth,float fTargetSpeed,const ST_BI_TS_INFO& stBITSInfo,float fTransmitterDepth);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BI_SOURCE_SEARCH_SET (ST_BI_SOURCE_SEARCH_SET&&) = default;
    ST_BI_SOURCE_SEARCH_SET& operator=(ST_BI_SOURCE_SEARCH_SET&&) = default;
    ST_BI_SOURCE_SEARCH_SET& operator=(const ST_BI_SOURCE_SEARCH_SET&) = default;
    ST_BI_SOURCE_SEARCH_SET(const ST_BI_SOURCE_SEARCH_SET&) = default;
    #else
    ST_BI_SOURCE_SEARCH_SET(ST_BI_SOURCE_SEARCH_SET&& other_) OMG_NOEXCEPT;  
    ST_BI_SOURCE_SEARCH_SET& operator=(ST_BI_SOURCE_SEARCH_SET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oTemperDBType() OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    const uint8_t& oTemperDBType() const OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    void oTemperDBType(uint8_t value) {
        m_oTemperDBType_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    ::dds::core::array< ST_POSITION_INFO, 2L>& stSearchArea() OMG_NOEXCEPT {
        return m_stSearchArea_;
    }

    const ::dds::core::array< ST_POSITION_INFO, 2L>& stSearchArea() const OMG_NOEXCEPT {
        return m_stSearchArea_;
    }

    void stSearchArea(const ::dds::core::array< ST_POSITION_INFO, 2L>& value) {
        m_stSearchArea_ = value;
    }

    void stSearchArea(::dds::core::array< ST_POSITION_INFO, 2L>&& value) {
        m_stSearchArea_ = std::move(value);
    }
    ::dds::core::array< ST_QROUTE_INFO, 3L>& stQroute() OMG_NOEXCEPT {
        return m_stQroute_;
    }

    const ::dds::core::array< ST_QROUTE_INFO, 3L>& stQroute() const OMG_NOEXCEPT {
        return m_stQroute_;
    }

    void stQroute(const ::dds::core::array< ST_QROUTE_INFO, 3L>& value) {
        m_stQroute_ = value;
    }

    void stQroute(::dds::core::array< ST_QROUTE_INFO, 3L>&& value) {
        m_stQroute_ = std::move(value);
    }
    ST_SOUND_INFO& stSoundInfo() OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    const ST_SOUND_INFO& stSoundInfo() const OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    void stSoundInfo(const ST_SOUND_INFO& value) {
        m_stSoundInfo_ = value;
    }

    void stSoundInfo(ST_SOUND_INFO&& value) {
        m_stSoundInfo_ = std::move(value);
    }
    uint16_t& usSoundNum() OMG_NOEXCEPT {
        return m_usSoundNum_;
    }

    const uint16_t& usSoundNum() const OMG_NOEXCEPT {
        return m_usSoundNum_;
    }

    void usSoundNum(uint16_t value) {
        m_usSoundNum_ = value;
    }

    float& fMinTgtDepth() OMG_NOEXCEPT {
        return m_fMinTgtDepth_;
    }

    const float& fMinTgtDepth() const OMG_NOEXCEPT {
        return m_fMinTgtDepth_;
    }

    void fMinTgtDepth(float value) {
        m_fMinTgtDepth_ = value;
    }

    float& fMaxTgtDepth() OMG_NOEXCEPT {
        return m_fMaxTgtDepth_;
    }

    const float& fMaxTgtDepth() const OMG_NOEXCEPT {
        return m_fMaxTgtDepth_;
    }

    void fMaxTgtDepth(float value) {
        m_fMaxTgtDepth_ = value;
    }

    float& fTargetSpeed() OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    const float& fTargetSpeed() const OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    void fTargetSpeed(float value) {
        m_fTargetSpeed_ = value;
    }

    ST_BI_TS_INFO& stBITSInfo() OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    const ST_BI_TS_INFO& stBITSInfo() const OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    void stBITSInfo(const ST_BI_TS_INFO& value) {
        m_stBITSInfo_ = value;
    }

    void stBITSInfo(ST_BI_TS_INFO&& value) {
        m_stBITSInfo_ = std::move(value);
    }
    float& fTransmitterDepth() OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    const float& fTransmitterDepth() const OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    void fTransmitterDepth(float value) {
        m_fTransmitterDepth_ = value;
    }

    bool operator == (const ST_BI_SOURCE_SEARCH_SET& other_) const;
    bool operator != (const ST_BI_SOURCE_SEARCH_SET& other_) const;

    void swap(ST_BI_SOURCE_SEARCH_SET& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oTemperDBType_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;
    ::dds::core::array< ST_POSITION_INFO, 2L> m_stSearchArea_;
    ::dds::core::array< ST_QROUTE_INFO, 3L> m_stQroute_;
    ST_SOUND_INFO m_stSoundInfo_;
    uint16_t m_usSoundNum_;
    float m_fMinTgtDepth_;
    float m_fMaxTgtDepth_;
    float m_fTargetSpeed_;
    ST_BI_TS_INFO m_stBITSInfo_;
    float m_fTransmitterDepth_;

};

inline void swap(ST_BI_SOURCE_SEARCH_SET& a, ST_BI_SOURCE_SEARCH_SET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BI_SOURCE_SEARCH_SET& sample);

class NDDSUSERDllExport USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST {
  public:
    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST();

    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ST_BI_SOURCE_SEARCH_SET& stBISSrcPosSearch);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST (USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST&&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& operator=(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST&&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& operator=(const USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST&) = default;
    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST(const USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST&) = default;
    #else
    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& operator=(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_BI_SOURCE_SEARCH_SET& stBISSrcPosSearch() OMG_NOEXCEPT {
        return m_stBISSrcPosSearch_;
    }

    const ST_BI_SOURCE_SEARCH_SET& stBISSrcPosSearch() const OMG_NOEXCEPT {
        return m_stBISSrcPosSearch_;
    }

    void stBISSrcPosSearch(const ST_BI_SOURCE_SEARCH_SET& value) {
        m_stBISSrcPosSearch_ = value;
    }

    void stBISSrcPosSearch(ST_BI_SOURCE_SEARCH_SET&& value) {
        m_stBISSrcPosSearch_ = std::move(value);
    }

    bool operator == (const USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& other_) const;

    void swap(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_BI_SOURCE_SEARCH_SET m_stBISSrcPosSearch_;

};

inline void swap(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& a, USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& sample);

class NDDSUSERDllExport USERIF_BIS_SOURCE_DB_CONTROL_REQUEST {
  public:
    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST();

    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint16_t usDataNum,const ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& stBISSourceDBInfo,const ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& stTypeMatchingInfo,const ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& stShipMatchingInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST (USERIF_BIS_SOURCE_DB_CONTROL_REQUEST&&) = default;
    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& operator=(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST&&) = default;
    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& operator=(const USERIF_BIS_SOURCE_DB_CONTROL_REQUEST&) = default;
    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST(const USERIF_BIS_SOURCE_DB_CONTROL_REQUEST&) = default;
    #else
    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& operator=(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint16_t& usDataNum() OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    const uint16_t& usDataNum() const OMG_NOEXCEPT {
        return m_usDataNum_;
    }

    void usDataNum(uint16_t value) {
        m_usDataNum_ = value;
    }

    ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& stBISSourceDBInfo() OMG_NOEXCEPT {
        return m_stBISSourceDBInfo_;
    }

    const ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& stBISSourceDBInfo() const OMG_NOEXCEPT {
        return m_stBISSourceDBInfo_;
    }

    void stBISSourceDBInfo(const ::dds::core::array< ST_BIS_SOURCE_DB, 1000L>& value) {
        m_stBISSourceDBInfo_ = value;
    }

    void stBISSourceDBInfo(::dds::core::array< ST_BIS_SOURCE_DB, 1000L>&& value) {
        m_stBISSourceDBInfo_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& stTypeMatchingInfo() OMG_NOEXCEPT {
        return m_stTypeMatchingInfo_;
    }

    const ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& stTypeMatchingInfo() const OMG_NOEXCEPT {
        return m_stTypeMatchingInfo_;
    }

    void stTypeMatchingInfo(const ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>& value) {
        m_stTypeMatchingInfo_ = value;
    }

    void stTypeMatchingInfo(::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L>&& value) {
        m_stTypeMatchingInfo_ = std::move(value);
    }
    ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& stShipMatchingInfo() OMG_NOEXCEPT {
        return m_stShipMatchingInfo_;
    }

    const ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& stShipMatchingInfo() const OMG_NOEXCEPT {
        return m_stShipMatchingInfo_;
    }

    void stShipMatchingInfo(const ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>& value) {
        m_stShipMatchingInfo_ = value;
    }

    void stShipMatchingInfo(::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L>&& value) {
        m_stShipMatchingInfo_ = std::move(value);
    }

    bool operator == (const USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& other_) const;

    void swap(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint16_t m_usDataNum_;
    ::dds::core::array< ST_BIS_SOURCE_DB, 1000L> m_stBISSourceDBInfo_;
    ::dds::core::array< ST_BIS_SOURCE_TYPE_MATCHING_INFO, 100L> m_stTypeMatchingInfo_;
    ::dds::core::array< ST_BIS_SOURCE_SHIP_MATCHING_INFO, 100L> m_stShipMatchingInfo_;

};

inline void swap(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& a, USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_BIS_TRACK_USER_CONFIRM_COMMAND {
  public:
    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND();

    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCommandID,uint16_t usGlobalID,uint8_t oAxis,uint8_t oDetectionType,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND (USERIF_BIS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& operator=(const USERIF_BIS_TRACK_USER_CONFIRM_COMMAND&) = default;
    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND(const USERIF_BIS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint16_t& usGlobalID() OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    const uint16_t& usGlobalID() const OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    void usGlobalID(uint16_t value) {
        m_usGlobalID_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint8_t& oDetectionType() OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    const uint8_t& oDetectionType() const OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    void oDetectionType(uint8_t value) {
        m_oDetectionType_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCommandID_;
    uint16_t m_usGlobalID_;
    uint8_t m_oAxis_;
    uint8_t m_oDetectionType_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& a, USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST {
  public:
    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST();

    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 3L>& unPowervalue);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST (USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST&&) = default;
    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& operator=(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST&&) = default;
    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& operator=(const USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST&) = default;
    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST(const USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST&) = default;
    #else
    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& operator=(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& unPowervalue() OMG_NOEXCEPT {
        return m_unPowervalue_;
    }

    const ::dds::core::array< uint8_t, 3L>& unPowervalue() const OMG_NOEXCEPT {
        return m_unPowervalue_;
    }

    void unPowervalue(const ::dds::core::array< uint8_t, 3L>& value) {
        m_unPowervalue_ = value;
    }

    void unPowervalue(::dds::core::array< uint8_t, 3L>&& value) {
        m_unPowervalue_ = std::move(value);
    }

    bool operator == (const USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& other_) const;

    void swap(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 3L> m_unPowervalue_;

};

inline void swap(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& a, USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& sample);

class NDDSUSERDllExport ST_BI_MODEL_INPUT_SET {
  public:
    ST_BI_MODEL_INPUT_SET();

    ST_BI_MODEL_INPUT_SET(uint8_t oTemperDBType,uint16_t usMonth,uint16_t usDay,const ST_USER_TEMP_INFO& stTempInfo,float fTargetSpeed,const ST_BI_TS_INFO& stBITSInfo,float fTransmitterDepth,const ST_SOUND_INFO& stSoundInfo,double dSrcPosLat,double dSrcPosLon);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_BI_MODEL_INPUT_SET (ST_BI_MODEL_INPUT_SET&&) = default;
    ST_BI_MODEL_INPUT_SET& operator=(ST_BI_MODEL_INPUT_SET&&) = default;
    ST_BI_MODEL_INPUT_SET& operator=(const ST_BI_MODEL_INPUT_SET&) = default;
    ST_BI_MODEL_INPUT_SET(const ST_BI_MODEL_INPUT_SET&) = default;
    #else
    ST_BI_MODEL_INPUT_SET(ST_BI_MODEL_INPUT_SET&& other_) OMG_NOEXCEPT;  
    ST_BI_MODEL_INPUT_SET& operator=(ST_BI_MODEL_INPUT_SET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oTemperDBType() OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    const uint8_t& oTemperDBType() const OMG_NOEXCEPT {
        return m_oTemperDBType_;
    }

    void oTemperDBType(uint8_t value) {
        m_oTemperDBType_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    ST_USER_TEMP_INFO& stTempInfo() OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    const ST_USER_TEMP_INFO& stTempInfo() const OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    void stTempInfo(const ST_USER_TEMP_INFO& value) {
        m_stTempInfo_ = value;
    }

    void stTempInfo(ST_USER_TEMP_INFO&& value) {
        m_stTempInfo_ = std::move(value);
    }
    float& fTargetSpeed() OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    const float& fTargetSpeed() const OMG_NOEXCEPT {
        return m_fTargetSpeed_;
    }

    void fTargetSpeed(float value) {
        m_fTargetSpeed_ = value;
    }

    ST_BI_TS_INFO& stBITSInfo() OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    const ST_BI_TS_INFO& stBITSInfo() const OMG_NOEXCEPT {
        return m_stBITSInfo_;
    }

    void stBITSInfo(const ST_BI_TS_INFO& value) {
        m_stBITSInfo_ = value;
    }

    void stBITSInfo(ST_BI_TS_INFO&& value) {
        m_stBITSInfo_ = std::move(value);
    }
    float& fTransmitterDepth() OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    const float& fTransmitterDepth() const OMG_NOEXCEPT {
        return m_fTransmitterDepth_;
    }

    void fTransmitterDepth(float value) {
        m_fTransmitterDepth_ = value;
    }

    ST_SOUND_INFO& stSoundInfo() OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    const ST_SOUND_INFO& stSoundInfo() const OMG_NOEXCEPT {
        return m_stSoundInfo_;
    }

    void stSoundInfo(const ST_SOUND_INFO& value) {
        m_stSoundInfo_ = value;
    }

    void stSoundInfo(ST_SOUND_INFO&& value) {
        m_stSoundInfo_ = std::move(value);
    }
    double& dSrcPosLat() OMG_NOEXCEPT {
        return m_dSrcPosLat_;
    }

    const double& dSrcPosLat() const OMG_NOEXCEPT {
        return m_dSrcPosLat_;
    }

    void dSrcPosLat(double value) {
        m_dSrcPosLat_ = value;
    }

    double& dSrcPosLon() OMG_NOEXCEPT {
        return m_dSrcPosLon_;
    }

    const double& dSrcPosLon() const OMG_NOEXCEPT {
        return m_dSrcPosLon_;
    }

    void dSrcPosLon(double value) {
        m_dSrcPosLon_ = value;
    }

    bool operator == (const ST_BI_MODEL_INPUT_SET& other_) const;
    bool operator != (const ST_BI_MODEL_INPUT_SET& other_) const;

    void swap(ST_BI_MODEL_INPUT_SET& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oTemperDBType_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;
    ST_USER_TEMP_INFO m_stTempInfo_;
    float m_fTargetSpeed_;
    ST_BI_TS_INFO m_stBITSInfo_;
    float m_fTransmitterDepth_;
    ST_SOUND_INFO m_stSoundInfo_;
    double m_dSrcPosLat_;
    double m_dSrcPosLon_;

};

inline void swap(ST_BI_MODEL_INPUT_SET& a, ST_BI_MODEL_INPUT_SET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_BI_MODEL_INPUT_SET& sample);

class NDDSUSERDllExport USERIF_BI_DETECTION_PROBABILITY_REQUEST {
  public:
    USERIF_BI_DETECTION_PROBABILITY_REQUEST();

    USERIF_BI_DETECTION_PROBABILITY_REQUEST(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,const ST_BI_MODEL_INPUT_SET& stBIModelInput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_BI_DETECTION_PROBABILITY_REQUEST (USERIF_BI_DETECTION_PROBABILITY_REQUEST&&) = default;
    USERIF_BI_DETECTION_PROBABILITY_REQUEST& operator=(USERIF_BI_DETECTION_PROBABILITY_REQUEST&&) = default;
    USERIF_BI_DETECTION_PROBABILITY_REQUEST& operator=(const USERIF_BI_DETECTION_PROBABILITY_REQUEST&) = default;
    USERIF_BI_DETECTION_PROBABILITY_REQUEST(const USERIF_BI_DETECTION_PROBABILITY_REQUEST&) = default;
    #else
    USERIF_BI_DETECTION_PROBABILITY_REQUEST(USERIF_BI_DETECTION_PROBABILITY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_BI_DETECTION_PROBABILITY_REQUEST& operator=(USERIF_BI_DETECTION_PROBABILITY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    ST_BI_MODEL_INPUT_SET& stBIModelInput() OMG_NOEXCEPT {
        return m_stBIModelInput_;
    }

    const ST_BI_MODEL_INPUT_SET& stBIModelInput() const OMG_NOEXCEPT {
        return m_stBIModelInput_;
    }

    void stBIModelInput(const ST_BI_MODEL_INPUT_SET& value) {
        m_stBIModelInput_ = value;
    }

    void stBIModelInput(ST_BI_MODEL_INPUT_SET&& value) {
        m_stBIModelInput_ = std::move(value);
    }

    bool operator == (const USERIF_BI_DETECTION_PROBABILITY_REQUEST& other_) const;
    bool operator != (const USERIF_BI_DETECTION_PROBABILITY_REQUEST& other_) const;

    void swap(USERIF_BI_DETECTION_PROBABILITY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    ST_BI_MODEL_INPUT_SET m_stBIModelInput_;

};

inline void swap(USERIF_BI_DETECTION_PROBABILITY_REQUEST& a, USERIF_BI_DETECTION_PROBABILITY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_BI_DETECTION_PROBABILITY_REQUEST& sample);

class NDDSUSERDllExport USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST {
  public:
    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST();

    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oCertificationDBmode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST (USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST&&) = default;
    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& operator=(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST&&) = default;
    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& operator=(const USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST&) = default;
    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST(const USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST&) = default;
    #else
    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& operator=(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oCertificationDBmode() OMG_NOEXCEPT {
        return m_oCertificationDBmode_;
    }

    const uint8_t& oCertificationDBmode() const OMG_NOEXCEPT {
        return m_oCertificationDBmode_;
    }

    void oCertificationDBmode(uint8_t value) {
        m_oCertificationDBmode_ = value;
    }

    bool operator == (const USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& other_) const;
    bool operator != (const USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& other_) const;

    void swap(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oCertificationDBmode_;

};

inline void swap(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& a, USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& sample);

class NDDSUSERDllExport USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST {
  public:
    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST();

    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< char, 80L>& acDatabasedirectory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST (USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST&&) = default;
    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& operator=(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST&&) = default;
    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& operator=(const USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST&) = default;
    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST(const USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST&) = default;
    #else
    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& operator=(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< char, 80L>& acDatabasedirectory() OMG_NOEXCEPT {
        return m_acDatabasedirectory_;
    }

    const ::dds::core::array< char, 80L>& acDatabasedirectory() const OMG_NOEXCEPT {
        return m_acDatabasedirectory_;
    }

    void acDatabasedirectory(const ::dds::core::array< char, 80L>& value) {
        m_acDatabasedirectory_ = value;
    }

    void acDatabasedirectory(::dds::core::array< char, 80L>&& value) {
        m_acDatabasedirectory_ = std::move(value);
    }

    bool operator == (const USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& other_) const;

    void swap(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< char, 80L> m_acDatabasedirectory_;

};

inline void swap(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& a, USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST {
  public:
    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST();

    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oClaType,uint8_t oRequestCommand,uint16_t usDataIndex,uint16_t usPageNum,const ::dds::core::array< uint8_t, 256L>& szComments);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST (USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST&&) = default;
    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& operator=(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST&&) = default;
    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& operator=(const USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST&) = default;
    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST(const USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST&) = default;
    #else
    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& operator=(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oClaType() OMG_NOEXCEPT {
        return m_oClaType_;
    }

    const uint8_t& oClaType() const OMG_NOEXCEPT {
        return m_oClaType_;
    }

    void oClaType(uint8_t value) {
        m_oClaType_ = value;
    }

    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint16_t& usDataIndex() OMG_NOEXCEPT {
        return m_usDataIndex_;
    }

    const uint16_t& usDataIndex() const OMG_NOEXCEPT {
        return m_usDataIndex_;
    }

    void usDataIndex(uint16_t value) {
        m_usDataIndex_ = value;
    }

    uint16_t& usPageNum() OMG_NOEXCEPT {
        return m_usPageNum_;
    }

    const uint16_t& usPageNum() const OMG_NOEXCEPT {
        return m_usPageNum_;
    }

    void usPageNum(uint16_t value) {
        m_usPageNum_ = value;
    }

    ::dds::core::array< uint8_t, 256L>& szComments() OMG_NOEXCEPT {
        return m_szComments_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComments() const OMG_NOEXCEPT {
        return m_szComments_;
    }

    void szComments(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComments_ = value;
    }

    void szComments(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComments_ = std::move(value);
    }

    bool operator == (const USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& other_) const;
    bool operator != (const USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& other_) const;

    void swap(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oClaType_;
    uint8_t m_oRequestCommand_;
    uint16_t m_usDataIndex_;
    uint16_t m_usPageNum_;
    ::dds::core::array< uint8_t, 256L> m_szComments_;

};

inline void swap(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& a, USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& sample);

class NDDSUSERDllExport USERIF_CPACALCULATE_INFO_REQUEST {
  public:
    USERIF_CPACALCULATE_INFO_REQUEST();

    USERIF_CPACALCULATE_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usActivateCmd,uint16_t unGlobalID,uint16_t usRelativeTgtID,double dCPALatitude,double dCPALongitude);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_CPACALCULATE_INFO_REQUEST (USERIF_CPACALCULATE_INFO_REQUEST&&) = default;
    USERIF_CPACALCULATE_INFO_REQUEST& operator=(USERIF_CPACALCULATE_INFO_REQUEST&&) = default;
    USERIF_CPACALCULATE_INFO_REQUEST& operator=(const USERIF_CPACALCULATE_INFO_REQUEST&) = default;
    USERIF_CPACALCULATE_INFO_REQUEST(const USERIF_CPACALCULATE_INFO_REQUEST&) = default;
    #else
    USERIF_CPACALCULATE_INFO_REQUEST(USERIF_CPACALCULATE_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_CPACALCULATE_INFO_REQUEST& operator=(USERIF_CPACALCULATE_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usActivateCmd() OMG_NOEXCEPT {
        return m_usActivateCmd_;
    }

    const uint16_t& usActivateCmd() const OMG_NOEXCEPT {
        return m_usActivateCmd_;
    }

    void usActivateCmd(uint16_t value) {
        m_usActivateCmd_ = value;
    }

    uint16_t& unGlobalID() OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    const uint16_t& unGlobalID() const OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    void unGlobalID(uint16_t value) {
        m_unGlobalID_ = value;
    }

    uint16_t& usRelativeTgtID() OMG_NOEXCEPT {
        return m_usRelativeTgtID_;
    }

    const uint16_t& usRelativeTgtID() const OMG_NOEXCEPT {
        return m_usRelativeTgtID_;
    }

    void usRelativeTgtID(uint16_t value) {
        m_usRelativeTgtID_ = value;
    }

    double& dCPALatitude() OMG_NOEXCEPT {
        return m_dCPALatitude_;
    }

    const double& dCPALatitude() const OMG_NOEXCEPT {
        return m_dCPALatitude_;
    }

    void dCPALatitude(double value) {
        m_dCPALatitude_ = value;
    }

    double& dCPALongitude() OMG_NOEXCEPT {
        return m_dCPALongitude_;
    }

    const double& dCPALongitude() const OMG_NOEXCEPT {
        return m_dCPALongitude_;
    }

    void dCPALongitude(double value) {
        m_dCPALongitude_ = value;
    }

    bool operator == (const USERIF_CPACALCULATE_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_CPACALCULATE_INFO_REQUEST& other_) const;

    void swap(USERIF_CPACALCULATE_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usActivateCmd_;
    uint16_t m_unGlobalID_;
    uint16_t m_usRelativeTgtID_;
    double m_dCPALatitude_;
    double m_dCPALongitude_;

};

inline void swap(USERIF_CPACALCULATE_INFO_REQUEST& a, USERIF_CPACALCULATE_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_CPACALCULATE_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_DATA_BACKUP_CONTROL_REQUEST {
  public:
    USERIF_DATA_BACKUP_CONTROL_REQUEST();

    USERIF_DATA_BACKUP_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oDataType,uint32_t ulDataIndex,const ::dds::core::array< uint8_t, 256L>& szFilePath);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_DATA_BACKUP_CONTROL_REQUEST (USERIF_DATA_BACKUP_CONTROL_REQUEST&&) = default;
    USERIF_DATA_BACKUP_CONTROL_REQUEST& operator=(USERIF_DATA_BACKUP_CONTROL_REQUEST&&) = default;
    USERIF_DATA_BACKUP_CONTROL_REQUEST& operator=(const USERIF_DATA_BACKUP_CONTROL_REQUEST&) = default;
    USERIF_DATA_BACKUP_CONTROL_REQUEST(const USERIF_DATA_BACKUP_CONTROL_REQUEST&) = default;
    #else
    USERIF_DATA_BACKUP_CONTROL_REQUEST(USERIF_DATA_BACKUP_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_DATA_BACKUP_CONTROL_REQUEST& operator=(USERIF_DATA_BACKUP_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oDataType() OMG_NOEXCEPT {
        return m_oDataType_;
    }

    const uint8_t& oDataType() const OMG_NOEXCEPT {
        return m_oDataType_;
    }

    void oDataType(uint8_t value) {
        m_oDataType_ = value;
    }

    uint32_t& ulDataIndex() OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    const uint32_t& ulDataIndex() const OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    void ulDataIndex(uint32_t value) {
        m_ulDataIndex_ = value;
    }

    ::dds::core::array< uint8_t, 256L>& szFilePath() OMG_NOEXCEPT {
        return m_szFilePath_;
    }

    const ::dds::core::array< uint8_t, 256L>& szFilePath() const OMG_NOEXCEPT {
        return m_szFilePath_;
    }

    void szFilePath(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szFilePath_ = value;
    }

    void szFilePath(::dds::core::array< uint8_t, 256L>&& value) {
        m_szFilePath_ = std::move(value);
    }

    bool operator == (const USERIF_DATA_BACKUP_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_DATA_BACKUP_CONTROL_REQUEST& other_) const;

    void swap(USERIF_DATA_BACKUP_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oDataType_;
    uint32_t m_ulDataIndex_;
    ::dds::core::array< uint8_t, 256L> m_szFilePath_;

};

inline void swap(USERIF_DATA_BACKUP_CONTROL_REQUEST& a, USERIF_DATA_BACKUP_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_DATA_BACKUP_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_DATA_DELETE_CONTROL_REQUEST {
  public:
    USERIF_DATA_DELETE_CONTROL_REQUEST();

    USERIF_DATA_DELETE_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oDataType,uint32_t ulDataIndex);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_DATA_DELETE_CONTROL_REQUEST (USERIF_DATA_DELETE_CONTROL_REQUEST&&) = default;
    USERIF_DATA_DELETE_CONTROL_REQUEST& operator=(USERIF_DATA_DELETE_CONTROL_REQUEST&&) = default;
    USERIF_DATA_DELETE_CONTROL_REQUEST& operator=(const USERIF_DATA_DELETE_CONTROL_REQUEST&) = default;
    USERIF_DATA_DELETE_CONTROL_REQUEST(const USERIF_DATA_DELETE_CONTROL_REQUEST&) = default;
    #else
    USERIF_DATA_DELETE_CONTROL_REQUEST(USERIF_DATA_DELETE_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_DATA_DELETE_CONTROL_REQUEST& operator=(USERIF_DATA_DELETE_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oDataType() OMG_NOEXCEPT {
        return m_oDataType_;
    }

    const uint8_t& oDataType() const OMG_NOEXCEPT {
        return m_oDataType_;
    }

    void oDataType(uint8_t value) {
        m_oDataType_ = value;
    }

    uint32_t& ulDataIndex() OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    const uint32_t& ulDataIndex() const OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    void ulDataIndex(uint32_t value) {
        m_ulDataIndex_ = value;
    }

    bool operator == (const USERIF_DATA_DELETE_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_DATA_DELETE_CONTROL_REQUEST& other_) const;

    void swap(USERIF_DATA_DELETE_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oDataType_;
    uint32_t m_ulDataIndex_;

};

inline void swap(USERIF_DATA_DELETE_CONTROL_REQUEST& a, USERIF_DATA_DELETE_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_DATA_DELETE_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_DATA_LIST_REQUEST {
  public:
    USERIF_DATA_LIST_REQUEST();

    USERIF_DATA_LIST_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oListType,uint16_t unPageNum,const ST_DATE_TIME& stStartTime,const ST_DATE_TIME& stEndTime,const ::dds::core::array< uint8_t, 256L>& szComments);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_DATA_LIST_REQUEST (USERIF_DATA_LIST_REQUEST&&) = default;
    USERIF_DATA_LIST_REQUEST& operator=(USERIF_DATA_LIST_REQUEST&&) = default;
    USERIF_DATA_LIST_REQUEST& operator=(const USERIF_DATA_LIST_REQUEST&) = default;
    USERIF_DATA_LIST_REQUEST(const USERIF_DATA_LIST_REQUEST&) = default;
    #else
    USERIF_DATA_LIST_REQUEST(USERIF_DATA_LIST_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_DATA_LIST_REQUEST& operator=(USERIF_DATA_LIST_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oListType() OMG_NOEXCEPT {
        return m_oListType_;
    }

    const uint8_t& oListType() const OMG_NOEXCEPT {
        return m_oListType_;
    }

    void oListType(uint8_t value) {
        m_oListType_ = value;
    }

    uint16_t& unPageNum() OMG_NOEXCEPT {
        return m_unPageNum_;
    }

    const uint16_t& unPageNum() const OMG_NOEXCEPT {
        return m_unPageNum_;
    }

    void unPageNum(uint16_t value) {
        m_unPageNum_ = value;
    }

    ST_DATE_TIME& stStartTime() OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    const ST_DATE_TIME& stStartTime() const OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    void stStartTime(const ST_DATE_TIME& value) {
        m_stStartTime_ = value;
    }

    void stStartTime(ST_DATE_TIME&& value) {
        m_stStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stEndTime() OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    const ST_DATE_TIME& stEndTime() const OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    void stEndTime(const ST_DATE_TIME& value) {
        m_stEndTime_ = value;
    }

    void stEndTime(ST_DATE_TIME&& value) {
        m_stEndTime_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& szComments() OMG_NOEXCEPT {
        return m_szComments_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComments() const OMG_NOEXCEPT {
        return m_szComments_;
    }

    void szComments(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComments_ = value;
    }

    void szComments(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComments_ = std::move(value);
    }

    bool operator == (const USERIF_DATA_LIST_REQUEST& other_) const;
    bool operator != (const USERIF_DATA_LIST_REQUEST& other_) const;

    void swap(USERIF_DATA_LIST_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oListType_;
    uint16_t m_unPageNum_;
    ST_DATE_TIME m_stStartTime_;
    ST_DATE_TIME m_stEndTime_;
    ::dds::core::array< uint8_t, 256L> m_szComments_;

};

inline void swap(USERIF_DATA_LIST_REQUEST& a, USERIF_DATA_LIST_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_DATA_LIST_REQUEST& sample);

class NDDSUSERDllExport USERIF_DATA_MODIFY_CONTROL_REQUEST {
  public:
    USERIF_DATA_MODIFY_CONTROL_REQUEST();

    USERIF_DATA_MODIFY_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t unDatamodifycommand,uint8_t oDataType,uint32_t ulDataIndex,const ST_OPER_DATA_LIST& stDataModifyInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_DATA_MODIFY_CONTROL_REQUEST (USERIF_DATA_MODIFY_CONTROL_REQUEST&&) = default;
    USERIF_DATA_MODIFY_CONTROL_REQUEST& operator=(USERIF_DATA_MODIFY_CONTROL_REQUEST&&) = default;
    USERIF_DATA_MODIFY_CONTROL_REQUEST& operator=(const USERIF_DATA_MODIFY_CONTROL_REQUEST&) = default;
    USERIF_DATA_MODIFY_CONTROL_REQUEST(const USERIF_DATA_MODIFY_CONTROL_REQUEST&) = default;
    #else
    USERIF_DATA_MODIFY_CONTROL_REQUEST(USERIF_DATA_MODIFY_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_DATA_MODIFY_CONTROL_REQUEST& operator=(USERIF_DATA_MODIFY_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& unDatamodifycommand() OMG_NOEXCEPT {
        return m_unDatamodifycommand_;
    }

    const uint8_t& unDatamodifycommand() const OMG_NOEXCEPT {
        return m_unDatamodifycommand_;
    }

    void unDatamodifycommand(uint8_t value) {
        m_unDatamodifycommand_ = value;
    }

    uint8_t& oDataType() OMG_NOEXCEPT {
        return m_oDataType_;
    }

    const uint8_t& oDataType() const OMG_NOEXCEPT {
        return m_oDataType_;
    }

    void oDataType(uint8_t value) {
        m_oDataType_ = value;
    }

    uint32_t& ulDataIndex() OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    const uint32_t& ulDataIndex() const OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    void ulDataIndex(uint32_t value) {
        m_ulDataIndex_ = value;
    }

    ST_OPER_DATA_LIST& stDataModifyInfo() OMG_NOEXCEPT {
        return m_stDataModifyInfo_;
    }

    const ST_OPER_DATA_LIST& stDataModifyInfo() const OMG_NOEXCEPT {
        return m_stDataModifyInfo_;
    }

    void stDataModifyInfo(const ST_OPER_DATA_LIST& value) {
        m_stDataModifyInfo_ = value;
    }

    void stDataModifyInfo(ST_OPER_DATA_LIST&& value) {
        m_stDataModifyInfo_ = std::move(value);
    }

    bool operator == (const USERIF_DATA_MODIFY_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_DATA_MODIFY_CONTROL_REQUEST& other_) const;

    void swap(USERIF_DATA_MODIFY_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_unDatamodifycommand_;
    uint8_t m_oDataType_;
    uint32_t m_ulDataIndex_;
    ST_OPER_DATA_LIST m_stDataModifyInfo_;

};

inline void swap(USERIF_DATA_MODIFY_CONTROL_REQUEST& a, USERIF_DATA_MODIFY_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_DATA_MODIFY_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_DATA_RECORD_CONTROL_REQUEST {
  public:
    USERIF_DATA_RECORD_CONTROL_REQUEST();

    USERIF_DATA_RECORD_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_OPER_DATA_LIST, 30L>& stOperDataList);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_DATA_RECORD_CONTROL_REQUEST (USERIF_DATA_RECORD_CONTROL_REQUEST&&) = default;
    USERIF_DATA_RECORD_CONTROL_REQUEST& operator=(USERIF_DATA_RECORD_CONTROL_REQUEST&&) = default;
    USERIF_DATA_RECORD_CONTROL_REQUEST& operator=(const USERIF_DATA_RECORD_CONTROL_REQUEST&) = default;
    USERIF_DATA_RECORD_CONTROL_REQUEST(const USERIF_DATA_RECORD_CONTROL_REQUEST&) = default;
    #else
    USERIF_DATA_RECORD_CONTROL_REQUEST(USERIF_DATA_RECORD_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_DATA_RECORD_CONTROL_REQUEST& operator=(USERIF_DATA_RECORD_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_OPER_DATA_LIST, 30L>& stOperDataList() OMG_NOEXCEPT {
        return m_stOperDataList_;
    }

    const ::dds::core::array< ST_OPER_DATA_LIST, 30L>& stOperDataList() const OMG_NOEXCEPT {
        return m_stOperDataList_;
    }

    void stOperDataList(const ::dds::core::array< ST_OPER_DATA_LIST, 30L>& value) {
        m_stOperDataList_ = value;
    }

    void stOperDataList(::dds::core::array< ST_OPER_DATA_LIST, 30L>&& value) {
        m_stOperDataList_ = std::move(value);
    }

    bool operator == (const USERIF_DATA_RECORD_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_DATA_RECORD_CONTROL_REQUEST& other_) const;

    void swap(USERIF_DATA_RECORD_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_OPER_DATA_LIST, 30L> m_stOperDataList_;

};

inline void swap(USERIF_DATA_RECORD_CONTROL_REQUEST& a, USERIF_DATA_RECORD_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_DATA_RECORD_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_DATA_RESTORE_CONTROL_REQUEST {
  public:
    USERIF_DATA_RESTORE_CONTROL_REQUEST();

    USERIF_DATA_RESTORE_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oDataType,uint32_t ulDataIndex,const ::dds::core::array< uint8_t, 256L>& szFilePath);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_DATA_RESTORE_CONTROL_REQUEST (USERIF_DATA_RESTORE_CONTROL_REQUEST&&) = default;
    USERIF_DATA_RESTORE_CONTROL_REQUEST& operator=(USERIF_DATA_RESTORE_CONTROL_REQUEST&&) = default;
    USERIF_DATA_RESTORE_CONTROL_REQUEST& operator=(const USERIF_DATA_RESTORE_CONTROL_REQUEST&) = default;
    USERIF_DATA_RESTORE_CONTROL_REQUEST(const USERIF_DATA_RESTORE_CONTROL_REQUEST&) = default;
    #else
    USERIF_DATA_RESTORE_CONTROL_REQUEST(USERIF_DATA_RESTORE_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_DATA_RESTORE_CONTROL_REQUEST& operator=(USERIF_DATA_RESTORE_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oDataType() OMG_NOEXCEPT {
        return m_oDataType_;
    }

    const uint8_t& oDataType() const OMG_NOEXCEPT {
        return m_oDataType_;
    }

    void oDataType(uint8_t value) {
        m_oDataType_ = value;
    }

    uint32_t& ulDataIndex() OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    const uint32_t& ulDataIndex() const OMG_NOEXCEPT {
        return m_ulDataIndex_;
    }

    void ulDataIndex(uint32_t value) {
        m_ulDataIndex_ = value;
    }

    ::dds::core::array< uint8_t, 256L>& szFilePath() OMG_NOEXCEPT {
        return m_szFilePath_;
    }

    const ::dds::core::array< uint8_t, 256L>& szFilePath() const OMG_NOEXCEPT {
        return m_szFilePath_;
    }

    void szFilePath(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szFilePath_ = value;
    }

    void szFilePath(::dds::core::array< uint8_t, 256L>&& value) {
        m_szFilePath_ = std::move(value);
    }

    bool operator == (const USERIF_DATA_RESTORE_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_DATA_RESTORE_CONTROL_REQUEST& other_) const;

    void swap(USERIF_DATA_RESTORE_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oDataType_;
    uint32_t m_ulDataIndex_;
    ::dds::core::array< uint8_t, 256L> m_szFilePath_;

};

inline void swap(USERIF_DATA_RESTORE_CONTROL_REQUEST& a, USERIF_DATA_RESTORE_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_DATA_RESTORE_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_ADDITIONAL_INFO_REQUEST {
  public:
    USERIF_EOTE_ADDITIONAL_INFO_REQUEST();

    USERIF_EOTE_ADDITIONAL_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_ADDITIONAL_INFO_REQUEST (USERIF_EOTE_ADDITIONAL_INFO_REQUEST&&) = default;
    USERIF_EOTE_ADDITIONAL_INFO_REQUEST& operator=(USERIF_EOTE_ADDITIONAL_INFO_REQUEST&&) = default;
    USERIF_EOTE_ADDITIONAL_INFO_REQUEST& operator=(const USERIF_EOTE_ADDITIONAL_INFO_REQUEST&) = default;
    USERIF_EOTE_ADDITIONAL_INFO_REQUEST(const USERIF_EOTE_ADDITIONAL_INFO_REQUEST&) = default;
    #else
    USERIF_EOTE_ADDITIONAL_INFO_REQUEST(USERIF_EOTE_ADDITIONAL_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_ADDITIONAL_INFO_REQUEST& operator=(USERIF_EOTE_ADDITIONAL_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const USERIF_EOTE_ADDITIONAL_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_ADDITIONAL_INFO_REQUEST& other_) const;

    void swap(USERIF_EOTE_ADDITIONAL_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;

};

inline void swap(USERIF_EOTE_ADDITIONAL_INFO_REQUEST& a, USERIF_EOTE_ADDITIONAL_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_ADDITIONAL_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_ADDITIONAL_SET_REQUEST {
  public:
    USERIF_EOTE_ADDITIONAL_SET_REQUEST();

    USERIF_EOTE_ADDITIONAL_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved,uint8_t oIRCalibration,uint8_t oInverseHigh,int16_t sTrueDeg,uint16_t usEOCenterX,uint16_t usEOCenterY,uint16_t usIRCenterX,uint16_t usIRCenterY);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_ADDITIONAL_SET_REQUEST (USERIF_EOTE_ADDITIONAL_SET_REQUEST&&) = default;
    USERIF_EOTE_ADDITIONAL_SET_REQUEST& operator=(USERIF_EOTE_ADDITIONAL_SET_REQUEST&&) = default;
    USERIF_EOTE_ADDITIONAL_SET_REQUEST& operator=(const USERIF_EOTE_ADDITIONAL_SET_REQUEST&) = default;
    USERIF_EOTE_ADDITIONAL_SET_REQUEST(const USERIF_EOTE_ADDITIONAL_SET_REQUEST&) = default;
    #else
    USERIF_EOTE_ADDITIONAL_SET_REQUEST(USERIF_EOTE_ADDITIONAL_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_ADDITIONAL_SET_REQUEST& operator=(USERIF_EOTE_ADDITIONAL_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint8_t& oIRCalibration() OMG_NOEXCEPT {
        return m_oIRCalibration_;
    }

    const uint8_t& oIRCalibration() const OMG_NOEXCEPT {
        return m_oIRCalibration_;
    }

    void oIRCalibration(uint8_t value) {
        m_oIRCalibration_ = value;
    }

    uint8_t& oInverseHigh() OMG_NOEXCEPT {
        return m_oInverseHigh_;
    }

    const uint8_t& oInverseHigh() const OMG_NOEXCEPT {
        return m_oInverseHigh_;
    }

    void oInverseHigh(uint8_t value) {
        m_oInverseHigh_ = value;
    }

    int16_t& sTrueDeg() OMG_NOEXCEPT {
        return m_sTrueDeg_;
    }

    const int16_t& sTrueDeg() const OMG_NOEXCEPT {
        return m_sTrueDeg_;
    }

    void sTrueDeg(int16_t value) {
        m_sTrueDeg_ = value;
    }

    uint16_t& usEOCenterX() OMG_NOEXCEPT {
        return m_usEOCenterX_;
    }

    const uint16_t& usEOCenterX() const OMG_NOEXCEPT {
        return m_usEOCenterX_;
    }

    void usEOCenterX(uint16_t value) {
        m_usEOCenterX_ = value;
    }

    uint16_t& usEOCenterY() OMG_NOEXCEPT {
        return m_usEOCenterY_;
    }

    const uint16_t& usEOCenterY() const OMG_NOEXCEPT {
        return m_usEOCenterY_;
    }

    void usEOCenterY(uint16_t value) {
        m_usEOCenterY_ = value;
    }

    uint16_t& usIRCenterX() OMG_NOEXCEPT {
        return m_usIRCenterX_;
    }

    const uint16_t& usIRCenterX() const OMG_NOEXCEPT {
        return m_usIRCenterX_;
    }

    void usIRCenterX(uint16_t value) {
        m_usIRCenterX_ = value;
    }

    uint16_t& usIRCenterY() OMG_NOEXCEPT {
        return m_usIRCenterY_;
    }

    const uint16_t& usIRCenterY() const OMG_NOEXCEPT {
        return m_usIRCenterY_;
    }

    void usIRCenterY(uint16_t value) {
        m_usIRCenterY_ = value;
    }

    bool operator == (const USERIF_EOTE_ADDITIONAL_SET_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_ADDITIONAL_SET_REQUEST& other_) const;

    void swap(USERIF_EOTE_ADDITIONAL_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;
    uint8_t m_oIRCalibration_;
    uint8_t m_oInverseHigh_;
    int16_t m_sTrueDeg_;
    uint16_t m_usEOCenterX_;
    uint16_t m_usEOCenterY_;
    uint16_t m_usIRCenterX_;
    uint16_t m_usIRCenterY_;

};

inline void swap(USERIF_EOTE_ADDITIONAL_SET_REQUEST& a, USERIF_EOTE_ADDITIONAL_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_ADDITIONAL_SET_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_AUTH_CONTROL_REQUEST {
  public:
    USERIF_EOTE_AUTH_CONTROL_REQUEST();

    USERIF_EOTE_AUTH_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usAuthCmd,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_AUTH_CONTROL_REQUEST (USERIF_EOTE_AUTH_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_AUTH_CONTROL_REQUEST& operator=(USERIF_EOTE_AUTH_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_AUTH_CONTROL_REQUEST& operator=(const USERIF_EOTE_AUTH_CONTROL_REQUEST&) = default;
    USERIF_EOTE_AUTH_CONTROL_REQUEST(const USERIF_EOTE_AUTH_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_AUTH_CONTROL_REQUEST(USERIF_EOTE_AUTH_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_AUTH_CONTROL_REQUEST& operator=(USERIF_EOTE_AUTH_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usAuthCmd() OMG_NOEXCEPT {
        return m_usAuthCmd_;
    }

    const uint16_t& usAuthCmd() const OMG_NOEXCEPT {
        return m_usAuthCmd_;
    }

    void usAuthCmd(uint16_t value) {
        m_usAuthCmd_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_EOTE_AUTH_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_AUTH_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_AUTH_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usAuthCmd_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_EOTE_AUTH_CONTROL_REQUEST& a, USERIF_EOTE_AUTH_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_AUTH_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_AUTH_INFO_REQUEST {
  public:
    USERIF_EOTE_AUTH_INFO_REQUEST();

    USERIF_EOTE_AUTH_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_AUTH_INFO_REQUEST (USERIF_EOTE_AUTH_INFO_REQUEST&&) = default;
    USERIF_EOTE_AUTH_INFO_REQUEST& operator=(USERIF_EOTE_AUTH_INFO_REQUEST&&) = default;
    USERIF_EOTE_AUTH_INFO_REQUEST& operator=(const USERIF_EOTE_AUTH_INFO_REQUEST&) = default;
    USERIF_EOTE_AUTH_INFO_REQUEST(const USERIF_EOTE_AUTH_INFO_REQUEST&) = default;
    #else
    USERIF_EOTE_AUTH_INFO_REQUEST(USERIF_EOTE_AUTH_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_AUTH_INFO_REQUEST& operator=(USERIF_EOTE_AUTH_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const USERIF_EOTE_AUTH_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_AUTH_INFO_REQUEST& other_) const;

    void swap(USERIF_EOTE_AUTH_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;

};

inline void swap(USERIF_EOTE_AUTH_INFO_REQUEST& a, USERIF_EOTE_AUTH_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_AUTH_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_BLOCK_INFO_REQUEST {
  public:
    USERIF_EOTE_BLOCK_INFO_REQUEST();

    USERIF_EOTE_BLOCK_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_BLOCK_INFO_REQUEST (USERIF_EOTE_BLOCK_INFO_REQUEST&&) = default;
    USERIF_EOTE_BLOCK_INFO_REQUEST& operator=(USERIF_EOTE_BLOCK_INFO_REQUEST&&) = default;
    USERIF_EOTE_BLOCK_INFO_REQUEST& operator=(const USERIF_EOTE_BLOCK_INFO_REQUEST&) = default;
    USERIF_EOTE_BLOCK_INFO_REQUEST(const USERIF_EOTE_BLOCK_INFO_REQUEST&) = default;
    #else
    USERIF_EOTE_BLOCK_INFO_REQUEST(USERIF_EOTE_BLOCK_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_BLOCK_INFO_REQUEST& operator=(USERIF_EOTE_BLOCK_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const USERIF_EOTE_BLOCK_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_BLOCK_INFO_REQUEST& other_) const;

    void swap(USERIF_EOTE_BLOCK_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;

};

inline void swap(USERIF_EOTE_BLOCK_INFO_REQUEST& a, USERIF_EOTE_BLOCK_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_BLOCK_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_BLOCK_SET_REQUEST {
  public:
    USERIF_EOTE_BLOCK_SET_REQUEST();

    USERIF_EOTE_BLOCK_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved,const ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& stBlockSet);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_BLOCK_SET_REQUEST (USERIF_EOTE_BLOCK_SET_REQUEST&&) = default;
    USERIF_EOTE_BLOCK_SET_REQUEST& operator=(USERIF_EOTE_BLOCK_SET_REQUEST&&) = default;
    USERIF_EOTE_BLOCK_SET_REQUEST& operator=(const USERIF_EOTE_BLOCK_SET_REQUEST&) = default;
    USERIF_EOTE_BLOCK_SET_REQUEST(const USERIF_EOTE_BLOCK_SET_REQUEST&) = default;
    #else
    USERIF_EOTE_BLOCK_SET_REQUEST(USERIF_EOTE_BLOCK_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_BLOCK_SET_REQUEST& operator=(USERIF_EOTE_BLOCK_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& stBlockSet() OMG_NOEXCEPT {
        return m_stBlockSet_;
    }

    const ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& stBlockSet() const OMG_NOEXCEPT {
        return m_stBlockSet_;
    }

    void stBlockSet(const ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>& value) {
        m_stBlockSet_ = value;
    }

    void stBlockSet(::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L>&& value) {
        m_stBlockSet_ = std::move(value);
    }

    bool operator == (const USERIF_EOTE_BLOCK_SET_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_BLOCK_SET_REQUEST& other_) const;

    void swap(USERIF_EOTE_BLOCK_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;
    ::dds::core::array< ST_EOTE_RESTIRCT_DISTRICT, 10L> m_stBlockSet_;

};

inline void swap(USERIF_EOTE_BLOCK_SET_REQUEST& a, USERIF_EOTE_BLOCK_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_BLOCK_SET_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_CALIBRATION_CONTROL_REQUEST {
  public:
    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST();

    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usIRInverse,uint16_t usIRSharpness,uint16_t usEOFogAdapt,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST (USERIF_EOTE_CALIBRATION_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& operator=(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& operator=(const USERIF_EOTE_CALIBRATION_CONTROL_REQUEST&) = default;
    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST(const USERIF_EOTE_CALIBRATION_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& operator=(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usIRInverse() OMG_NOEXCEPT {
        return m_usIRInverse_;
    }

    const uint16_t& usIRInverse() const OMG_NOEXCEPT {
        return m_usIRInverse_;
    }

    void usIRInverse(uint16_t value) {
        m_usIRInverse_ = value;
    }

    uint16_t& usIRSharpness() OMG_NOEXCEPT {
        return m_usIRSharpness_;
    }

    const uint16_t& usIRSharpness() const OMG_NOEXCEPT {
        return m_usIRSharpness_;
    }

    void usIRSharpness(uint16_t value) {
        m_usIRSharpness_ = value;
    }

    uint16_t& usEOFogAdapt() OMG_NOEXCEPT {
        return m_usEOFogAdapt_;
    }

    const uint16_t& usEOFogAdapt() const OMG_NOEXCEPT {
        return m_usEOFogAdapt_;
    }

    void usEOFogAdapt(uint16_t value) {
        m_usEOFogAdapt_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usIRInverse_;
    uint16_t m_usIRSharpness_;
    uint16_t m_usEOFogAdapt_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& a, USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_LASER_CONTROL_REQUEST {
  public:
    USERIF_EOTE_LASER_CONTROL_REQUEST();

    USERIF_EOTE_LASER_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_LASER_CONTROL_REQUEST (USERIF_EOTE_LASER_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_LASER_CONTROL_REQUEST& operator=(USERIF_EOTE_LASER_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_LASER_CONTROL_REQUEST& operator=(const USERIF_EOTE_LASER_CONTROL_REQUEST&) = default;
    USERIF_EOTE_LASER_CONTROL_REQUEST(const USERIF_EOTE_LASER_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_LASER_CONTROL_REQUEST(USERIF_EOTE_LASER_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_LASER_CONTROL_REQUEST& operator=(USERIF_EOTE_LASER_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const USERIF_EOTE_LASER_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_LASER_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_LASER_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;

};

inline void swap(USERIF_EOTE_LASER_CONTROL_REQUEST& a, USERIF_EOTE_LASER_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_LASER_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_MOTOR_CONTROL_REQUEST {
  public:
    USERIF_EOTE_MOTOR_CONTROL_REQUEST();

    USERIF_EOTE_MOTOR_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usMode,uint16_t usDegControlMode,uint16_t usDegControlSpeed,uint16_t usAngControlMode,uint16_t usAngControlSpeed,int16_t sDegPosition,int16_t sAngPosition);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_MOTOR_CONTROL_REQUEST (USERIF_EOTE_MOTOR_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_MOTOR_CONTROL_REQUEST& operator=(USERIF_EOTE_MOTOR_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_MOTOR_CONTROL_REQUEST& operator=(const USERIF_EOTE_MOTOR_CONTROL_REQUEST&) = default;
    USERIF_EOTE_MOTOR_CONTROL_REQUEST(const USERIF_EOTE_MOTOR_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_MOTOR_CONTROL_REQUEST(USERIF_EOTE_MOTOR_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_MOTOR_CONTROL_REQUEST& operator=(USERIF_EOTE_MOTOR_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usMode() OMG_NOEXCEPT {
        return m_usMode_;
    }

    const uint16_t& usMode() const OMG_NOEXCEPT {
        return m_usMode_;
    }

    void usMode(uint16_t value) {
        m_usMode_ = value;
    }

    uint16_t& usDegControlMode() OMG_NOEXCEPT {
        return m_usDegControlMode_;
    }

    const uint16_t& usDegControlMode() const OMG_NOEXCEPT {
        return m_usDegControlMode_;
    }

    void usDegControlMode(uint16_t value) {
        m_usDegControlMode_ = value;
    }

    uint16_t& usDegControlSpeed() OMG_NOEXCEPT {
        return m_usDegControlSpeed_;
    }

    const uint16_t& usDegControlSpeed() const OMG_NOEXCEPT {
        return m_usDegControlSpeed_;
    }

    void usDegControlSpeed(uint16_t value) {
        m_usDegControlSpeed_ = value;
    }

    uint16_t& usAngControlMode() OMG_NOEXCEPT {
        return m_usAngControlMode_;
    }

    const uint16_t& usAngControlMode() const OMG_NOEXCEPT {
        return m_usAngControlMode_;
    }

    void usAngControlMode(uint16_t value) {
        m_usAngControlMode_ = value;
    }

    uint16_t& usAngControlSpeed() OMG_NOEXCEPT {
        return m_usAngControlSpeed_;
    }

    const uint16_t& usAngControlSpeed() const OMG_NOEXCEPT {
        return m_usAngControlSpeed_;
    }

    void usAngControlSpeed(uint16_t value) {
        m_usAngControlSpeed_ = value;
    }

    int16_t& sDegPosition() OMG_NOEXCEPT {
        return m_sDegPosition_;
    }

    const int16_t& sDegPosition() const OMG_NOEXCEPT {
        return m_sDegPosition_;
    }

    void sDegPosition(int16_t value) {
        m_sDegPosition_ = value;
    }

    int16_t& sAngPosition() OMG_NOEXCEPT {
        return m_sAngPosition_;
    }

    const int16_t& sAngPosition() const OMG_NOEXCEPT {
        return m_sAngPosition_;
    }

    void sAngPosition(int16_t value) {
        m_sAngPosition_ = value;
    }

    bool operator == (const USERIF_EOTE_MOTOR_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_MOTOR_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_MOTOR_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usMode_;
    uint16_t m_usDegControlMode_;
    uint16_t m_usDegControlSpeed_;
    uint16_t m_usAngControlMode_;
    uint16_t m_usAngControlSpeed_;
    int16_t m_sDegPosition_;
    int16_t m_sAngPosition_;

};

inline void swap(USERIF_EOTE_MOTOR_CONTROL_REQUEST& a, USERIF_EOTE_MOTOR_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_MOTOR_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_MOVE_CONTROL_REQUEST {
  public:
    USERIF_EOTE_MOVE_CONTROL_REQUEST();

    USERIF_EOTE_MOVE_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved,uint16_t usDoSearch,uint16_t usAreaID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_MOVE_CONTROL_REQUEST (USERIF_EOTE_MOVE_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_MOVE_CONTROL_REQUEST& operator=(USERIF_EOTE_MOVE_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_MOVE_CONTROL_REQUEST& operator=(const USERIF_EOTE_MOVE_CONTROL_REQUEST&) = default;
    USERIF_EOTE_MOVE_CONTROL_REQUEST(const USERIF_EOTE_MOVE_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_MOVE_CONTROL_REQUEST(USERIF_EOTE_MOVE_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_MOVE_CONTROL_REQUEST& operator=(USERIF_EOTE_MOVE_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint16_t& usDoSearch() OMG_NOEXCEPT {
        return m_usDoSearch_;
    }

    const uint16_t& usDoSearch() const OMG_NOEXCEPT {
        return m_usDoSearch_;
    }

    void usDoSearch(uint16_t value) {
        m_usDoSearch_ = value;
    }

    uint16_t& usAreaID() OMG_NOEXCEPT {
        return m_usAreaID_;
    }

    const uint16_t& usAreaID() const OMG_NOEXCEPT {
        return m_usAreaID_;
    }

    void usAreaID(uint16_t value) {
        m_usAreaID_ = value;
    }

    bool operator == (const USERIF_EOTE_MOVE_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_MOVE_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_MOVE_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;
    uint16_t m_usDoSearch_;
    uint16_t m_usAreaID_;

};

inline void swap(USERIF_EOTE_MOVE_CONTROL_REQUEST& a, USERIF_EOTE_MOVE_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_MOVE_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_MOVE_INFO_REQUEST {
  public:
    USERIF_EOTE_MOVE_INFO_REQUEST();

    USERIF_EOTE_MOVE_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usAreaID,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_MOVE_INFO_REQUEST (USERIF_EOTE_MOVE_INFO_REQUEST&&) = default;
    USERIF_EOTE_MOVE_INFO_REQUEST& operator=(USERIF_EOTE_MOVE_INFO_REQUEST&&) = default;
    USERIF_EOTE_MOVE_INFO_REQUEST& operator=(const USERIF_EOTE_MOVE_INFO_REQUEST&) = default;
    USERIF_EOTE_MOVE_INFO_REQUEST(const USERIF_EOTE_MOVE_INFO_REQUEST&) = default;
    #else
    USERIF_EOTE_MOVE_INFO_REQUEST(USERIF_EOTE_MOVE_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_MOVE_INFO_REQUEST& operator=(USERIF_EOTE_MOVE_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usAreaID() OMG_NOEXCEPT {
        return m_usAreaID_;
    }

    const uint16_t& usAreaID() const OMG_NOEXCEPT {
        return m_usAreaID_;
    }

    void usAreaID(uint16_t value) {
        m_usAreaID_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_EOTE_MOVE_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_MOVE_INFO_REQUEST& other_) const;

    void swap(USERIF_EOTE_MOVE_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usAreaID_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_EOTE_MOVE_INFO_REQUEST& a, USERIF_EOTE_MOVE_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_MOVE_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_MOVE_SET_REQUEST {
  public:
    USERIF_EOTE_MOVE_SET_REQUEST();

    USERIF_EOTE_MOVE_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usAreaID,uint16_t usReserved2,const ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& stMovingSet);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_MOVE_SET_REQUEST (USERIF_EOTE_MOVE_SET_REQUEST&&) = default;
    USERIF_EOTE_MOVE_SET_REQUEST& operator=(USERIF_EOTE_MOVE_SET_REQUEST&&) = default;
    USERIF_EOTE_MOVE_SET_REQUEST& operator=(const USERIF_EOTE_MOVE_SET_REQUEST&) = default;
    USERIF_EOTE_MOVE_SET_REQUEST(const USERIF_EOTE_MOVE_SET_REQUEST&) = default;
    #else
    USERIF_EOTE_MOVE_SET_REQUEST(USERIF_EOTE_MOVE_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_MOVE_SET_REQUEST& operator=(USERIF_EOTE_MOVE_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usAreaID() OMG_NOEXCEPT {
        return m_usAreaID_;
    }

    const uint16_t& usAreaID() const OMG_NOEXCEPT {
        return m_usAreaID_;
    }

    void usAreaID(uint16_t value) {
        m_usAreaID_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& stMovingSet() OMG_NOEXCEPT {
        return m_stMovingSet_;
    }

    const ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& stMovingSet() const OMG_NOEXCEPT {
        return m_stMovingSet_;
    }

    void stMovingSet(const ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>& value) {
        m_stMovingSet_ = value;
    }

    void stMovingSet(::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L>&& value) {
        m_stMovingSet_ = std::move(value);
    }

    bool operator == (const USERIF_EOTE_MOVE_SET_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_MOVE_SET_REQUEST& other_) const;

    void swap(USERIF_EOTE_MOVE_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usAreaID_;
    uint16_t m_usReserved2_;
    ::dds::core::array< ST_EOTE_MOVING_SEARCHING_INFO, 10L> m_stMovingSet_;

};

inline void swap(USERIF_EOTE_MOVE_SET_REQUEST& a, USERIF_EOTE_MOVE_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_MOVE_SET_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_POWER_CONTROL_REQUEST {
  public:
    USERIF_EOTE_POWER_CONTROL_REQUEST();

    USERIF_EOTE_POWER_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint8_t oEOPwer,uint8_t oIRPower,uint8_t oLRFPower,uint8_t oFANPower,uint8_t oHeaterPower,uint8_t oReserved2,uint16_t usReserved3);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_POWER_CONTROL_REQUEST (USERIF_EOTE_POWER_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_POWER_CONTROL_REQUEST& operator=(USERIF_EOTE_POWER_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_POWER_CONTROL_REQUEST& operator=(const USERIF_EOTE_POWER_CONTROL_REQUEST&) = default;
    USERIF_EOTE_POWER_CONTROL_REQUEST(const USERIF_EOTE_POWER_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_POWER_CONTROL_REQUEST(USERIF_EOTE_POWER_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_POWER_CONTROL_REQUEST& operator=(USERIF_EOTE_POWER_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint8_t& oEOPwer() OMG_NOEXCEPT {
        return m_oEOPwer_;
    }

    const uint8_t& oEOPwer() const OMG_NOEXCEPT {
        return m_oEOPwer_;
    }

    void oEOPwer(uint8_t value) {
        m_oEOPwer_ = value;
    }

    uint8_t& oIRPower() OMG_NOEXCEPT {
        return m_oIRPower_;
    }

    const uint8_t& oIRPower() const OMG_NOEXCEPT {
        return m_oIRPower_;
    }

    void oIRPower(uint8_t value) {
        m_oIRPower_ = value;
    }

    uint8_t& oLRFPower() OMG_NOEXCEPT {
        return m_oLRFPower_;
    }

    const uint8_t& oLRFPower() const OMG_NOEXCEPT {
        return m_oLRFPower_;
    }

    void oLRFPower(uint8_t value) {
        m_oLRFPower_ = value;
    }

    uint8_t& oFANPower() OMG_NOEXCEPT {
        return m_oFANPower_;
    }

    const uint8_t& oFANPower() const OMG_NOEXCEPT {
        return m_oFANPower_;
    }

    void oFANPower(uint8_t value) {
        m_oFANPower_ = value;
    }

    uint8_t& oHeaterPower() OMG_NOEXCEPT {
        return m_oHeaterPower_;
    }

    const uint8_t& oHeaterPower() const OMG_NOEXCEPT {
        return m_oHeaterPower_;
    }

    void oHeaterPower(uint8_t value) {
        m_oHeaterPower_ = value;
    }

    uint8_t& oReserved2() OMG_NOEXCEPT {
        return m_oReserved2_;
    }

    const uint8_t& oReserved2() const OMG_NOEXCEPT {
        return m_oReserved2_;
    }

    void oReserved2(uint8_t value) {
        m_oReserved2_ = value;
    }

    uint16_t& usReserved3() OMG_NOEXCEPT {
        return m_usReserved3_;
    }

    const uint16_t& usReserved3() const OMG_NOEXCEPT {
        return m_usReserved3_;
    }

    void usReserved3(uint16_t value) {
        m_usReserved3_ = value;
    }

    bool operator == (const USERIF_EOTE_POWER_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_POWER_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_POWER_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint8_t m_oEOPwer_;
    uint8_t m_oIRPower_;
    uint8_t m_oLRFPower_;
    uint8_t m_oFANPower_;
    uint8_t m_oHeaterPower_;
    uint8_t m_oReserved2_;
    uint16_t m_usReserved3_;

};

inline void swap(USERIF_EOTE_POWER_CONTROL_REQUEST& a, USERIF_EOTE_POWER_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_POWER_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_TRACKING_CONTROL_REQUEST {
  public:
    USERIF_EOTE_TRACKING_CONTROL_REQUEST();

    USERIF_EOTE_TRACKING_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved1,uint16_t usEOIR,uint16_t usTargetPosX,uint16_t usTargetPosY,uint16_t usTargetH,uint16_t usTargetV,uint16_t usTargetConfirm,uint16_t usTargetTracking,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_TRACKING_CONTROL_REQUEST (USERIF_EOTE_TRACKING_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_TRACKING_CONTROL_REQUEST& operator=(USERIF_EOTE_TRACKING_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_TRACKING_CONTROL_REQUEST& operator=(const USERIF_EOTE_TRACKING_CONTROL_REQUEST&) = default;
    USERIF_EOTE_TRACKING_CONTROL_REQUEST(const USERIF_EOTE_TRACKING_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_TRACKING_CONTROL_REQUEST(USERIF_EOTE_TRACKING_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_TRACKING_CONTROL_REQUEST& operator=(USERIF_EOTE_TRACKING_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usEOIR() OMG_NOEXCEPT {
        return m_usEOIR_;
    }

    const uint16_t& usEOIR() const OMG_NOEXCEPT {
        return m_usEOIR_;
    }

    void usEOIR(uint16_t value) {
        m_usEOIR_ = value;
    }

    uint16_t& usTargetPosX() OMG_NOEXCEPT {
        return m_usTargetPosX_;
    }

    const uint16_t& usTargetPosX() const OMG_NOEXCEPT {
        return m_usTargetPosX_;
    }

    void usTargetPosX(uint16_t value) {
        m_usTargetPosX_ = value;
    }

    uint16_t& usTargetPosY() OMG_NOEXCEPT {
        return m_usTargetPosY_;
    }

    const uint16_t& usTargetPosY() const OMG_NOEXCEPT {
        return m_usTargetPosY_;
    }

    void usTargetPosY(uint16_t value) {
        m_usTargetPosY_ = value;
    }

    uint16_t& usTargetH() OMG_NOEXCEPT {
        return m_usTargetH_;
    }

    const uint16_t& usTargetH() const OMG_NOEXCEPT {
        return m_usTargetH_;
    }

    void usTargetH(uint16_t value) {
        m_usTargetH_ = value;
    }

    uint16_t& usTargetV() OMG_NOEXCEPT {
        return m_usTargetV_;
    }

    const uint16_t& usTargetV() const OMG_NOEXCEPT {
        return m_usTargetV_;
    }

    void usTargetV(uint16_t value) {
        m_usTargetV_ = value;
    }

    uint16_t& usTargetConfirm() OMG_NOEXCEPT {
        return m_usTargetConfirm_;
    }

    const uint16_t& usTargetConfirm() const OMG_NOEXCEPT {
        return m_usTargetConfirm_;
    }

    void usTargetConfirm(uint16_t value) {
        m_usTargetConfirm_ = value;
    }

    uint16_t& usTargetTracking() OMG_NOEXCEPT {
        return m_usTargetTracking_;
    }

    const uint16_t& usTargetTracking() const OMG_NOEXCEPT {
        return m_usTargetTracking_;
    }

    void usTargetTracking(uint16_t value) {
        m_usTargetTracking_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_EOTE_TRACKING_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_TRACKING_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_TRACKING_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved1_;
    uint16_t m_usEOIR_;
    uint16_t m_usTargetPosX_;
    uint16_t m_usTargetPosY_;
    uint16_t m_usTargetH_;
    uint16_t m_usTargetV_;
    uint16_t m_usTargetConfirm_;
    uint16_t m_usTargetTracking_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_EOTE_TRACKING_CONTROL_REQUEST& a, USERIF_EOTE_TRACKING_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_TRACKING_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST {
  public:
    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST();

    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID,uint8_t oReceiverID,uint16_t usReserved,uint8_t oEOIR,uint8_t oReserved,uint8_t oZoomControlMode,uint8_t oZoomContinusMode,uint16_t usZoomPosition,uint8_t oFocusControlMode,uint8_t oFocusContinusMode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST (USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& operator=(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST&&) = default;
    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& operator=(const USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST&) = default;
    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST(const USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST&) = default;
    #else
    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& operator=(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    uint8_t& oReceiverID() OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    const uint8_t& oReceiverID() const OMG_NOEXCEPT {
        return m_oReceiverID_;
    }

    void oReceiverID(uint8_t value) {
        m_oReceiverID_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    uint8_t& oEOIR() OMG_NOEXCEPT {
        return m_oEOIR_;
    }

    const uint8_t& oEOIR() const OMG_NOEXCEPT {
        return m_oEOIR_;
    }

    void oEOIR(uint8_t value) {
        m_oEOIR_ = value;
    }

    uint8_t& oReserved() OMG_NOEXCEPT {
        return m_oReserved_;
    }

    const uint8_t& oReserved() const OMG_NOEXCEPT {
        return m_oReserved_;
    }

    void oReserved(uint8_t value) {
        m_oReserved_ = value;
    }

    uint8_t& oZoomControlMode() OMG_NOEXCEPT {
        return m_oZoomControlMode_;
    }

    const uint8_t& oZoomControlMode() const OMG_NOEXCEPT {
        return m_oZoomControlMode_;
    }

    void oZoomControlMode(uint8_t value) {
        m_oZoomControlMode_ = value;
    }

    uint8_t& oZoomContinusMode() OMG_NOEXCEPT {
        return m_oZoomContinusMode_;
    }

    const uint8_t& oZoomContinusMode() const OMG_NOEXCEPT {
        return m_oZoomContinusMode_;
    }

    void oZoomContinusMode(uint8_t value) {
        m_oZoomContinusMode_ = value;
    }

    uint16_t& usZoomPosition() OMG_NOEXCEPT {
        return m_usZoomPosition_;
    }

    const uint16_t& usZoomPosition() const OMG_NOEXCEPT {
        return m_usZoomPosition_;
    }

    void usZoomPosition(uint16_t value) {
        m_usZoomPosition_ = value;
    }

    uint8_t& oFocusControlMode() OMG_NOEXCEPT {
        return m_oFocusControlMode_;
    }

    const uint8_t& oFocusControlMode() const OMG_NOEXCEPT {
        return m_oFocusControlMode_;
    }

    void oFocusControlMode(uint8_t value) {
        m_oFocusControlMode_ = value;
    }

    uint8_t& oFocusContinusMode() OMG_NOEXCEPT {
        return m_oFocusContinusMode_;
    }

    const uint8_t& oFocusContinusMode() const OMG_NOEXCEPT {
        return m_oFocusContinusMode_;
    }

    void oFocusContinusMode(uint8_t value) {
        m_oFocusContinusMode_ = value;
    }

    bool operator == (const USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& other_) const;

    void swap(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;
    uint8_t m_oReceiverID_;
    uint16_t m_usReserved_;
    uint8_t m_oEOIR_;
    uint8_t m_oReserved_;
    uint8_t m_oZoomControlMode_;
    uint8_t m_oZoomContinusMode_;
    uint16_t m_usZoomPosition_;
    uint8_t m_oFocusControlMode_;
    uint8_t m_oFocusContinusMode_;

};

inline void swap(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& a, USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_EQUIP_DIAGNOSTIC_REQUEST {
  public:
    USERIF_EQUIP_DIAGNOSTIC_REQUEST();

    USERIF_EQUIP_DIAGNOSTIC_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oStationID,const ::dds::core::array< uint8_t, 3L>& oReserved,int32_t lHWID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EQUIP_DIAGNOSTIC_REQUEST (USERIF_EQUIP_DIAGNOSTIC_REQUEST&&) = default;
    USERIF_EQUIP_DIAGNOSTIC_REQUEST& operator=(USERIF_EQUIP_DIAGNOSTIC_REQUEST&&) = default;
    USERIF_EQUIP_DIAGNOSTIC_REQUEST& operator=(const USERIF_EQUIP_DIAGNOSTIC_REQUEST&) = default;
    USERIF_EQUIP_DIAGNOSTIC_REQUEST(const USERIF_EQUIP_DIAGNOSTIC_REQUEST&) = default;
    #else
    USERIF_EQUIP_DIAGNOSTIC_REQUEST(USERIF_EQUIP_DIAGNOSTIC_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EQUIP_DIAGNOSTIC_REQUEST& operator=(USERIF_EQUIP_DIAGNOSTIC_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oReserved() OMG_NOEXCEPT {
        return m_oReserved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oReserved() const OMG_NOEXCEPT {
        return m_oReserved_;
    }

    void oReserved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oReserved_ = value;
    }

    void oReserved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oReserved_ = std::move(value);
    }
    int32_t& lHWID() OMG_NOEXCEPT {
        return m_lHWID_;
    }

    const int32_t& lHWID() const OMG_NOEXCEPT {
        return m_lHWID_;
    }

    void lHWID(int32_t value) {
        m_lHWID_ = value;
    }

    bool operator == (const USERIF_EQUIP_DIAGNOSTIC_REQUEST& other_) const;
    bool operator != (const USERIF_EQUIP_DIAGNOSTIC_REQUEST& other_) const;

    void swap(USERIF_EQUIP_DIAGNOSTIC_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oStationID_;
    ::dds::core::array< uint8_t, 3L> m_oReserved_;
    int32_t m_lHWID_;

};

inline void swap(USERIF_EQUIP_DIAGNOSTIC_REQUEST& a, USERIF_EQUIP_DIAGNOSTIC_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EQUIP_DIAGNOSTIC_REQUEST& sample);

class NDDSUSERDllExport USERIF_FOC_DR_REQUEST {
  public:
    USERIF_FOC_DR_REQUEST();

    USERIF_FOC_DR_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unCommandID,uint16_t usActivateCmd,uint16_t unTgtNo,uint16_t usEstimationMode,uint16_t usEstimationTime,float fUserInputSpeed,float fUserInputCourse);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_FOC_DR_REQUEST (USERIF_FOC_DR_REQUEST&&) = default;
    USERIF_FOC_DR_REQUEST& operator=(USERIF_FOC_DR_REQUEST&&) = default;
    USERIF_FOC_DR_REQUEST& operator=(const USERIF_FOC_DR_REQUEST&) = default;
    USERIF_FOC_DR_REQUEST(const USERIF_FOC_DR_REQUEST&) = default;
    #else
    USERIF_FOC_DR_REQUEST(USERIF_FOC_DR_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_FOC_DR_REQUEST& operator=(USERIF_FOC_DR_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unCommandID() OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    const uint16_t& unCommandID() const OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    void unCommandID(uint16_t value) {
        m_unCommandID_ = value;
    }

    uint16_t& usActivateCmd() OMG_NOEXCEPT {
        return m_usActivateCmd_;
    }

    const uint16_t& usActivateCmd() const OMG_NOEXCEPT {
        return m_usActivateCmd_;
    }

    void usActivateCmd(uint16_t value) {
        m_usActivateCmd_ = value;
    }

    uint16_t& unTgtNo() OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    const uint16_t& unTgtNo() const OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    void unTgtNo(uint16_t value) {
        m_unTgtNo_ = value;
    }

    uint16_t& usEstimationMode() OMG_NOEXCEPT {
        return m_usEstimationMode_;
    }

    const uint16_t& usEstimationMode() const OMG_NOEXCEPT {
        return m_usEstimationMode_;
    }

    void usEstimationMode(uint16_t value) {
        m_usEstimationMode_ = value;
    }

    uint16_t& usEstimationTime() OMG_NOEXCEPT {
        return m_usEstimationTime_;
    }

    const uint16_t& usEstimationTime() const OMG_NOEXCEPT {
        return m_usEstimationTime_;
    }

    void usEstimationTime(uint16_t value) {
        m_usEstimationTime_ = value;
    }

    float& fUserInputSpeed() OMG_NOEXCEPT {
        return m_fUserInputSpeed_;
    }

    const float& fUserInputSpeed() const OMG_NOEXCEPT {
        return m_fUserInputSpeed_;
    }

    void fUserInputSpeed(float value) {
        m_fUserInputSpeed_ = value;
    }

    float& fUserInputCourse() OMG_NOEXCEPT {
        return m_fUserInputCourse_;
    }

    const float& fUserInputCourse() const OMG_NOEXCEPT {
        return m_fUserInputCourse_;
    }

    void fUserInputCourse(float value) {
        m_fUserInputCourse_ = value;
    }

    bool operator == (const USERIF_FOC_DR_REQUEST& other_) const;
    bool operator != (const USERIF_FOC_DR_REQUEST& other_) const;

    void swap(USERIF_FOC_DR_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unCommandID_;
    uint16_t m_usActivateCmd_;
    uint16_t m_unTgtNo_;
    uint16_t m_usEstimationMode_;
    uint16_t m_usEstimationTime_;
    float m_fUserInputSpeed_;
    float m_fUserInputCourse_;

};

inline void swap(USERIF_FOC_DR_REQUEST& a, USERIF_FOC_DR_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_FOC_DR_REQUEST& sample);

class NDDSUSERDllExport USERIF_HISTORY_EXCUTE_VACCINE {
  public:
    USERIF_HISTORY_EXCUTE_VACCINE();

    USERIF_HISTORY_EXCUTE_VACCINE(const ST_MSG_HEADER& stMsgHeader,uint32_t ulReserved1,uint32_t ulReserved2,uint32_t ulReserved3);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_HISTORY_EXCUTE_VACCINE (USERIF_HISTORY_EXCUTE_VACCINE&&) = default;
    USERIF_HISTORY_EXCUTE_VACCINE& operator=(USERIF_HISTORY_EXCUTE_VACCINE&&) = default;
    USERIF_HISTORY_EXCUTE_VACCINE& operator=(const USERIF_HISTORY_EXCUTE_VACCINE&) = default;
    USERIF_HISTORY_EXCUTE_VACCINE(const USERIF_HISTORY_EXCUTE_VACCINE&) = default;
    #else
    USERIF_HISTORY_EXCUTE_VACCINE(USERIF_HISTORY_EXCUTE_VACCINE&& other_) OMG_NOEXCEPT;  
    USERIF_HISTORY_EXCUTE_VACCINE& operator=(USERIF_HISTORY_EXCUTE_VACCINE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulReserved1() OMG_NOEXCEPT {
        return m_ulReserved1_;
    }

    const uint32_t& ulReserved1() const OMG_NOEXCEPT {
        return m_ulReserved1_;
    }

    void ulReserved1(uint32_t value) {
        m_ulReserved1_ = value;
    }

    uint32_t& ulReserved2() OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    const uint32_t& ulReserved2() const OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    void ulReserved2(uint32_t value) {
        m_ulReserved2_ = value;
    }

    uint32_t& ulReserved3() OMG_NOEXCEPT {
        return m_ulReserved3_;
    }

    const uint32_t& ulReserved3() const OMG_NOEXCEPT {
        return m_ulReserved3_;
    }

    void ulReserved3(uint32_t value) {
        m_ulReserved3_ = value;
    }

    bool operator == (const USERIF_HISTORY_EXCUTE_VACCINE& other_) const;
    bool operator != (const USERIF_HISTORY_EXCUTE_VACCINE& other_) const;

    void swap(USERIF_HISTORY_EXCUTE_VACCINE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulReserved1_;
    uint32_t m_ulReserved2_;
    uint32_t m_ulReserved3_;

};

inline void swap(USERIF_HISTORY_EXCUTE_VACCINE& a, USERIF_HISTORY_EXCUTE_VACCINE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_HISTORY_EXCUTE_VACCINE& sample);

class NDDSUSERDllExport USERIF_HISTORY_LIST_REQUEST {
  public:
    USERIF_HISTORY_LIST_REQUEST();

    USERIF_HISTORY_LIST_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t unHistorylistrequest,uint16_t unPageNum,const ::dds::core::array< uint8_t, 32L>& szUserID,const ::dds::core::array< uint8_t, 32L>& szUserName,const ::dds::core::array< uint8_t, 100L>& szContents,const ST_DATE_TIME& stStartTime,const ST_DATE_TIME& stEndTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_HISTORY_LIST_REQUEST (USERIF_HISTORY_LIST_REQUEST&&) = default;
    USERIF_HISTORY_LIST_REQUEST& operator=(USERIF_HISTORY_LIST_REQUEST&&) = default;
    USERIF_HISTORY_LIST_REQUEST& operator=(const USERIF_HISTORY_LIST_REQUEST&) = default;
    USERIF_HISTORY_LIST_REQUEST(const USERIF_HISTORY_LIST_REQUEST&) = default;
    #else
    USERIF_HISTORY_LIST_REQUEST(USERIF_HISTORY_LIST_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_HISTORY_LIST_REQUEST& operator=(USERIF_HISTORY_LIST_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& unHistorylistrequest() OMG_NOEXCEPT {
        return m_unHistorylistrequest_;
    }

    const uint8_t& unHistorylistrequest() const OMG_NOEXCEPT {
        return m_unHistorylistrequest_;
    }

    void unHistorylistrequest(uint8_t value) {
        m_unHistorylistrequest_ = value;
    }

    uint16_t& unPageNum() OMG_NOEXCEPT {
        return m_unPageNum_;
    }

    const uint16_t& unPageNum() const OMG_NOEXCEPT {
        return m_unPageNum_;
    }

    void unPageNum(uint16_t value) {
        m_unPageNum_ = value;
    }

    ::dds::core::array< uint8_t, 32L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 32L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 32L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 32L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& szUserName() OMG_NOEXCEPT {
        return m_szUserName_;
    }

    const ::dds::core::array< uint8_t, 32L>& szUserName() const OMG_NOEXCEPT {
        return m_szUserName_;
    }

    void szUserName(const ::dds::core::array< uint8_t, 32L>& value) {
        m_szUserName_ = value;
    }

    void szUserName(::dds::core::array< uint8_t, 32L>&& value) {
        m_szUserName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 100L>& szContents() OMG_NOEXCEPT {
        return m_szContents_;
    }

    const ::dds::core::array< uint8_t, 100L>& szContents() const OMG_NOEXCEPT {
        return m_szContents_;
    }

    void szContents(const ::dds::core::array< uint8_t, 100L>& value) {
        m_szContents_ = value;
    }

    void szContents(::dds::core::array< uint8_t, 100L>&& value) {
        m_szContents_ = std::move(value);
    }
    ST_DATE_TIME& stStartTime() OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    const ST_DATE_TIME& stStartTime() const OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    void stStartTime(const ST_DATE_TIME& value) {
        m_stStartTime_ = value;
    }

    void stStartTime(ST_DATE_TIME&& value) {
        m_stStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stEndTime() OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    const ST_DATE_TIME& stEndTime() const OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    void stEndTime(const ST_DATE_TIME& value) {
        m_stEndTime_ = value;
    }

    void stEndTime(ST_DATE_TIME&& value) {
        m_stEndTime_ = std::move(value);
    }

    bool operator == (const USERIF_HISTORY_LIST_REQUEST& other_) const;
    bool operator != (const USERIF_HISTORY_LIST_REQUEST& other_) const;

    void swap(USERIF_HISTORY_LIST_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_unHistorylistrequest_;
    uint16_t m_unPageNum_;
    ::dds::core::array< uint8_t, 32L> m_szUserID_;
    ::dds::core::array< uint8_t, 32L> m_szUserName_;
    ::dds::core::array< uint8_t, 100L> m_szContents_;
    ST_DATE_TIME m_stStartTime_;
    ST_DATE_TIME m_stEndTime_;

};

inline void swap(USERIF_HISTORY_LIST_REQUEST& a, USERIF_HISTORY_LIST_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_HISTORY_LIST_REQUEST& sample);

class NDDSUSERDllExport USERIF_HISTORY_MANAGE_ACCOUNT {
  public:
    USERIF_HISTORY_MANAGE_ACCOUNT();

    USERIF_HISTORY_MANAGE_ACCOUNT(const ST_MSG_HEADER& stMsgHeader,uint32_t ulOperation,const ST_USER_ACCOUNT_INFO& stAccountInfo,const ST_USER_ACCOUNT_INFO& stOldAccountInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_HISTORY_MANAGE_ACCOUNT (USERIF_HISTORY_MANAGE_ACCOUNT&&) = default;
    USERIF_HISTORY_MANAGE_ACCOUNT& operator=(USERIF_HISTORY_MANAGE_ACCOUNT&&) = default;
    USERIF_HISTORY_MANAGE_ACCOUNT& operator=(const USERIF_HISTORY_MANAGE_ACCOUNT&) = default;
    USERIF_HISTORY_MANAGE_ACCOUNT(const USERIF_HISTORY_MANAGE_ACCOUNT&) = default;
    #else
    USERIF_HISTORY_MANAGE_ACCOUNT(USERIF_HISTORY_MANAGE_ACCOUNT&& other_) OMG_NOEXCEPT;  
    USERIF_HISTORY_MANAGE_ACCOUNT& operator=(USERIF_HISTORY_MANAGE_ACCOUNT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulOperation() OMG_NOEXCEPT {
        return m_ulOperation_;
    }

    const uint32_t& ulOperation() const OMG_NOEXCEPT {
        return m_ulOperation_;
    }

    void ulOperation(uint32_t value) {
        m_ulOperation_ = value;
    }

    ST_USER_ACCOUNT_INFO& stAccountInfo() OMG_NOEXCEPT {
        return m_stAccountInfo_;
    }

    const ST_USER_ACCOUNT_INFO& stAccountInfo() const OMG_NOEXCEPT {
        return m_stAccountInfo_;
    }

    void stAccountInfo(const ST_USER_ACCOUNT_INFO& value) {
        m_stAccountInfo_ = value;
    }

    void stAccountInfo(ST_USER_ACCOUNT_INFO&& value) {
        m_stAccountInfo_ = std::move(value);
    }
    ST_USER_ACCOUNT_INFO& stOldAccountInfo() OMG_NOEXCEPT {
        return m_stOldAccountInfo_;
    }

    const ST_USER_ACCOUNT_INFO& stOldAccountInfo() const OMG_NOEXCEPT {
        return m_stOldAccountInfo_;
    }

    void stOldAccountInfo(const ST_USER_ACCOUNT_INFO& value) {
        m_stOldAccountInfo_ = value;
    }

    void stOldAccountInfo(ST_USER_ACCOUNT_INFO&& value) {
        m_stOldAccountInfo_ = std::move(value);
    }

    bool operator == (const USERIF_HISTORY_MANAGE_ACCOUNT& other_) const;
    bool operator != (const USERIF_HISTORY_MANAGE_ACCOUNT& other_) const;

    void swap(USERIF_HISTORY_MANAGE_ACCOUNT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulOperation_;
    ST_USER_ACCOUNT_INFO m_stAccountInfo_;
    ST_USER_ACCOUNT_INFO m_stOldAccountInfo_;

};

inline void swap(USERIF_HISTORY_MANAGE_ACCOUNT& a, USERIF_HISTORY_MANAGE_ACCOUNT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_HISTORY_MANAGE_ACCOUNT& sample);

class NDDSUSERDllExport USERIF_HISTORY_PRINT_REPORT {
  public:
    USERIF_HISTORY_PRINT_REPORT();

    USERIF_HISTORY_PRINT_REPORT(const ST_MSG_HEADER& stMsgHeader,const ST_DATE_TIME& stReportDate,uint32_t ulReserved1,uint32_t ulReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_HISTORY_PRINT_REPORT (USERIF_HISTORY_PRINT_REPORT&&) = default;
    USERIF_HISTORY_PRINT_REPORT& operator=(USERIF_HISTORY_PRINT_REPORT&&) = default;
    USERIF_HISTORY_PRINT_REPORT& operator=(const USERIF_HISTORY_PRINT_REPORT&) = default;
    USERIF_HISTORY_PRINT_REPORT(const USERIF_HISTORY_PRINT_REPORT&) = default;
    #else
    USERIF_HISTORY_PRINT_REPORT(USERIF_HISTORY_PRINT_REPORT&& other_) OMG_NOEXCEPT;  
    USERIF_HISTORY_PRINT_REPORT& operator=(USERIF_HISTORY_PRINT_REPORT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_DATE_TIME& stReportDate() OMG_NOEXCEPT {
        return m_stReportDate_;
    }

    const ST_DATE_TIME& stReportDate() const OMG_NOEXCEPT {
        return m_stReportDate_;
    }

    void stReportDate(const ST_DATE_TIME& value) {
        m_stReportDate_ = value;
    }

    void stReportDate(ST_DATE_TIME&& value) {
        m_stReportDate_ = std::move(value);
    }
    uint32_t& ulReserved1() OMG_NOEXCEPT {
        return m_ulReserved1_;
    }

    const uint32_t& ulReserved1() const OMG_NOEXCEPT {
        return m_ulReserved1_;
    }

    void ulReserved1(uint32_t value) {
        m_ulReserved1_ = value;
    }

    uint32_t& ulReserved2() OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    const uint32_t& ulReserved2() const OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    void ulReserved2(uint32_t value) {
        m_ulReserved2_ = value;
    }

    bool operator == (const USERIF_HISTORY_PRINT_REPORT& other_) const;
    bool operator != (const USERIF_HISTORY_PRINT_REPORT& other_) const;

    void swap(USERIF_HISTORY_PRINT_REPORT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_DATE_TIME m_stReportDate_;
    uint32_t m_ulReserved1_;
    uint32_t m_ulReserved2_;

};

inline void swap(USERIF_HISTORY_PRINT_REPORT& a, USERIF_HISTORY_PRINT_REPORT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_HISTORY_PRINT_REPORT& sample);

class NDDSUSERDllExport USERIF_HISTORY_RESERVED {
  public:
    USERIF_HISTORY_RESERVED();

    USERIF_HISTORY_RESERVED(const ST_MSG_HEADER& stMsgHeader,uint32_t ulReserved1,uint32_t ulReserved2,uint32_t ulReserved3);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_HISTORY_RESERVED (USERIF_HISTORY_RESERVED&&) = default;
    USERIF_HISTORY_RESERVED& operator=(USERIF_HISTORY_RESERVED&&) = default;
    USERIF_HISTORY_RESERVED& operator=(const USERIF_HISTORY_RESERVED&) = default;
    USERIF_HISTORY_RESERVED(const USERIF_HISTORY_RESERVED&) = default;
    #else
    USERIF_HISTORY_RESERVED(USERIF_HISTORY_RESERVED&& other_) OMG_NOEXCEPT;  
    USERIF_HISTORY_RESERVED& operator=(USERIF_HISTORY_RESERVED&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulReserved1() OMG_NOEXCEPT {
        return m_ulReserved1_;
    }

    const uint32_t& ulReserved1() const OMG_NOEXCEPT {
        return m_ulReserved1_;
    }

    void ulReserved1(uint32_t value) {
        m_ulReserved1_ = value;
    }

    uint32_t& ulReserved2() OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    const uint32_t& ulReserved2() const OMG_NOEXCEPT {
        return m_ulReserved2_;
    }

    void ulReserved2(uint32_t value) {
        m_ulReserved2_ = value;
    }

    uint32_t& ulReserved3() OMG_NOEXCEPT {
        return m_ulReserved3_;
    }

    const uint32_t& ulReserved3() const OMG_NOEXCEPT {
        return m_ulReserved3_;
    }

    void ulReserved3(uint32_t value) {
        m_ulReserved3_ = value;
    }

    bool operator == (const USERIF_HISTORY_RESERVED& other_) const;
    bool operator != (const USERIF_HISTORY_RESERVED& other_) const;

    void swap(USERIF_HISTORY_RESERVED& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulReserved1_;
    uint32_t m_ulReserved2_;
    uint32_t m_ulReserved3_;

};

inline void swap(USERIF_HISTORY_RESERVED& a, USERIF_HISTORY_RESERVED& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_HISTORY_RESERVED& sample);

class NDDSUSERDllExport USERIF_HORIZONTAL_ANALYSIS_REQUEST {
  public:
    USERIF_HORIZONTAL_ANALYSIS_REQUEST();

    USERIF_HORIZONTAL_ANALYSIS_REQUEST(const ST_MSG_HEADER& stMsgHeader,float fDepth,uint16_t usMonth,uint16_t usDay);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_HORIZONTAL_ANALYSIS_REQUEST (USERIF_HORIZONTAL_ANALYSIS_REQUEST&&) = default;
    USERIF_HORIZONTAL_ANALYSIS_REQUEST& operator=(USERIF_HORIZONTAL_ANALYSIS_REQUEST&&) = default;
    USERIF_HORIZONTAL_ANALYSIS_REQUEST& operator=(const USERIF_HORIZONTAL_ANALYSIS_REQUEST&) = default;
    USERIF_HORIZONTAL_ANALYSIS_REQUEST(const USERIF_HORIZONTAL_ANALYSIS_REQUEST&) = default;
    #else
    USERIF_HORIZONTAL_ANALYSIS_REQUEST(USERIF_HORIZONTAL_ANALYSIS_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_HORIZONTAL_ANALYSIS_REQUEST& operator=(USERIF_HORIZONTAL_ANALYSIS_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    float& fDepth() OMG_NOEXCEPT {
        return m_fDepth_;
    }

    const float& fDepth() const OMG_NOEXCEPT {
        return m_fDepth_;
    }

    void fDepth(float value) {
        m_fDepth_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    bool operator == (const USERIF_HORIZONTAL_ANALYSIS_REQUEST& other_) const;
    bool operator != (const USERIF_HORIZONTAL_ANALYSIS_REQUEST& other_) const;

    void swap(USERIF_HORIZONTAL_ANALYSIS_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    float m_fDepth_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;

};

inline void swap(USERIF_HORIZONTAL_ANALYSIS_REQUEST& a, USERIF_HORIZONTAL_ANALYSIS_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_HORIZONTAL_ANALYSIS_REQUEST& sample);

class NDDSUSERDllExport USERIF_IPE_DEVICE_CTRL_COMMAND {
  public:
    USERIF_IPE_DEVICE_CTRL_COMMAND();

    USERIF_IPE_DEVICE_CTRL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCommandID,int32_t eSWID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_IPE_DEVICE_CTRL_COMMAND (USERIF_IPE_DEVICE_CTRL_COMMAND&&) = default;
    USERIF_IPE_DEVICE_CTRL_COMMAND& operator=(USERIF_IPE_DEVICE_CTRL_COMMAND&&) = default;
    USERIF_IPE_DEVICE_CTRL_COMMAND& operator=(const USERIF_IPE_DEVICE_CTRL_COMMAND&) = default;
    USERIF_IPE_DEVICE_CTRL_COMMAND(const USERIF_IPE_DEVICE_CTRL_COMMAND&) = default;
    #else
    USERIF_IPE_DEVICE_CTRL_COMMAND(USERIF_IPE_DEVICE_CTRL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_IPE_DEVICE_CTRL_COMMAND& operator=(USERIF_IPE_DEVICE_CTRL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    int32_t& eSWID() OMG_NOEXCEPT {
        return m_eSWID_;
    }

    const int32_t& eSWID() const OMG_NOEXCEPT {
        return m_eSWID_;
    }

    void eSWID(int32_t value) {
        m_eSWID_ = value;
    }

    bool operator == (const USERIF_IPE_DEVICE_CTRL_COMMAND& other_) const;
    bool operator != (const USERIF_IPE_DEVICE_CTRL_COMMAND& other_) const;

    void swap(USERIF_IPE_DEVICE_CTRL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCommandID_;
    int32_t m_eSWID_;

};

inline void swap(USERIF_IPE_DEVICE_CTRL_COMMAND& a, USERIF_IPE_DEVICE_CTRL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_IPE_DEVICE_CTRL_COMMAND& sample);

class NDDSUSERDllExport USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND {
  public:
    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND();

    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oOitUserID,uint16_t usTmpTgtNo,uint8_t oAxisID,uint8_t oBbdBFType,uint8_t oIsAddOrDelete,float fBbdOitBearing,uint16_t usBbdOitDelTrackNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND (USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& operator=(const USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND&) = default;
    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND(const USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND&) = default;
    #else
    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oBbdBFType() OMG_NOEXCEPT {
        return m_oBbdBFType_;
    }

    const uint8_t& oBbdBFType() const OMG_NOEXCEPT {
        return m_oBbdBFType_;
    }

    void oBbdBFType(uint8_t value) {
        m_oBbdBFType_ = value;
    }

    uint8_t& oIsAddOrDelete() OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    const uint8_t& oIsAddOrDelete() const OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    void oIsAddOrDelete(uint8_t value) {
        m_oIsAddOrDelete_ = value;
    }

    float& fBbdOitBearing() OMG_NOEXCEPT {
        return m_fBbdOitBearing_;
    }

    const float& fBbdOitBearing() const OMG_NOEXCEPT {
        return m_fBbdOitBearing_;
    }

    void fBbdOitBearing(float value) {
        m_fBbdOitBearing_ = value;
    }

    uint16_t& usBbdOitDelTrackNo() OMG_NOEXCEPT {
        return m_usBbdOitDelTrackNo_;
    }

    const uint16_t& usBbdOitDelTrackNo() const OMG_NOEXCEPT {
        return m_usBbdOitDelTrackNo_;
    }

    void usBbdOitDelTrackNo(uint16_t value) {
        m_usBbdOitDelTrackNo_ = value;
    }

    bool operator == (const USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& other_) const;

    void swap(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;
    uint8_t m_oAxisID_;
    uint8_t m_oBbdBFType_;
    uint8_t m_oIsAddOrDelete_;
    float m_fBbdOitBearing_;
    uint16_t m_usBbdOitDelTrackNo_;

};

inline void swap(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& a, USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& sample);

class NDDSUSERDllExport USERIF_LASTRK_CONC_TGT_REG_COMMAND {
  public:
    USERIF_LASTRK_CONC_TGT_REG_COMMAND();

    USERIF_LASTRK_CONC_TGT_REG_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint8_t oLasTrkType,uint16_t unTgtNo,const ::dds::core::array< uint16_t, 2L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_CONC_TGT_REG_COMMAND (USERIF_LASTRK_CONC_TGT_REG_COMMAND&&) = default;
    USERIF_LASTRK_CONC_TGT_REG_COMMAND& operator=(USERIF_LASTRK_CONC_TGT_REG_COMMAND&&) = default;
    USERIF_LASTRK_CONC_TGT_REG_COMMAND& operator=(const USERIF_LASTRK_CONC_TGT_REG_COMMAND&) = default;
    USERIF_LASTRK_CONC_TGT_REG_COMMAND(const USERIF_LASTRK_CONC_TGT_REG_COMMAND&) = default;
    #else
    USERIF_LASTRK_CONC_TGT_REG_COMMAND(USERIF_LASTRK_CONC_TGT_REG_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_CONC_TGT_REG_COMMAND& operator=(USERIF_LASTRK_CONC_TGT_REG_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oLasTrkType() OMG_NOEXCEPT {
        return m_oLasTrkType_;
    }

    const uint8_t& oLasTrkType() const OMG_NOEXCEPT {
        return m_oLasTrkType_;
    }

    void oLasTrkType(uint8_t value) {
        m_oLasTrkType_ = value;
    }

    uint16_t& unTgtNo() OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    const uint16_t& unTgtNo() const OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    void unTgtNo(uint16_t value) {
        m_unTgtNo_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const USERIF_LASTRK_CONC_TGT_REG_COMMAND& other_) const;
    bool operator != (const USERIF_LASTRK_CONC_TGT_REG_COMMAND& other_) const;

    void swap(USERIF_LASTRK_CONC_TGT_REG_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint8_t m_oLasTrkType_;
    uint16_t m_unTgtNo_;
    ::dds::core::array< uint16_t, 2L> m_aReserved_;

};

inline void swap(USERIF_LASTRK_CONC_TGT_REG_COMMAND& a, USERIF_LASTRK_CONC_TGT_REG_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_CONC_TGT_REG_COMMAND& sample);

class NDDSUSERDllExport USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND {
  public:
    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND();

    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oOitUserID,uint16_t usTmpTgtNo,uint8_t oAxisID,uint8_t oIsAddOrDelete,uint16_t unDemonOitTrackNo,uint16_t unDemonOitBeamNo,float fDemonOitFreq,uint16_t unDemonOitDelTrackNo,uint16_t unDemonOitDelFreq);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND (USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& operator=(const USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND&) = default;
    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND(const USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND&) = default;
    #else
    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oIsAddOrDelete() OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    const uint8_t& oIsAddOrDelete() const OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    void oIsAddOrDelete(uint8_t value) {
        m_oIsAddOrDelete_ = value;
    }

    uint16_t& unDemonOitTrackNo() OMG_NOEXCEPT {
        return m_unDemonOitTrackNo_;
    }

    const uint16_t& unDemonOitTrackNo() const OMG_NOEXCEPT {
        return m_unDemonOitTrackNo_;
    }

    void unDemonOitTrackNo(uint16_t value) {
        m_unDemonOitTrackNo_ = value;
    }

    uint16_t& unDemonOitBeamNo() OMG_NOEXCEPT {
        return m_unDemonOitBeamNo_;
    }

    const uint16_t& unDemonOitBeamNo() const OMG_NOEXCEPT {
        return m_unDemonOitBeamNo_;
    }

    void unDemonOitBeamNo(uint16_t value) {
        m_unDemonOitBeamNo_ = value;
    }

    float& fDemonOitFreq() OMG_NOEXCEPT {
        return m_fDemonOitFreq_;
    }

    const float& fDemonOitFreq() const OMG_NOEXCEPT {
        return m_fDemonOitFreq_;
    }

    void fDemonOitFreq(float value) {
        m_fDemonOitFreq_ = value;
    }

    uint16_t& unDemonOitDelTrackNo() OMG_NOEXCEPT {
        return m_unDemonOitDelTrackNo_;
    }

    const uint16_t& unDemonOitDelTrackNo() const OMG_NOEXCEPT {
        return m_unDemonOitDelTrackNo_;
    }

    void unDemonOitDelTrackNo(uint16_t value) {
        m_unDemonOitDelTrackNo_ = value;
    }

    uint16_t& unDemonOitDelFreq() OMG_NOEXCEPT {
        return m_unDemonOitDelFreq_;
    }

    const uint16_t& unDemonOitDelFreq() const OMG_NOEXCEPT {
        return m_unDemonOitDelFreq_;
    }

    void unDemonOitDelFreq(uint16_t value) {
        m_unDemonOitDelFreq_ = value;
    }

    bool operator == (const USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& other_) const;

    void swap(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;
    uint8_t m_oAxisID_;
    uint8_t m_oIsAddOrDelete_;
    uint16_t m_unDemonOitTrackNo_;
    uint16_t m_unDemonOitBeamNo_;
    float m_fDemonOitFreq_;
    uint16_t m_unDemonOitDelTrackNo_;
    uint16_t m_unDemonOitDelFreq_;

};

inline void swap(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& a, USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& sample);

class NDDSUSERDllExport USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND {
  public:
    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND();

    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxis,const ::dds::core::array< float, 24L>& aExclusFrequency);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND (USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& operator=(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& operator=(const USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND&) = default;
    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND(const USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND&) = default;
    #else
    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& operator=(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    ::dds::core::array< float, 24L>& aExclusFrequency() OMG_NOEXCEPT {
        return m_aExclusFrequency_;
    }

    const ::dds::core::array< float, 24L>& aExclusFrequency() const OMG_NOEXCEPT {
        return m_aExclusFrequency_;
    }

    void aExclusFrequency(const ::dds::core::array< float, 24L>& value) {
        m_aExclusFrequency_ = value;
    }

    void aExclusFrequency(::dds::core::array< float, 24L>&& value) {
        m_aExclusFrequency_ = std::move(value);
    }

    bool operator == (const USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& other_) const;

    void swap(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxis_;
    ::dds::core::array< float, 24L> m_aExclusFrequency_;

};

inline void swap(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& a, USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& sample);

class NDDSUSERDllExport USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND {
  public:
    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND();

    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oOitUserID,uint16_t usTmpTgtNo,uint8_t oAxisID,uint8_t oLofBFType,uint8_t oIsAddOrDelete,uint16_t unLofarOitTrackNo,uint16_t unLofarOitBeamNo,uint16_t unLofarOitBandNo,float fLofarOitFreq,uint16_t unLofarOitDelTrackNo,uint16_t unLofarOitDelFreq);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND (USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& operator=(const USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND&) = default;
    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND(const USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND&) = default;
    #else
    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oOitUserID() OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    const uint8_t& oOitUserID() const OMG_NOEXCEPT {
        return m_oOitUserID_;
    }

    void oOitUserID(uint8_t value) {
        m_oOitUserID_ = value;
    }

    uint16_t& usTmpTgtNo() OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    const uint16_t& usTmpTgtNo() const OMG_NOEXCEPT {
        return m_usTmpTgtNo_;
    }

    void usTmpTgtNo(uint16_t value) {
        m_usTmpTgtNo_ = value;
    }

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oLofBFType() OMG_NOEXCEPT {
        return m_oLofBFType_;
    }

    const uint8_t& oLofBFType() const OMG_NOEXCEPT {
        return m_oLofBFType_;
    }

    void oLofBFType(uint8_t value) {
        m_oLofBFType_ = value;
    }

    uint8_t& oIsAddOrDelete() OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    const uint8_t& oIsAddOrDelete() const OMG_NOEXCEPT {
        return m_oIsAddOrDelete_;
    }

    void oIsAddOrDelete(uint8_t value) {
        m_oIsAddOrDelete_ = value;
    }

    uint16_t& unLofarOitTrackNo() OMG_NOEXCEPT {
        return m_unLofarOitTrackNo_;
    }

    const uint16_t& unLofarOitTrackNo() const OMG_NOEXCEPT {
        return m_unLofarOitTrackNo_;
    }

    void unLofarOitTrackNo(uint16_t value) {
        m_unLofarOitTrackNo_ = value;
    }

    uint16_t& unLofarOitBeamNo() OMG_NOEXCEPT {
        return m_unLofarOitBeamNo_;
    }

    const uint16_t& unLofarOitBeamNo() const OMG_NOEXCEPT {
        return m_unLofarOitBeamNo_;
    }

    void unLofarOitBeamNo(uint16_t value) {
        m_unLofarOitBeamNo_ = value;
    }

    uint16_t& unLofarOitBandNo() OMG_NOEXCEPT {
        return m_unLofarOitBandNo_;
    }

    const uint16_t& unLofarOitBandNo() const OMG_NOEXCEPT {
        return m_unLofarOitBandNo_;
    }

    void unLofarOitBandNo(uint16_t value) {
        m_unLofarOitBandNo_ = value;
    }

    float& fLofarOitFreq() OMG_NOEXCEPT {
        return m_fLofarOitFreq_;
    }

    const float& fLofarOitFreq() const OMG_NOEXCEPT {
        return m_fLofarOitFreq_;
    }

    void fLofarOitFreq(float value) {
        m_fLofarOitFreq_ = value;
    }

    uint16_t& unLofarOitDelTrackNo() OMG_NOEXCEPT {
        return m_unLofarOitDelTrackNo_;
    }

    const uint16_t& unLofarOitDelTrackNo() const OMG_NOEXCEPT {
        return m_unLofarOitDelTrackNo_;
    }

    void unLofarOitDelTrackNo(uint16_t value) {
        m_unLofarOitDelTrackNo_ = value;
    }

    uint16_t& unLofarOitDelFreq() OMG_NOEXCEPT {
        return m_unLofarOitDelFreq_;
    }

    const uint16_t& unLofarOitDelFreq() const OMG_NOEXCEPT {
        return m_unLofarOitDelFreq_;
    }

    void unLofarOitDelFreq(uint16_t value) {
        m_unLofarOitDelFreq_ = value;
    }

    bool operator == (const USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& other_) const;

    void swap(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oOitUserID_;
    uint16_t m_usTmpTgtNo_;
    uint8_t m_oAxisID_;
    uint8_t m_oLofBFType_;
    uint8_t m_oIsAddOrDelete_;
    uint16_t m_unLofarOitTrackNo_;
    uint16_t m_unLofarOitBeamNo_;
    uint16_t m_unLofarOitBandNo_;
    float m_fLofarOitFreq_;
    uint16_t m_unLofarOitDelTrackNo_;
    uint16_t m_unLofarOitDelFreq_;

};

inline void swap(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& a, USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& sample);

class NDDSUSERDllExport ST_LAS_ASS_TGT_INFO {
  public:
    ST_LAS_ASS_TGT_INFO();

    ST_LAS_ASS_TGT_INFO(uint8_t oTgtAssoFlat,uint8_t oAxisID,const ST_LAS_TARGET& usLasLocalTgtInfo,const ::dds::core::array< uint16_t, 2L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_ASS_TGT_INFO (ST_LAS_ASS_TGT_INFO&&) = default;
    ST_LAS_ASS_TGT_INFO& operator=(ST_LAS_ASS_TGT_INFO&&) = default;
    ST_LAS_ASS_TGT_INFO& operator=(const ST_LAS_ASS_TGT_INFO&) = default;
    ST_LAS_ASS_TGT_INFO(const ST_LAS_ASS_TGT_INFO&) = default;
    #else
    ST_LAS_ASS_TGT_INFO(ST_LAS_ASS_TGT_INFO&& other_) OMG_NOEXCEPT;  
    ST_LAS_ASS_TGT_INFO& operator=(ST_LAS_ASS_TGT_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oTgtAssoFlat() OMG_NOEXCEPT {
        return m_oTgtAssoFlat_;
    }

    const uint8_t& oTgtAssoFlat() const OMG_NOEXCEPT {
        return m_oTgtAssoFlat_;
    }

    void oTgtAssoFlat(uint8_t value) {
        m_oTgtAssoFlat_ = value;
    }

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    ST_LAS_TARGET& usLasLocalTgtInfo() OMG_NOEXCEPT {
        return m_usLasLocalTgtInfo_;
    }

    const ST_LAS_TARGET& usLasLocalTgtInfo() const OMG_NOEXCEPT {
        return m_usLasLocalTgtInfo_;
    }

    void usLasLocalTgtInfo(const ST_LAS_TARGET& value) {
        m_usLasLocalTgtInfo_ = value;
    }

    void usLasLocalTgtInfo(ST_LAS_TARGET&& value) {
        m_usLasLocalTgtInfo_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const ST_LAS_ASS_TGT_INFO& other_) const;
    bool operator != (const ST_LAS_ASS_TGT_INFO& other_) const;

    void swap(ST_LAS_ASS_TGT_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oTgtAssoFlat_;
    uint8_t m_oAxisID_;
    ST_LAS_TARGET m_usLasLocalTgtInfo_;
    ::dds::core::array< uint16_t, 2L> m_aReserved_;

};

inline void swap(ST_LAS_ASS_TGT_INFO& a, ST_LAS_ASS_TGT_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_ASS_TGT_INFO& sample);

class NDDSUSERDllExport USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND {
  public:
    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND();

    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oConsoleID,uint8_t oSemiOITType,const ::dds::core::array< uint8_t, 3L>& aAxisValidFlag,const ::dds::core::array< float, 3L>& aAxisBearing,const ::dds::core::array< uint16_t, 3L>& aAxisBeamNo,const ST_LAS_ASS_TGT_INFO& stLasAssoTgtNo,const ::dds::core::array< uint16_t, 2L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND (USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& operator=(const USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND&) = default;
    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND(const USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND&) = default;
    #else
    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& operator=(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oConsoleID() OMG_NOEXCEPT {
        return m_oConsoleID_;
    }

    const uint8_t& oConsoleID() const OMG_NOEXCEPT {
        return m_oConsoleID_;
    }

    void oConsoleID(uint8_t value) {
        m_oConsoleID_ = value;
    }

    uint8_t& oSemiOITType() OMG_NOEXCEPT {
        return m_oSemiOITType_;
    }

    const uint8_t& oSemiOITType() const OMG_NOEXCEPT {
        return m_oSemiOITType_;
    }

    void oSemiOITType(uint8_t value) {
        m_oSemiOITType_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& aAxisValidFlag() OMG_NOEXCEPT {
        return m_aAxisValidFlag_;
    }

    const ::dds::core::array< uint8_t, 3L>& aAxisValidFlag() const OMG_NOEXCEPT {
        return m_aAxisValidFlag_;
    }

    void aAxisValidFlag(const ::dds::core::array< uint8_t, 3L>& value) {
        m_aAxisValidFlag_ = value;
    }

    void aAxisValidFlag(::dds::core::array< uint8_t, 3L>&& value) {
        m_aAxisValidFlag_ = std::move(value);
    }
    ::dds::core::array< float, 3L>& aAxisBearing() OMG_NOEXCEPT {
        return m_aAxisBearing_;
    }

    const ::dds::core::array< float, 3L>& aAxisBearing() const OMG_NOEXCEPT {
        return m_aAxisBearing_;
    }

    void aAxisBearing(const ::dds::core::array< float, 3L>& value) {
        m_aAxisBearing_ = value;
    }

    void aAxisBearing(::dds::core::array< float, 3L>&& value) {
        m_aAxisBearing_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 3L>& aAxisBeamNo() OMG_NOEXCEPT {
        return m_aAxisBeamNo_;
    }

    const ::dds::core::array< uint16_t, 3L>& aAxisBeamNo() const OMG_NOEXCEPT {
        return m_aAxisBeamNo_;
    }

    void aAxisBeamNo(const ::dds::core::array< uint16_t, 3L>& value) {
        m_aAxisBeamNo_ = value;
    }

    void aAxisBeamNo(::dds::core::array< uint16_t, 3L>&& value) {
        m_aAxisBeamNo_ = std::move(value);
    }
    ST_LAS_ASS_TGT_INFO& stLasAssoTgtNo() OMG_NOEXCEPT {
        return m_stLasAssoTgtNo_;
    }

    const ST_LAS_ASS_TGT_INFO& stLasAssoTgtNo() const OMG_NOEXCEPT {
        return m_stLasAssoTgtNo_;
    }

    void stLasAssoTgtNo(const ST_LAS_ASS_TGT_INFO& value) {
        m_stLasAssoTgtNo_ = value;
    }

    void stLasAssoTgtNo(ST_LAS_ASS_TGT_INFO&& value) {
        m_stLasAssoTgtNo_ = std::move(value);
    }
    ::dds::core::array< uint16_t, 2L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& other_) const;

    void swap(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oConsoleID_;
    uint8_t m_oSemiOITType_;
    ::dds::core::array< uint8_t, 3L> m_aAxisValidFlag_;
    ::dds::core::array< float, 3L> m_aAxisBearing_;
    ::dds::core::array< uint16_t, 3L> m_aAxisBeamNo_;
    ST_LAS_ASS_TGT_INFO m_stLasAssoTgtNo_;
    ::dds::core::array< uint16_t, 2L> m_aReserved_;

};

inline void swap(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& a, USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample);

class NDDSUSERDllExport USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND {
  public:
    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND();

    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< float, 24L>& aThreatFrequency);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND (USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& operator=(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND&&) = default;
    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& operator=(const USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND&) = default;
    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND(const USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND&) = default;
    #else
    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& operator=(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< float, 24L>& aThreatFrequency() OMG_NOEXCEPT {
        return m_aThreatFrequency_;
    }

    const ::dds::core::array< float, 24L>& aThreatFrequency() const OMG_NOEXCEPT {
        return m_aThreatFrequency_;
    }

    void aThreatFrequency(const ::dds::core::array< float, 24L>& value) {
        m_aThreatFrequency_ = value;
    }

    void aThreatFrequency(::dds::core::array< float, 24L>&& value) {
        m_aThreatFrequency_ = std::move(value);
    }

    bool operator == (const USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& other_) const;

    void swap(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< float, 24L> m_aThreatFrequency_;

};

inline void swap(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& a, USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& sample);

class NDDSUSERDllExport USERIF_LASTRK_THRESHOLD_INFO {
  public:
    USERIF_LASTRK_THRESHOLD_INFO();

    USERIF_LASTRK_THRESHOLD_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsLasCitThrshAuto,const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LASTRK_THRESHOLD_INFO (USERIF_LASTRK_THRESHOLD_INFO&&) = default;
    USERIF_LASTRK_THRESHOLD_INFO& operator=(USERIF_LASTRK_THRESHOLD_INFO&&) = default;
    USERIF_LASTRK_THRESHOLD_INFO& operator=(const USERIF_LASTRK_THRESHOLD_INFO&) = default;
    USERIF_LASTRK_THRESHOLD_INFO(const USERIF_LASTRK_THRESHOLD_INFO&) = default;
    #else
    USERIF_LASTRK_THRESHOLD_INFO(USERIF_LASTRK_THRESHOLD_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_LASTRK_THRESHOLD_INFO& operator=(USERIF_LASTRK_THRESHOLD_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsLasCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsLasCitThrshAuto_;
    }

    const uint8_t& oIsLasCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsLasCitThrshAuto_;
    }

    void oIsLasCitThrshAuto(uint8_t value) {
        m_oIsLasCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh() OMG_NOEXCEPT {
        return m_stLasThresh_;
    }

    const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& stLasThresh() const OMG_NOEXCEPT {
        return m_stLasThresh_;
    }

    void stLasThresh(const ::dds::core::array< ST_LAS_THRESH_INFO, 3L>& value) {
        m_stLasThresh_ = value;
    }

    void stLasThresh(::dds::core::array< ST_LAS_THRESH_INFO, 3L>&& value) {
        m_stLasThresh_ = std::move(value);
    }

    bool operator == (const USERIF_LASTRK_THRESHOLD_INFO& other_) const;
    bool operator != (const USERIF_LASTRK_THRESHOLD_INFO& other_) const;

    void swap(USERIF_LASTRK_THRESHOLD_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsLasCitThrshAuto_;
    ::dds::core::array< ST_LAS_THRESH_INFO, 3L> m_stLasThresh_;

};

inline void swap(USERIF_LASTRK_THRESHOLD_INFO& a, USERIF_LASTRK_THRESHOLD_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LASTRK_THRESHOLD_INFO& sample);

class NDDSUSERDllExport USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST {
  public:
    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST();

    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t unLineID,uint8_t unCBFBBDintegraltime,uint8_t unCBFSBDintegraltime,uint8_t unABFBBDintegraltime,uint8_t unABFSBDintegraltime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST (USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST&&) = default;
    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& operator=(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST&&) = default;
    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& operator=(const USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST&) = default;
    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST(const USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST&) = default;
    #else
    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& operator=(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& unLineID() OMG_NOEXCEPT {
        return m_unLineID_;
    }

    const uint8_t& unLineID() const OMG_NOEXCEPT {
        return m_unLineID_;
    }

    void unLineID(uint8_t value) {
        m_unLineID_ = value;
    }

    uint8_t& unCBFBBDintegraltime() OMG_NOEXCEPT {
        return m_unCBFBBDintegraltime_;
    }

    const uint8_t& unCBFBBDintegraltime() const OMG_NOEXCEPT {
        return m_unCBFBBDintegraltime_;
    }

    void unCBFBBDintegraltime(uint8_t value) {
        m_unCBFBBDintegraltime_ = value;
    }

    uint8_t& unCBFSBDintegraltime() OMG_NOEXCEPT {
        return m_unCBFSBDintegraltime_;
    }

    const uint8_t& unCBFSBDintegraltime() const OMG_NOEXCEPT {
        return m_unCBFSBDintegraltime_;
    }

    void unCBFSBDintegraltime(uint8_t value) {
        m_unCBFSBDintegraltime_ = value;
    }

    uint8_t& unABFBBDintegraltime() OMG_NOEXCEPT {
        return m_unABFBBDintegraltime_;
    }

    const uint8_t& unABFBBDintegraltime() const OMG_NOEXCEPT {
        return m_unABFBBDintegraltime_;
    }

    void unABFBBDintegraltime(uint8_t value) {
        m_unABFBBDintegraltime_ = value;
    }

    uint8_t& unABFSBDintegraltime() OMG_NOEXCEPT {
        return m_unABFSBDintegraltime_;
    }

    const uint8_t& unABFSBDintegraltime() const OMG_NOEXCEPT {
        return m_unABFSBDintegraltime_;
    }

    void unABFSBDintegraltime(uint8_t value) {
        m_unABFSBDintegraltime_ = value;
    }

    bool operator == (const USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& other_) const;

    void swap(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_unLineID_;
    uint8_t m_unCBFBBDintegraltime_;
    uint8_t m_unCBFSBDintegraltime_;
    uint8_t m_unABFBBDintegraltime_;
    uint8_t m_unABFSBDintegraltime_;

};

inline void swap(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& a, USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& sample);

class NDDSUSERDllExport ST_LAS_MAS_MODEL_INPUT_SET {
  public:
    ST_LAS_MAS_MODEL_INPUT_SET();

    ST_LAS_MAS_MODEL_INPUT_SET(uint8_t oTempDBType,uint16_t usMonth,uint16_t usDay,const ST_USER_TEMP_INFO& stTempInfo,const ::dds::core::array< float, 15L>& fNBTargetSourceLevel,const ::dds::core::array< float, 4L>& fBBTargetSourceLevel,bool bDetMode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_LAS_MAS_MODEL_INPUT_SET (ST_LAS_MAS_MODEL_INPUT_SET&&) = default;
    ST_LAS_MAS_MODEL_INPUT_SET& operator=(ST_LAS_MAS_MODEL_INPUT_SET&&) = default;
    ST_LAS_MAS_MODEL_INPUT_SET& operator=(const ST_LAS_MAS_MODEL_INPUT_SET&) = default;
    ST_LAS_MAS_MODEL_INPUT_SET(const ST_LAS_MAS_MODEL_INPUT_SET&) = default;
    #else
    ST_LAS_MAS_MODEL_INPUT_SET(ST_LAS_MAS_MODEL_INPUT_SET&& other_) OMG_NOEXCEPT;  
    ST_LAS_MAS_MODEL_INPUT_SET& operator=(ST_LAS_MAS_MODEL_INPUT_SET&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oTempDBType() OMG_NOEXCEPT {
        return m_oTempDBType_;
    }

    const uint8_t& oTempDBType() const OMG_NOEXCEPT {
        return m_oTempDBType_;
    }

    void oTempDBType(uint8_t value) {
        m_oTempDBType_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    ST_USER_TEMP_INFO& stTempInfo() OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    const ST_USER_TEMP_INFO& stTempInfo() const OMG_NOEXCEPT {
        return m_stTempInfo_;
    }

    void stTempInfo(const ST_USER_TEMP_INFO& value) {
        m_stTempInfo_ = value;
    }

    void stTempInfo(ST_USER_TEMP_INFO&& value) {
        m_stTempInfo_ = std::move(value);
    }
    ::dds::core::array< float, 15L>& fNBTargetSourceLevel() OMG_NOEXCEPT {
        return m_fNBTargetSourceLevel_;
    }

    const ::dds::core::array< float, 15L>& fNBTargetSourceLevel() const OMG_NOEXCEPT {
        return m_fNBTargetSourceLevel_;
    }

    void fNBTargetSourceLevel(const ::dds::core::array< float, 15L>& value) {
        m_fNBTargetSourceLevel_ = value;
    }

    void fNBTargetSourceLevel(::dds::core::array< float, 15L>&& value) {
        m_fNBTargetSourceLevel_ = std::move(value);
    }
    ::dds::core::array< float, 4L>& fBBTargetSourceLevel() OMG_NOEXCEPT {
        return m_fBBTargetSourceLevel_;
    }

    const ::dds::core::array< float, 4L>& fBBTargetSourceLevel() const OMG_NOEXCEPT {
        return m_fBBTargetSourceLevel_;
    }

    void fBBTargetSourceLevel(const ::dds::core::array< float, 4L>& value) {
        m_fBBTargetSourceLevel_ = value;
    }

    void fBBTargetSourceLevel(::dds::core::array< float, 4L>&& value) {
        m_fBBTargetSourceLevel_ = std::move(value);
    }
    bool& bDetMode() OMG_NOEXCEPT {
        return m_bDetMode_;
    }

    const bool& bDetMode() const OMG_NOEXCEPT {
        return m_bDetMode_;
    }

    void bDetMode(bool value) {
        m_bDetMode_ = value;
    }

    bool operator == (const ST_LAS_MAS_MODEL_INPUT_SET& other_) const;
    bool operator != (const ST_LAS_MAS_MODEL_INPUT_SET& other_) const;

    void swap(ST_LAS_MAS_MODEL_INPUT_SET& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oTempDBType_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;
    ST_USER_TEMP_INFO m_stTempInfo_;
    ::dds::core::array< float, 15L> m_fNBTargetSourceLevel_;
    ::dds::core::array< float, 4L> m_fBBTargetSourceLevel_;
    bool m_bDetMode_;

};

inline void swap(ST_LAS_MAS_MODEL_INPUT_SET& a, ST_LAS_MAS_MODEL_INPUT_SET& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_LAS_MAS_MODEL_INPUT_SET& sample);

class NDDSUSERDllExport USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST {
  public:
    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST();

    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST(const ST_MSG_HEADER& stMsgHeader,bool bProcessType,uint8_t oAnalSensor,const ST_LAS_MAS_MODEL_INPUT_SET& stLASMASModelInput);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST (USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST&&) = default;
    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& operator=(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST&&) = default;
    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& operator=(const USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST&) = default;
    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST(const USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST&) = default;
    #else
    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& operator=(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    bool& bProcessType() OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    const bool& bProcessType() const OMG_NOEXCEPT {
        return m_bProcessType_;
    }

    void bProcessType(bool value) {
        m_bProcessType_ = value;
    }

    uint8_t& oAnalSensor() OMG_NOEXCEPT {
        return m_oAnalSensor_;
    }

    const uint8_t& oAnalSensor() const OMG_NOEXCEPT {
        return m_oAnalSensor_;
    }

    void oAnalSensor(uint8_t value) {
        m_oAnalSensor_ = value;
    }

    ST_LAS_MAS_MODEL_INPUT_SET& stLASMASModelInput() OMG_NOEXCEPT {
        return m_stLASMASModelInput_;
    }

    const ST_LAS_MAS_MODEL_INPUT_SET& stLASMASModelInput() const OMG_NOEXCEPT {
        return m_stLASMASModelInput_;
    }

    void stLASMASModelInput(const ST_LAS_MAS_MODEL_INPUT_SET& value) {
        m_stLASMASModelInput_ = value;
    }

    void stLASMASModelInput(ST_LAS_MAS_MODEL_INPUT_SET&& value) {
        m_stLASMASModelInput_ = std::move(value);
    }

    bool operator == (const USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& other_) const;
    bool operator != (const USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& other_) const;

    void swap(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    bool m_bProcessType_;
    uint8_t m_oAnalSensor_;
    ST_LAS_MAS_MODEL_INPUT_SET m_stLASMASModelInput_;

};

inline void swap(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& a, USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& sample);

class NDDSUSERDllExport USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST {
  public:
    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST();

    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerControl,uint8_t oReceiverPowerControl,uint8_t oProcessorPowerControl,uint8_t oNetworkPowerControl,uint8_t oDisplayPowerControl);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST (USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST&&) = default;
    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST&&) = default;
    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(const USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST&) = default;
    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST(const USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST&) = default;
    #else
    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerControl() OMG_NOEXCEPT {
        return m_oPowerSupplyPowerControl_;
    }

    const ::dds::core::array< uint8_t, 3L>& oPowerSupplyPowerControl() const OMG_NOEXCEPT {
        return m_oPowerSupplyPowerControl_;
    }

    void oPowerSupplyPowerControl(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oPowerSupplyPowerControl_ = value;
    }

    void oPowerSupplyPowerControl(::dds::core::array< uint8_t, 3L>&& value) {
        m_oPowerSupplyPowerControl_ = std::move(value);
    }
    uint8_t& oReceiverPowerControl() OMG_NOEXCEPT {
        return m_oReceiverPowerControl_;
    }

    const uint8_t& oReceiverPowerControl() const OMG_NOEXCEPT {
        return m_oReceiverPowerControl_;
    }

    void oReceiverPowerControl(uint8_t value) {
        m_oReceiverPowerControl_ = value;
    }

    uint8_t& oProcessorPowerControl() OMG_NOEXCEPT {
        return m_oProcessorPowerControl_;
    }

    const uint8_t& oProcessorPowerControl() const OMG_NOEXCEPT {
        return m_oProcessorPowerControl_;
    }

    void oProcessorPowerControl(uint8_t value) {
        m_oProcessorPowerControl_ = value;
    }

    uint8_t& oNetworkPowerControl() OMG_NOEXCEPT {
        return m_oNetworkPowerControl_;
    }

    const uint8_t& oNetworkPowerControl() const OMG_NOEXCEPT {
        return m_oNetworkPowerControl_;
    }

    void oNetworkPowerControl(uint8_t value) {
        m_oNetworkPowerControl_ = value;
    }

    uint8_t& oDisplayPowerControl() OMG_NOEXCEPT {
        return m_oDisplayPowerControl_;
    }

    const uint8_t& oDisplayPowerControl() const OMG_NOEXCEPT {
        return m_oDisplayPowerControl_;
    }

    void oDisplayPowerControl(uint8_t value) {
        m_oDisplayPowerControl_ = value;
    }

    bool operator == (const USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) const;

    void swap(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 3L> m_oPowerSupplyPowerControl_;
    uint8_t m_oReceiverPowerControl_;
    uint8_t m_oProcessorPowerControl_;
    uint8_t m_oNetworkPowerControl_;
    uint8_t m_oDisplayPowerControl_;

};

inline void swap(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& a, USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_LAS_SENSOR_CONTROL_REQUEST {
  public:
    USERIF_LAS_SENSOR_CONTROL_REQUEST();

    USERIF_LAS_SENSOR_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 3L>& oGainCtrlMode,const ::dds::core::array< uint8_t, 3L>& oAGCvalue,const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Tx,const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Rx,const ::dds::core::array< uint8_t, 3L>& oMainMuxSwitch);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_SENSOR_CONTROL_REQUEST (USERIF_LAS_SENSOR_CONTROL_REQUEST&&) = default;
    USERIF_LAS_SENSOR_CONTROL_REQUEST& operator=(USERIF_LAS_SENSOR_CONTROL_REQUEST&&) = default;
    USERIF_LAS_SENSOR_CONTROL_REQUEST& operator=(const USERIF_LAS_SENSOR_CONTROL_REQUEST&) = default;
    USERIF_LAS_SENSOR_CONTROL_REQUEST(const USERIF_LAS_SENSOR_CONTROL_REQUEST&) = default;
    #else
    USERIF_LAS_SENSOR_CONTROL_REQUEST(USERIF_LAS_SENSOR_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_SENSOR_CONTROL_REQUEST& operator=(USERIF_LAS_SENSOR_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oGainCtrlMode() OMG_NOEXCEPT {
        return m_oGainCtrlMode_;
    }

    const ::dds::core::array< uint8_t, 3L>& oGainCtrlMode() const OMG_NOEXCEPT {
        return m_oGainCtrlMode_;
    }

    void oGainCtrlMode(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oGainCtrlMode_ = value;
    }

    void oGainCtrlMode(::dds::core::array< uint8_t, 3L>&& value) {
        m_oGainCtrlMode_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oAGCvalue() OMG_NOEXCEPT {
        return m_oAGCvalue_;
    }

    const ::dds::core::array< uint8_t, 3L>& oAGCvalue() const OMG_NOEXCEPT {
        return m_oAGCvalue_;
    }

    void oAGCvalue(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oAGCvalue_ = value;
    }

    void oAGCvalue(::dds::core::array< uint8_t, 3L>&& value) {
        m_oAGCvalue_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oEOSwitch_Tx() OMG_NOEXCEPT {
        return m_oEOSwitch_Tx_;
    }

    const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Tx() const OMG_NOEXCEPT {
        return m_oEOSwitch_Tx_;
    }

    void oEOSwitch_Tx(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oEOSwitch_Tx_ = value;
    }

    void oEOSwitch_Tx(::dds::core::array< uint8_t, 3L>&& value) {
        m_oEOSwitch_Tx_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oEOSwitch_Rx() OMG_NOEXCEPT {
        return m_oEOSwitch_Rx_;
    }

    const ::dds::core::array< uint8_t, 3L>& oEOSwitch_Rx() const OMG_NOEXCEPT {
        return m_oEOSwitch_Rx_;
    }

    void oEOSwitch_Rx(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oEOSwitch_Rx_ = value;
    }

    void oEOSwitch_Rx(::dds::core::array< uint8_t, 3L>&& value) {
        m_oEOSwitch_Rx_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& oMainMuxSwitch() OMG_NOEXCEPT {
        return m_oMainMuxSwitch_;
    }

    const ::dds::core::array< uint8_t, 3L>& oMainMuxSwitch() const OMG_NOEXCEPT {
        return m_oMainMuxSwitch_;
    }

    void oMainMuxSwitch(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oMainMuxSwitch_ = value;
    }

    void oMainMuxSwitch(::dds::core::array< uint8_t, 3L>&& value) {
        m_oMainMuxSwitch_ = std::move(value);
    }

    bool operator == (const USERIF_LAS_SENSOR_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_LAS_SENSOR_CONTROL_REQUEST& other_) const;

    void swap(USERIF_LAS_SENSOR_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 3L> m_oGainCtrlMode_;
    ::dds::core::array< uint8_t, 3L> m_oAGCvalue_;
    ::dds::core::array< uint8_t, 3L> m_oEOSwitch_Tx_;
    ::dds::core::array< uint8_t, 3L> m_oEOSwitch_Rx_;
    ::dds::core::array< uint8_t, 3L> m_oMainMuxSwitch_;

};

inline void swap(USERIF_LAS_SENSOR_CONTROL_REQUEST& a, USERIF_LAS_SENSOR_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_SENSOR_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST {
  public:
    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST();

    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ::dds::core::array< uint8_t, 240L>, 3L>& unSensorStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST (USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST&&) = default;
    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST&&) = default;
    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(const USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST&) = default;
    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST(const USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST&) = default;
    #else
    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint8_t, 240L>, 3L>& unSensorStatus() OMG_NOEXCEPT {
        return m_unSensorStatus_;
    }

    const ::dds::core::array< ::dds::core::array< uint8_t, 240L>, 3L>& unSensorStatus() const OMG_NOEXCEPT {
        return m_unSensorStatus_;
    }

    void unSensorStatus(const ::dds::core::array< ::dds::core::array< uint8_t, 240L>, 3L>& value) {
        m_unSensorStatus_ = value;
    }

    void unSensorStatus(::dds::core::array< ::dds::core::array< uint8_t, 240L>, 3L>&& value) {
        m_unSensorStatus_ = std::move(value);
    }

    bool operator == (const USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) const;
    bool operator != (const USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) const;

    void swap(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ::dds::core::array< uint8_t, 240L>, 3L> m_unSensorStatus_;

};

inline void swap(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& a, USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample);

class NDDSUSERDllExport USERIF_LAS_TRACK_SFL_DELETE_CONTROL {
  public:
    USERIF_LAS_TRACK_SFL_DELETE_CONTROL();

    USERIF_LAS_TRACK_SFL_DELETE_CONTROL(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usGlobalID,uint8_t oAxis,float fFreq,uint8_t oDetectionType,uint8_t oSFLIndex,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_TRACK_SFL_DELETE_CONTROL (USERIF_LAS_TRACK_SFL_DELETE_CONTROL&&) = default;
    USERIF_LAS_TRACK_SFL_DELETE_CONTROL& operator=(USERIF_LAS_TRACK_SFL_DELETE_CONTROL&&) = default;
    USERIF_LAS_TRACK_SFL_DELETE_CONTROL& operator=(const USERIF_LAS_TRACK_SFL_DELETE_CONTROL&) = default;
    USERIF_LAS_TRACK_SFL_DELETE_CONTROL(const USERIF_LAS_TRACK_SFL_DELETE_CONTROL&) = default;
    #else
    USERIF_LAS_TRACK_SFL_DELETE_CONTROL(USERIF_LAS_TRACK_SFL_DELETE_CONTROL&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_TRACK_SFL_DELETE_CONTROL& operator=(USERIF_LAS_TRACK_SFL_DELETE_CONTROL&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usGlobalID() OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    const uint16_t& usGlobalID() const OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    void usGlobalID(uint16_t value) {
        m_usGlobalID_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    float& fFreq() OMG_NOEXCEPT {
        return m_fFreq_;
    }

    const float& fFreq() const OMG_NOEXCEPT {
        return m_fFreq_;
    }

    void fFreq(float value) {
        m_fFreq_ = value;
    }

    uint8_t& oDetectionType() OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    const uint8_t& oDetectionType() const OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    void oDetectionType(uint8_t value) {
        m_oDetectionType_ = value;
    }

    uint8_t& oSFLIndex() OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    const uint8_t& oSFLIndex() const OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    void oSFLIndex(uint8_t value) {
        m_oSFLIndex_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_LAS_TRACK_SFL_DELETE_CONTROL& other_) const;
    bool operator != (const USERIF_LAS_TRACK_SFL_DELETE_CONTROL& other_) const;

    void swap(USERIF_LAS_TRACK_SFL_DELETE_CONTROL& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usGlobalID_;
    uint8_t m_oAxis_;
    float m_fFreq_;
    uint8_t m_oDetectionType_;
    uint8_t m_oSFLIndex_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_LAS_TRACK_SFL_DELETE_CONTROL& a, USERIF_LAS_TRACK_SFL_DELETE_CONTROL& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_TRACK_SFL_DELETE_CONTROL& sample);

class NDDSUSERDllExport USERIF_LAS_TRACK_USER_CONFIRM_COMMAND {
  public:
    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND();

    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCommandID,uint16_t usGlobalID,uint8_t oAxis,float fFreq,uint8_t oDetectionType,uint8_t oSFLIndex,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND (USERIF_LAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& operator=(const USERIF_LAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND(const USERIF_LAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint16_t& usGlobalID() OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    const uint16_t& usGlobalID() const OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    void usGlobalID(uint16_t value) {
        m_usGlobalID_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    float& fFreq() OMG_NOEXCEPT {
        return m_fFreq_;
    }

    const float& fFreq() const OMG_NOEXCEPT {
        return m_fFreq_;
    }

    void fFreq(float value) {
        m_fFreq_ = value;
    }

    uint8_t& oDetectionType() OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    const uint8_t& oDetectionType() const OMG_NOEXCEPT {
        return m_oDetectionType_;
    }

    void oDetectionType(uint8_t value) {
        m_oDetectionType_ = value;
    }

    uint8_t& oSFLIndex() OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    const uint8_t& oSFLIndex() const OMG_NOEXCEPT {
        return m_oSFLIndex_;
    }

    void oSFLIndex(uint8_t value) {
        m_oSFLIndex_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCommandID_;
    uint16_t m_usGlobalID_;
    uint8_t m_oAxis_;
    float m_fFreq_;
    uint8_t m_oDetectionType_;
    uint8_t m_oSFLIndex_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& a, USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST {
  public:
    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST();

    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 3L>& unPowervalue);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST (USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST&&) = default;
    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& operator=(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST&&) = default;
    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& operator=(const USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST&) = default;
    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST(const USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST&) = default;
    #else
    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& operator=(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 3L>& unPowervalue() OMG_NOEXCEPT {
        return m_unPowervalue_;
    }

    const ::dds::core::array< uint8_t, 3L>& unPowervalue() const OMG_NOEXCEPT {
        return m_unPowervalue_;
    }

    void unPowervalue(const ::dds::core::array< uint8_t, 3L>& value) {
        m_unPowervalue_ = value;
    }

    void unPowervalue(::dds::core::array< uint8_t, 3L>&& value) {
        m_unPowervalue_ = std::move(value);
    }

    bool operator == (const USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& other_) const;

    void swap(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 3L> m_unPowervalue_;

};

inline void swap(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& a, USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_LOST_INTEREST_TARGET_SEND_REQUEST {
  public:
    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST();

    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usTgtNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST (USERIF_LOST_INTEREST_TARGET_SEND_REQUEST&&) = default;
    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& operator=(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST&&) = default;
    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& operator=(const USERIF_LOST_INTEREST_TARGET_SEND_REQUEST&) = default;
    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST(const USERIF_LOST_INTEREST_TARGET_SEND_REQUEST&) = default;
    #else
    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& operator=(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usTgtNo() OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    const uint16_t& usTgtNo() const OMG_NOEXCEPT {
        return m_usTgtNo_;
    }

    void usTgtNo(uint16_t value) {
        m_usTgtNo_ = value;
    }

    bool operator == (const USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& other_) const;
    bool operator != (const USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& other_) const;

    void swap(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usTgtNo_;

};

inline void swap(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& a, USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& sample);

class NDDSUSERDllExport USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST {
  public:
    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST();

    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unCommandID,uint16_t unGlobalID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST (USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST&&) = default;
    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& operator=(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST&&) = default;
    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& operator=(const USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST&) = default;
    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST(const USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST&) = default;
    #else
    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& operator=(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unCommandID() OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    const uint16_t& unCommandID() const OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    void unCommandID(uint16_t value) {
        m_unCommandID_ = value;
    }

    uint16_t& unGlobalID() OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    const uint16_t& unGlobalID() const OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    void unGlobalID(uint16_t value) {
        m_unGlobalID_ = value;
    }

    bool operator == (const USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& other_) const;
    bool operator != (const USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& other_) const;

    void swap(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unCommandID_;
    uint16_t m_unGlobalID_;

};

inline void swap(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& a, USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& sample);

class NDDSUSERDllExport USERIF_MASTRK_CONC_TGT_REG_COMMAND {
  public:
    USERIF_MASTRK_CONC_TGT_REG_COMMAND();

    USERIF_MASTRK_CONC_TGT_REG_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oAxisID,uint8_t oMasTrkType,uint16_t unTgtNo,const ::dds::core::array< uint16_t, 2L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MASTRK_CONC_TGT_REG_COMMAND (USERIF_MASTRK_CONC_TGT_REG_COMMAND&&) = default;
    USERIF_MASTRK_CONC_TGT_REG_COMMAND& operator=(USERIF_MASTRK_CONC_TGT_REG_COMMAND&&) = default;
    USERIF_MASTRK_CONC_TGT_REG_COMMAND& operator=(const USERIF_MASTRK_CONC_TGT_REG_COMMAND&) = default;
    USERIF_MASTRK_CONC_TGT_REG_COMMAND(const USERIF_MASTRK_CONC_TGT_REG_COMMAND&) = default;
    #else
    USERIF_MASTRK_CONC_TGT_REG_COMMAND(USERIF_MASTRK_CONC_TGT_REG_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_MASTRK_CONC_TGT_REG_COMMAND& operator=(USERIF_MASTRK_CONC_TGT_REG_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint8_t& oMasTrkType() OMG_NOEXCEPT {
        return m_oMasTrkType_;
    }

    const uint8_t& oMasTrkType() const OMG_NOEXCEPT {
        return m_oMasTrkType_;
    }

    void oMasTrkType(uint8_t value) {
        m_oMasTrkType_ = value;
    }

    uint16_t& unTgtNo() OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    const uint16_t& unTgtNo() const OMG_NOEXCEPT {
        return m_unTgtNo_;
    }

    void unTgtNo(uint16_t value) {
        m_unTgtNo_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const USERIF_MASTRK_CONC_TGT_REG_COMMAND& other_) const;
    bool operator != (const USERIF_MASTRK_CONC_TGT_REG_COMMAND& other_) const;

    void swap(USERIF_MASTRK_CONC_TGT_REG_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oAxisID_;
    uint8_t m_oMasTrkType_;
    uint16_t m_unTgtNo_;
    ::dds::core::array< uint16_t, 2L> m_aReserved_;

};

inline void swap(USERIF_MASTRK_CONC_TGT_REG_COMMAND& a, USERIF_MASTRK_CONC_TGT_REG_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MASTRK_CONC_TGT_REG_COMMAND& sample);

class NDDSUSERDllExport USERIF_MASTRK_THRESHOLD_INFO {
  public:
    USERIF_MASTRK_THRESHOLD_INFO();

    USERIF_MASTRK_THRESHOLD_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oIsMasCitThrshAuto,const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasThresh);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MASTRK_THRESHOLD_INFO (USERIF_MASTRK_THRESHOLD_INFO&&) = default;
    USERIF_MASTRK_THRESHOLD_INFO& operator=(USERIF_MASTRK_THRESHOLD_INFO&&) = default;
    USERIF_MASTRK_THRESHOLD_INFO& operator=(const USERIF_MASTRK_THRESHOLD_INFO&) = default;
    USERIF_MASTRK_THRESHOLD_INFO(const USERIF_MASTRK_THRESHOLD_INFO&) = default;
    #else
    USERIF_MASTRK_THRESHOLD_INFO(USERIF_MASTRK_THRESHOLD_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_MASTRK_THRESHOLD_INFO& operator=(USERIF_MASTRK_THRESHOLD_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oIsMasCitThrshAuto() OMG_NOEXCEPT {
        return m_oIsMasCitThrshAuto_;
    }

    const uint8_t& oIsMasCitThrshAuto() const OMG_NOEXCEPT {
        return m_oIsMasCitThrshAuto_;
    }

    void oIsMasCitThrshAuto(uint8_t value) {
        m_oIsMasCitThrshAuto_ = value;
    }

    ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasThresh() OMG_NOEXCEPT {
        return m_stMasThresh_;
    }

    const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& stMasThresh() const OMG_NOEXCEPT {
        return m_stMasThresh_;
    }

    void stMasThresh(const ::dds::core::array< ST_MAS_THRESH_INFO, 2L>& value) {
        m_stMasThresh_ = value;
    }

    void stMasThresh(::dds::core::array< ST_MAS_THRESH_INFO, 2L>&& value) {
        m_stMasThresh_ = std::move(value);
    }

    bool operator == (const USERIF_MASTRK_THRESHOLD_INFO& other_) const;
    bool operator != (const USERIF_MASTRK_THRESHOLD_INFO& other_) const;

    void swap(USERIF_MASTRK_THRESHOLD_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oIsMasCitThrshAuto_;
    ::dds::core::array< ST_MAS_THRESH_INFO, 2L> m_stMasThresh_;

};

inline void swap(USERIF_MASTRK_THRESHOLD_INFO& a, USERIF_MASTRK_THRESHOLD_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MASTRK_THRESHOLD_INFO& sample);

class NDDSUSERDllExport USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST {
  public:
    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST();

    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 2L>& unSBDintegraltime,const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST (USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST&&) = default;
    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& operator=(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST&&) = default;
    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& operator=(const USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST&) = default;
    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST(const USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST&) = default;
    #else
    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& operator=(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& unSBDintegraltime() OMG_NOEXCEPT {
        return m_unSBDintegraltime_;
    }

    const ::dds::core::array< uint8_t, 2L>& unSBDintegraltime() const OMG_NOEXCEPT {
        return m_unSBDintegraltime_;
    }

    void unSBDintegraltime(const ::dds::core::array< uint8_t, 2L>& value) {
        m_unSBDintegraltime_ = value;
    }

    void unSBDintegraltime(::dds::core::array< uint8_t, 2L>&& value) {
        m_unSBDintegraltime_ = std::move(value);
    }
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& stMASDetFreqExcInfo() const OMG_NOEXCEPT {
        return m_stMASDetFreqExcInfo_;
    }

    void stMASDetFreqExcInfo(const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& value) {
        m_stMASDetFreqExcInfo_ = value;
    }

    void stMASDetFreqExcInfo(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO&& value) {
        m_stMASDetFreqExcInfo_ = std::move(value);
    }

    bool operator == (const USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& other_) const;

    void swap(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 2L> m_unSBDintegraltime_;
    ST_MAS_DETECTION_EXCLUSION_FREQ_INFO m_stMASDetFreqExcInfo_;

};

inline void swap(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& a, USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST {
  public:
    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST();

    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 2L>& oPowerSupplyPowerControl,uint8_t oReceiverPowerControl,uint8_t oProcessorPowerControl,uint8_t oNetworkPowerControl,uint8_t oDisplayPowerControl);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST (USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST&&) = default;
    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST&&) = default;
    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(const USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST&) = default;
    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST(const USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST&) = default;
    #else
    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& operator=(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& oPowerSupplyPowerControl() OMG_NOEXCEPT {
        return m_oPowerSupplyPowerControl_;
    }

    const ::dds::core::array< uint8_t, 2L>& oPowerSupplyPowerControl() const OMG_NOEXCEPT {
        return m_oPowerSupplyPowerControl_;
    }

    void oPowerSupplyPowerControl(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oPowerSupplyPowerControl_ = value;
    }

    void oPowerSupplyPowerControl(::dds::core::array< uint8_t, 2L>&& value) {
        m_oPowerSupplyPowerControl_ = std::move(value);
    }
    uint8_t& oReceiverPowerControl() OMG_NOEXCEPT {
        return m_oReceiverPowerControl_;
    }

    const uint8_t& oReceiverPowerControl() const OMG_NOEXCEPT {
        return m_oReceiverPowerControl_;
    }

    void oReceiverPowerControl(uint8_t value) {
        m_oReceiverPowerControl_ = value;
    }

    uint8_t& oProcessorPowerControl() OMG_NOEXCEPT {
        return m_oProcessorPowerControl_;
    }

    const uint8_t& oProcessorPowerControl() const OMG_NOEXCEPT {
        return m_oProcessorPowerControl_;
    }

    void oProcessorPowerControl(uint8_t value) {
        m_oProcessorPowerControl_ = value;
    }

    uint8_t& oNetworkPowerControl() OMG_NOEXCEPT {
        return m_oNetworkPowerControl_;
    }

    const uint8_t& oNetworkPowerControl() const OMG_NOEXCEPT {
        return m_oNetworkPowerControl_;
    }

    void oNetworkPowerControl(uint8_t value) {
        m_oNetworkPowerControl_ = value;
    }

    uint8_t& oDisplayPowerControl() OMG_NOEXCEPT {
        return m_oDisplayPowerControl_;
    }

    const uint8_t& oDisplayPowerControl() const OMG_NOEXCEPT {
        return m_oDisplayPowerControl_;
    }

    void oDisplayPowerControl(uint8_t value) {
        m_oDisplayPowerControl_ = value;
    }

    bool operator == (const USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) const;

    void swap(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 2L> m_oPowerSupplyPowerControl_;
    uint8_t m_oReceiverPowerControl_;
    uint8_t m_oProcessorPowerControl_;
    uint8_t m_oNetworkPowerControl_;
    uint8_t m_oDisplayPowerControl_;

};

inline void swap(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& a, USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_MAS_SENSOR_CONTROL_REQUEST {
  public:
    USERIF_MAS_SENSOR_CONTROL_REQUEST();

    USERIF_MAS_SENSOR_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 2L>& oGainCtrlMode,const ::dds::core::array< uint8_t, 2L>& oAGCvalue,const ::dds::core::array< uint8_t, 2L>& oEOSwitch_Tx,const ::dds::core::array< uint8_t, 2L>& oEOSwitch_Rx,const ::dds::core::array< uint8_t, 2L>& oMainMuxSwitch);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MAS_SENSOR_CONTROL_REQUEST (USERIF_MAS_SENSOR_CONTROL_REQUEST&&) = default;
    USERIF_MAS_SENSOR_CONTROL_REQUEST& operator=(USERIF_MAS_SENSOR_CONTROL_REQUEST&&) = default;
    USERIF_MAS_SENSOR_CONTROL_REQUEST& operator=(const USERIF_MAS_SENSOR_CONTROL_REQUEST&) = default;
    USERIF_MAS_SENSOR_CONTROL_REQUEST(const USERIF_MAS_SENSOR_CONTROL_REQUEST&) = default;
    #else
    USERIF_MAS_SENSOR_CONTROL_REQUEST(USERIF_MAS_SENSOR_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MAS_SENSOR_CONTROL_REQUEST& operator=(USERIF_MAS_SENSOR_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& oGainCtrlMode() OMG_NOEXCEPT {
        return m_oGainCtrlMode_;
    }

    const ::dds::core::array< uint8_t, 2L>& oGainCtrlMode() const OMG_NOEXCEPT {
        return m_oGainCtrlMode_;
    }

    void oGainCtrlMode(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oGainCtrlMode_ = value;
    }

    void oGainCtrlMode(::dds::core::array< uint8_t, 2L>&& value) {
        m_oGainCtrlMode_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& oAGCvalue() OMG_NOEXCEPT {
        return m_oAGCvalue_;
    }

    const ::dds::core::array< uint8_t, 2L>& oAGCvalue() const OMG_NOEXCEPT {
        return m_oAGCvalue_;
    }

    void oAGCvalue(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oAGCvalue_ = value;
    }

    void oAGCvalue(::dds::core::array< uint8_t, 2L>&& value) {
        m_oAGCvalue_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& oEOSwitch_Tx() OMG_NOEXCEPT {
        return m_oEOSwitch_Tx_;
    }

    const ::dds::core::array< uint8_t, 2L>& oEOSwitch_Tx() const OMG_NOEXCEPT {
        return m_oEOSwitch_Tx_;
    }

    void oEOSwitch_Tx(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oEOSwitch_Tx_ = value;
    }

    void oEOSwitch_Tx(::dds::core::array< uint8_t, 2L>&& value) {
        m_oEOSwitch_Tx_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& oEOSwitch_Rx() OMG_NOEXCEPT {
        return m_oEOSwitch_Rx_;
    }

    const ::dds::core::array< uint8_t, 2L>& oEOSwitch_Rx() const OMG_NOEXCEPT {
        return m_oEOSwitch_Rx_;
    }

    void oEOSwitch_Rx(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oEOSwitch_Rx_ = value;
    }

    void oEOSwitch_Rx(::dds::core::array< uint8_t, 2L>&& value) {
        m_oEOSwitch_Rx_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& oMainMuxSwitch() OMG_NOEXCEPT {
        return m_oMainMuxSwitch_;
    }

    const ::dds::core::array< uint8_t, 2L>& oMainMuxSwitch() const OMG_NOEXCEPT {
        return m_oMainMuxSwitch_;
    }

    void oMainMuxSwitch(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oMainMuxSwitch_ = value;
    }

    void oMainMuxSwitch(::dds::core::array< uint8_t, 2L>&& value) {
        m_oMainMuxSwitch_ = std::move(value);
    }

    bool operator == (const USERIF_MAS_SENSOR_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_MAS_SENSOR_CONTROL_REQUEST& other_) const;

    void swap(USERIF_MAS_SENSOR_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 2L> m_oGainCtrlMode_;
    ::dds::core::array< uint8_t, 2L> m_oAGCvalue_;
    ::dds::core::array< uint8_t, 2L> m_oEOSwitch_Tx_;
    ::dds::core::array< uint8_t, 2L> m_oEOSwitch_Rx_;
    ::dds::core::array< uint8_t, 2L> m_oMainMuxSwitch_;

};

inline void swap(USERIF_MAS_SENSOR_CONTROL_REQUEST& a, USERIF_MAS_SENSOR_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MAS_SENSOR_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST {
  public:
    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST();

    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ::dds::core::array< uint8_t, 49L>, 2L>& unMAGSensorStatus,const ::dds::core::array< ::dds::core::array< uint8_t, 25L>, 2L>& unACOSensorStatus);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST (USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST&&) = default;
    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST&&) = default;
    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(const USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST&) = default;
    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST(const USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST&) = default;
    #else
    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& operator=(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint8_t, 49L>, 2L>& unMAGSensorStatus() OMG_NOEXCEPT {
        return m_unMAGSensorStatus_;
    }

    const ::dds::core::array< ::dds::core::array< uint8_t, 49L>, 2L>& unMAGSensorStatus() const OMG_NOEXCEPT {
        return m_unMAGSensorStatus_;
    }

    void unMAGSensorStatus(const ::dds::core::array< ::dds::core::array< uint8_t, 49L>, 2L>& value) {
        m_unMAGSensorStatus_ = value;
    }

    void unMAGSensorStatus(::dds::core::array< ::dds::core::array< uint8_t, 49L>, 2L>&& value) {
        m_unMAGSensorStatus_ = std::move(value);
    }
    ::dds::core::array< ::dds::core::array< uint8_t, 25L>, 2L>& unACOSensorStatus() OMG_NOEXCEPT {
        return m_unACOSensorStatus_;
    }

    const ::dds::core::array< ::dds::core::array< uint8_t, 25L>, 2L>& unACOSensorStatus() const OMG_NOEXCEPT {
        return m_unACOSensorStatus_;
    }

    void unACOSensorStatus(const ::dds::core::array< ::dds::core::array< uint8_t, 25L>, 2L>& value) {
        m_unACOSensorStatus_ = value;
    }

    void unACOSensorStatus(::dds::core::array< ::dds::core::array< uint8_t, 25L>, 2L>&& value) {
        m_unACOSensorStatus_ = std::move(value);
    }

    bool operator == (const USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) const;
    bool operator != (const USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) const;

    void swap(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ::dds::core::array< uint8_t, 49L>, 2L> m_unMAGSensorStatus_;
    ::dds::core::array< ::dds::core::array< uint8_t, 25L>, 2L> m_unACOSensorStatus_;

};

inline void swap(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& a, USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample);

class NDDSUSERDllExport USERIF_MAS_TRACK_USER_CONFIRM_COMMAND {
  public:
    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND();

    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCommandID,uint16_t usGlobalID,uint8_t oAxis,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND (USERIF_MAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND&&) = default;
    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& operator=(const USERIF_MAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND(const USERIF_MAS_TRACK_USER_CONFIRM_COMMAND&) = default;
    #else
    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& operator=(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    uint16_t& usGlobalID() OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    const uint16_t& usGlobalID() const OMG_NOEXCEPT {
        return m_usGlobalID_;
    }

    void usGlobalID(uint16_t value) {
        m_usGlobalID_ = value;
    }

    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& other_) const;
    bool operator != (const USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& other_) const;

    void swap(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCommandID_;
    uint16_t m_usGlobalID_;
    uint8_t m_oAxis_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& a, USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& sample);

class NDDSUSERDllExport USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST {
  public:
    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST();

    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 2L>& unPowervalue);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST (USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST&&) = default;
    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& operator=(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST&&) = default;
    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& operator=(const USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST&) = default;
    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST(const USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST&) = default;
    #else
    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& operator=(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 2L>& unPowervalue() OMG_NOEXCEPT {
        return m_unPowervalue_;
    }

    const ::dds::core::array< uint8_t, 2L>& unPowervalue() const OMG_NOEXCEPT {
        return m_unPowervalue_;
    }

    void unPowervalue(const ::dds::core::array< uint8_t, 2L>& value) {
        m_unPowervalue_ = value;
    }

    void unPowervalue(::dds::core::array< uint8_t, 2L>&& value) {
        m_unPowervalue_ = std::move(value);
    }

    bool operator == (const USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& other_) const;

    void swap(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 2L> m_unPowervalue_;

};

inline void swap(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& a, USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_OI_CLASSIFICATION_FREQ_INFO {
  public:
    USERIF_OI_CLASSIFICATION_FREQ_INFO();

    USERIF_OI_CLASSIFICATION_FREQ_INFO(const ST_MSG_HEADER& stMsgHeader,const ST_FEATURE_FREQ_INFO& stFeatureInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_OI_CLASSIFICATION_FREQ_INFO (USERIF_OI_CLASSIFICATION_FREQ_INFO&&) = default;
    USERIF_OI_CLASSIFICATION_FREQ_INFO& operator=(USERIF_OI_CLASSIFICATION_FREQ_INFO&&) = default;
    USERIF_OI_CLASSIFICATION_FREQ_INFO& operator=(const USERIF_OI_CLASSIFICATION_FREQ_INFO&) = default;
    USERIF_OI_CLASSIFICATION_FREQ_INFO(const USERIF_OI_CLASSIFICATION_FREQ_INFO&) = default;
    #else
    USERIF_OI_CLASSIFICATION_FREQ_INFO(USERIF_OI_CLASSIFICATION_FREQ_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_OI_CLASSIFICATION_FREQ_INFO& operator=(USERIF_OI_CLASSIFICATION_FREQ_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_FEATURE_FREQ_INFO& stFeatureInfo() OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    const ST_FEATURE_FREQ_INFO& stFeatureInfo() const OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    void stFeatureInfo(const ST_FEATURE_FREQ_INFO& value) {
        m_stFeatureInfo_ = value;
    }

    void stFeatureInfo(ST_FEATURE_FREQ_INFO&& value) {
        m_stFeatureInfo_ = std::move(value);
    }

    bool operator == (const USERIF_OI_CLASSIFICATION_FREQ_INFO& other_) const;
    bool operator != (const USERIF_OI_CLASSIFICATION_FREQ_INFO& other_) const;

    void swap(USERIF_OI_CLASSIFICATION_FREQ_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_FEATURE_FREQ_INFO m_stFeatureInfo_;

};

inline void swap(USERIF_OI_CLASSIFICATION_FREQ_INFO& a, USERIF_OI_CLASSIFICATION_FREQ_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_OI_CLASSIFICATION_FREQ_INFO& sample);

class NDDSUSERDllExport USERIF_OI_CLASSIFICATION_REQUEST {
  public:
    USERIF_OI_CLASSIFICATION_REQUEST();

    USERIF_OI_CLASSIFICATION_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ST_DATE_TIME& stSelectTime,uint8_t oAxis,uint16_t usBeamNum);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_OI_CLASSIFICATION_REQUEST (USERIF_OI_CLASSIFICATION_REQUEST&&) = default;
    USERIF_OI_CLASSIFICATION_REQUEST& operator=(USERIF_OI_CLASSIFICATION_REQUEST&&) = default;
    USERIF_OI_CLASSIFICATION_REQUEST& operator=(const USERIF_OI_CLASSIFICATION_REQUEST&) = default;
    USERIF_OI_CLASSIFICATION_REQUEST(const USERIF_OI_CLASSIFICATION_REQUEST&) = default;
    #else
    USERIF_OI_CLASSIFICATION_REQUEST(USERIF_OI_CLASSIFICATION_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_OI_CLASSIFICATION_REQUEST& operator=(USERIF_OI_CLASSIFICATION_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_DATE_TIME& stSelectTime() OMG_NOEXCEPT {
        return m_stSelectTime_;
    }

    const ST_DATE_TIME& stSelectTime() const OMG_NOEXCEPT {
        return m_stSelectTime_;
    }

    void stSelectTime(const ST_DATE_TIME& value) {
        m_stSelectTime_ = value;
    }

    void stSelectTime(ST_DATE_TIME&& value) {
        m_stSelectTime_ = std::move(value);
    }
    uint8_t& oAxis() OMG_NOEXCEPT {
        return m_oAxis_;
    }

    const uint8_t& oAxis() const OMG_NOEXCEPT {
        return m_oAxis_;
    }

    void oAxis(uint8_t value) {
        m_oAxis_ = value;
    }

    uint16_t& usBeamNum() OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    const uint16_t& usBeamNum() const OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    void usBeamNum(uint16_t value) {
        m_usBeamNum_ = value;
    }

    bool operator == (const USERIF_OI_CLASSIFICATION_REQUEST& other_) const;
    bool operator != (const USERIF_OI_CLASSIFICATION_REQUEST& other_) const;

    void swap(USERIF_OI_CLASSIFICATION_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_DATE_TIME m_stSelectTime_;
    uint8_t m_oAxis_;
    uint16_t m_usBeamNum_;

};

inline void swap(USERIF_OI_CLASSIFICATION_REQUEST& a, USERIF_OI_CLASSIFICATION_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_OI_CLASSIFICATION_REQUEST& sample);

class NDDSUSERDllExport USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST {
  public:
    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST();

    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ST_DATE_TIME& stReqTime,const ST_DATE_TIME& stSendTime,uint16_t usSensorID,uint16_t usBeamNum,uint16_t usGlobalTargetNum,uint16_t usClaRetNum,const ST_FEATURE_FREQ_INFO& stFeatureInfo,const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stOICLARet,const ::dds::core::array< uint8_t, 256L>& szComments,uint16_t usLOFARFrameNum,const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram,uint16_t usDEMONFrameNum,const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST (USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST&&) = default;
    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& operator=(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST&&) = default;
    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& operator=(const USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST&) = default;
    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST(const USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST&) = default;
    #else
    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& operator=(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_DATE_TIME& stReqTime() OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    const ST_DATE_TIME& stReqTime() const OMG_NOEXCEPT {
        return m_stReqTime_;
    }

    void stReqTime(const ST_DATE_TIME& value) {
        m_stReqTime_ = value;
    }

    void stReqTime(ST_DATE_TIME&& value) {
        m_stReqTime_ = std::move(value);
    }
    ST_DATE_TIME& stSendTime() OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    const ST_DATE_TIME& stSendTime() const OMG_NOEXCEPT {
        return m_stSendTime_;
    }

    void stSendTime(const ST_DATE_TIME& value) {
        m_stSendTime_ = value;
    }

    void stSendTime(ST_DATE_TIME&& value) {
        m_stSendTime_ = std::move(value);
    }
    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usBeamNum() OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    const uint16_t& usBeamNum() const OMG_NOEXCEPT {
        return m_usBeamNum_;
    }

    void usBeamNum(uint16_t value) {
        m_usBeamNum_ = value;
    }

    uint16_t& usGlobalTargetNum() OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    const uint16_t& usGlobalTargetNum() const OMG_NOEXCEPT {
        return m_usGlobalTargetNum_;
    }

    void usGlobalTargetNum(uint16_t value) {
        m_usGlobalTargetNum_ = value;
    }

    uint16_t& usClaRetNum() OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    const uint16_t& usClaRetNum() const OMG_NOEXCEPT {
        return m_usClaRetNum_;
    }

    void usClaRetNum(uint16_t value) {
        m_usClaRetNum_ = value;
    }

    ST_FEATURE_FREQ_INFO& stFeatureInfo() OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    const ST_FEATURE_FREQ_INFO& stFeatureInfo() const OMG_NOEXCEPT {
        return m_stFeatureInfo_;
    }

    void stFeatureInfo(const ST_FEATURE_FREQ_INFO& value) {
        m_stFeatureInfo_ = value;
    }

    void stFeatureInfo(ST_FEATURE_FREQ_INFO&& value) {
        m_stFeatureInfo_ = std::move(value);
    }
    ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stOICLARet() OMG_NOEXCEPT {
        return m_stOICLARet_;
    }

    const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& stOICLARet() const OMG_NOEXCEPT {
        return m_stOICLARet_;
    }

    void stOICLARet(const ::dds::core::array< ST_CLA_RESULT_INFO, 8L>& value) {
        m_stOICLARet_ = value;
    }

    void stOICLARet(::dds::core::array< ST_CLA_RESULT_INFO, 8L>&& value) {
        m_stOICLARet_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& szComments() OMG_NOEXCEPT {
        return m_szComments_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComments() const OMG_NOEXCEPT {
        return m_szComments_;
    }

    void szComments(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComments_ = value;
    }

    void szComments(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComments_ = std::move(value);
    }
    uint16_t& usLOFARFrameNum() OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    const uint16_t& usLOFARFrameNum() const OMG_NOEXCEPT {
        return m_usLOFARFrameNum_;
    }

    void usLOFARFrameNum(uint16_t value) {
        m_usLOFARFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& fLOFARGram() const OMG_NOEXCEPT {
        return m_fLOFARGram_;
    }

    void fLOFARGram(const ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>& value) {
        m_fLOFARGram_ = value;
    }

    void fLOFARGram(::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L>&& value) {
        m_fLOFARGram_ = std::move(value);
    }
    uint16_t& usDEMONFrameNum() OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    const uint16_t& usDEMONFrameNum() const OMG_NOEXCEPT {
        return m_usDEMONFrameNum_;
    }

    void usDEMONFrameNum(uint16_t value) {
        m_usDEMONFrameNum_ = value;
    }

    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& fDEMONGram() const OMG_NOEXCEPT {
        return m_fDEMONGram_;
    }

    void fDEMONGram(const ::dds::core::array< ::dds::core::array< float, 1601L>, 300L>& value) {
        m_fDEMONGram_ = value;
    }

    void fDEMONGram(::dds::core::array< ::dds::core::array< float, 1601L>, 300L>&& value) {
        m_fDEMONGram_ = std::move(value);
    }

    bool operator == (const USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& other_) const;
    bool operator != (const USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& other_) const;

    void swap(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_DATE_TIME m_stReqTime_;
    ST_DATE_TIME m_stSendTime_;
    uint16_t m_usSensorID_;
    uint16_t m_usBeamNum_;
    uint16_t m_usGlobalTargetNum_;
    uint16_t m_usClaRetNum_;
    ST_FEATURE_FREQ_INFO m_stFeatureInfo_;
    ::dds::core::array< ST_CLA_RESULT_INFO, 8L> m_stOICLARet_;
    ::dds::core::array< uint8_t, 256L> m_szComments_;
    uint16_t m_usLOFARFrameNum_;
    ::dds::core::array< ::dds::core::array< ::dds::core::array< float, 1601L>, 4L>, 300L> m_fLOFARGram_;
    uint16_t m_usDEMONFrameNum_;
    ::dds::core::array< ::dds::core::array< float, 1601L>, 300L> m_fDEMONGram_;

};

inline void swap(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& a, USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& sample);

class NDDSUSERDllExport USERIF_POINT_ANALYSIS_REQUEST {
  public:
    USERIF_POINT_ANALYSIS_REQUEST();

    USERIF_POINT_ANALYSIS_REQUEST(const ST_MSG_HEADER& stMsgHeader,double dPointLatPos,double dPointLonPos,uint16_t usMonth,uint16_t usDay);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_POINT_ANALYSIS_REQUEST (USERIF_POINT_ANALYSIS_REQUEST&&) = default;
    USERIF_POINT_ANALYSIS_REQUEST& operator=(USERIF_POINT_ANALYSIS_REQUEST&&) = default;
    USERIF_POINT_ANALYSIS_REQUEST& operator=(const USERIF_POINT_ANALYSIS_REQUEST&) = default;
    USERIF_POINT_ANALYSIS_REQUEST(const USERIF_POINT_ANALYSIS_REQUEST&) = default;
    #else
    USERIF_POINT_ANALYSIS_REQUEST(USERIF_POINT_ANALYSIS_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_POINT_ANALYSIS_REQUEST& operator=(USERIF_POINT_ANALYSIS_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    double& dPointLatPos() OMG_NOEXCEPT {
        return m_dPointLatPos_;
    }

    const double& dPointLatPos() const OMG_NOEXCEPT {
        return m_dPointLatPos_;
    }

    void dPointLatPos(double value) {
        m_dPointLatPos_ = value;
    }

    double& dPointLonPos() OMG_NOEXCEPT {
        return m_dPointLonPos_;
    }

    const double& dPointLonPos() const OMG_NOEXCEPT {
        return m_dPointLonPos_;
    }

    void dPointLonPos(double value) {
        m_dPointLonPos_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    bool operator == (const USERIF_POINT_ANALYSIS_REQUEST& other_) const;
    bool operator != (const USERIF_POINT_ANALYSIS_REQUEST& other_) const;

    void swap(USERIF_POINT_ANALYSIS_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    double m_dPointLatPos_;
    double m_dPointLonPos_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;

};

inline void swap(USERIF_POINT_ANALYSIS_REQUEST& a, USERIF_POINT_ANALYSIS_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_POINT_ANALYSIS_REQUEST& sample);

class NDDSUSERDllExport USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST {
  public:
    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST();

    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCalculationTime,uint16_t unGlobalID,uint16_t unPredicTime,uint16_t usActivateCmd);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST (USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST&&) = default;
    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& operator=(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST&&) = default;
    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& operator=(const USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST&) = default;
    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST(const USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST&) = default;
    #else
    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& operator=(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCalculationTime() OMG_NOEXCEPT {
        return m_usCalculationTime_;
    }

    const uint16_t& usCalculationTime() const OMG_NOEXCEPT {
        return m_usCalculationTime_;
    }

    void usCalculationTime(uint16_t value) {
        m_usCalculationTime_ = value;
    }

    uint16_t& unGlobalID() OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    const uint16_t& unGlobalID() const OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    void unGlobalID(uint16_t value) {
        m_unGlobalID_ = value;
    }

    uint16_t& unPredicTime() OMG_NOEXCEPT {
        return m_unPredicTime_;
    }

    const uint16_t& unPredicTime() const OMG_NOEXCEPT {
        return m_unPredicTime_;
    }

    void unPredicTime(uint16_t value) {
        m_unPredicTime_ = value;
    }

    uint16_t& usActivateCmd() OMG_NOEXCEPT {
        return m_usActivateCmd_;
    }

    const uint16_t& usActivateCmd() const OMG_NOEXCEPT {
        return m_usActivateCmd_;
    }

    void usActivateCmd(uint16_t value) {
        m_usActivateCmd_ = value;
    }

    bool operator == (const USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& other_) const;
    bool operator != (const USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& other_) const;

    void swap(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCalculationTime_;
    uint16_t m_unGlobalID_;
    uint16_t m_unPredicTime_;
    uint16_t m_usActivateCmd_;

};

inline void swap(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& a, USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& sample);

class NDDSUSERDllExport USERIF_RADAR_CHANNEL_CONTROL_REQUEST {
  public:
    USERIF_RADAR_CHANNEL_CONTROL_REQUEST();

    USERIF_RADAR_CHANNEL_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulRaderID,uint32_t ucChannelID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RADAR_CHANNEL_CONTROL_REQUEST (USERIF_RADAR_CHANNEL_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_CHANNEL_CONTROL_REQUEST& operator=(USERIF_RADAR_CHANNEL_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_CHANNEL_CONTROL_REQUEST& operator=(const USERIF_RADAR_CHANNEL_CONTROL_REQUEST&) = default;
    USERIF_RADAR_CHANNEL_CONTROL_REQUEST(const USERIF_RADAR_CHANNEL_CONTROL_REQUEST&) = default;
    #else
    USERIF_RADAR_CHANNEL_CONTROL_REQUEST(USERIF_RADAR_CHANNEL_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_RADAR_CHANNEL_CONTROL_REQUEST& operator=(USERIF_RADAR_CHANNEL_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulRaderID() OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    const uint32_t& ulRaderID() const OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    void ulRaderID(uint32_t value) {
        m_ulRaderID_ = value;
    }

    uint32_t& ucChannelID() OMG_NOEXCEPT {
        return m_ucChannelID_;
    }

    const uint32_t& ucChannelID() const OMG_NOEXCEPT {
        return m_ucChannelID_;
    }

    void ucChannelID(uint32_t value) {
        m_ucChannelID_ = value;
    }

    bool operator == (const USERIF_RADAR_CHANNEL_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_RADAR_CHANNEL_CONTROL_REQUEST& other_) const;

    void swap(USERIF_RADAR_CHANNEL_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulRaderID_;
    uint32_t m_ucChannelID_;

};

inline void swap(USERIF_RADAR_CHANNEL_CONTROL_REQUEST& a, USERIF_RADAR_CHANNEL_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RADAR_CHANNEL_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_RADAR_FILTER_CONTROL_REQUEST {
  public:
    USERIF_RADAR_FILTER_CONTROL_REQUEST();

    USERIF_RADAR_FILTER_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulRaderID,uint8_t ucResetTarget,uint8_t ucTrackmethod,uint8_t ucTrackregieon,uint8_t ucTrackcancelvalue,uint32_t ulSpeedhigh,uint32_t ulSpeedlow,uint32_t ulContactFrequency);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RADAR_FILTER_CONTROL_REQUEST (USERIF_RADAR_FILTER_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_FILTER_CONTROL_REQUEST& operator=(USERIF_RADAR_FILTER_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_FILTER_CONTROL_REQUEST& operator=(const USERIF_RADAR_FILTER_CONTROL_REQUEST&) = default;
    USERIF_RADAR_FILTER_CONTROL_REQUEST(const USERIF_RADAR_FILTER_CONTROL_REQUEST&) = default;
    #else
    USERIF_RADAR_FILTER_CONTROL_REQUEST(USERIF_RADAR_FILTER_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_RADAR_FILTER_CONTROL_REQUEST& operator=(USERIF_RADAR_FILTER_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulRaderID() OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    const uint32_t& ulRaderID() const OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    void ulRaderID(uint32_t value) {
        m_ulRaderID_ = value;
    }

    uint8_t& ucResetTarget() OMG_NOEXCEPT {
        return m_ucResetTarget_;
    }

    const uint8_t& ucResetTarget() const OMG_NOEXCEPT {
        return m_ucResetTarget_;
    }

    void ucResetTarget(uint8_t value) {
        m_ucResetTarget_ = value;
    }

    uint8_t& ucTrackmethod() OMG_NOEXCEPT {
        return m_ucTrackmethod_;
    }

    const uint8_t& ucTrackmethod() const OMG_NOEXCEPT {
        return m_ucTrackmethod_;
    }

    void ucTrackmethod(uint8_t value) {
        m_ucTrackmethod_ = value;
    }

    uint8_t& ucTrackregieon() OMG_NOEXCEPT {
        return m_ucTrackregieon_;
    }

    const uint8_t& ucTrackregieon() const OMG_NOEXCEPT {
        return m_ucTrackregieon_;
    }

    void ucTrackregieon(uint8_t value) {
        m_ucTrackregieon_ = value;
    }

    uint8_t& ucTrackcancelvalue() OMG_NOEXCEPT {
        return m_ucTrackcancelvalue_;
    }

    const uint8_t& ucTrackcancelvalue() const OMG_NOEXCEPT {
        return m_ucTrackcancelvalue_;
    }

    void ucTrackcancelvalue(uint8_t value) {
        m_ucTrackcancelvalue_ = value;
    }

    uint32_t& ulSpeedhigh() OMG_NOEXCEPT {
        return m_ulSpeedhigh_;
    }

    const uint32_t& ulSpeedhigh() const OMG_NOEXCEPT {
        return m_ulSpeedhigh_;
    }

    void ulSpeedhigh(uint32_t value) {
        m_ulSpeedhigh_ = value;
    }

    uint32_t& ulSpeedlow() OMG_NOEXCEPT {
        return m_ulSpeedlow_;
    }

    const uint32_t& ulSpeedlow() const OMG_NOEXCEPT {
        return m_ulSpeedlow_;
    }

    void ulSpeedlow(uint32_t value) {
        m_ulSpeedlow_ = value;
    }

    uint32_t& ulContactFrequency() OMG_NOEXCEPT {
        return m_ulContactFrequency_;
    }

    const uint32_t& ulContactFrequency() const OMG_NOEXCEPT {
        return m_ulContactFrequency_;
    }

    void ulContactFrequency(uint32_t value) {
        m_ulContactFrequency_ = value;
    }

    bool operator == (const USERIF_RADAR_FILTER_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_RADAR_FILTER_CONTROL_REQUEST& other_) const;

    void swap(USERIF_RADAR_FILTER_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulRaderID_;
    uint8_t m_ucResetTarget_;
    uint8_t m_ucTrackmethod_;
    uint8_t m_ucTrackregieon_;
    uint8_t m_ucTrackcancelvalue_;
    uint32_t m_ulSpeedhigh_;
    uint32_t m_ulSpeedlow_;
    uint32_t m_ulContactFrequency_;

};

inline void swap(USERIF_RADAR_FILTER_CONTROL_REQUEST& a, USERIF_RADAR_FILTER_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RADAR_FILTER_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_RADAR_TRACK_CONTROL_REQUEST {
  public:
    USERIF_RADAR_TRACK_CONTROL_REQUEST();

    USERIF_RADAR_TRACK_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulRaderID,uint32_t ulTrackingstart,float fTargetdistance,float fTargetdegree,uint32_t ulTrackingend,uint32_t ulTrackingendID,uint32_t ulExchangetraking,uint32_t ulExchangetrakingID1,uint32_t ulExchangetrakingID2,uint32_t ulChangetraking,uint32_t ulChangetrakingID1,uint32_t ulChangetrakingID2,uint32_t ulUserDefine,uint32_t ulUserDefineID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RADAR_TRACK_CONTROL_REQUEST (USERIF_RADAR_TRACK_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_TRACK_CONTROL_REQUEST& operator=(USERIF_RADAR_TRACK_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_TRACK_CONTROL_REQUEST& operator=(const USERIF_RADAR_TRACK_CONTROL_REQUEST&) = default;
    USERIF_RADAR_TRACK_CONTROL_REQUEST(const USERIF_RADAR_TRACK_CONTROL_REQUEST&) = default;
    #else
    USERIF_RADAR_TRACK_CONTROL_REQUEST(USERIF_RADAR_TRACK_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_RADAR_TRACK_CONTROL_REQUEST& operator=(USERIF_RADAR_TRACK_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulRaderID() OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    const uint32_t& ulRaderID() const OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    void ulRaderID(uint32_t value) {
        m_ulRaderID_ = value;
    }

    uint32_t& ulTrackingstart() OMG_NOEXCEPT {
        return m_ulTrackingstart_;
    }

    const uint32_t& ulTrackingstart() const OMG_NOEXCEPT {
        return m_ulTrackingstart_;
    }

    void ulTrackingstart(uint32_t value) {
        m_ulTrackingstart_ = value;
    }

    float& fTargetdistance() OMG_NOEXCEPT {
        return m_fTargetdistance_;
    }

    const float& fTargetdistance() const OMG_NOEXCEPT {
        return m_fTargetdistance_;
    }

    void fTargetdistance(float value) {
        m_fTargetdistance_ = value;
    }

    float& fTargetdegree() OMG_NOEXCEPT {
        return m_fTargetdegree_;
    }

    const float& fTargetdegree() const OMG_NOEXCEPT {
        return m_fTargetdegree_;
    }

    void fTargetdegree(float value) {
        m_fTargetdegree_ = value;
    }

    uint32_t& ulTrackingend() OMG_NOEXCEPT {
        return m_ulTrackingend_;
    }

    const uint32_t& ulTrackingend() const OMG_NOEXCEPT {
        return m_ulTrackingend_;
    }

    void ulTrackingend(uint32_t value) {
        m_ulTrackingend_ = value;
    }

    uint32_t& ulTrackingendID() OMG_NOEXCEPT {
        return m_ulTrackingendID_;
    }

    const uint32_t& ulTrackingendID() const OMG_NOEXCEPT {
        return m_ulTrackingendID_;
    }

    void ulTrackingendID(uint32_t value) {
        m_ulTrackingendID_ = value;
    }

    uint32_t& ulExchangetraking() OMG_NOEXCEPT {
        return m_ulExchangetraking_;
    }

    const uint32_t& ulExchangetraking() const OMG_NOEXCEPT {
        return m_ulExchangetraking_;
    }

    void ulExchangetraking(uint32_t value) {
        m_ulExchangetraking_ = value;
    }

    uint32_t& ulExchangetrakingID1() OMG_NOEXCEPT {
        return m_ulExchangetrakingID1_;
    }

    const uint32_t& ulExchangetrakingID1() const OMG_NOEXCEPT {
        return m_ulExchangetrakingID1_;
    }

    void ulExchangetrakingID1(uint32_t value) {
        m_ulExchangetrakingID1_ = value;
    }

    uint32_t& ulExchangetrakingID2() OMG_NOEXCEPT {
        return m_ulExchangetrakingID2_;
    }

    const uint32_t& ulExchangetrakingID2() const OMG_NOEXCEPT {
        return m_ulExchangetrakingID2_;
    }

    void ulExchangetrakingID2(uint32_t value) {
        m_ulExchangetrakingID2_ = value;
    }

    uint32_t& ulChangetraking() OMG_NOEXCEPT {
        return m_ulChangetraking_;
    }

    const uint32_t& ulChangetraking() const OMG_NOEXCEPT {
        return m_ulChangetraking_;
    }

    void ulChangetraking(uint32_t value) {
        m_ulChangetraking_ = value;
    }

    uint32_t& ulChangetrakingID1() OMG_NOEXCEPT {
        return m_ulChangetrakingID1_;
    }

    const uint32_t& ulChangetrakingID1() const OMG_NOEXCEPT {
        return m_ulChangetrakingID1_;
    }

    void ulChangetrakingID1(uint32_t value) {
        m_ulChangetrakingID1_ = value;
    }

    uint32_t& ulChangetrakingID2() OMG_NOEXCEPT {
        return m_ulChangetrakingID2_;
    }

    const uint32_t& ulChangetrakingID2() const OMG_NOEXCEPT {
        return m_ulChangetrakingID2_;
    }

    void ulChangetrakingID2(uint32_t value) {
        m_ulChangetrakingID2_ = value;
    }

    uint32_t& ulUserDefine() OMG_NOEXCEPT {
        return m_ulUserDefine_;
    }

    const uint32_t& ulUserDefine() const OMG_NOEXCEPT {
        return m_ulUserDefine_;
    }

    void ulUserDefine(uint32_t value) {
        m_ulUserDefine_ = value;
    }

    uint32_t& ulUserDefineID() OMG_NOEXCEPT {
        return m_ulUserDefineID_;
    }

    const uint32_t& ulUserDefineID() const OMG_NOEXCEPT {
        return m_ulUserDefineID_;
    }

    void ulUserDefineID(uint32_t value) {
        m_ulUserDefineID_ = value;
    }

    bool operator == (const USERIF_RADAR_TRACK_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_RADAR_TRACK_CONTROL_REQUEST& other_) const;

    void swap(USERIF_RADAR_TRACK_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulRaderID_;
    uint32_t m_ulTrackingstart_;
    float m_fTargetdistance_;
    float m_fTargetdegree_;
    uint32_t m_ulTrackingend_;
    uint32_t m_ulTrackingendID_;
    uint32_t m_ulExchangetraking_;
    uint32_t m_ulExchangetrakingID1_;
    uint32_t m_ulExchangetrakingID2_;
    uint32_t m_ulChangetraking_;
    uint32_t m_ulChangetrakingID1_;
    uint32_t m_ulChangetrakingID2_;
    uint32_t m_ulUserDefine_;
    uint32_t m_ulUserDefineID_;

};

inline void swap(USERIF_RADAR_TRACK_CONTROL_REQUEST& a, USERIF_RADAR_TRACK_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RADAR_TRACK_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_RADAR_VIDEO_CONTROL_REQUEST {
  public:
    USERIF_RADAR_VIDEO_CONTROL_REQUEST();

    USERIF_RADAR_VIDEO_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint32_t ulRaderID,uint8_t ucreserved,uint8_t ucFTCvalue,uint8_t ucSTCvalue,uint8_t ucCACFARvalue,uint8_t ucreserved2,uint8_t ucReserved3,uint16_t unCurrentDisplay,float fScreencenter,float fScreenDegree);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RADAR_VIDEO_CONTROL_REQUEST (USERIF_RADAR_VIDEO_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_VIDEO_CONTROL_REQUEST& operator=(USERIF_RADAR_VIDEO_CONTROL_REQUEST&&) = default;
    USERIF_RADAR_VIDEO_CONTROL_REQUEST& operator=(const USERIF_RADAR_VIDEO_CONTROL_REQUEST&) = default;
    USERIF_RADAR_VIDEO_CONTROL_REQUEST(const USERIF_RADAR_VIDEO_CONTROL_REQUEST&) = default;
    #else
    USERIF_RADAR_VIDEO_CONTROL_REQUEST(USERIF_RADAR_VIDEO_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_RADAR_VIDEO_CONTROL_REQUEST& operator=(USERIF_RADAR_VIDEO_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulRaderID() OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    const uint32_t& ulRaderID() const OMG_NOEXCEPT {
        return m_ulRaderID_;
    }

    void ulRaderID(uint32_t value) {
        m_ulRaderID_ = value;
    }

    uint8_t& ucreserved() OMG_NOEXCEPT {
        return m_ucreserved_;
    }

    const uint8_t& ucreserved() const OMG_NOEXCEPT {
        return m_ucreserved_;
    }

    void ucreserved(uint8_t value) {
        m_ucreserved_ = value;
    }

    uint8_t& ucFTCvalue() OMG_NOEXCEPT {
        return m_ucFTCvalue_;
    }

    const uint8_t& ucFTCvalue() const OMG_NOEXCEPT {
        return m_ucFTCvalue_;
    }

    void ucFTCvalue(uint8_t value) {
        m_ucFTCvalue_ = value;
    }

    uint8_t& ucSTCvalue() OMG_NOEXCEPT {
        return m_ucSTCvalue_;
    }

    const uint8_t& ucSTCvalue() const OMG_NOEXCEPT {
        return m_ucSTCvalue_;
    }

    void ucSTCvalue(uint8_t value) {
        m_ucSTCvalue_ = value;
    }

    uint8_t& ucCACFARvalue() OMG_NOEXCEPT {
        return m_ucCACFARvalue_;
    }

    const uint8_t& ucCACFARvalue() const OMG_NOEXCEPT {
        return m_ucCACFARvalue_;
    }

    void ucCACFARvalue(uint8_t value) {
        m_ucCACFARvalue_ = value;
    }

    uint8_t& ucreserved2() OMG_NOEXCEPT {
        return m_ucreserved2_;
    }

    const uint8_t& ucreserved2() const OMG_NOEXCEPT {
        return m_ucreserved2_;
    }

    void ucreserved2(uint8_t value) {
        m_ucreserved2_ = value;
    }

    uint8_t& ucReserved3() OMG_NOEXCEPT {
        return m_ucReserved3_;
    }

    const uint8_t& ucReserved3() const OMG_NOEXCEPT {
        return m_ucReserved3_;
    }

    void ucReserved3(uint8_t value) {
        m_ucReserved3_ = value;
    }

    uint16_t& unCurrentDisplay() OMG_NOEXCEPT {
        return m_unCurrentDisplay_;
    }

    const uint16_t& unCurrentDisplay() const OMG_NOEXCEPT {
        return m_unCurrentDisplay_;
    }

    void unCurrentDisplay(uint16_t value) {
        m_unCurrentDisplay_ = value;
    }

    float& fScreencenter() OMG_NOEXCEPT {
        return m_fScreencenter_;
    }

    const float& fScreencenter() const OMG_NOEXCEPT {
        return m_fScreencenter_;
    }

    void fScreencenter(float value) {
        m_fScreencenter_ = value;
    }

    float& fScreenDegree() OMG_NOEXCEPT {
        return m_fScreenDegree_;
    }

    const float& fScreenDegree() const OMG_NOEXCEPT {
        return m_fScreenDegree_;
    }

    void fScreenDegree(float value) {
        m_fScreenDegree_ = value;
    }

    bool operator == (const USERIF_RADAR_VIDEO_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_RADAR_VIDEO_CONTROL_REQUEST& other_) const;

    void swap(USERIF_RADAR_VIDEO_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulRaderID_;
    uint8_t m_ucreserved_;
    uint8_t m_ucFTCvalue_;
    uint8_t m_ucSTCvalue_;
    uint8_t m_ucCACFARvalue_;
    uint8_t m_ucreserved2_;
    uint8_t m_ucReserved3_;
    uint16_t m_unCurrentDisplay_;
    float m_fScreencenter_;
    float m_fScreenDegree_;

};

inline void swap(USERIF_RADAR_VIDEO_CONTROL_REQUEST& a, USERIF_RADAR_VIDEO_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RADAR_VIDEO_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_RAWAUDIO_CONTROL_REQUEST {
  public:
    USERIF_RAWAUDIO_CONTROL_REQUEST();

    USERIF_RAWAUDIO_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t unCommandcode,const ::dds::core::array< uint8_t, 256L>& szFileName,const ::dds::core::array< uint8_t, 100L>& szUserTag,uint16_t usIndex,uint16_t usPageNum,const ST_DATE_TIME& stStartTime,const ST_DATE_TIME& stEndTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RAWAUDIO_CONTROL_REQUEST (USERIF_RAWAUDIO_CONTROL_REQUEST&&) = default;
    USERIF_RAWAUDIO_CONTROL_REQUEST& operator=(USERIF_RAWAUDIO_CONTROL_REQUEST&&) = default;
    USERIF_RAWAUDIO_CONTROL_REQUEST& operator=(const USERIF_RAWAUDIO_CONTROL_REQUEST&) = default;
    USERIF_RAWAUDIO_CONTROL_REQUEST(const USERIF_RAWAUDIO_CONTROL_REQUEST&) = default;
    #else
    USERIF_RAWAUDIO_CONTROL_REQUEST(USERIF_RAWAUDIO_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_RAWAUDIO_CONTROL_REQUEST& operator=(USERIF_RAWAUDIO_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& unCommandcode() OMG_NOEXCEPT {
        return m_unCommandcode_;
    }

    const uint8_t& unCommandcode() const OMG_NOEXCEPT {
        return m_unCommandcode_;
    }

    void unCommandcode(uint8_t value) {
        m_unCommandcode_ = value;
    }

    ::dds::core::array< uint8_t, 256L>& szFileName() OMG_NOEXCEPT {
        return m_szFileName_;
    }

    const ::dds::core::array< uint8_t, 256L>& szFileName() const OMG_NOEXCEPT {
        return m_szFileName_;
    }

    void szFileName(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szFileName_ = value;
    }

    void szFileName(::dds::core::array< uint8_t, 256L>&& value) {
        m_szFileName_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 100L>& szUserTag() OMG_NOEXCEPT {
        return m_szUserTag_;
    }

    const ::dds::core::array< uint8_t, 100L>& szUserTag() const OMG_NOEXCEPT {
        return m_szUserTag_;
    }

    void szUserTag(const ::dds::core::array< uint8_t, 100L>& value) {
        m_szUserTag_ = value;
    }

    void szUserTag(::dds::core::array< uint8_t, 100L>&& value) {
        m_szUserTag_ = std::move(value);
    }
    uint16_t& usIndex() OMG_NOEXCEPT {
        return m_usIndex_;
    }

    const uint16_t& usIndex() const OMG_NOEXCEPT {
        return m_usIndex_;
    }

    void usIndex(uint16_t value) {
        m_usIndex_ = value;
    }

    uint16_t& usPageNum() OMG_NOEXCEPT {
        return m_usPageNum_;
    }

    const uint16_t& usPageNum() const OMG_NOEXCEPT {
        return m_usPageNum_;
    }

    void usPageNum(uint16_t value) {
        m_usPageNum_ = value;
    }

    ST_DATE_TIME& stStartTime() OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    const ST_DATE_TIME& stStartTime() const OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    void stStartTime(const ST_DATE_TIME& value) {
        m_stStartTime_ = value;
    }

    void stStartTime(ST_DATE_TIME&& value) {
        m_stStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stEndTime() OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    const ST_DATE_TIME& stEndTime() const OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    void stEndTime(const ST_DATE_TIME& value) {
        m_stEndTime_ = value;
    }

    void stEndTime(ST_DATE_TIME&& value) {
        m_stEndTime_ = std::move(value);
    }

    bool operator == (const USERIF_RAWAUDIO_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_RAWAUDIO_CONTROL_REQUEST& other_) const;

    void swap(USERIF_RAWAUDIO_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_unCommandcode_;
    ::dds::core::array< uint8_t, 256L> m_szFileName_;
    ::dds::core::array< uint8_t, 100L> m_szUserTag_;
    uint16_t m_usIndex_;
    uint16_t m_usPageNum_;
    ST_DATE_TIME m_stStartTime_;
    ST_DATE_TIME m_stEndTime_;

};

inline void swap(USERIF_RAWAUDIO_CONTROL_REQUEST& a, USERIF_RAWAUDIO_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RAWAUDIO_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_RMT_DEVICE_CTRL_COMMAND {
  public:
    USERIF_RMT_DEVICE_CTRL_COMMAND();

    USERIF_RMT_DEVICE_CTRL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCommandID,int32_t eSWID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RMT_DEVICE_CTRL_COMMAND (USERIF_RMT_DEVICE_CTRL_COMMAND&&) = default;
    USERIF_RMT_DEVICE_CTRL_COMMAND& operator=(USERIF_RMT_DEVICE_CTRL_COMMAND&&) = default;
    USERIF_RMT_DEVICE_CTRL_COMMAND& operator=(const USERIF_RMT_DEVICE_CTRL_COMMAND&) = default;
    USERIF_RMT_DEVICE_CTRL_COMMAND(const USERIF_RMT_DEVICE_CTRL_COMMAND&) = default;
    #else
    USERIF_RMT_DEVICE_CTRL_COMMAND(USERIF_RMT_DEVICE_CTRL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_RMT_DEVICE_CTRL_COMMAND& operator=(USERIF_RMT_DEVICE_CTRL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    int32_t& eSWID() OMG_NOEXCEPT {
        return m_eSWID_;
    }

    const int32_t& eSWID() const OMG_NOEXCEPT {
        return m_eSWID_;
    }

    void eSWID(int32_t value) {
        m_eSWID_ = value;
    }

    bool operator == (const USERIF_RMT_DEVICE_CTRL_COMMAND& other_) const;
    bool operator != (const USERIF_RMT_DEVICE_CTRL_COMMAND& other_) const;

    void swap(USERIF_RMT_DEVICE_CTRL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCommandID_;
    int32_t m_eSWID_;

};

inline void swap(USERIF_RMT_DEVICE_CTRL_COMMAND& a, USERIF_RMT_DEVICE_CTRL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RMT_DEVICE_CTRL_COMMAND& sample);

class NDDSUSERDllExport USERIF_SCREENSHOT_CONTROL_REQUEST {
  public:
    USERIF_SCREENSHOT_CONTROL_REQUEST();

    USERIF_SCREENSHOT_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unScreenShotIndex,uint8_t oRequestCommand,const ::dds::core::array< uint8_t, 256L>& szComment);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SCREENSHOT_CONTROL_REQUEST (USERIF_SCREENSHOT_CONTROL_REQUEST&&) = default;
    USERIF_SCREENSHOT_CONTROL_REQUEST& operator=(USERIF_SCREENSHOT_CONTROL_REQUEST&&) = default;
    USERIF_SCREENSHOT_CONTROL_REQUEST& operator=(const USERIF_SCREENSHOT_CONTROL_REQUEST&) = default;
    USERIF_SCREENSHOT_CONTROL_REQUEST(const USERIF_SCREENSHOT_CONTROL_REQUEST&) = default;
    #else
    USERIF_SCREENSHOT_CONTROL_REQUEST(USERIF_SCREENSHOT_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_SCREENSHOT_CONTROL_REQUEST& operator=(USERIF_SCREENSHOT_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unScreenShotIndex() OMG_NOEXCEPT {
        return m_unScreenShotIndex_;
    }

    const uint16_t& unScreenShotIndex() const OMG_NOEXCEPT {
        return m_unScreenShotIndex_;
    }

    void unScreenShotIndex(uint16_t value) {
        m_unScreenShotIndex_ = value;
    }

    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    ::dds::core::array< uint8_t, 256L>& szComment() OMG_NOEXCEPT {
        return m_szComment_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComment() const OMG_NOEXCEPT {
        return m_szComment_;
    }

    void szComment(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComment_ = value;
    }

    void szComment(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComment_ = std::move(value);
    }

    bool operator == (const USERIF_SCREENSHOT_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_SCREENSHOT_CONTROL_REQUEST& other_) const;

    void swap(USERIF_SCREENSHOT_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unScreenShotIndex_;
    uint8_t m_oRequestCommand_;
    ::dds::core::array< uint8_t, 256L> m_szComment_;

};

inline void swap(USERIF_SCREENSHOT_CONTROL_REQUEST& a, USERIF_SCREENSHOT_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SCREENSHOT_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_SCREENSHOT_LIST_REQUEST {
  public:
    USERIF_SCREENSHOT_LIST_REQUEST();

    USERIF_SCREENSHOT_LIST_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unPageNum);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SCREENSHOT_LIST_REQUEST (USERIF_SCREENSHOT_LIST_REQUEST&&) = default;
    USERIF_SCREENSHOT_LIST_REQUEST& operator=(USERIF_SCREENSHOT_LIST_REQUEST&&) = default;
    USERIF_SCREENSHOT_LIST_REQUEST& operator=(const USERIF_SCREENSHOT_LIST_REQUEST&) = default;
    USERIF_SCREENSHOT_LIST_REQUEST(const USERIF_SCREENSHOT_LIST_REQUEST&) = default;
    #else
    USERIF_SCREENSHOT_LIST_REQUEST(USERIF_SCREENSHOT_LIST_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_SCREENSHOT_LIST_REQUEST& operator=(USERIF_SCREENSHOT_LIST_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unPageNum() OMG_NOEXCEPT {
        return m_unPageNum_;
    }

    const uint16_t& unPageNum() const OMG_NOEXCEPT {
        return m_unPageNum_;
    }

    void unPageNum(uint16_t value) {
        m_unPageNum_ = value;
    }

    bool operator == (const USERIF_SCREENSHOT_LIST_REQUEST& other_) const;
    bool operator != (const USERIF_SCREENSHOT_LIST_REQUEST& other_) const;

    void swap(USERIF_SCREENSHOT_LIST_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unPageNum_;

};

inline void swap(USERIF_SCREENSHOT_LIST_REQUEST& a, USERIF_SCREENSHOT_LIST_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SCREENSHOT_LIST_REQUEST& sample);

class NDDSUSERDllExport USERIF_SCREENSHOT_SAVE_REQUEST {
  public:
    USERIF_SCREENSHOT_SAVE_REQUEST();

    USERIF_SCREENSHOT_SAVE_REQUEST(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 30L>& szUserID,const ::dds::core::array< uint8_t, 256L>& szComment,uint8_t oScreenNum,const ::dds::core::array< uint8_t, 6220800L>& aScreenContents);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SCREENSHOT_SAVE_REQUEST (USERIF_SCREENSHOT_SAVE_REQUEST&&) = default;
    USERIF_SCREENSHOT_SAVE_REQUEST& operator=(USERIF_SCREENSHOT_SAVE_REQUEST&&) = default;
    USERIF_SCREENSHOT_SAVE_REQUEST& operator=(const USERIF_SCREENSHOT_SAVE_REQUEST&) = default;
    USERIF_SCREENSHOT_SAVE_REQUEST(const USERIF_SCREENSHOT_SAVE_REQUEST&) = default;
    #else
    USERIF_SCREENSHOT_SAVE_REQUEST(USERIF_SCREENSHOT_SAVE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_SCREENSHOT_SAVE_REQUEST& operator=(USERIF_SCREENSHOT_SAVE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 30L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 30L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 30L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 30L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 256L>& szComment() OMG_NOEXCEPT {
        return m_szComment_;
    }

    const ::dds::core::array< uint8_t, 256L>& szComment() const OMG_NOEXCEPT {
        return m_szComment_;
    }

    void szComment(const ::dds::core::array< uint8_t, 256L>& value) {
        m_szComment_ = value;
    }

    void szComment(::dds::core::array< uint8_t, 256L>&& value) {
        m_szComment_ = std::move(value);
    }
    uint8_t& oScreenNum() OMG_NOEXCEPT {
        return m_oScreenNum_;
    }

    const uint8_t& oScreenNum() const OMG_NOEXCEPT {
        return m_oScreenNum_;
    }

    void oScreenNum(uint8_t value) {
        m_oScreenNum_ = value;
    }

    ::dds::core::array< uint8_t, 6220800L>& aScreenContents() OMG_NOEXCEPT {
        return m_aScreenContents_;
    }

    const ::dds::core::array< uint8_t, 6220800L>& aScreenContents() const OMG_NOEXCEPT {
        return m_aScreenContents_;
    }

    void aScreenContents(const ::dds::core::array< uint8_t, 6220800L>& value) {
        m_aScreenContents_ = value;
    }

    void aScreenContents(::dds::core::array< uint8_t, 6220800L>&& value) {
        m_aScreenContents_ = std::move(value);
    }

    bool operator == (const USERIF_SCREENSHOT_SAVE_REQUEST& other_) const;
    bool operator != (const USERIF_SCREENSHOT_SAVE_REQUEST& other_) const;

    void swap(USERIF_SCREENSHOT_SAVE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 30L> m_szUserID_;
    ::dds::core::array< uint8_t, 256L> m_szComment_;
    uint8_t m_oScreenNum_;
    ::dds::core::array< uint8_t, 6220800L> m_aScreenContents_;

};

inline void swap(USERIF_SCREENSHOT_SAVE_REQUEST& a, USERIF_SCREENSHOT_SAVE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SCREENSHOT_SAVE_REQUEST& sample);

class NDDSUSERDllExport USERIF_SENSOR_PROTECTION_CONTROL_REQUEST {
  public:
    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST();

    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,const ST_SENSOR_PROTECTION_AREA_INFO& stSensorProtectionAreaInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST (USERIF_SENSOR_PROTECTION_CONTROL_REQUEST&&) = default;
    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& operator=(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST&&) = default;
    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& operator=(const USERIF_SENSOR_PROTECTION_CONTROL_REQUEST&) = default;
    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST(const USERIF_SENSOR_PROTECTION_CONTROL_REQUEST&) = default;
    #else
    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& operator=(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    ST_SENSOR_PROTECTION_AREA_INFO& stSensorProtectionAreaInfo() OMG_NOEXCEPT {
        return m_stSensorProtectionAreaInfo_;
    }

    const ST_SENSOR_PROTECTION_AREA_INFO& stSensorProtectionAreaInfo() const OMG_NOEXCEPT {
        return m_stSensorProtectionAreaInfo_;
    }

    void stSensorProtectionAreaInfo(const ST_SENSOR_PROTECTION_AREA_INFO& value) {
        m_stSensorProtectionAreaInfo_ = value;
    }

    void stSensorProtectionAreaInfo(ST_SENSOR_PROTECTION_AREA_INFO&& value) {
        m_stSensorProtectionAreaInfo_ = std::move(value);
    }

    bool operator == (const USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& other_) const;

    void swap(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    ST_SENSOR_PROTECTION_AREA_INFO m_stSensorProtectionAreaInfo_;

};

inline void swap(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& a, USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_SOFTWARE_OPERATE_REQUEST {
  public:
    USERIF_SOFTWARE_OPERATE_REQUEST();

    USERIF_SOFTWARE_OPERATE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t unStationID,uint8_t unSWID,uint8_t unOperationcommand);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SOFTWARE_OPERATE_REQUEST (USERIF_SOFTWARE_OPERATE_REQUEST&&) = default;
    USERIF_SOFTWARE_OPERATE_REQUEST& operator=(USERIF_SOFTWARE_OPERATE_REQUEST&&) = default;
    USERIF_SOFTWARE_OPERATE_REQUEST& operator=(const USERIF_SOFTWARE_OPERATE_REQUEST&) = default;
    USERIF_SOFTWARE_OPERATE_REQUEST(const USERIF_SOFTWARE_OPERATE_REQUEST&) = default;
    #else
    USERIF_SOFTWARE_OPERATE_REQUEST(USERIF_SOFTWARE_OPERATE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_SOFTWARE_OPERATE_REQUEST& operator=(USERIF_SOFTWARE_OPERATE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint8_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint8_t value) {
        m_unStationID_ = value;
    }

    uint8_t& unSWID() OMG_NOEXCEPT {
        return m_unSWID_;
    }

    const uint8_t& unSWID() const OMG_NOEXCEPT {
        return m_unSWID_;
    }

    void unSWID(uint8_t value) {
        m_unSWID_ = value;
    }

    uint8_t& unOperationcommand() OMG_NOEXCEPT {
        return m_unOperationcommand_;
    }

    const uint8_t& unOperationcommand() const OMG_NOEXCEPT {
        return m_unOperationcommand_;
    }

    void unOperationcommand(uint8_t value) {
        m_unOperationcommand_ = value;
    }

    bool operator == (const USERIF_SOFTWARE_OPERATE_REQUEST& other_) const;
    bool operator != (const USERIF_SOFTWARE_OPERATE_REQUEST& other_) const;

    void swap(USERIF_SOFTWARE_OPERATE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_unStationID_;
    uint8_t m_unSWID_;
    uint8_t m_unOperationcommand_;

};

inline void swap(USERIF_SOFTWARE_OPERATE_REQUEST& a, USERIF_SOFTWARE_OPERATE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SOFTWARE_OPERATE_REQUEST& sample);

class NDDSUSERDllExport USERIF_SPE_DEVICE_CTRL_COMMAND {
  public:
    USERIF_SPE_DEVICE_CTRL_COMMAND();

    USERIF_SPE_DEVICE_CTRL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usCommandID,int32_t eSWID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SPE_DEVICE_CTRL_COMMAND (USERIF_SPE_DEVICE_CTRL_COMMAND&&) = default;
    USERIF_SPE_DEVICE_CTRL_COMMAND& operator=(USERIF_SPE_DEVICE_CTRL_COMMAND&&) = default;
    USERIF_SPE_DEVICE_CTRL_COMMAND& operator=(const USERIF_SPE_DEVICE_CTRL_COMMAND&) = default;
    USERIF_SPE_DEVICE_CTRL_COMMAND(const USERIF_SPE_DEVICE_CTRL_COMMAND&) = default;
    #else
    USERIF_SPE_DEVICE_CTRL_COMMAND(USERIF_SPE_DEVICE_CTRL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_SPE_DEVICE_CTRL_COMMAND& operator=(USERIF_SPE_DEVICE_CTRL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usCommandID() OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    const uint16_t& usCommandID() const OMG_NOEXCEPT {
        return m_usCommandID_;
    }

    void usCommandID(uint16_t value) {
        m_usCommandID_ = value;
    }

    int32_t& eSWID() OMG_NOEXCEPT {
        return m_eSWID_;
    }

    const int32_t& eSWID() const OMG_NOEXCEPT {
        return m_eSWID_;
    }

    void eSWID(int32_t value) {
        m_eSWID_ = value;
    }

    bool operator == (const USERIF_SPE_DEVICE_CTRL_COMMAND& other_) const;
    bool operator != (const USERIF_SPE_DEVICE_CTRL_COMMAND& other_) const;

    void swap(USERIF_SPE_DEVICE_CTRL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usCommandID_;
    int32_t m_eSWID_;

};

inline void swap(USERIF_SPE_DEVICE_CTRL_COMMAND& a, USERIF_SPE_DEVICE_CTRL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SPE_DEVICE_CTRL_COMMAND& sample);

class NDDSUSERDllExport USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST {
  public:
    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST();

    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usTargetNo,uint16_t usAxis);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST (USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST&&) = default;
    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& operator=(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST&&) = default;
    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& operator=(const USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST&) = default;
    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST(const USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST&) = default;
    #else
    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& operator=(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    uint16_t& usAxis() OMG_NOEXCEPT {
        return m_usAxis_;
    }

    const uint16_t& usAxis() const OMG_NOEXCEPT {
        return m_usAxis_;
    }

    void usAxis(uint16_t value) {
        m_usAxis_ = value;
    }

    bool operator == (const USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& other_) const;

    void swap(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usTargetNo_;
    uint16_t m_usAxis_;

};

inline void swap(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& a, USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& sample);

class NDDSUSERDllExport USERIF_SYSMGR_ALL_STATE_REQ {
  public:
    USERIF_SYSMGR_ALL_STATE_REQ();

    USERIF_SYSMGR_ALL_STATE_REQ(const ST_MSG_HEADER& stMsgHeader,uint8_t oCMDType);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SYSMGR_ALL_STATE_REQ (USERIF_SYSMGR_ALL_STATE_REQ&&) = default;
    USERIF_SYSMGR_ALL_STATE_REQ& operator=(USERIF_SYSMGR_ALL_STATE_REQ&&) = default;
    USERIF_SYSMGR_ALL_STATE_REQ& operator=(const USERIF_SYSMGR_ALL_STATE_REQ&) = default;
    USERIF_SYSMGR_ALL_STATE_REQ(const USERIF_SYSMGR_ALL_STATE_REQ&) = default;
    #else
    USERIF_SYSMGR_ALL_STATE_REQ(USERIF_SYSMGR_ALL_STATE_REQ&& other_) OMG_NOEXCEPT;  
    USERIF_SYSMGR_ALL_STATE_REQ& operator=(USERIF_SYSMGR_ALL_STATE_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oCMDType() OMG_NOEXCEPT {
        return m_oCMDType_;
    }

    const uint8_t& oCMDType() const OMG_NOEXCEPT {
        return m_oCMDType_;
    }

    void oCMDType(uint8_t value) {
        m_oCMDType_ = value;
    }

    bool operator == (const USERIF_SYSMGR_ALL_STATE_REQ& other_) const;
    bool operator != (const USERIF_SYSMGR_ALL_STATE_REQ& other_) const;

    void swap(USERIF_SYSMGR_ALL_STATE_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oCMDType_;

};

inline void swap(USERIF_SYSMGR_ALL_STATE_REQ& a, USERIF_SYSMGR_ALL_STATE_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SYSMGR_ALL_STATE_REQ& sample);

class NDDSUSERDllExport USERIF_SYSMGR_REALLOCATION_CMD {
  public:
    USERIF_SYSMGR_REALLOCATION_CMD();

    USERIF_SYSMGR_REALLOCATION_CMD(const ST_MSG_HEADER& stMsgHeader,uint16_t usSrcHWID,uint16_t usDesHWID,const ::dds::core::array< uint8_t, 100L>& oReAssignSWGID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SYSMGR_REALLOCATION_CMD (USERIF_SYSMGR_REALLOCATION_CMD&&) = default;
    USERIF_SYSMGR_REALLOCATION_CMD& operator=(USERIF_SYSMGR_REALLOCATION_CMD&&) = default;
    USERIF_SYSMGR_REALLOCATION_CMD& operator=(const USERIF_SYSMGR_REALLOCATION_CMD&) = default;
    USERIF_SYSMGR_REALLOCATION_CMD(const USERIF_SYSMGR_REALLOCATION_CMD&) = default;
    #else
    USERIF_SYSMGR_REALLOCATION_CMD(USERIF_SYSMGR_REALLOCATION_CMD&& other_) OMG_NOEXCEPT;  
    USERIF_SYSMGR_REALLOCATION_CMD& operator=(USERIF_SYSMGR_REALLOCATION_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSrcHWID() OMG_NOEXCEPT {
        return m_usSrcHWID_;
    }

    const uint16_t& usSrcHWID() const OMG_NOEXCEPT {
        return m_usSrcHWID_;
    }

    void usSrcHWID(uint16_t value) {
        m_usSrcHWID_ = value;
    }

    uint16_t& usDesHWID() OMG_NOEXCEPT {
        return m_usDesHWID_;
    }

    const uint16_t& usDesHWID() const OMG_NOEXCEPT {
        return m_usDesHWID_;
    }

    void usDesHWID(uint16_t value) {
        m_usDesHWID_ = value;
    }

    ::dds::core::array< uint8_t, 100L>& oReAssignSWGID() OMG_NOEXCEPT {
        return m_oReAssignSWGID_;
    }

    const ::dds::core::array< uint8_t, 100L>& oReAssignSWGID() const OMG_NOEXCEPT {
        return m_oReAssignSWGID_;
    }

    void oReAssignSWGID(const ::dds::core::array< uint8_t, 100L>& value) {
        m_oReAssignSWGID_ = value;
    }

    void oReAssignSWGID(::dds::core::array< uint8_t, 100L>&& value) {
        m_oReAssignSWGID_ = std::move(value);
    }

    bool operator == (const USERIF_SYSMGR_REALLOCATION_CMD& other_) const;
    bool operator != (const USERIF_SYSMGR_REALLOCATION_CMD& other_) const;

    void swap(USERIF_SYSMGR_REALLOCATION_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSrcHWID_;
    uint16_t m_usDesHWID_;
    ::dds::core::array< uint8_t, 100L> m_oReAssignSWGID_;

};

inline void swap(USERIF_SYSMGR_REALLOCATION_CMD& a, USERIF_SYSMGR_REALLOCATION_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SYSMGR_REALLOCATION_CMD& sample);

class NDDSUSERDllExport ST_SW_UPDATE_INFO {
  public:
    ST_SW_UPDATE_INFO();

    ST_SW_UPDATE_INFO(uint8_t oUpdate,uint32_t ulSWID,const ST_SW_VERSION& stSWVersion,const ::dds::core::array< uint8_t, 500L>& oInstallSWPath);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_UPDATE_INFO (ST_SW_UPDATE_INFO&&) = default;
    ST_SW_UPDATE_INFO& operator=(ST_SW_UPDATE_INFO&&) = default;
    ST_SW_UPDATE_INFO& operator=(const ST_SW_UPDATE_INFO&) = default;
    ST_SW_UPDATE_INFO(const ST_SW_UPDATE_INFO&) = default;
    #else
    ST_SW_UPDATE_INFO(ST_SW_UPDATE_INFO&& other_) OMG_NOEXCEPT;  
    ST_SW_UPDATE_INFO& operator=(ST_SW_UPDATE_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint8_t& oUpdate() OMG_NOEXCEPT {
        return m_oUpdate_;
    }

    const uint8_t& oUpdate() const OMG_NOEXCEPT {
        return m_oUpdate_;
    }

    void oUpdate(uint8_t value) {
        m_oUpdate_ = value;
    }

    uint32_t& ulSWID() OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    const uint32_t& ulSWID() const OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    void ulSWID(uint32_t value) {
        m_ulSWID_ = value;
    }

    ST_SW_VERSION& stSWVersion() OMG_NOEXCEPT {
        return m_stSWVersion_;
    }

    const ST_SW_VERSION& stSWVersion() const OMG_NOEXCEPT {
        return m_stSWVersion_;
    }

    void stSWVersion(const ST_SW_VERSION& value) {
        m_stSWVersion_ = value;
    }

    void stSWVersion(ST_SW_VERSION&& value) {
        m_stSWVersion_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 500L>& oInstallSWPath() OMG_NOEXCEPT {
        return m_oInstallSWPath_;
    }

    const ::dds::core::array< uint8_t, 500L>& oInstallSWPath() const OMG_NOEXCEPT {
        return m_oInstallSWPath_;
    }

    void oInstallSWPath(const ::dds::core::array< uint8_t, 500L>& value) {
        m_oInstallSWPath_ = value;
    }

    void oInstallSWPath(::dds::core::array< uint8_t, 500L>&& value) {
        m_oInstallSWPath_ = std::move(value);
    }

    bool operator == (const ST_SW_UPDATE_INFO& other_) const;
    bool operator != (const ST_SW_UPDATE_INFO& other_) const;

    void swap(ST_SW_UPDATE_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint8_t m_oUpdate_;
    uint32_t m_ulSWID_;
    ST_SW_VERSION m_stSWVersion_;
    ::dds::core::array< uint8_t, 500L> m_oInstallSWPath_;

};

inline void swap(ST_SW_UPDATE_INFO& a, ST_SW_UPDATE_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_UPDATE_INFO& sample);

class NDDSUSERDllExport USERIF_SYSMGR_SWUPDATE_CMD {
  public:
    USERIF_SYSMGR_SWUPDATE_CMD();

    USERIF_SYSMGR_SWUPDATE_CMD(const ST_MSG_HEADER& stMsgHeader,const ST_SW_UPDATE_INFO& stUpdateSWInfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SYSMGR_SWUPDATE_CMD (USERIF_SYSMGR_SWUPDATE_CMD&&) = default;
    USERIF_SYSMGR_SWUPDATE_CMD& operator=(USERIF_SYSMGR_SWUPDATE_CMD&&) = default;
    USERIF_SYSMGR_SWUPDATE_CMD& operator=(const USERIF_SYSMGR_SWUPDATE_CMD&) = default;
    USERIF_SYSMGR_SWUPDATE_CMD(const USERIF_SYSMGR_SWUPDATE_CMD&) = default;
    #else
    USERIF_SYSMGR_SWUPDATE_CMD(USERIF_SYSMGR_SWUPDATE_CMD&& other_) OMG_NOEXCEPT;  
    USERIF_SYSMGR_SWUPDATE_CMD& operator=(USERIF_SYSMGR_SWUPDATE_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_SW_UPDATE_INFO& stUpdateSWInfo() OMG_NOEXCEPT {
        return m_stUpdateSWInfo_;
    }

    const ST_SW_UPDATE_INFO& stUpdateSWInfo() const OMG_NOEXCEPT {
        return m_stUpdateSWInfo_;
    }

    void stUpdateSWInfo(const ST_SW_UPDATE_INFO& value) {
        m_stUpdateSWInfo_ = value;
    }

    void stUpdateSWInfo(ST_SW_UPDATE_INFO&& value) {
        m_stUpdateSWInfo_ = std::move(value);
    }

    bool operator == (const USERIF_SYSMGR_SWUPDATE_CMD& other_) const;
    bool operator != (const USERIF_SYSMGR_SWUPDATE_CMD& other_) const;

    void swap(USERIF_SYSMGR_SWUPDATE_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_SW_UPDATE_INFO m_stUpdateSWInfo_;

};

inline void swap(USERIF_SYSMGR_SWUPDATE_CMD& a, USERIF_SYSMGR_SWUPDATE_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SYSMGR_SWUPDATE_CMD& sample);

class NDDSUSERDllExport USERIF_SYSMGR_SWUPDATE_OVERALL_CMD {
  public:
    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD();

    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< ST_SW_UPDATE_INFO, 100L>& stUpdateSWinfo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD (USERIF_SYSMGR_SWUPDATE_OVERALL_CMD&&) = default;
    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& operator=(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD&&) = default;
    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& operator=(const USERIF_SYSMGR_SWUPDATE_OVERALL_CMD&) = default;
    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD(const USERIF_SYSMGR_SWUPDATE_OVERALL_CMD&) = default;
    #else
    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD&& other_) OMG_NOEXCEPT;  
    USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& operator=(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< ST_SW_UPDATE_INFO, 100L>& stUpdateSWinfo() OMG_NOEXCEPT {
        return m_stUpdateSWinfo_;
    }

    const ::dds::core::array< ST_SW_UPDATE_INFO, 100L>& stUpdateSWinfo() const OMG_NOEXCEPT {
        return m_stUpdateSWinfo_;
    }

    void stUpdateSWinfo(const ::dds::core::array< ST_SW_UPDATE_INFO, 100L>& value) {
        m_stUpdateSWinfo_ = value;
    }

    void stUpdateSWinfo(::dds::core::array< ST_SW_UPDATE_INFO, 100L>&& value) {
        m_stUpdateSWinfo_ = std::move(value);
    }

    bool operator == (const USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& other_) const;
    bool operator != (const USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& other_) const;

    void swap(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< ST_SW_UPDATE_INFO, 100L> m_stUpdateSWinfo_;

};

inline void swap(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& a, USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& sample);

class NDDSUSERDllExport USERIF_TARGET_DANGER_INFO_REQ {
  public:
    USERIF_TARGET_DANGER_INFO_REQ();

    USERIF_TARGET_DANGER_INFO_REQ(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unCommandID,uint16_t unGlobalID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_DANGER_INFO_REQ (USERIF_TARGET_DANGER_INFO_REQ&&) = default;
    USERIF_TARGET_DANGER_INFO_REQ& operator=(USERIF_TARGET_DANGER_INFO_REQ&&) = default;
    USERIF_TARGET_DANGER_INFO_REQ& operator=(const USERIF_TARGET_DANGER_INFO_REQ&) = default;
    USERIF_TARGET_DANGER_INFO_REQ(const USERIF_TARGET_DANGER_INFO_REQ&) = default;
    #else
    USERIF_TARGET_DANGER_INFO_REQ(USERIF_TARGET_DANGER_INFO_REQ&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_DANGER_INFO_REQ& operator=(USERIF_TARGET_DANGER_INFO_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unCommandID() OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    const uint16_t& unCommandID() const OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    void unCommandID(uint16_t value) {
        m_unCommandID_ = value;
    }

    uint16_t& unGlobalID() OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    const uint16_t& unGlobalID() const OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    void unGlobalID(uint16_t value) {
        m_unGlobalID_ = value;
    }

    bool operator == (const USERIF_TARGET_DANGER_INFO_REQ& other_) const;
    bool operator != (const USERIF_TARGET_DANGER_INFO_REQ& other_) const;

    void swap(USERIF_TARGET_DANGER_INFO_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unCommandID_;
    uint16_t m_unGlobalID_;

};

inline void swap(USERIF_TARGET_DANGER_INFO_REQ& a, USERIF_TARGET_DANGER_INFO_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_DANGER_INFO_REQ& sample);

class NDDSUSERDllExport USERIF_TARGET_DB_CONTROL_REQUEST {
  public:
    USERIF_TARGET_DB_CONTROL_REQUEST();

    USERIF_TARGET_DB_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,uint16_t usTargetDBInfoCnt,const ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& stTargetDBInfo,uint16_t usTargetDBASStrengthCnt,const ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& stTargetDBASStrength,uint16_t usTargetDBBISStrengthCnt,const ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& stTargetDBBISStrength,uint16_t usTargetDBBBSourceLevelCnt,const ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& stTargetDBBBSourceLevel,uint16_t usTargetDBNBSourceLevelCnt,const ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& stTargetDBNBSourceLevel);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_DB_CONTROL_REQUEST (USERIF_TARGET_DB_CONTROL_REQUEST&&) = default;
    USERIF_TARGET_DB_CONTROL_REQUEST& operator=(USERIF_TARGET_DB_CONTROL_REQUEST&&) = default;
    USERIF_TARGET_DB_CONTROL_REQUEST& operator=(const USERIF_TARGET_DB_CONTROL_REQUEST&) = default;
    USERIF_TARGET_DB_CONTROL_REQUEST(const USERIF_TARGET_DB_CONTROL_REQUEST&) = default;
    #else
    USERIF_TARGET_DB_CONTROL_REQUEST(USERIF_TARGET_DB_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_DB_CONTROL_REQUEST& operator=(USERIF_TARGET_DB_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    uint16_t& usTargetDBInfoCnt() OMG_NOEXCEPT {
        return m_usTargetDBInfoCnt_;
    }

    const uint16_t& usTargetDBInfoCnt() const OMG_NOEXCEPT {
        return m_usTargetDBInfoCnt_;
    }

    void usTargetDBInfoCnt(uint16_t value) {
        m_usTargetDBInfoCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& stTargetDBInfo() OMG_NOEXCEPT {
        return m_stTargetDBInfo_;
    }

    const ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& stTargetDBInfo() const OMG_NOEXCEPT {
        return m_stTargetDBInfo_;
    }

    void stTargetDBInfo(const ::dds::core::array< ST_TARGET_DB_INFO, 1000L>& value) {
        m_stTargetDBInfo_ = value;
    }

    void stTargetDBInfo(::dds::core::array< ST_TARGET_DB_INFO, 1000L>&& value) {
        m_stTargetDBInfo_ = std::move(value);
    }
    uint16_t& usTargetDBASStrengthCnt() OMG_NOEXCEPT {
        return m_usTargetDBASStrengthCnt_;
    }

    const uint16_t& usTargetDBASStrengthCnt() const OMG_NOEXCEPT {
        return m_usTargetDBASStrengthCnt_;
    }

    void usTargetDBASStrengthCnt(uint16_t value) {
        m_usTargetDBASStrengthCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& stTargetDBASStrength() OMG_NOEXCEPT {
        return m_stTargetDBASStrength_;
    }

    const ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& stTargetDBASStrength() const OMG_NOEXCEPT {
        return m_stTargetDBASStrength_;
    }

    void stTargetDBASStrength(const ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>& value) {
        m_stTargetDBASStrength_ = value;
    }

    void stTargetDBASStrength(::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L>&& value) {
        m_stTargetDBASStrength_ = std::move(value);
    }
    uint16_t& usTargetDBBISStrengthCnt() OMG_NOEXCEPT {
        return m_usTargetDBBISStrengthCnt_;
    }

    const uint16_t& usTargetDBBISStrengthCnt() const OMG_NOEXCEPT {
        return m_usTargetDBBISStrengthCnt_;
    }

    void usTargetDBBISStrengthCnt(uint16_t value) {
        m_usTargetDBBISStrengthCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& stTargetDBBISStrength() OMG_NOEXCEPT {
        return m_stTargetDBBISStrength_;
    }

    const ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& stTargetDBBISStrength() const OMG_NOEXCEPT {
        return m_stTargetDBBISStrength_;
    }

    void stTargetDBBISStrength(const ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>& value) {
        m_stTargetDBBISStrength_ = value;
    }

    void stTargetDBBISStrength(::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L>&& value) {
        m_stTargetDBBISStrength_ = std::move(value);
    }
    uint16_t& usTargetDBBBSourceLevelCnt() OMG_NOEXCEPT {
        return m_usTargetDBBBSourceLevelCnt_;
    }

    const uint16_t& usTargetDBBBSourceLevelCnt() const OMG_NOEXCEPT {
        return m_usTargetDBBBSourceLevelCnt_;
    }

    void usTargetDBBBSourceLevelCnt(uint16_t value) {
        m_usTargetDBBBSourceLevelCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& stTargetDBBBSourceLevel() OMG_NOEXCEPT {
        return m_stTargetDBBBSourceLevel_;
    }

    const ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& stTargetDBBBSourceLevel() const OMG_NOEXCEPT {
        return m_stTargetDBBBSourceLevel_;
    }

    void stTargetDBBBSourceLevel(const ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>& value) {
        m_stTargetDBBBSourceLevel_ = value;
    }

    void stTargetDBBBSourceLevel(::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L>&& value) {
        m_stTargetDBBBSourceLevel_ = std::move(value);
    }
    uint16_t& usTargetDBNBSourceLevelCnt() OMG_NOEXCEPT {
        return m_usTargetDBNBSourceLevelCnt_;
    }

    const uint16_t& usTargetDBNBSourceLevelCnt() const OMG_NOEXCEPT {
        return m_usTargetDBNBSourceLevelCnt_;
    }

    void usTargetDBNBSourceLevelCnt(uint16_t value) {
        m_usTargetDBNBSourceLevelCnt_ = value;
    }

    ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& stTargetDBNBSourceLevel() OMG_NOEXCEPT {
        return m_stTargetDBNBSourceLevel_;
    }

    const ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& stTargetDBNBSourceLevel() const OMG_NOEXCEPT {
        return m_stTargetDBNBSourceLevel_;
    }

    void stTargetDBNBSourceLevel(const ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>& value) {
        m_stTargetDBNBSourceLevel_ = value;
    }

    void stTargetDBNBSourceLevel(::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L>&& value) {
        m_stTargetDBNBSourceLevel_ = std::move(value);
    }

    bool operator == (const USERIF_TARGET_DB_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_DB_CONTROL_REQUEST& other_) const;

    void swap(USERIF_TARGET_DB_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    uint16_t m_usTargetDBInfoCnt_;
    ::dds::core::array< ST_TARGET_DB_INFO, 1000L> m_stTargetDBInfo_;
    uint16_t m_usTargetDBASStrengthCnt_;
    ::dds::core::array< ST_TARGET_DB_AS_STRENGTH, 1000L> m_stTargetDBASStrength_;
    uint16_t m_usTargetDBBISStrengthCnt_;
    ::dds::core::array< ST_TARGET_DB_BIS_STRENGTH, 1000L> m_stTargetDBBISStrength_;
    uint16_t m_usTargetDBBBSourceLevelCnt_;
    ::dds::core::array< ST_TARGET_DB_BB_SOURCE_LEVEL, 1000L> m_stTargetDBBBSourceLevel_;
    uint16_t m_usTargetDBNBSourceLevelCnt_;
    ::dds::core::array< ST_TARGET_DB_NB_SOURCE_LEVEL, 1000L> m_stTargetDBNBSourceLevel_;

};

inline void swap(USERIF_TARGET_DB_CONTROL_REQUEST& a, USERIF_TARGET_DB_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_DB_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_FUSION_ACTIVATION_COMMAND {
  public:
    USERIF_TARGET_FUSION_ACTIVATION_COMMAND();

    USERIF_TARGET_FUSION_ACTIVATION_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint8_t oLasActivation,uint8_t oBisActivation,uint8_t oMasActivation,uint8_t oAsEosActivation,uint8_t oRdsKntdsActivation,uint16_t usReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_FUSION_ACTIVATION_COMMAND (USERIF_TARGET_FUSION_ACTIVATION_COMMAND&&) = default;
    USERIF_TARGET_FUSION_ACTIVATION_COMMAND& operator=(USERIF_TARGET_FUSION_ACTIVATION_COMMAND&&) = default;
    USERIF_TARGET_FUSION_ACTIVATION_COMMAND& operator=(const USERIF_TARGET_FUSION_ACTIVATION_COMMAND&) = default;
    USERIF_TARGET_FUSION_ACTIVATION_COMMAND(const USERIF_TARGET_FUSION_ACTIVATION_COMMAND&) = default;
    #else
    USERIF_TARGET_FUSION_ACTIVATION_COMMAND(USERIF_TARGET_FUSION_ACTIVATION_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_FUSION_ACTIVATION_COMMAND& operator=(USERIF_TARGET_FUSION_ACTIVATION_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint8_t& oLasActivation() OMG_NOEXCEPT {
        return m_oLasActivation_;
    }

    const uint8_t& oLasActivation() const OMG_NOEXCEPT {
        return m_oLasActivation_;
    }

    void oLasActivation(uint8_t value) {
        m_oLasActivation_ = value;
    }

    uint8_t& oBisActivation() OMG_NOEXCEPT {
        return m_oBisActivation_;
    }

    const uint8_t& oBisActivation() const OMG_NOEXCEPT {
        return m_oBisActivation_;
    }

    void oBisActivation(uint8_t value) {
        m_oBisActivation_ = value;
    }

    uint8_t& oMasActivation() OMG_NOEXCEPT {
        return m_oMasActivation_;
    }

    const uint8_t& oMasActivation() const OMG_NOEXCEPT {
        return m_oMasActivation_;
    }

    void oMasActivation(uint8_t value) {
        m_oMasActivation_ = value;
    }

    uint8_t& oAsEosActivation() OMG_NOEXCEPT {
        return m_oAsEosActivation_;
    }

    const uint8_t& oAsEosActivation() const OMG_NOEXCEPT {
        return m_oAsEosActivation_;
    }

    void oAsEosActivation(uint8_t value) {
        m_oAsEosActivation_ = value;
    }

    uint8_t& oRdsKntdsActivation() OMG_NOEXCEPT {
        return m_oRdsKntdsActivation_;
    }

    const uint8_t& oRdsKntdsActivation() const OMG_NOEXCEPT {
        return m_oRdsKntdsActivation_;
    }

    void oRdsKntdsActivation(uint8_t value) {
        m_oRdsKntdsActivation_ = value;
    }

    uint16_t& usReserved() OMG_NOEXCEPT {
        return m_usReserved_;
    }

    const uint16_t& usReserved() const OMG_NOEXCEPT {
        return m_usReserved_;
    }

    void usReserved(uint16_t value) {
        m_usReserved_ = value;
    }

    bool operator == (const USERIF_TARGET_FUSION_ACTIVATION_COMMAND& other_) const;
    bool operator != (const USERIF_TARGET_FUSION_ACTIVATION_COMMAND& other_) const;

    void swap(USERIF_TARGET_FUSION_ACTIVATION_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint8_t m_oLasActivation_;
    uint8_t m_oBisActivation_;
    uint8_t m_oMasActivation_;
    uint8_t m_oAsEosActivation_;
    uint8_t m_oRdsKntdsActivation_;
    uint16_t m_usReserved_;

};

inline void swap(USERIF_TARGET_FUSION_ACTIVATION_COMMAND& a, USERIF_TARGET_FUSION_ACTIVATION_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_FUSION_ACTIVATION_COMMAND& sample);

class NDDSUSERDllExport USERIF_TARGET_FUSION_CONTROL_REQUEST {
  public:
    USERIF_TARGET_FUSION_CONTROL_REQUEST();

    USERIF_TARGET_FUSION_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unCommandID,uint8_t unMode,uint16_t unMasternumber,uint16_t unSlavenumber,uint16_t usSensorID,uint16_t usResetUserAssociationHistory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_FUSION_CONTROL_REQUEST (USERIF_TARGET_FUSION_CONTROL_REQUEST&&) = default;
    USERIF_TARGET_FUSION_CONTROL_REQUEST& operator=(USERIF_TARGET_FUSION_CONTROL_REQUEST&&) = default;
    USERIF_TARGET_FUSION_CONTROL_REQUEST& operator=(const USERIF_TARGET_FUSION_CONTROL_REQUEST&) = default;
    USERIF_TARGET_FUSION_CONTROL_REQUEST(const USERIF_TARGET_FUSION_CONTROL_REQUEST&) = default;
    #else
    USERIF_TARGET_FUSION_CONTROL_REQUEST(USERIF_TARGET_FUSION_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_FUSION_CONTROL_REQUEST& operator=(USERIF_TARGET_FUSION_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unCommandID() OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    const uint16_t& unCommandID() const OMG_NOEXCEPT {
        return m_unCommandID_;
    }

    void unCommandID(uint16_t value) {
        m_unCommandID_ = value;
    }

    uint8_t& unMode() OMG_NOEXCEPT {
        return m_unMode_;
    }

    const uint8_t& unMode() const OMG_NOEXCEPT {
        return m_unMode_;
    }

    void unMode(uint8_t value) {
        m_unMode_ = value;
    }

    uint16_t& unMasternumber() OMG_NOEXCEPT {
        return m_unMasternumber_;
    }

    const uint16_t& unMasternumber() const OMG_NOEXCEPT {
        return m_unMasternumber_;
    }

    void unMasternumber(uint16_t value) {
        m_unMasternumber_ = value;
    }

    uint16_t& unSlavenumber() OMG_NOEXCEPT {
        return m_unSlavenumber_;
    }

    const uint16_t& unSlavenumber() const OMG_NOEXCEPT {
        return m_unSlavenumber_;
    }

    void unSlavenumber(uint16_t value) {
        m_unSlavenumber_ = value;
    }

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usResetUserAssociationHistory() OMG_NOEXCEPT {
        return m_usResetUserAssociationHistory_;
    }

    const uint16_t& usResetUserAssociationHistory() const OMG_NOEXCEPT {
        return m_usResetUserAssociationHistory_;
    }

    void usResetUserAssociationHistory(uint16_t value) {
        m_usResetUserAssociationHistory_ = value;
    }

    bool operator == (const USERIF_TARGET_FUSION_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_FUSION_CONTROL_REQUEST& other_) const;

    void swap(USERIF_TARGET_FUSION_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unCommandID_;
    uint8_t m_unMode_;
    uint16_t m_unMasternumber_;
    uint16_t m_unSlavenumber_;
    uint16_t m_usSensorID_;
    uint16_t m_usResetUserAssociationHistory_;

};

inline void swap(USERIF_TARGET_FUSION_CONTROL_REQUEST& a, USERIF_TARGET_FUSION_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_FUSION_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_GLOBAL_DELETE_REQUEST {
  public:
    USERIF_TARGET_GLOBAL_DELETE_REQUEST();

    USERIF_TARGET_GLOBAL_DELETE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unGlobalID,uint16_t usSensorTypeToDelete,uint16_t usReserved1,uint16_t usReserved2);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_GLOBAL_DELETE_REQUEST (USERIF_TARGET_GLOBAL_DELETE_REQUEST&&) = default;
    USERIF_TARGET_GLOBAL_DELETE_REQUEST& operator=(USERIF_TARGET_GLOBAL_DELETE_REQUEST&&) = default;
    USERIF_TARGET_GLOBAL_DELETE_REQUEST& operator=(const USERIF_TARGET_GLOBAL_DELETE_REQUEST&) = default;
    USERIF_TARGET_GLOBAL_DELETE_REQUEST(const USERIF_TARGET_GLOBAL_DELETE_REQUEST&) = default;
    #else
    USERIF_TARGET_GLOBAL_DELETE_REQUEST(USERIF_TARGET_GLOBAL_DELETE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_GLOBAL_DELETE_REQUEST& operator=(USERIF_TARGET_GLOBAL_DELETE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unGlobalID() OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    const uint16_t& unGlobalID() const OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    void unGlobalID(uint16_t value) {
        m_unGlobalID_ = value;
    }

    uint16_t& usSensorTypeToDelete() OMG_NOEXCEPT {
        return m_usSensorTypeToDelete_;
    }

    const uint16_t& usSensorTypeToDelete() const OMG_NOEXCEPT {
        return m_usSensorTypeToDelete_;
    }

    void usSensorTypeToDelete(uint16_t value) {
        m_usSensorTypeToDelete_ = value;
    }

    uint16_t& usReserved1() OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    const uint16_t& usReserved1() const OMG_NOEXCEPT {
        return m_usReserved1_;
    }

    void usReserved1(uint16_t value) {
        m_usReserved1_ = value;
    }

    uint16_t& usReserved2() OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    const uint16_t& usReserved2() const OMG_NOEXCEPT {
        return m_usReserved2_;
    }

    void usReserved2(uint16_t value) {
        m_usReserved2_ = value;
    }

    bool operator == (const USERIF_TARGET_GLOBAL_DELETE_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_GLOBAL_DELETE_REQUEST& other_) const;

    void swap(USERIF_TARGET_GLOBAL_DELETE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unGlobalID_;
    uint16_t m_usSensorTypeToDelete_;
    uint16_t m_usReserved1_;
    uint16_t m_usReserved2_;

};

inline void swap(USERIF_TARGET_GLOBAL_DELETE_REQUEST& a, USERIF_TARGET_GLOBAL_DELETE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_GLOBAL_DELETE_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_GLOBAL_REFRESH_REQUEST {
  public:
    USERIF_TARGET_GLOBAL_REFRESH_REQUEST();

    USERIF_TARGET_GLOBAL_REFRESH_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unGlobalID,uint16_t usFriendlyInfo,uint16_t usClassInfo,uint8_t oThreatGrade,const ::dds::core::array< uint8_t, 20L>& aTag);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_GLOBAL_REFRESH_REQUEST (USERIF_TARGET_GLOBAL_REFRESH_REQUEST&&) = default;
    USERIF_TARGET_GLOBAL_REFRESH_REQUEST& operator=(USERIF_TARGET_GLOBAL_REFRESH_REQUEST&&) = default;
    USERIF_TARGET_GLOBAL_REFRESH_REQUEST& operator=(const USERIF_TARGET_GLOBAL_REFRESH_REQUEST&) = default;
    USERIF_TARGET_GLOBAL_REFRESH_REQUEST(const USERIF_TARGET_GLOBAL_REFRESH_REQUEST&) = default;
    #else
    USERIF_TARGET_GLOBAL_REFRESH_REQUEST(USERIF_TARGET_GLOBAL_REFRESH_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_GLOBAL_REFRESH_REQUEST& operator=(USERIF_TARGET_GLOBAL_REFRESH_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unGlobalID() OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    const uint16_t& unGlobalID() const OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    void unGlobalID(uint16_t value) {
        m_unGlobalID_ = value;
    }

    uint16_t& usFriendlyInfo() OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    const uint16_t& usFriendlyInfo() const OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    void usFriendlyInfo(uint16_t value) {
        m_usFriendlyInfo_ = value;
    }

    uint16_t& usClassInfo() OMG_NOEXCEPT {
        return m_usClassInfo_;
    }

    const uint16_t& usClassInfo() const OMG_NOEXCEPT {
        return m_usClassInfo_;
    }

    void usClassInfo(uint16_t value) {
        m_usClassInfo_ = value;
    }

    uint8_t& oThreatGrade() OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    const uint8_t& oThreatGrade() const OMG_NOEXCEPT {
        return m_oThreatGrade_;
    }

    void oThreatGrade(uint8_t value) {
        m_oThreatGrade_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& aTag() OMG_NOEXCEPT {
        return m_aTag_;
    }

    const ::dds::core::array< uint8_t, 20L>& aTag() const OMG_NOEXCEPT {
        return m_aTag_;
    }

    void aTag(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aTag_ = value;
    }

    void aTag(::dds::core::array< uint8_t, 20L>&& value) {
        m_aTag_ = std::move(value);
    }

    bool operator == (const USERIF_TARGET_GLOBAL_REFRESH_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_GLOBAL_REFRESH_REQUEST& other_) const;

    void swap(USERIF_TARGET_GLOBAL_REFRESH_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unGlobalID_;
    uint16_t m_usFriendlyInfo_;
    uint16_t m_usClassInfo_;
    uint8_t m_oThreatGrade_;
    ::dds::core::array< uint8_t, 20L> m_aTag_;

};

inline void swap(USERIF_TARGET_GLOBAL_REFRESH_REQUEST& a, USERIF_TARGET_GLOBAL_REFRESH_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_GLOBAL_REFRESH_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_GLOBAL_REGISTER_REQUEST {
  public:
    USERIF_TARGET_GLOBAL_REGISTER_REQUEST();

    USERIF_TARGET_GLOBAL_REGISTER_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unSensorID,uint16_t unLocalID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_GLOBAL_REGISTER_REQUEST (USERIF_TARGET_GLOBAL_REGISTER_REQUEST&&) = default;
    USERIF_TARGET_GLOBAL_REGISTER_REQUEST& operator=(USERIF_TARGET_GLOBAL_REGISTER_REQUEST&&) = default;
    USERIF_TARGET_GLOBAL_REGISTER_REQUEST& operator=(const USERIF_TARGET_GLOBAL_REGISTER_REQUEST&) = default;
    USERIF_TARGET_GLOBAL_REGISTER_REQUEST(const USERIF_TARGET_GLOBAL_REGISTER_REQUEST&) = default;
    #else
    USERIF_TARGET_GLOBAL_REGISTER_REQUEST(USERIF_TARGET_GLOBAL_REGISTER_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_GLOBAL_REGISTER_REQUEST& operator=(USERIF_TARGET_GLOBAL_REGISTER_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unSensorID() OMG_NOEXCEPT {
        return m_unSensorID_;
    }

    const uint16_t& unSensorID() const OMG_NOEXCEPT {
        return m_unSensorID_;
    }

    void unSensorID(uint16_t value) {
        m_unSensorID_ = value;
    }

    uint16_t& unLocalID() OMG_NOEXCEPT {
        return m_unLocalID_;
    }

    const uint16_t& unLocalID() const OMG_NOEXCEPT {
        return m_unLocalID_;
    }

    void unLocalID(uint16_t value) {
        m_unLocalID_ = value;
    }

    bool operator == (const USERIF_TARGET_GLOBAL_REGISTER_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_GLOBAL_REGISTER_REQUEST& other_) const;

    void swap(USERIF_TARGET_GLOBAL_REGISTER_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unSensorID_;
    uint16_t m_unLocalID_;

};

inline void swap(USERIF_TARGET_GLOBAL_REGISTER_REQUEST& a, USERIF_TARGET_GLOBAL_REGISTER_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_GLOBAL_REGISTER_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_INFO_INITIATE_REQUEST {
  public:
    USERIF_TARGET_INFO_INITIATE_REQUEST();

    USERIF_TARGET_INFO_INITIATE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t usInitCmd,uint16_t usSensorID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_INFO_INITIATE_REQUEST (USERIF_TARGET_INFO_INITIATE_REQUEST&&) = default;
    USERIF_TARGET_INFO_INITIATE_REQUEST& operator=(USERIF_TARGET_INFO_INITIATE_REQUEST&&) = default;
    USERIF_TARGET_INFO_INITIATE_REQUEST& operator=(const USERIF_TARGET_INFO_INITIATE_REQUEST&) = default;
    USERIF_TARGET_INFO_INITIATE_REQUEST(const USERIF_TARGET_INFO_INITIATE_REQUEST&) = default;
    #else
    USERIF_TARGET_INFO_INITIATE_REQUEST(USERIF_TARGET_INFO_INITIATE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_INFO_INITIATE_REQUEST& operator=(USERIF_TARGET_INFO_INITIATE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& usInitCmd() OMG_NOEXCEPT {
        return m_usInitCmd_;
    }

    const uint16_t& usInitCmd() const OMG_NOEXCEPT {
        return m_usInitCmd_;
    }

    void usInitCmd(uint16_t value) {
        m_usInitCmd_ = value;
    }

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    bool operator == (const USERIF_TARGET_INFO_INITIATE_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_INFO_INITIATE_REQUEST& other_) const;

    void swap(USERIF_TARGET_INFO_INITIATE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_usInitCmd_;
    uint16_t m_usSensorID_;

};

inline void swap(USERIF_TARGET_INFO_INITIATE_REQUEST& a, USERIF_TARGET_INFO_INITIATE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_INFO_INITIATE_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_INTEREST_DELETE_REQUEST {
  public:
    USERIF_TARGET_INTEREST_DELETE_REQUEST();

    USERIF_TARGET_INTEREST_DELETE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unAtractID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_INTEREST_DELETE_REQUEST (USERIF_TARGET_INTEREST_DELETE_REQUEST&&) = default;
    USERIF_TARGET_INTEREST_DELETE_REQUEST& operator=(USERIF_TARGET_INTEREST_DELETE_REQUEST&&) = default;
    USERIF_TARGET_INTEREST_DELETE_REQUEST& operator=(const USERIF_TARGET_INTEREST_DELETE_REQUEST&) = default;
    USERIF_TARGET_INTEREST_DELETE_REQUEST(const USERIF_TARGET_INTEREST_DELETE_REQUEST&) = default;
    #else
    USERIF_TARGET_INTEREST_DELETE_REQUEST(USERIF_TARGET_INTEREST_DELETE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_INTEREST_DELETE_REQUEST& operator=(USERIF_TARGET_INTEREST_DELETE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unAtractID() OMG_NOEXCEPT {
        return m_unAtractID_;
    }

    const uint16_t& unAtractID() const OMG_NOEXCEPT {
        return m_unAtractID_;
    }

    void unAtractID(uint16_t value) {
        m_unAtractID_ = value;
    }

    bool operator == (const USERIF_TARGET_INTEREST_DELETE_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_INTEREST_DELETE_REQUEST& other_) const;

    void swap(USERIF_TARGET_INTEREST_DELETE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unAtractID_;

};

inline void swap(USERIF_TARGET_INTEREST_DELETE_REQUEST& a, USERIF_TARGET_INTEREST_DELETE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_INTEREST_DELETE_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_INTEREST_NEW_REQUEST {
  public:
    USERIF_TARGET_INTEREST_NEW_REQUEST();

    USERIF_TARGET_INTEREST_NEW_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unGlobalID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_INTEREST_NEW_REQUEST (USERIF_TARGET_INTEREST_NEW_REQUEST&&) = default;
    USERIF_TARGET_INTEREST_NEW_REQUEST& operator=(USERIF_TARGET_INTEREST_NEW_REQUEST&&) = default;
    USERIF_TARGET_INTEREST_NEW_REQUEST& operator=(const USERIF_TARGET_INTEREST_NEW_REQUEST&) = default;
    USERIF_TARGET_INTEREST_NEW_REQUEST(const USERIF_TARGET_INTEREST_NEW_REQUEST&) = default;
    #else
    USERIF_TARGET_INTEREST_NEW_REQUEST(USERIF_TARGET_INTEREST_NEW_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_INTEREST_NEW_REQUEST& operator=(USERIF_TARGET_INTEREST_NEW_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unGlobalID() OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    const uint16_t& unGlobalID() const OMG_NOEXCEPT {
        return m_unGlobalID_;
    }

    void unGlobalID(uint16_t value) {
        m_unGlobalID_ = value;
    }

    bool operator == (const USERIF_TARGET_INTEREST_NEW_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_INTEREST_NEW_REQUEST& other_) const;

    void swap(USERIF_TARGET_INTEREST_NEW_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unGlobalID_;

};

inline void swap(USERIF_TARGET_INTEREST_NEW_REQUEST& a, USERIF_TARGET_INTEREST_NEW_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_INTEREST_NEW_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_OUM_DELETE_REQUEST {
  public:
    USERIF_TARGET_OUM_DELETE_REQUEST();

    USERIF_TARGET_OUM_DELETE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unOUMID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_OUM_DELETE_REQUEST (USERIF_TARGET_OUM_DELETE_REQUEST&&) = default;
    USERIF_TARGET_OUM_DELETE_REQUEST& operator=(USERIF_TARGET_OUM_DELETE_REQUEST&&) = default;
    USERIF_TARGET_OUM_DELETE_REQUEST& operator=(const USERIF_TARGET_OUM_DELETE_REQUEST&) = default;
    USERIF_TARGET_OUM_DELETE_REQUEST(const USERIF_TARGET_OUM_DELETE_REQUEST&) = default;
    #else
    USERIF_TARGET_OUM_DELETE_REQUEST(USERIF_TARGET_OUM_DELETE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_OUM_DELETE_REQUEST& operator=(USERIF_TARGET_OUM_DELETE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unOUMID() OMG_NOEXCEPT {
        return m_unOUMID_;
    }

    const uint16_t& unOUMID() const OMG_NOEXCEPT {
        return m_unOUMID_;
    }

    void unOUMID(uint16_t value) {
        m_unOUMID_ = value;
    }

    bool operator == (const USERIF_TARGET_OUM_DELETE_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_OUM_DELETE_REQUEST& other_) const;

    void swap(USERIF_TARGET_OUM_DELETE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unOUMID_;

};

inline void swap(USERIF_TARGET_OUM_DELETE_REQUEST& a, USERIF_TARGET_OUM_DELETE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_OUM_DELETE_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_OUM_REFRESH_REQUEST {
  public:
    USERIF_TARGET_OUM_REFRESH_REQUEST();

    USERIF_TARGET_OUM_REFRESH_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,uint16_t unOUMID,double dLatitude,double dLongitude,uint16_t usClassInfo,uint16_t usFriendlyInfo,const ::dds::core::array< uint8_t, 20L>& aTag);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_OUM_REFRESH_REQUEST (USERIF_TARGET_OUM_REFRESH_REQUEST&&) = default;
    USERIF_TARGET_OUM_REFRESH_REQUEST& operator=(USERIF_TARGET_OUM_REFRESH_REQUEST&&) = default;
    USERIF_TARGET_OUM_REFRESH_REQUEST& operator=(const USERIF_TARGET_OUM_REFRESH_REQUEST&) = default;
    USERIF_TARGET_OUM_REFRESH_REQUEST(const USERIF_TARGET_OUM_REFRESH_REQUEST&) = default;
    #else
    USERIF_TARGET_OUM_REFRESH_REQUEST(USERIF_TARGET_OUM_REFRESH_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_OUM_REFRESH_REQUEST& operator=(USERIF_TARGET_OUM_REFRESH_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    uint16_t& unOUMID() OMG_NOEXCEPT {
        return m_unOUMID_;
    }

    const uint16_t& unOUMID() const OMG_NOEXCEPT {
        return m_unOUMID_;
    }

    void unOUMID(uint16_t value) {
        m_unOUMID_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    uint16_t& usClassInfo() OMG_NOEXCEPT {
        return m_usClassInfo_;
    }

    const uint16_t& usClassInfo() const OMG_NOEXCEPT {
        return m_usClassInfo_;
    }

    void usClassInfo(uint16_t value) {
        m_usClassInfo_ = value;
    }

    uint16_t& usFriendlyInfo() OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    const uint16_t& usFriendlyInfo() const OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    void usFriendlyInfo(uint16_t value) {
        m_usFriendlyInfo_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& aTag() OMG_NOEXCEPT {
        return m_aTag_;
    }

    const ::dds::core::array< uint8_t, 20L>& aTag() const OMG_NOEXCEPT {
        return m_aTag_;
    }

    void aTag(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aTag_ = value;
    }

    void aTag(::dds::core::array< uint8_t, 20L>&& value) {
        m_aTag_ = std::move(value);
    }

    bool operator == (const USERIF_TARGET_OUM_REFRESH_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_OUM_REFRESH_REQUEST& other_) const;

    void swap(USERIF_TARGET_OUM_REFRESH_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    uint16_t m_unOUMID_;
    double m_dLatitude_;
    double m_dLongitude_;
    uint16_t m_usClassInfo_;
    uint16_t m_usFriendlyInfo_;
    ::dds::core::array< uint8_t, 20L> m_aTag_;

};

inline void swap(USERIF_TARGET_OUM_REFRESH_REQUEST& a, USERIF_TARGET_OUM_REFRESH_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_OUM_REFRESH_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_OUM_REGISTER_REQUEST {
  public:
    USERIF_TARGET_OUM_REGISTER_REQUEST();

    USERIF_TARGET_OUM_REGISTER_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t usUserID,double dLatitude,double dLongitude,uint16_t usClassInfo,uint16_t usFriendlyInfo,uint16_t usSensorID,uint16_t usTargetNo,const ::dds::core::array< uint8_t, 20L>& aTag);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_OUM_REGISTER_REQUEST (USERIF_TARGET_OUM_REGISTER_REQUEST&&) = default;
    USERIF_TARGET_OUM_REGISTER_REQUEST& operator=(USERIF_TARGET_OUM_REGISTER_REQUEST&&) = default;
    USERIF_TARGET_OUM_REGISTER_REQUEST& operator=(const USERIF_TARGET_OUM_REGISTER_REQUEST&) = default;
    USERIF_TARGET_OUM_REGISTER_REQUEST(const USERIF_TARGET_OUM_REGISTER_REQUEST&) = default;
    #else
    USERIF_TARGET_OUM_REGISTER_REQUEST(USERIF_TARGET_OUM_REGISTER_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_OUM_REGISTER_REQUEST& operator=(USERIF_TARGET_OUM_REGISTER_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usUserID() OMG_NOEXCEPT {
        return m_usUserID_;
    }

    const uint16_t& usUserID() const OMG_NOEXCEPT {
        return m_usUserID_;
    }

    void usUserID(uint16_t value) {
        m_usUserID_ = value;
    }

    double& dLatitude() OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    const double& dLatitude() const OMG_NOEXCEPT {
        return m_dLatitude_;
    }

    void dLatitude(double value) {
        m_dLatitude_ = value;
    }

    double& dLongitude() OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    const double& dLongitude() const OMG_NOEXCEPT {
        return m_dLongitude_;
    }

    void dLongitude(double value) {
        m_dLongitude_ = value;
    }

    uint16_t& usClassInfo() OMG_NOEXCEPT {
        return m_usClassInfo_;
    }

    const uint16_t& usClassInfo() const OMG_NOEXCEPT {
        return m_usClassInfo_;
    }

    void usClassInfo(uint16_t value) {
        m_usClassInfo_ = value;
    }

    uint16_t& usFriendlyInfo() OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    const uint16_t& usFriendlyInfo() const OMG_NOEXCEPT {
        return m_usFriendlyInfo_;
    }

    void usFriendlyInfo(uint16_t value) {
        m_usFriendlyInfo_ = value;
    }

    uint16_t& usSensorID() OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    const uint16_t& usSensorID() const OMG_NOEXCEPT {
        return m_usSensorID_;
    }

    void usSensorID(uint16_t value) {
        m_usSensorID_ = value;
    }

    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    ::dds::core::array< uint8_t, 20L>& aTag() OMG_NOEXCEPT {
        return m_aTag_;
    }

    const ::dds::core::array< uint8_t, 20L>& aTag() const OMG_NOEXCEPT {
        return m_aTag_;
    }

    void aTag(const ::dds::core::array< uint8_t, 20L>& value) {
        m_aTag_ = value;
    }

    void aTag(::dds::core::array< uint8_t, 20L>&& value) {
        m_aTag_ = std::move(value);
    }

    bool operator == (const USERIF_TARGET_OUM_REGISTER_REQUEST& other_) const;
    bool operator != (const USERIF_TARGET_OUM_REGISTER_REQUEST& other_) const;

    void swap(USERIF_TARGET_OUM_REGISTER_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usUserID_;
    double m_dLatitude_;
    double m_dLongitude_;
    uint16_t m_usClassInfo_;
    uint16_t m_usFriendlyInfo_;
    uint16_t m_usSensorID_;
    uint16_t m_usTargetNo_;
    ::dds::core::array< uint8_t, 20L> m_aTag_;

};

inline void swap(USERIF_TARGET_OUM_REGISTER_REQUEST& a, USERIF_TARGET_OUM_REGISTER_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_OUM_REGISTER_REQUEST& sample);

class NDDSUSERDllExport USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND {
  public:
    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND();

    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND(const ST_MSG_HEADER& stMsgHeader,uint8_t oConsoleID,uint8_t oAxisID,uint16_t usTargetNo,const ::dds::core::array< uint16_t, 2L>& aReserved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND (USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND&&) = default;
    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& operator=(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND&&) = default;
    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& operator=(const USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND&) = default;
    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND(const USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND&) = default;
    #else
    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND&& other_) OMG_NOEXCEPT;  
    USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& operator=(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oConsoleID() OMG_NOEXCEPT {
        return m_oConsoleID_;
    }

    const uint8_t& oConsoleID() const OMG_NOEXCEPT {
        return m_oConsoleID_;
    }

    void oConsoleID(uint8_t value) {
        m_oConsoleID_ = value;
    }

    uint8_t& oAxisID() OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    const uint8_t& oAxisID() const OMG_NOEXCEPT {
        return m_oAxisID_;
    }

    void oAxisID(uint8_t value) {
        m_oAxisID_ = value;
    }

    uint16_t& usTargetNo() OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    const uint16_t& usTargetNo() const OMG_NOEXCEPT {
        return m_usTargetNo_;
    }

    void usTargetNo(uint16_t value) {
        m_usTargetNo_ = value;
    }

    ::dds::core::array< uint16_t, 2L>& aReserved() OMG_NOEXCEPT {
        return m_aReserved_;
    }

    const ::dds::core::array< uint16_t, 2L>& aReserved() const OMG_NOEXCEPT {
        return m_aReserved_;
    }

    void aReserved(const ::dds::core::array< uint16_t, 2L>& value) {
        m_aReserved_ = value;
    }

    void aReserved(::dds::core::array< uint16_t, 2L>&& value) {
        m_aReserved_ = std::move(value);
    }

    bool operator == (const USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& other_) const;
    bool operator != (const USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& other_) const;

    void swap(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oConsoleID_;
    uint8_t m_oAxisID_;
    uint16_t m_usTargetNo_;
    ::dds::core::array< uint16_t, 2L> m_aReserved_;

};

inline void swap(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& a, USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& sample);

class NDDSUSERDllExport USERIF_THREAT_AREA_CONTROL_REQUEST {
  public:
    USERIF_THREAT_AREA_CONTROL_REQUEST();

    USERIF_THREAT_AREA_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,const ::dds::core::array< uint8_t, 30L>& szUserID,const ST_THREAT_AREA& stThreatArea1,const ST_THREAT_AREA& stThreatArea2,const ST_THREAT_AREA& stThreatArea3);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_THREAT_AREA_CONTROL_REQUEST (USERIF_THREAT_AREA_CONTROL_REQUEST&&) = default;
    USERIF_THREAT_AREA_CONTROL_REQUEST& operator=(USERIF_THREAT_AREA_CONTROL_REQUEST&&) = default;
    USERIF_THREAT_AREA_CONTROL_REQUEST& operator=(const USERIF_THREAT_AREA_CONTROL_REQUEST&) = default;
    USERIF_THREAT_AREA_CONTROL_REQUEST(const USERIF_THREAT_AREA_CONTROL_REQUEST&) = default;
    #else
    USERIF_THREAT_AREA_CONTROL_REQUEST(USERIF_THREAT_AREA_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_THREAT_AREA_CONTROL_REQUEST& operator=(USERIF_THREAT_AREA_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    ::dds::core::array< uint8_t, 30L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 30L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 30L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 30L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ST_THREAT_AREA& stThreatArea1() OMG_NOEXCEPT {
        return m_stThreatArea1_;
    }

    const ST_THREAT_AREA& stThreatArea1() const OMG_NOEXCEPT {
        return m_stThreatArea1_;
    }

    void stThreatArea1(const ST_THREAT_AREA& value) {
        m_stThreatArea1_ = value;
    }

    void stThreatArea1(ST_THREAT_AREA&& value) {
        m_stThreatArea1_ = std::move(value);
    }
    ST_THREAT_AREA& stThreatArea2() OMG_NOEXCEPT {
        return m_stThreatArea2_;
    }

    const ST_THREAT_AREA& stThreatArea2() const OMG_NOEXCEPT {
        return m_stThreatArea2_;
    }

    void stThreatArea2(const ST_THREAT_AREA& value) {
        m_stThreatArea2_ = value;
    }

    void stThreatArea2(ST_THREAT_AREA&& value) {
        m_stThreatArea2_ = std::move(value);
    }
    ST_THREAT_AREA& stThreatArea3() OMG_NOEXCEPT {
        return m_stThreatArea3_;
    }

    const ST_THREAT_AREA& stThreatArea3() const OMG_NOEXCEPT {
        return m_stThreatArea3_;
    }

    void stThreatArea3(const ST_THREAT_AREA& value) {
        m_stThreatArea3_ = value;
    }

    void stThreatArea3(ST_THREAT_AREA&& value) {
        m_stThreatArea3_ = std::move(value);
    }

    bool operator == (const USERIF_THREAT_AREA_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_THREAT_AREA_CONTROL_REQUEST& other_) const;

    void swap(USERIF_THREAT_AREA_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    ::dds::core::array< uint8_t, 30L> m_szUserID_;
    ST_THREAT_AREA m_stThreatArea1_;
    ST_THREAT_AREA m_stThreatArea2_;
    ST_THREAT_AREA m_stThreatArea3_;

};

inline void swap(USERIF_THREAT_AREA_CONTROL_REQUEST& a, USERIF_THREAT_AREA_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_THREAT_AREA_CONTROL_REQUEST& sample);

class NDDSUSERDllExport USERIF_TIMESYNC_MODE_CMD {
  public:
    USERIF_TIMESYNC_MODE_CMD();

    USERIF_TIMESYNC_MODE_CMD(const ST_MSG_HEADER& stMsgHeader,uint16_t usMode,const ST_DATE_TIME& stSetTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_TIMESYNC_MODE_CMD (USERIF_TIMESYNC_MODE_CMD&&) = default;
    USERIF_TIMESYNC_MODE_CMD& operator=(USERIF_TIMESYNC_MODE_CMD&&) = default;
    USERIF_TIMESYNC_MODE_CMD& operator=(const USERIF_TIMESYNC_MODE_CMD&) = default;
    USERIF_TIMESYNC_MODE_CMD(const USERIF_TIMESYNC_MODE_CMD&) = default;
    #else
    USERIF_TIMESYNC_MODE_CMD(USERIF_TIMESYNC_MODE_CMD&& other_) OMG_NOEXCEPT;  
    USERIF_TIMESYNC_MODE_CMD& operator=(USERIF_TIMESYNC_MODE_CMD&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usMode() OMG_NOEXCEPT {
        return m_usMode_;
    }

    const uint16_t& usMode() const OMG_NOEXCEPT {
        return m_usMode_;
    }

    void usMode(uint16_t value) {
        m_usMode_ = value;
    }

    ST_DATE_TIME& stSetTime() OMG_NOEXCEPT {
        return m_stSetTime_;
    }

    const ST_DATE_TIME& stSetTime() const OMG_NOEXCEPT {
        return m_stSetTime_;
    }

    void stSetTime(const ST_DATE_TIME& value) {
        m_stSetTime_ = value;
    }

    void stSetTime(ST_DATE_TIME&& value) {
        m_stSetTime_ = std::move(value);
    }

    bool operator == (const USERIF_TIMESYNC_MODE_CMD& other_) const;
    bool operator != (const USERIF_TIMESYNC_MODE_CMD& other_) const;

    void swap(USERIF_TIMESYNC_MODE_CMD& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usMode_;
    ST_DATE_TIME m_stSetTime_;

};

inline void swap(USERIF_TIMESYNC_MODE_CMD& a, USERIF_TIMESYNC_MODE_CMD& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_TIMESYNC_MODE_CMD& sample);

class NDDSUSERDllExport USERIF_USER_ACCOUNT_INFO_REQ {
  public:
    USERIF_USER_ACCOUNT_INFO_REQ();

    USERIF_USER_ACCOUNT_INFO_REQ(const ST_MSG_HEADER& stMsgHeader,const ST_USER_ACCOUNT_INFO& stUserAccountInfo,uint8_t oMode,uint8_t oStationID,const ::dds::core::array< uint8_t, 2L>& oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_USER_ACCOUNT_INFO_REQ (USERIF_USER_ACCOUNT_INFO_REQ&&) = default;
    USERIF_USER_ACCOUNT_INFO_REQ& operator=(USERIF_USER_ACCOUNT_INFO_REQ&&) = default;
    USERIF_USER_ACCOUNT_INFO_REQ& operator=(const USERIF_USER_ACCOUNT_INFO_REQ&) = default;
    USERIF_USER_ACCOUNT_INFO_REQ(const USERIF_USER_ACCOUNT_INFO_REQ&) = default;
    #else
    USERIF_USER_ACCOUNT_INFO_REQ(USERIF_USER_ACCOUNT_INFO_REQ&& other_) OMG_NOEXCEPT;  
    USERIF_USER_ACCOUNT_INFO_REQ& operator=(USERIF_USER_ACCOUNT_INFO_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ST_USER_ACCOUNT_INFO& stUserAccountInfo() OMG_NOEXCEPT {
        return m_stUserAccountInfo_;
    }

    const ST_USER_ACCOUNT_INFO& stUserAccountInfo() const OMG_NOEXCEPT {
        return m_stUserAccountInfo_;
    }

    void stUserAccountInfo(const ST_USER_ACCOUNT_INFO& value) {
        m_stUserAccountInfo_ = value;
    }

    void stUserAccountInfo(ST_USER_ACCOUNT_INFO&& value) {
        m_stUserAccountInfo_ = std::move(value);
    }
    uint8_t& oMode() OMG_NOEXCEPT {
        return m_oMode_;
    }

    const uint8_t& oMode() const OMG_NOEXCEPT {
        return m_oMode_;
    }

    void oMode(uint8_t value) {
        m_oMode_ = value;
    }

    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    ::dds::core::array< uint8_t, 2L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 2L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 2L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 2L>&& value) {
        m_oResearved_ = std::move(value);
    }

    bool operator == (const USERIF_USER_ACCOUNT_INFO_REQ& other_) const;
    bool operator != (const USERIF_USER_ACCOUNT_INFO_REQ& other_) const;

    void swap(USERIF_USER_ACCOUNT_INFO_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ST_USER_ACCOUNT_INFO m_stUserAccountInfo_;
    uint8_t m_oMode_;
    uint8_t m_oStationID_;
    ::dds::core::array< uint8_t, 2L> m_oResearved_;

};

inline void swap(USERIF_USER_ACCOUNT_INFO_REQ& a, USERIF_USER_ACCOUNT_INFO_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_USER_ACCOUNT_INFO_REQ& sample);

class NDDSUSERDllExport USERIF_USER_ACCOUNT_LIST_REQ {
  public:
    USERIF_USER_ACCOUNT_LIST_REQ();

    USERIF_USER_ACCOUNT_LIST_REQ(const ST_MSG_HEADER& stMsgHeader,uint8_t oStationID,const ::dds::core::array< uint8_t, 3L>& oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_USER_ACCOUNT_LIST_REQ (USERIF_USER_ACCOUNT_LIST_REQ&&) = default;
    USERIF_USER_ACCOUNT_LIST_REQ& operator=(USERIF_USER_ACCOUNT_LIST_REQ&&) = default;
    USERIF_USER_ACCOUNT_LIST_REQ& operator=(const USERIF_USER_ACCOUNT_LIST_REQ&) = default;
    USERIF_USER_ACCOUNT_LIST_REQ(const USERIF_USER_ACCOUNT_LIST_REQ&) = default;
    #else
    USERIF_USER_ACCOUNT_LIST_REQ(USERIF_USER_ACCOUNT_LIST_REQ&& other_) OMG_NOEXCEPT;  
    USERIF_USER_ACCOUNT_LIST_REQ& operator=(USERIF_USER_ACCOUNT_LIST_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oResearved_ = std::move(value);
    }

    bool operator == (const USERIF_USER_ACCOUNT_LIST_REQ& other_) const;
    bool operator != (const USERIF_USER_ACCOUNT_LIST_REQ& other_) const;

    void swap(USERIF_USER_ACCOUNT_LIST_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oStationID_;
    ::dds::core::array< uint8_t, 3L> m_oResearved_;

};

inline void swap(USERIF_USER_ACCOUNT_LIST_REQ& a, USERIF_USER_ACCOUNT_LIST_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_USER_ACCOUNT_LIST_REQ& sample);

class NDDSUSERDllExport USERIF_USER_ACCOUNT_LOG_REQ {
  public:
    USERIF_USER_ACCOUNT_LOG_REQ();

    USERIF_USER_ACCOUNT_LOG_REQ(const ST_MSG_HEADER& stMsgHeader,uint16_t unTotalPageNum,uint16_t unCurrentPageNum,const ST_DATE_TIME& stStartTime,const ST_DATE_TIME& stEndTime,uint8_t oStationID,const ::dds::core::array< uint8_t, 3L>& oResearved);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_USER_ACCOUNT_LOG_REQ (USERIF_USER_ACCOUNT_LOG_REQ&&) = default;
    USERIF_USER_ACCOUNT_LOG_REQ& operator=(USERIF_USER_ACCOUNT_LOG_REQ&&) = default;
    USERIF_USER_ACCOUNT_LOG_REQ& operator=(const USERIF_USER_ACCOUNT_LOG_REQ&) = default;
    USERIF_USER_ACCOUNT_LOG_REQ(const USERIF_USER_ACCOUNT_LOG_REQ&) = default;
    #else
    USERIF_USER_ACCOUNT_LOG_REQ(USERIF_USER_ACCOUNT_LOG_REQ&& other_) OMG_NOEXCEPT;  
    USERIF_USER_ACCOUNT_LOG_REQ& operator=(USERIF_USER_ACCOUNT_LOG_REQ&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unTotalPageNum() OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    const uint16_t& unTotalPageNum() const OMG_NOEXCEPT {
        return m_unTotalPageNum_;
    }

    void unTotalPageNum(uint16_t value) {
        m_unTotalPageNum_ = value;
    }

    uint16_t& unCurrentPageNum() OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    const uint16_t& unCurrentPageNum() const OMG_NOEXCEPT {
        return m_unCurrentPageNum_;
    }

    void unCurrentPageNum(uint16_t value) {
        m_unCurrentPageNum_ = value;
    }

    ST_DATE_TIME& stStartTime() OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    const ST_DATE_TIME& stStartTime() const OMG_NOEXCEPT {
        return m_stStartTime_;
    }

    void stStartTime(const ST_DATE_TIME& value) {
        m_stStartTime_ = value;
    }

    void stStartTime(ST_DATE_TIME&& value) {
        m_stStartTime_ = std::move(value);
    }
    ST_DATE_TIME& stEndTime() OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    const ST_DATE_TIME& stEndTime() const OMG_NOEXCEPT {
        return m_stEndTime_;
    }

    void stEndTime(const ST_DATE_TIME& value) {
        m_stEndTime_ = value;
    }

    void stEndTime(ST_DATE_TIME&& value) {
        m_stEndTime_ = std::move(value);
    }
    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    ::dds::core::array< uint8_t, 3L>& oResearved() OMG_NOEXCEPT {
        return m_oResearved_;
    }

    const ::dds::core::array< uint8_t, 3L>& oResearved() const OMG_NOEXCEPT {
        return m_oResearved_;
    }

    void oResearved(const ::dds::core::array< uint8_t, 3L>& value) {
        m_oResearved_ = value;
    }

    void oResearved(::dds::core::array< uint8_t, 3L>&& value) {
        m_oResearved_ = std::move(value);
    }

    bool operator == (const USERIF_USER_ACCOUNT_LOG_REQ& other_) const;
    bool operator != (const USERIF_USER_ACCOUNT_LOG_REQ& other_) const;

    void swap(USERIF_USER_ACCOUNT_LOG_REQ& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unTotalPageNum_;
    uint16_t m_unCurrentPageNum_;
    ST_DATE_TIME m_stStartTime_;
    ST_DATE_TIME m_stEndTime_;
    uint8_t m_oStationID_;
    ::dds::core::array< uint8_t, 3L> m_oResearved_;

};

inline void swap(USERIF_USER_ACCOUNT_LOG_REQ& a, USERIF_USER_ACCOUNT_LOG_REQ& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_USER_ACCOUNT_LOG_REQ& sample);

class NDDSUSERDllExport USERIF_USER_LOGIN_INFO {
  public:
    USERIF_USER_LOGIN_INFO();

    USERIF_USER_LOGIN_INFO(const ST_MSG_HEADER& stMsgHeader,const ::dds::core::array< uint8_t, 32L>& szUserID,const ::dds::core::array< uint8_t, 32L>& szUserName,uint8_t oUserRank,uint8_t oUserAuthority);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_USER_LOGIN_INFO (USERIF_USER_LOGIN_INFO&&) = default;
    USERIF_USER_LOGIN_INFO& operator=(USERIF_USER_LOGIN_INFO&&) = default;
    USERIF_USER_LOGIN_INFO& operator=(const USERIF_USER_LOGIN_INFO&) = default;
    USERIF_USER_LOGIN_INFO(const USERIF_USER_LOGIN_INFO&) = default;
    #else
    USERIF_USER_LOGIN_INFO(USERIF_USER_LOGIN_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_USER_LOGIN_INFO& operator=(USERIF_USER_LOGIN_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& szUserID() OMG_NOEXCEPT {
        return m_szUserID_;
    }

    const ::dds::core::array< uint8_t, 32L>& szUserID() const OMG_NOEXCEPT {
        return m_szUserID_;
    }

    void szUserID(const ::dds::core::array< uint8_t, 32L>& value) {
        m_szUserID_ = value;
    }

    void szUserID(::dds::core::array< uint8_t, 32L>&& value) {
        m_szUserID_ = std::move(value);
    }
    ::dds::core::array< uint8_t, 32L>& szUserName() OMG_NOEXCEPT {
        return m_szUserName_;
    }

    const ::dds::core::array< uint8_t, 32L>& szUserName() const OMG_NOEXCEPT {
        return m_szUserName_;
    }

    void szUserName(const ::dds::core::array< uint8_t, 32L>& value) {
        m_szUserName_ = value;
    }

    void szUserName(::dds::core::array< uint8_t, 32L>&& value) {
        m_szUserName_ = std::move(value);
    }
    uint8_t& oUserRank() OMG_NOEXCEPT {
        return m_oUserRank_;
    }

    const uint8_t& oUserRank() const OMG_NOEXCEPT {
        return m_oUserRank_;
    }

    void oUserRank(uint8_t value) {
        m_oUserRank_ = value;
    }

    uint8_t& oUserAuthority() OMG_NOEXCEPT {
        return m_oUserAuthority_;
    }

    const uint8_t& oUserAuthority() const OMG_NOEXCEPT {
        return m_oUserAuthority_;
    }

    void oUserAuthority(uint8_t value) {
        m_oUserAuthority_ = value;
    }

    bool operator == (const USERIF_USER_LOGIN_INFO& other_) const;
    bool operator != (const USERIF_USER_LOGIN_INFO& other_) const;

    void swap(USERIF_USER_LOGIN_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::dds::core::array< uint8_t, 32L> m_szUserID_;
    ::dds::core::array< uint8_t, 32L> m_szUserName_;
    uint8_t m_oUserRank_;
    uint8_t m_oUserAuthority_;

};

inline void swap(USERIF_USER_LOGIN_INFO& a, USERIF_USER_LOGIN_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_USER_LOGIN_INFO& sample);

class NDDSUSERDllExport USERIF_VERTICAL_ANALYSIS_REQUEST {
  public:
    USERIF_VERTICAL_ANALYSIS_REQUEST();

    USERIF_VERTICAL_ANALYSIS_REQUEST(const ST_MSG_HEADER& stMsgHeader,double dPointLatPos1,double dPointLonPos1,double dPointLatPos2,double dPointLonPos2,uint16_t usMonth,uint16_t usDay);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_VERTICAL_ANALYSIS_REQUEST (USERIF_VERTICAL_ANALYSIS_REQUEST&&) = default;
    USERIF_VERTICAL_ANALYSIS_REQUEST& operator=(USERIF_VERTICAL_ANALYSIS_REQUEST&&) = default;
    USERIF_VERTICAL_ANALYSIS_REQUEST& operator=(const USERIF_VERTICAL_ANALYSIS_REQUEST&) = default;
    USERIF_VERTICAL_ANALYSIS_REQUEST(const USERIF_VERTICAL_ANALYSIS_REQUEST&) = default;
    #else
    USERIF_VERTICAL_ANALYSIS_REQUEST(USERIF_VERTICAL_ANALYSIS_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_VERTICAL_ANALYSIS_REQUEST& operator=(USERIF_VERTICAL_ANALYSIS_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    double& dPointLatPos1() OMG_NOEXCEPT {
        return m_dPointLatPos1_;
    }

    const double& dPointLatPos1() const OMG_NOEXCEPT {
        return m_dPointLatPos1_;
    }

    void dPointLatPos1(double value) {
        m_dPointLatPos1_ = value;
    }

    double& dPointLonPos1() OMG_NOEXCEPT {
        return m_dPointLonPos1_;
    }

    const double& dPointLonPos1() const OMG_NOEXCEPT {
        return m_dPointLonPos1_;
    }

    void dPointLonPos1(double value) {
        m_dPointLonPos1_ = value;
    }

    double& dPointLatPos2() OMG_NOEXCEPT {
        return m_dPointLatPos2_;
    }

    const double& dPointLatPos2() const OMG_NOEXCEPT {
        return m_dPointLatPos2_;
    }

    void dPointLatPos2(double value) {
        m_dPointLatPos2_ = value;
    }

    double& dPointLonPos2() OMG_NOEXCEPT {
        return m_dPointLonPos2_;
    }

    const double& dPointLonPos2() const OMG_NOEXCEPT {
        return m_dPointLonPos2_;
    }

    void dPointLonPos2(double value) {
        m_dPointLonPos2_ = value;
    }

    uint16_t& usMonth() OMG_NOEXCEPT {
        return m_usMonth_;
    }

    const uint16_t& usMonth() const OMG_NOEXCEPT {
        return m_usMonth_;
    }

    void usMonth(uint16_t value) {
        m_usMonth_ = value;
    }

    uint16_t& usDay() OMG_NOEXCEPT {
        return m_usDay_;
    }

    const uint16_t& usDay() const OMG_NOEXCEPT {
        return m_usDay_;
    }

    void usDay(uint16_t value) {
        m_usDay_ = value;
    }

    bool operator == (const USERIF_VERTICAL_ANALYSIS_REQUEST& other_) const;
    bool operator != (const USERIF_VERTICAL_ANALYSIS_REQUEST& other_) const;

    void swap(USERIF_VERTICAL_ANALYSIS_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    double m_dPointLatPos1_;
    double m_dPointLonPos1_;
    double m_dPointLatPos2_;
    double m_dPointLonPos2_;
    uint16_t m_usMonth_;
    uint16_t m_usDay_;

};

inline void swap(USERIF_VERTICAL_ANALYSIS_REQUEST& a, USERIF_VERTICAL_ANALYSIS_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_VERTICAL_ANALYSIS_REQUEST& sample);

class NDDSUSERDllExport USERIF_ZONE_CONTROL_REQUEST {
  public:
    USERIF_ZONE_CONTROL_REQUEST();

    USERIF_ZONE_CONTROL_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oRequestCommand,const ST_TACTICAL_AREA& stTacticalArea);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_ZONE_CONTROL_REQUEST (USERIF_ZONE_CONTROL_REQUEST&&) = default;
    USERIF_ZONE_CONTROL_REQUEST& operator=(USERIF_ZONE_CONTROL_REQUEST&&) = default;
    USERIF_ZONE_CONTROL_REQUEST& operator=(const USERIF_ZONE_CONTROL_REQUEST&) = default;
    USERIF_ZONE_CONTROL_REQUEST(const USERIF_ZONE_CONTROL_REQUEST&) = default;
    #else
    USERIF_ZONE_CONTROL_REQUEST(USERIF_ZONE_CONTROL_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_ZONE_CONTROL_REQUEST& operator=(USERIF_ZONE_CONTROL_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oRequestCommand() OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    const uint8_t& oRequestCommand() const OMG_NOEXCEPT {
        return m_oRequestCommand_;
    }

    void oRequestCommand(uint8_t value) {
        m_oRequestCommand_ = value;
    }

    ST_TACTICAL_AREA& stTacticalArea() OMG_NOEXCEPT {
        return m_stTacticalArea_;
    }

    const ST_TACTICAL_AREA& stTacticalArea() const OMG_NOEXCEPT {
        return m_stTacticalArea_;
    }

    void stTacticalArea(const ST_TACTICAL_AREA& value) {
        m_stTacticalArea_ = value;
    }

    void stTacticalArea(ST_TACTICAL_AREA&& value) {
        m_stTacticalArea_ = std::move(value);
    }

    bool operator == (const USERIF_ZONE_CONTROL_REQUEST& other_) const;
    bool operator != (const USERIF_ZONE_CONTROL_REQUEST& other_) const;

    void swap(USERIF_ZONE_CONTROL_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oRequestCommand_;
    ST_TACTICAL_AREA m_stTacticalArea_;

};

inline void swap(USERIF_ZONE_CONTROL_REQUEST& a, USERIF_ZONE_CONTROL_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_ZONE_CONTROL_REQUEST& sample);

class NDDSUSERDllExport ST_MSSSUP_SYSTEM_COMPONENT {
  public:
    ST_MSSSUP_SYSTEM_COMPONENT();

    ST_MSSSUP_SYSTEM_COMPONENT(uint32_t ulID,const std::wstring& strName,const std::wstring& strLCN,uint32_t ulDisplay,uint32_t ulIETMPM,uint32_t ulIETMCM);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SYSTEM_COMPONENT (ST_MSSSUP_SYSTEM_COMPONENT&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT& operator=(ST_MSSSUP_SYSTEM_COMPONENT&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT& operator=(const ST_MSSSUP_SYSTEM_COMPONENT&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT(const ST_MSSSUP_SYSTEM_COMPONENT&) = default;
    #else
    ST_MSSSUP_SYSTEM_COMPONENT(ST_MSSSUP_SYSTEM_COMPONENT&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SYSTEM_COMPONENT& operator=(ST_MSSSUP_SYSTEM_COMPONENT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    std::wstring& strName() OMG_NOEXCEPT {
        return m_strName_;
    }

    const std::wstring& strName() const OMG_NOEXCEPT {
        return m_strName_;
    }

    void strName(const std::wstring& value) {
        m_strName_ = value;
    }

    void strName(std::wstring&& value) {
        m_strName_ = std::move(value);
    }
    std::wstring& strLCN() OMG_NOEXCEPT {
        return m_strLCN_;
    }

    const std::wstring& strLCN() const OMG_NOEXCEPT {
        return m_strLCN_;
    }

    void strLCN(const std::wstring& value) {
        m_strLCN_ = value;
    }

    void strLCN(std::wstring&& value) {
        m_strLCN_ = std::move(value);
    }
    uint32_t& ulDisplay() OMG_NOEXCEPT {
        return m_ulDisplay_;
    }

    const uint32_t& ulDisplay() const OMG_NOEXCEPT {
        return m_ulDisplay_;
    }

    void ulDisplay(uint32_t value) {
        m_ulDisplay_ = value;
    }

    uint32_t& ulIETMPM() OMG_NOEXCEPT {
        return m_ulIETMPM_;
    }

    const uint32_t& ulIETMPM() const OMG_NOEXCEPT {
        return m_ulIETMPM_;
    }

    void ulIETMPM(uint32_t value) {
        m_ulIETMPM_ = value;
    }

    uint32_t& ulIETMCM() OMG_NOEXCEPT {
        return m_ulIETMCM_;
    }

    const uint32_t& ulIETMCM() const OMG_NOEXCEPT {
        return m_ulIETMCM_;
    }

    void ulIETMCM(uint32_t value) {
        m_ulIETMCM_ = value;
    }

    bool operator == (const ST_MSSSUP_SYSTEM_COMPONENT& other_) const;
    bool operator != (const ST_MSSSUP_SYSTEM_COMPONENT& other_) const;

    void swap(ST_MSSSUP_SYSTEM_COMPONENT& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    std::wstring m_strName_;
    std::wstring m_strLCN_;
    uint32_t m_ulDisplay_;
    uint32_t m_ulIETMPM_;
    uint32_t m_ulIETMCM_;

};

inline void swap(ST_MSSSUP_SYSTEM_COMPONENT& a, ST_MSSSUP_SYSTEM_COMPONENT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SYSTEM_COMPONENT& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_TREE_REQUEST {
  public:
    USERIF_MSS_SYSTEM_TREE_REQUEST();

    USERIF_MSS_SYSTEM_TREE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_TREE_REQUEST (USERIF_MSS_SYSTEM_TREE_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_TREE_REQUEST& operator=(USERIF_MSS_SYSTEM_TREE_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_TREE_REQUEST& operator=(const USERIF_MSS_SYSTEM_TREE_REQUEST&) = default;
    USERIF_MSS_SYSTEM_TREE_REQUEST(const USERIF_MSS_SYSTEM_TREE_REQUEST&) = default;
    #else
    USERIF_MSS_SYSTEM_TREE_REQUEST(USERIF_MSS_SYSTEM_TREE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_TREE_REQUEST& operator=(USERIF_MSS_SYSTEM_TREE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_TREE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_TREE_REQUEST& other_) const;

    void swap(USERIF_MSS_SYSTEM_TREE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SYSTEM_TREE_REQUEST& a, USERIF_MSS_SYSTEM_TREE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_TREE_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SYSTEM_COMPONENT >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SYSTEM_COMPONENT >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SYSTEM_TREE_RESULT {
  public:
    MSSSUP_USE_SYSTEM_TREE_RESULT();

    MSSSUP_USE_SYSTEM_TREE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT, 1000L >& seqSystemTree);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SYSTEM_TREE_RESULT (MSSSUP_USE_SYSTEM_TREE_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_TREE_RESULT& operator=(MSSSUP_USE_SYSTEM_TREE_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_TREE_RESULT& operator=(const MSSSUP_USE_SYSTEM_TREE_RESULT&) = default;
    MSSSUP_USE_SYSTEM_TREE_RESULT(const MSSSUP_USE_SYSTEM_TREE_RESULT&) = default;
    #else
    MSSSUP_USE_SYSTEM_TREE_RESULT(MSSSUP_USE_SYSTEM_TREE_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SYSTEM_TREE_RESULT& operator=(MSSSUP_USE_SYSTEM_TREE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT, 1000L >& seqSystemTree() OMG_NOEXCEPT {
        return m_seqSystemTree_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT, 1000L >& seqSystemTree() const OMG_NOEXCEPT {
        return m_seqSystemTree_;
    }

    void seqSystemTree(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT, 1000L >& value) {
        m_seqSystemTree_ = value;
    }

    void seqSystemTree(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT, 1000L >&& value) {
        m_seqSystemTree_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SYSTEM_TREE_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SYSTEM_TREE_RESULT& other_) const;

    void swap(MSSSUP_USE_SYSTEM_TREE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT, 1000L > m_seqSystemTree_;

};

inline void swap(MSSSUP_USE_SYSTEM_TREE_RESULT& a, MSSSUP_USE_SYSTEM_TREE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SYSTEM_TREE_RESULT& sample);

class NDDSUSERDllExport ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM {
  public:
    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM();

    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM(uint32_t ulID,const std::wstring& strContent);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM (ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& operator=(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& operator=(const ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM(const ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM&) = default;
    #else
    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& operator=(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    std::wstring& strContent() OMG_NOEXCEPT {
        return m_strContent_;
    }

    const std::wstring& strContent() const OMG_NOEXCEPT {
        return m_strContent_;
    }

    void strContent(const std::wstring& value) {
        m_strContent_ = value;
    }

    void strContent(std::wstring&& value) {
        m_strContent_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& other_) const;
    bool operator != (const ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& other_) const;

    void swap(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    std::wstring m_strContent_;

};

inline void swap(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& a, ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& sample);

class NDDSUSERDllExport ST_MSSSUP_SYSTEM_COMPONENT_PART {
  public:
    ST_MSSSUP_SYSTEM_COMPONENT_PART();

    ST_MSSSUP_SYSTEM_COMPONENT_PART(uint32_t ulID,const std::wstring& strName,const std::wstring& strSN,const std::wstring& strPN,const std::wstring& strUnit);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SYSTEM_COMPONENT_PART (ST_MSSSUP_SYSTEM_COMPONENT_PART&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_PART& operator=(ST_MSSSUP_SYSTEM_COMPONENT_PART&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_PART& operator=(const ST_MSSSUP_SYSTEM_COMPONENT_PART&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_PART(const ST_MSSSUP_SYSTEM_COMPONENT_PART&) = default;
    #else
    ST_MSSSUP_SYSTEM_COMPONENT_PART(ST_MSSSUP_SYSTEM_COMPONENT_PART&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SYSTEM_COMPONENT_PART& operator=(ST_MSSSUP_SYSTEM_COMPONENT_PART&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    std::wstring& strName() OMG_NOEXCEPT {
        return m_strName_;
    }

    const std::wstring& strName() const OMG_NOEXCEPT {
        return m_strName_;
    }

    void strName(const std::wstring& value) {
        m_strName_ = value;
    }

    void strName(std::wstring&& value) {
        m_strName_ = std::move(value);
    }
    std::wstring& strSN() OMG_NOEXCEPT {
        return m_strSN_;
    }

    const std::wstring& strSN() const OMG_NOEXCEPT {
        return m_strSN_;
    }

    void strSN(const std::wstring& value) {
        m_strSN_ = value;
    }

    void strSN(std::wstring&& value) {
        m_strSN_ = std::move(value);
    }
    std::wstring& strPN() OMG_NOEXCEPT {
        return m_strPN_;
    }

    const std::wstring& strPN() const OMG_NOEXCEPT {
        return m_strPN_;
    }

    void strPN(const std::wstring& value) {
        m_strPN_ = value;
    }

    void strPN(std::wstring&& value) {
        m_strPN_ = std::move(value);
    }
    std::wstring& strUnit() OMG_NOEXCEPT {
        return m_strUnit_;
    }

    const std::wstring& strUnit() const OMG_NOEXCEPT {
        return m_strUnit_;
    }

    void strUnit(const std::wstring& value) {
        m_strUnit_ = value;
    }

    void strUnit(std::wstring&& value) {
        m_strUnit_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_SYSTEM_COMPONENT_PART& other_) const;
    bool operator != (const ST_MSSSUP_SYSTEM_COMPONENT_PART& other_) const;

    void swap(ST_MSSSUP_SYSTEM_COMPONENT_PART& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    std::wstring m_strName_;
    std::wstring m_strSN_;
    std::wstring m_strPN_;
    std::wstring m_strUnit_;

};

inline void swap(ST_MSSSUP_SYSTEM_COMPONENT_PART& a, ST_MSSSUP_SYSTEM_COMPONENT_PART& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SYSTEM_COMPONENT_PART& sample);

class NDDSUSERDllExport ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY {
  public:
    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY();

    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY(const ST_MSSSUP_SYSTEM_COMPONENT_PART& stPart,uint32_t ulQuantity);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY (ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& operator=(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& operator=(const ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY(const ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY&) = default;
    #else
    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& operator=(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSSSUP_SYSTEM_COMPONENT_PART& stPart() OMG_NOEXCEPT {
        return m_stPart_;
    }

    const ST_MSSSUP_SYSTEM_COMPONENT_PART& stPart() const OMG_NOEXCEPT {
        return m_stPart_;
    }

    void stPart(const ST_MSSSUP_SYSTEM_COMPONENT_PART& value) {
        m_stPart_ = value;
    }

    void stPart(ST_MSSSUP_SYSTEM_COMPONENT_PART&& value) {
        m_stPart_ = std::move(value);
    }
    uint32_t& ulQuantity() OMG_NOEXCEPT {
        return m_ulQuantity_;
    }

    const uint32_t& ulQuantity() const OMG_NOEXCEPT {
        return m_ulQuantity_;
    }

    void ulQuantity(uint32_t value) {
        m_ulQuantity_ = value;
    }

    bool operator == (const ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& other_) const;
    bool operator != (const ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& other_) const;

    void swap(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& other_) OMG_NOEXCEPT ;

  private:

    ST_MSSSUP_SYSTEM_COMPONENT_PART m_stPart_;
    uint32_t m_ulQuantity_;

};

inline void swap(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& a, ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST();

    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST (USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& operator=(const USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST(const USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulID_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& a, USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM >;
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SYSTEM_COMPONENT_PART >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SYSTEM_COMPONENT_PART >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SYSTEM_COMPONENT_INFO {
  public:
    MSSSUP_USE_SYSTEM_COMPONENT_INFO();

    MSSSUP_USE_SYSTEM_COMPONENT_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulID,const std::wstring& strPN,const std::wstring& strURL,const std::wstring& strNameKr,const std::wstring& strNameEng,const std::wstring& strLCN,const std::wstring& strClassification,uint64_t ullPrice,const std::wstring& strUI,const std::wstring& strSN,const std::wstring& strProducer,const std::wstring& strCage,const std::wstring& strAC,const std::wstring& strSize,const std::wstring& strWeight,const std::wstring& strDescription,const std::wstring& strFunction,uint32_t ulIProperInventory,const std::wstring& strSmr,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& seqMaintenanceRepairItems,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& seqPreventionRepairItems,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART, 400L >& seqRepairParts);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SYSTEM_COMPONENT_INFO (MSSSUP_USE_SYSTEM_COMPONENT_INFO&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_INFO& operator=(MSSSUP_USE_SYSTEM_COMPONENT_INFO&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_INFO& operator=(const MSSSUP_USE_SYSTEM_COMPONENT_INFO&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_INFO(const MSSSUP_USE_SYSTEM_COMPONENT_INFO&) = default;
    #else
    MSSSUP_USE_SYSTEM_COMPONENT_INFO(MSSSUP_USE_SYSTEM_COMPONENT_INFO&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SYSTEM_COMPONENT_INFO& operator=(MSSSUP_USE_SYSTEM_COMPONENT_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    std::wstring& strPN() OMG_NOEXCEPT {
        return m_strPN_;
    }

    const std::wstring& strPN() const OMG_NOEXCEPT {
        return m_strPN_;
    }

    void strPN(const std::wstring& value) {
        m_strPN_ = value;
    }

    void strPN(std::wstring&& value) {
        m_strPN_ = std::move(value);
    }
    std::wstring& strURL() OMG_NOEXCEPT {
        return m_strURL_;
    }

    const std::wstring& strURL() const OMG_NOEXCEPT {
        return m_strURL_;
    }

    void strURL(const std::wstring& value) {
        m_strURL_ = value;
    }

    void strURL(std::wstring&& value) {
        m_strURL_ = std::move(value);
    }
    std::wstring& strNameKr() OMG_NOEXCEPT {
        return m_strNameKr_;
    }

    const std::wstring& strNameKr() const OMG_NOEXCEPT {
        return m_strNameKr_;
    }

    void strNameKr(const std::wstring& value) {
        m_strNameKr_ = value;
    }

    void strNameKr(std::wstring&& value) {
        m_strNameKr_ = std::move(value);
    }
    std::wstring& strNameEng() OMG_NOEXCEPT {
        return m_strNameEng_;
    }

    const std::wstring& strNameEng() const OMG_NOEXCEPT {
        return m_strNameEng_;
    }

    void strNameEng(const std::wstring& value) {
        m_strNameEng_ = value;
    }

    void strNameEng(std::wstring&& value) {
        m_strNameEng_ = std::move(value);
    }
    std::wstring& strLCN() OMG_NOEXCEPT {
        return m_strLCN_;
    }

    const std::wstring& strLCN() const OMG_NOEXCEPT {
        return m_strLCN_;
    }

    void strLCN(const std::wstring& value) {
        m_strLCN_ = value;
    }

    void strLCN(std::wstring&& value) {
        m_strLCN_ = std::move(value);
    }
    std::wstring& strClassification() OMG_NOEXCEPT {
        return m_strClassification_;
    }

    const std::wstring& strClassification() const OMG_NOEXCEPT {
        return m_strClassification_;
    }

    void strClassification(const std::wstring& value) {
        m_strClassification_ = value;
    }

    void strClassification(std::wstring&& value) {
        m_strClassification_ = std::move(value);
    }
    uint64_t& ullPrice() OMG_NOEXCEPT {
        return m_ullPrice_;
    }

    const uint64_t& ullPrice() const OMG_NOEXCEPT {
        return m_ullPrice_;
    }

    void ullPrice(uint64_t value) {
        m_ullPrice_ = value;
    }

    std::wstring& strUI() OMG_NOEXCEPT {
        return m_strUI_;
    }

    const std::wstring& strUI() const OMG_NOEXCEPT {
        return m_strUI_;
    }

    void strUI(const std::wstring& value) {
        m_strUI_ = value;
    }

    void strUI(std::wstring&& value) {
        m_strUI_ = std::move(value);
    }
    std::wstring& strSN() OMG_NOEXCEPT {
        return m_strSN_;
    }

    const std::wstring& strSN() const OMG_NOEXCEPT {
        return m_strSN_;
    }

    void strSN(const std::wstring& value) {
        m_strSN_ = value;
    }

    void strSN(std::wstring&& value) {
        m_strSN_ = std::move(value);
    }
    std::wstring& strProducer() OMG_NOEXCEPT {
        return m_strProducer_;
    }

    const std::wstring& strProducer() const OMG_NOEXCEPT {
        return m_strProducer_;
    }

    void strProducer(const std::wstring& value) {
        m_strProducer_ = value;
    }

    void strProducer(std::wstring&& value) {
        m_strProducer_ = std::move(value);
    }
    std::wstring& strCage() OMG_NOEXCEPT {
        return m_strCage_;
    }

    const std::wstring& strCage() const OMG_NOEXCEPT {
        return m_strCage_;
    }

    void strCage(const std::wstring& value) {
        m_strCage_ = value;
    }

    void strCage(std::wstring&& value) {
        m_strCage_ = std::move(value);
    }
    std::wstring& strAC() OMG_NOEXCEPT {
        return m_strAC_;
    }

    const std::wstring& strAC() const OMG_NOEXCEPT {
        return m_strAC_;
    }

    void strAC(const std::wstring& value) {
        m_strAC_ = value;
    }

    void strAC(std::wstring&& value) {
        m_strAC_ = std::move(value);
    }
    std::wstring& strSize() OMG_NOEXCEPT {
        return m_strSize_;
    }

    const std::wstring& strSize() const OMG_NOEXCEPT {
        return m_strSize_;
    }

    void strSize(const std::wstring& value) {
        m_strSize_ = value;
    }

    void strSize(std::wstring&& value) {
        m_strSize_ = std::move(value);
    }
    std::wstring& strWeight() OMG_NOEXCEPT {
        return m_strWeight_;
    }

    const std::wstring& strWeight() const OMG_NOEXCEPT {
        return m_strWeight_;
    }

    void strWeight(const std::wstring& value) {
        m_strWeight_ = value;
    }

    void strWeight(std::wstring&& value) {
        m_strWeight_ = std::move(value);
    }
    std::wstring& strDescription() OMG_NOEXCEPT {
        return m_strDescription_;
    }

    const std::wstring& strDescription() const OMG_NOEXCEPT {
        return m_strDescription_;
    }

    void strDescription(const std::wstring& value) {
        m_strDescription_ = value;
    }

    void strDescription(std::wstring&& value) {
        m_strDescription_ = std::move(value);
    }
    std::wstring& strFunction() OMG_NOEXCEPT {
        return m_strFunction_;
    }

    const std::wstring& strFunction() const OMG_NOEXCEPT {
        return m_strFunction_;
    }

    void strFunction(const std::wstring& value) {
        m_strFunction_ = value;
    }

    void strFunction(std::wstring&& value) {
        m_strFunction_ = std::move(value);
    }
    uint32_t& ulIProperInventory() OMG_NOEXCEPT {
        return m_ulIProperInventory_;
    }

    const uint32_t& ulIProperInventory() const OMG_NOEXCEPT {
        return m_ulIProperInventory_;
    }

    void ulIProperInventory(uint32_t value) {
        m_ulIProperInventory_ = value;
    }

    std::wstring& strSmr() OMG_NOEXCEPT {
        return m_strSmr_;
    }

    const std::wstring& strSmr() const OMG_NOEXCEPT {
        return m_strSmr_;
    }

    void strSmr(const std::wstring& value) {
        m_strSmr_ = value;
    }

    void strSmr(std::wstring&& value) {
        m_strSmr_ = std::move(value);
    }
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& seqMaintenanceRepairItems() OMG_NOEXCEPT {
        return m_seqMaintenanceRepairItems_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& seqMaintenanceRepairItems() const OMG_NOEXCEPT {
        return m_seqMaintenanceRepairItems_;
    }

    void seqMaintenanceRepairItems(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& value) {
        m_seqMaintenanceRepairItems_ = value;
    }

    void seqMaintenanceRepairItems(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >&& value) {
        m_seqMaintenanceRepairItems_ = std::move(value);
    }
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& seqPreventionRepairItems() OMG_NOEXCEPT {
        return m_seqPreventionRepairItems_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& seqPreventionRepairItems() const OMG_NOEXCEPT {
        return m_seqPreventionRepairItems_;
    }

    void seqPreventionRepairItems(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >& value) {
        m_seqPreventionRepairItems_ = value;
    }

    void seqPreventionRepairItems(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L >&& value) {
        m_seqPreventionRepairItems_ = std::move(value);
    }
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART, 400L >& seqRepairParts() OMG_NOEXCEPT {
        return m_seqRepairParts_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART, 400L >& seqRepairParts() const OMG_NOEXCEPT {
        return m_seqRepairParts_;
    }

    void seqRepairParts(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART, 400L >& value) {
        m_seqRepairParts_ = value;
    }

    void seqRepairParts(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART, 400L >&& value) {
        m_seqRepairParts_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SYSTEM_COMPONENT_INFO& other_) const;
    bool operator != (const MSSSUP_USE_SYSTEM_COMPONENT_INFO& other_) const;

    void swap(MSSSUP_USE_SYSTEM_COMPONENT_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulID_;
    std::wstring m_strPN_;
    std::wstring m_strURL_;
    std::wstring m_strNameKr_;
    std::wstring m_strNameEng_;
    std::wstring m_strLCN_;
    std::wstring m_strClassification_;
    uint64_t m_ullPrice_;
    std::wstring m_strUI_;
    std::wstring m_strSN_;
    std::wstring m_strProducer_;
    std::wstring m_strCage_;
    std::wstring m_strAC_;
    std::wstring m_strSize_;
    std::wstring m_strWeight_;
    std::wstring m_strDescription_;
    std::wstring m_strFunction_;
    uint32_t m_ulIProperInventory_;
    std::wstring m_strSmr_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L > m_seqMaintenanceRepairItems_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM, 150L > m_seqPreventionRepairItems_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART, 400L > m_seqRepairParts_;

};

inline void swap(MSSSUP_USE_SYSTEM_COMPONENT_INFO& a, MSSSUP_USE_SYSTEM_COMPONENT_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SYSTEM_COMPONENT_INFO& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY >;
#endif
class NDDSUSERDllExport ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN {
  public:
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN();

    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN(uint32_t ulID,uint32_t ulSystemComponentID,const std::wstring& strSystemComponentName,const std::wstring& strRepairItem,uint16_t unCycle,uint32_t ulStartDate,uint32_t ulEndDate,uint16_t unPersonnel,uint32_t ulTime,const std::wstring& strManager,const std::wstring& strInspecter,const std::wstring& strContent,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN (ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&&) = default;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& operator=(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&&) = default;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& operator=(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&) = default;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&) = default;
    #else
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& operator=(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    std::wstring& strSystemComponentName() OMG_NOEXCEPT {
        return m_strSystemComponentName_;
    }

    const std::wstring& strSystemComponentName() const OMG_NOEXCEPT {
        return m_strSystemComponentName_;
    }

    void strSystemComponentName(const std::wstring& value) {
        m_strSystemComponentName_ = value;
    }

    void strSystemComponentName(std::wstring&& value) {
        m_strSystemComponentName_ = std::move(value);
    }
    std::wstring& strRepairItem() OMG_NOEXCEPT {
        return m_strRepairItem_;
    }

    const std::wstring& strRepairItem() const OMG_NOEXCEPT {
        return m_strRepairItem_;
    }

    void strRepairItem(const std::wstring& value) {
        m_strRepairItem_ = value;
    }

    void strRepairItem(std::wstring&& value) {
        m_strRepairItem_ = std::move(value);
    }
    uint16_t& unCycle() OMG_NOEXCEPT {
        return m_unCycle_;
    }

    const uint16_t& unCycle() const OMG_NOEXCEPT {
        return m_unCycle_;
    }

    void unCycle(uint16_t value) {
        m_unCycle_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    uint16_t& unPersonnel() OMG_NOEXCEPT {
        return m_unPersonnel_;
    }

    const uint16_t& unPersonnel() const OMG_NOEXCEPT {
        return m_unPersonnel_;
    }

    void unPersonnel(uint16_t value) {
        m_unPersonnel_ = value;
    }

    uint32_t& ulTime() OMG_NOEXCEPT {
        return m_ulTime_;
    }

    const uint32_t& ulTime() const OMG_NOEXCEPT {
        return m_ulTime_;
    }

    void ulTime(uint32_t value) {
        m_ulTime_ = value;
    }

    std::wstring& strManager() OMG_NOEXCEPT {
        return m_strManager_;
    }

    const std::wstring& strManager() const OMG_NOEXCEPT {
        return m_strManager_;
    }

    void strManager(const std::wstring& value) {
        m_strManager_ = value;
    }

    void strManager(std::wstring&& value) {
        m_strManager_ = std::move(value);
    }
    std::wstring& strInspecter() OMG_NOEXCEPT {
        return m_strInspecter_;
    }

    const std::wstring& strInspecter() const OMG_NOEXCEPT {
        return m_strInspecter_;
    }

    void strInspecter(const std::wstring& value) {
        m_strInspecter_ = value;
    }

    void strInspecter(std::wstring&& value) {
        m_strInspecter_ = std::move(value);
    }
    std::wstring& strContent() OMG_NOEXCEPT {
        return m_strContent_;
    }

    const std::wstring& strContent() const OMG_NOEXCEPT {
        return m_strContent_;
    }

    void strContent(const std::wstring& value) {
        m_strContent_ = value;
    }

    void strContent(std::wstring&& value) {
        m_strContent_ = std::move(value);
    }
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts() OMG_NOEXCEPT {
        return m_seqParts_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts() const OMG_NOEXCEPT {
        return m_seqParts_;
    }

    void seqParts(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& value) {
        m_seqParts_ = value;
    }

    void seqParts(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >&& value) {
        m_seqParts_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& other_) const;
    bool operator != (const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& other_) const;

    void swap(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint32_t m_ulSystemComponentID_;
    std::wstring m_strSystemComponentName_;
    std::wstring m_strRepairItem_;
    uint16_t m_unCycle_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    uint16_t m_unPersonnel_;
    uint32_t m_ulTime_;
    std::wstring m_strManager_;
    std::wstring m_strInspecter_;
    std::wstring m_strContent_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L > m_seqParts_;

};

inline void swap(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& a, ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulStartDate,uint32_t ulEndDate,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST (USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN >;
#endif
class NDDSUSERDllExport MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT {
  public:
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT();

    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulStartDate,uint32_t ulEndDate,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN, 100L >& seqPreventiveMaintenancePlans);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT (MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT&&) = default;
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& operator=(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT&&) = default;
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& operator=(const MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT&) = default;
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT(const MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT&) = default;
    #else
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& operator=(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN, 100L >& seqPreventiveMaintenancePlans() OMG_NOEXCEPT {
        return m_seqPreventiveMaintenancePlans_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN, 100L >& seqPreventiveMaintenancePlans() const OMG_NOEXCEPT {
        return m_seqPreventiveMaintenancePlans_;
    }

    void seqPreventiveMaintenancePlans(const ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN, 100L >& value) {
        m_seqPreventiveMaintenancePlans_ = value;
    }

    void seqPreventiveMaintenancePlans(::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN, 100L >&& value) {
        m_seqPreventiveMaintenancePlans_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& other_) const;

    void swap(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN, 100L > m_seqPreventiveMaintenancePlans_;

};

inline void swap(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& a, MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& stPreventiveMaintenancePlan);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE (USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& stPreventiveMaintenancePlan() OMG_NOEXCEPT {
        return m_stPreventiveMaintenancePlan_;
    }

    const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& stPreventiveMaintenancePlan() const OMG_NOEXCEPT {
        return m_stPreventiveMaintenancePlan_;
    }

    void stPreventiveMaintenancePlan(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& value) {
        m_stPreventiveMaintenancePlan_ = value;
    }

    void stPreventiveMaintenancePlan(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&& value) {
        m_stPreventiveMaintenancePlan_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN m_stPreventiveMaintenancePlan_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& stPreventiveMaintenancePlan);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE (USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& stPreventiveMaintenancePlan() OMG_NOEXCEPT {
        return m_stPreventiveMaintenancePlan_;
    }

    const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& stPreventiveMaintenancePlan() const OMG_NOEXCEPT {
        return m_stPreventiveMaintenancePlan_;
    }

    void stPreventiveMaintenancePlan(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& value) {
        m_stPreventiveMaintenancePlan_ = value;
    }

    void stPreventiveMaintenancePlan(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN&& value) {
        m_stPreventiveMaintenancePlan_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN m_stPreventiveMaintenancePlan_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& sample);

class NDDSUSERDllExport MSSSUP_USE_ALERT_MSG {
  public:
    MSSSUP_USE_ALERT_MSG();

    MSSSUP_USE_ALERT_MSG(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint16_t unCode,const std::wstring& strMessage);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_ALERT_MSG (MSSSUP_USE_ALERT_MSG&&) = default;
    MSSSUP_USE_ALERT_MSG& operator=(MSSSUP_USE_ALERT_MSG&&) = default;
    MSSSUP_USE_ALERT_MSG& operator=(const MSSSUP_USE_ALERT_MSG&) = default;
    MSSSUP_USE_ALERT_MSG(const MSSSUP_USE_ALERT_MSG&) = default;
    #else
    MSSSUP_USE_ALERT_MSG(MSSSUP_USE_ALERT_MSG&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_ALERT_MSG& operator=(MSSSUP_USE_ALERT_MSG&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint16_t& unCode() OMG_NOEXCEPT {
        return m_unCode_;
    }

    const uint16_t& unCode() const OMG_NOEXCEPT {
        return m_unCode_;
    }

    void unCode(uint16_t value) {
        m_unCode_ = value;
    }

    std::wstring& strMessage() OMG_NOEXCEPT {
        return m_strMessage_;
    }

    const std::wstring& strMessage() const OMG_NOEXCEPT {
        return m_strMessage_;
    }

    void strMessage(const std::wstring& value) {
        m_strMessage_ = value;
    }

    void strMessage(std::wstring&& value) {
        m_strMessage_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_ALERT_MSG& other_) const;
    bool operator != (const MSSSUP_USE_ALERT_MSG& other_) const;

    void swap(MSSSUP_USE_ALERT_MSG& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint16_t m_unCode_;
    std::wstring m_strMessage_;

};

inline void swap(MSSSUP_USE_ALERT_MSG& a, MSSSUP_USE_ALERT_MSG& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_ALERT_MSG& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE (USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE(const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulID_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& sample);

class NDDSUSERDllExport ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT {
  public:
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT();

    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT(uint32_t ulID,uint32_t ulPlanID,uint16_t unPersonnel,uint32_t ulDate,uint32_t ulTime,const std::wstring& strFDM,const std::wstring& strFDS,const std::wstring& strState,const std::wstring& strManager,const std::wstring& strInspector,const std::wstring& strContent,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT (ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&&) = default;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& operator=(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&&) = default;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& operator=(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&) = default;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&) = default;
    #else
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& operator=(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint32_t& ulPlanID() OMG_NOEXCEPT {
        return m_ulPlanID_;
    }

    const uint32_t& ulPlanID() const OMG_NOEXCEPT {
        return m_ulPlanID_;
    }

    void ulPlanID(uint32_t value) {
        m_ulPlanID_ = value;
    }

    uint16_t& unPersonnel() OMG_NOEXCEPT {
        return m_unPersonnel_;
    }

    const uint16_t& unPersonnel() const OMG_NOEXCEPT {
        return m_unPersonnel_;
    }

    void unPersonnel(uint16_t value) {
        m_unPersonnel_ = value;
    }

    uint32_t& ulDate() OMG_NOEXCEPT {
        return m_ulDate_;
    }

    const uint32_t& ulDate() const OMG_NOEXCEPT {
        return m_ulDate_;
    }

    void ulDate(uint32_t value) {
        m_ulDate_ = value;
    }

    uint32_t& ulTime() OMG_NOEXCEPT {
        return m_ulTime_;
    }

    const uint32_t& ulTime() const OMG_NOEXCEPT {
        return m_ulTime_;
    }

    void ulTime(uint32_t value) {
        m_ulTime_ = value;
    }

    std::wstring& strFDM() OMG_NOEXCEPT {
        return m_strFDM_;
    }

    const std::wstring& strFDM() const OMG_NOEXCEPT {
        return m_strFDM_;
    }

    void strFDM(const std::wstring& value) {
        m_strFDM_ = value;
    }

    void strFDM(std::wstring&& value) {
        m_strFDM_ = std::move(value);
    }
    std::wstring& strFDS() OMG_NOEXCEPT {
        return m_strFDS_;
    }

    const std::wstring& strFDS() const OMG_NOEXCEPT {
        return m_strFDS_;
    }

    void strFDS(const std::wstring& value) {
        m_strFDS_ = value;
    }

    void strFDS(std::wstring&& value) {
        m_strFDS_ = std::move(value);
    }
    std::wstring& strState() OMG_NOEXCEPT {
        return m_strState_;
    }

    const std::wstring& strState() const OMG_NOEXCEPT {
        return m_strState_;
    }

    void strState(const std::wstring& value) {
        m_strState_ = value;
    }

    void strState(std::wstring&& value) {
        m_strState_ = std::move(value);
    }
    std::wstring& strManager() OMG_NOEXCEPT {
        return m_strManager_;
    }

    const std::wstring& strManager() const OMG_NOEXCEPT {
        return m_strManager_;
    }

    void strManager(const std::wstring& value) {
        m_strManager_ = value;
    }

    void strManager(std::wstring&& value) {
        m_strManager_ = std::move(value);
    }
    std::wstring& strInspector() OMG_NOEXCEPT {
        return m_strInspector_;
    }

    const std::wstring& strInspector() const OMG_NOEXCEPT {
        return m_strInspector_;
    }

    void strInspector(const std::wstring& value) {
        m_strInspector_ = value;
    }

    void strInspector(std::wstring&& value) {
        m_strInspector_ = std::move(value);
    }
    std::wstring& strContent() OMG_NOEXCEPT {
        return m_strContent_;
    }

    const std::wstring& strContent() const OMG_NOEXCEPT {
        return m_strContent_;
    }

    void strContent(const std::wstring& value) {
        m_strContent_ = value;
    }

    void strContent(std::wstring&& value) {
        m_strContent_ = std::move(value);
    }
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts() OMG_NOEXCEPT {
        return m_seqParts_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts() const OMG_NOEXCEPT {
        return m_seqParts_;
    }

    void seqParts(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& value) {
        m_seqParts_ = value;
    }

    void seqParts(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >&& value) {
        m_seqParts_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& other_) const;
    bool operator != (const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& other_) const;

    void swap(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint32_t m_ulPlanID_;
    uint16_t m_unPersonnel_;
    uint32_t m_ulDate_;
    uint32_t m_ulTime_;
    std::wstring m_strFDM_;
    std::wstring m_strFDS_;
    std::wstring m_strState_;
    std::wstring m_strManager_;
    std::wstring m_strInspector_;
    std::wstring m_strContent_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L > m_seqParts_;

};

inline void swap(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& a, ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulStartDate,uint32_t ulEndDate,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST (USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT >;
#endif
class NDDSUSERDllExport MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT {
  public:
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT();

    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulStartDate,uint32_t ulEndDate,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT, 100L >& seqPreventiveMaintenanceResults);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT (MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT&&) = default;
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& operator=(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT&&) = default;
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& operator=(const MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT&) = default;
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT(const MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT&) = default;
    #else
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& operator=(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT, 100L >& seqPreventiveMaintenanceResults() OMG_NOEXCEPT {
        return m_seqPreventiveMaintenanceResults_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT, 100L >& seqPreventiveMaintenanceResults() const OMG_NOEXCEPT {
        return m_seqPreventiveMaintenanceResults_;
    }

    void seqPreventiveMaintenanceResults(const ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT, 100L >& value) {
        m_seqPreventiveMaintenanceResults_ = value;
    }

    void seqPreventiveMaintenanceResults(::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT, 100L >&& value) {
        m_seqPreventiveMaintenanceResults_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& other_) const;

    void swap(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT, 100L > m_seqPreventiveMaintenanceResults_;

};

inline void swap(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& a, MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& stPreventiveMaintenanceResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE (USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& stPreventiveMaintenanceResult() OMG_NOEXCEPT {
        return m_stPreventiveMaintenanceResult_;
    }

    const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& stPreventiveMaintenanceResult() const OMG_NOEXCEPT {
        return m_stPreventiveMaintenanceResult_;
    }

    void stPreventiveMaintenanceResult(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& value) {
        m_stPreventiveMaintenanceResult_ = value;
    }

    void stPreventiveMaintenanceResult(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&& value) {
        m_stPreventiveMaintenanceResult_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT m_stPreventiveMaintenanceResult_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& stPreventiveMaintenanceResult);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE (USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& stPreventiveMaintenanceResult() OMG_NOEXCEPT {
        return m_stPreventiveMaintenanceResult_;
    }

    const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& stPreventiveMaintenanceResult() const OMG_NOEXCEPT {
        return m_stPreventiveMaintenanceResult_;
    }

    void stPreventiveMaintenanceResult(const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& value) {
        m_stPreventiveMaintenanceResult_ = value;
    }

    void stPreventiveMaintenanceResult(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT&& value) {
        m_stPreventiveMaintenanceResult_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT m_stPreventiveMaintenanceResult_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& sample);

class NDDSUSERDllExport USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE {
  public:
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE();

    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE (USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE&&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& operator=(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE&) = default;
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE(const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE&) = default;
    #else
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& operator=(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    bool operator == (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& other_) const;
    bool operator != (const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& other_) const;

    void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulID_;

};

inline void swap(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& a, USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& sample);

class NDDSUSERDllExport ST_MSSSUP_MAINTENANCE_HISTORY {
  public:
    ST_MSSSUP_MAINTENANCE_HISTORY();

    ST_MSSSUP_MAINTENANCE_HISTORY(uint32_t ulID,uint32_t ulOccurrenceDate,uint32_t ulActionDate,uint32_t ulTime,uint32_t ulSystemComponentID,uint32_t ulStartDate,uint32_t ulEndDate,const std::wstring& strLCN,const std::wstring& strNameKR,const std::wstring& strPN,const std::wstring& strSN,const std::wstring& strAC,int32_t lStock,const std::wstring& strFDM,const std::wstring& strFDS,const std::wstring& strState,const std::wstring& strItem,uint16_t unCycle,uint16_t unPersonnel,const std::wstring& strManager,const std::wstring& strInspector,const std::wstring& strContent,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_MAINTENANCE_HISTORY (ST_MSSSUP_MAINTENANCE_HISTORY&&) = default;
    ST_MSSSUP_MAINTENANCE_HISTORY& operator=(ST_MSSSUP_MAINTENANCE_HISTORY&&) = default;
    ST_MSSSUP_MAINTENANCE_HISTORY& operator=(const ST_MSSSUP_MAINTENANCE_HISTORY&) = default;
    ST_MSSSUP_MAINTENANCE_HISTORY(const ST_MSSSUP_MAINTENANCE_HISTORY&) = default;
    #else
    ST_MSSSUP_MAINTENANCE_HISTORY(ST_MSSSUP_MAINTENANCE_HISTORY&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_MAINTENANCE_HISTORY& operator=(ST_MSSSUP_MAINTENANCE_HISTORY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint32_t& ulOccurrenceDate() OMG_NOEXCEPT {
        return m_ulOccurrenceDate_;
    }

    const uint32_t& ulOccurrenceDate() const OMG_NOEXCEPT {
        return m_ulOccurrenceDate_;
    }

    void ulOccurrenceDate(uint32_t value) {
        m_ulOccurrenceDate_ = value;
    }

    uint32_t& ulActionDate() OMG_NOEXCEPT {
        return m_ulActionDate_;
    }

    const uint32_t& ulActionDate() const OMG_NOEXCEPT {
        return m_ulActionDate_;
    }

    void ulActionDate(uint32_t value) {
        m_ulActionDate_ = value;
    }

    uint32_t& ulTime() OMG_NOEXCEPT {
        return m_ulTime_;
    }

    const uint32_t& ulTime() const OMG_NOEXCEPT {
        return m_ulTime_;
    }

    void ulTime(uint32_t value) {
        m_ulTime_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    std::wstring& strLCN() OMG_NOEXCEPT {
        return m_strLCN_;
    }

    const std::wstring& strLCN() const OMG_NOEXCEPT {
        return m_strLCN_;
    }

    void strLCN(const std::wstring& value) {
        m_strLCN_ = value;
    }

    void strLCN(std::wstring&& value) {
        m_strLCN_ = std::move(value);
    }
    std::wstring& strNameKR() OMG_NOEXCEPT {
        return m_strNameKR_;
    }

    const std::wstring& strNameKR() const OMG_NOEXCEPT {
        return m_strNameKR_;
    }

    void strNameKR(const std::wstring& value) {
        m_strNameKR_ = value;
    }

    void strNameKR(std::wstring&& value) {
        m_strNameKR_ = std::move(value);
    }
    std::wstring& strPN() OMG_NOEXCEPT {
        return m_strPN_;
    }

    const std::wstring& strPN() const OMG_NOEXCEPT {
        return m_strPN_;
    }

    void strPN(const std::wstring& value) {
        m_strPN_ = value;
    }

    void strPN(std::wstring&& value) {
        m_strPN_ = std::move(value);
    }
    std::wstring& strSN() OMG_NOEXCEPT {
        return m_strSN_;
    }

    const std::wstring& strSN() const OMG_NOEXCEPT {
        return m_strSN_;
    }

    void strSN(const std::wstring& value) {
        m_strSN_ = value;
    }

    void strSN(std::wstring&& value) {
        m_strSN_ = std::move(value);
    }
    std::wstring& strAC() OMG_NOEXCEPT {
        return m_strAC_;
    }

    const std::wstring& strAC() const OMG_NOEXCEPT {
        return m_strAC_;
    }

    void strAC(const std::wstring& value) {
        m_strAC_ = value;
    }

    void strAC(std::wstring&& value) {
        m_strAC_ = std::move(value);
    }
    int32_t& lStock() OMG_NOEXCEPT {
        return m_lStock_;
    }

    const int32_t& lStock() const OMG_NOEXCEPT {
        return m_lStock_;
    }

    void lStock(int32_t value) {
        m_lStock_ = value;
    }

    std::wstring& strFDM() OMG_NOEXCEPT {
        return m_strFDM_;
    }

    const std::wstring& strFDM() const OMG_NOEXCEPT {
        return m_strFDM_;
    }

    void strFDM(const std::wstring& value) {
        m_strFDM_ = value;
    }

    void strFDM(std::wstring&& value) {
        m_strFDM_ = std::move(value);
    }
    std::wstring& strFDS() OMG_NOEXCEPT {
        return m_strFDS_;
    }

    const std::wstring& strFDS() const OMG_NOEXCEPT {
        return m_strFDS_;
    }

    void strFDS(const std::wstring& value) {
        m_strFDS_ = value;
    }

    void strFDS(std::wstring&& value) {
        m_strFDS_ = std::move(value);
    }
    std::wstring& strState() OMG_NOEXCEPT {
        return m_strState_;
    }

    const std::wstring& strState() const OMG_NOEXCEPT {
        return m_strState_;
    }

    void strState(const std::wstring& value) {
        m_strState_ = value;
    }

    void strState(std::wstring&& value) {
        m_strState_ = std::move(value);
    }
    std::wstring& strItem() OMG_NOEXCEPT {
        return m_strItem_;
    }

    const std::wstring& strItem() const OMG_NOEXCEPT {
        return m_strItem_;
    }

    void strItem(const std::wstring& value) {
        m_strItem_ = value;
    }

    void strItem(std::wstring&& value) {
        m_strItem_ = std::move(value);
    }
    uint16_t& unCycle() OMG_NOEXCEPT {
        return m_unCycle_;
    }

    const uint16_t& unCycle() const OMG_NOEXCEPT {
        return m_unCycle_;
    }

    void unCycle(uint16_t value) {
        m_unCycle_ = value;
    }

    uint16_t& unPersonnel() OMG_NOEXCEPT {
        return m_unPersonnel_;
    }

    const uint16_t& unPersonnel() const OMG_NOEXCEPT {
        return m_unPersonnel_;
    }

    void unPersonnel(uint16_t value) {
        m_unPersonnel_ = value;
    }

    std::wstring& strManager() OMG_NOEXCEPT {
        return m_strManager_;
    }

    const std::wstring& strManager() const OMG_NOEXCEPT {
        return m_strManager_;
    }

    void strManager(const std::wstring& value) {
        m_strManager_ = value;
    }

    void strManager(std::wstring&& value) {
        m_strManager_ = std::move(value);
    }
    std::wstring& strInspector() OMG_NOEXCEPT {
        return m_strInspector_;
    }

    const std::wstring& strInspector() const OMG_NOEXCEPT {
        return m_strInspector_;
    }

    void strInspector(const std::wstring& value) {
        m_strInspector_ = value;
    }

    void strInspector(std::wstring&& value) {
        m_strInspector_ = std::move(value);
    }
    std::wstring& strContent() OMG_NOEXCEPT {
        return m_strContent_;
    }

    const std::wstring& strContent() const OMG_NOEXCEPT {
        return m_strContent_;
    }

    void strContent(const std::wstring& value) {
        m_strContent_ = value;
    }

    void strContent(std::wstring&& value) {
        m_strContent_ = std::move(value);
    }
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts() OMG_NOEXCEPT {
        return m_seqParts_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& seqParts() const OMG_NOEXCEPT {
        return m_seqParts_;
    }

    void seqParts(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >& value) {
        m_seqParts_ = value;
    }

    void seqParts(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L >&& value) {
        m_seqParts_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_MAINTENANCE_HISTORY& other_) const;
    bool operator != (const ST_MSSSUP_MAINTENANCE_HISTORY& other_) const;

    void swap(ST_MSSSUP_MAINTENANCE_HISTORY& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint32_t m_ulOccurrenceDate_;
    uint32_t m_ulActionDate_;
    uint32_t m_ulTime_;
    uint32_t m_ulSystemComponentID_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    std::wstring m_strLCN_;
    std::wstring m_strNameKR_;
    std::wstring m_strPN_;
    std::wstring m_strSN_;
    std::wstring m_strAC_;
    int32_t m_lStock_;
    std::wstring m_strFDM_;
    std::wstring m_strFDS_;
    std::wstring m_strState_;
    std::wstring m_strItem_;
    uint16_t m_unCycle_;
    uint16_t m_unPersonnel_;
    std::wstring m_strManager_;
    std::wstring m_strInspector_;
    std::wstring m_strContent_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY, 200L > m_seqParts_;

};

inline void swap(ST_MSSSUP_MAINTENANCE_HISTORY& a, ST_MSSSUP_MAINTENANCE_HISTORY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_MAINTENANCE_HISTORY& sample);

class NDDSUSERDllExport USERIF_MSS_MAINTENANCE_HISTORY_REQUEST {
  public:
    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST();

    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulStartDate,uint32_t ulEndDate,uint32_t ulNextKey,uint16_t unCategory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST (USERIF_MSS_MAINTENANCE_HISTORY_REQUEST&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& operator=(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& operator=(const USERIF_MSS_MAINTENANCE_HISTORY_REQUEST&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST(const USERIF_MSS_MAINTENANCE_HISTORY_REQUEST&) = default;
    #else
    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& operator=(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    uint16_t& unCategory() OMG_NOEXCEPT {
        return m_unCategory_;
    }

    const uint16_t& unCategory() const OMG_NOEXCEPT {
        return m_unCategory_;
    }

    void unCategory(uint16_t value) {
        m_unCategory_ = value;
    }

    bool operator == (const USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& other_) const;

    void swap(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    uint32_t m_ulNextKey_;
    uint16_t m_unCategory_;

};

inline void swap(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& a, USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_MAINTENANCE_HISTORY >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_MAINTENANCE_HISTORY >;
#endif
class NDDSUSERDllExport MSSSUP_USE_MAINTENANCE_HISTORY_RESULT {
  public:
    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT();

    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulStartDate,uint32_t ulEndDate,uint32_t ulNextKey,uint16_t unCategory,const ::rti::core::bounded_sequence< ST_MSSSUP_MAINTENANCE_HISTORY, 100L >& seqMaintenanceHistories);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT (MSSSUP_USE_MAINTENANCE_HISTORY_RESULT&&) = default;
    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& operator=(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT&&) = default;
    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& operator=(const MSSSUP_USE_MAINTENANCE_HISTORY_RESULT&) = default;
    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT(const MSSSUP_USE_MAINTENANCE_HISTORY_RESULT&) = default;
    #else
    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& operator=(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulStartDate() OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    const uint32_t& ulStartDate() const OMG_NOEXCEPT {
        return m_ulStartDate_;
    }

    void ulStartDate(uint32_t value) {
        m_ulStartDate_ = value;
    }

    uint32_t& ulEndDate() OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    const uint32_t& ulEndDate() const OMG_NOEXCEPT {
        return m_ulEndDate_;
    }

    void ulEndDate(uint32_t value) {
        m_ulEndDate_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    uint16_t& unCategory() OMG_NOEXCEPT {
        return m_unCategory_;
    }

    const uint16_t& unCategory() const OMG_NOEXCEPT {
        return m_unCategory_;
    }

    void unCategory(uint16_t value) {
        m_unCategory_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_MAINTENANCE_HISTORY, 100L >& seqMaintenanceHistories() OMG_NOEXCEPT {
        return m_seqMaintenanceHistories_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_MAINTENANCE_HISTORY, 100L >& seqMaintenanceHistories() const OMG_NOEXCEPT {
        return m_seqMaintenanceHistories_;
    }

    void seqMaintenanceHistories(const ::rti::core::bounded_sequence< ST_MSSSUP_MAINTENANCE_HISTORY, 100L >& value) {
        m_seqMaintenanceHistories_ = value;
    }

    void seqMaintenanceHistories(::rti::core::bounded_sequence< ST_MSSSUP_MAINTENANCE_HISTORY, 100L >&& value) {
        m_seqMaintenanceHistories_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& other_) const;

    void swap(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulStartDate_;
    uint32_t m_ulEndDate_;
    uint32_t m_ulNextKey_;
    uint16_t m_unCategory_;
    ::rti::core::bounded_sequence< ST_MSSSUP_MAINTENANCE_HISTORY, 100L > m_seqMaintenanceHistories_;

};

inline void swap(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& a, MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_MAINTENANCE_HISTORY_CREATE {
  public:
    USERIF_MSS_MAINTENANCE_HISTORY_CREATE();

    USERIF_MSS_MAINTENANCE_HISTORY_CREATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_MAINTENANCE_HISTORY& stMaintenanceHistory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_MAINTENANCE_HISTORY_CREATE (USERIF_MSS_MAINTENANCE_HISTORY_CREATE&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_CREATE& operator=(USERIF_MSS_MAINTENANCE_HISTORY_CREATE&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_CREATE& operator=(const USERIF_MSS_MAINTENANCE_HISTORY_CREATE&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_CREATE(const USERIF_MSS_MAINTENANCE_HISTORY_CREATE&) = default;
    #else
    USERIF_MSS_MAINTENANCE_HISTORY_CREATE(USERIF_MSS_MAINTENANCE_HISTORY_CREATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_MAINTENANCE_HISTORY_CREATE& operator=(USERIF_MSS_MAINTENANCE_HISTORY_CREATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_MAINTENANCE_HISTORY& stMaintenanceHistory() OMG_NOEXCEPT {
        return m_stMaintenanceHistory_;
    }

    const ST_MSSSUP_MAINTENANCE_HISTORY& stMaintenanceHistory() const OMG_NOEXCEPT {
        return m_stMaintenanceHistory_;
    }

    void stMaintenanceHistory(const ST_MSSSUP_MAINTENANCE_HISTORY& value) {
        m_stMaintenanceHistory_ = value;
    }

    void stMaintenanceHistory(ST_MSSSUP_MAINTENANCE_HISTORY&& value) {
        m_stMaintenanceHistory_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_MAINTENANCE_HISTORY_CREATE& other_) const;
    bool operator != (const USERIF_MSS_MAINTENANCE_HISTORY_CREATE& other_) const;

    void swap(USERIF_MSS_MAINTENANCE_HISTORY_CREATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_MAINTENANCE_HISTORY m_stMaintenanceHistory_;

};

inline void swap(USERIF_MSS_MAINTENANCE_HISTORY_CREATE& a, USERIF_MSS_MAINTENANCE_HISTORY_CREATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_MAINTENANCE_HISTORY_CREATE& sample);

class NDDSUSERDllExport USERIF_MSS_MAINTENANCE_HISTORY_UPDATE {
  public:
    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE();

    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_MAINTENANCE_HISTORY& stMaintenanceHistory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE (USERIF_MSS_MAINTENANCE_HISTORY_UPDATE&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& operator=(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& operator=(const USERIF_MSS_MAINTENANCE_HISTORY_UPDATE&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE(const USERIF_MSS_MAINTENANCE_HISTORY_UPDATE&) = default;
    #else
    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& operator=(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_MAINTENANCE_HISTORY& stMaintenanceHistory() OMG_NOEXCEPT {
        return m_stMaintenanceHistory_;
    }

    const ST_MSSSUP_MAINTENANCE_HISTORY& stMaintenanceHistory() const OMG_NOEXCEPT {
        return m_stMaintenanceHistory_;
    }

    void stMaintenanceHistory(const ST_MSSSUP_MAINTENANCE_HISTORY& value) {
        m_stMaintenanceHistory_ = value;
    }

    void stMaintenanceHistory(ST_MSSSUP_MAINTENANCE_HISTORY&& value) {
        m_stMaintenanceHistory_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& other_) const;
    bool operator != (const USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& other_) const;

    void swap(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_MAINTENANCE_HISTORY m_stMaintenanceHistory_;

};

inline void swap(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& a, USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& sample);

class NDDSUSERDllExport USERIF_MSS_MAINTENANCE_HISTORY_DELETE {
  public:
    USERIF_MSS_MAINTENANCE_HISTORY_DELETE();

    USERIF_MSS_MAINTENANCE_HISTORY_DELETE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_MAINTENANCE_HISTORY_DELETE (USERIF_MSS_MAINTENANCE_HISTORY_DELETE&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_DELETE& operator=(USERIF_MSS_MAINTENANCE_HISTORY_DELETE&&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_DELETE& operator=(const USERIF_MSS_MAINTENANCE_HISTORY_DELETE&) = default;
    USERIF_MSS_MAINTENANCE_HISTORY_DELETE(const USERIF_MSS_MAINTENANCE_HISTORY_DELETE&) = default;
    #else
    USERIF_MSS_MAINTENANCE_HISTORY_DELETE(USERIF_MSS_MAINTENANCE_HISTORY_DELETE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_MAINTENANCE_HISTORY_DELETE& operator=(USERIF_MSS_MAINTENANCE_HISTORY_DELETE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    bool operator == (const USERIF_MSS_MAINTENANCE_HISTORY_DELETE& other_) const;
    bool operator != (const USERIF_MSS_MAINTENANCE_HISTORY_DELETE& other_) const;

    void swap(USERIF_MSS_MAINTENANCE_HISTORY_DELETE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulID_;

};

inline void swap(USERIF_MSS_MAINTENANCE_HISTORY_DELETE& a, USERIF_MSS_MAINTENANCE_HISTORY_DELETE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_MAINTENANCE_HISTORY_DELETE& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST();

    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulSystemComponentID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST (USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& operator=(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulSystemComponentID_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& a, USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& sample);

class NDDSUSERDllExport MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO {
  public:
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO();

    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulSystemComponentID,int32_t lStock);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO (MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& operator=(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& operator=(const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO(const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO&) = default;
    #else
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& operator=(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    int32_t& lStock() OMG_NOEXCEPT {
        return m_lStock_;
    }

    const int32_t& lStock() const OMG_NOEXCEPT {
        return m_lStock_;
    }

    void lStock(int32_t value) {
        m_lStock_ = value;
    }

    bool operator == (const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& other_) const;
    bool operator != (const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& other_) const;

    void swap(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulSystemComponentID_;
    int32_t m_lStock_;

};

inline void swap(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& a, MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& sample);

class NDDSUSERDllExport ST_MSSSUP_SYSTEM_COMPONENT_STOCK {
  public:
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK();

    ST_MSSSUP_SYSTEM_COMPONENT_STOCK(uint32_t ulSystemComponentID,int32_t lStock);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK (ST_MSSSUP_SYSTEM_COMPONENT_STOCK&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK& operator=(ST_MSSSUP_SYSTEM_COMPONENT_STOCK&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK& operator=(const ST_MSSSUP_SYSTEM_COMPONENT_STOCK&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK(const ST_MSSSUP_SYSTEM_COMPONENT_STOCK&) = default;
    #else
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK(ST_MSSSUP_SYSTEM_COMPONENT_STOCK&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK& operator=(ST_MSSSUP_SYSTEM_COMPONENT_STOCK&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    int32_t& lStock() OMG_NOEXCEPT {
        return m_lStock_;
    }

    const int32_t& lStock() const OMG_NOEXCEPT {
        return m_lStock_;
    }

    void lStock(int32_t value) {
        m_lStock_ = value;
    }

    bool operator == (const ST_MSSSUP_SYSTEM_COMPONENT_STOCK& other_) const;
    bool operator != (const ST_MSSSUP_SYSTEM_COMPONENT_STOCK& other_) const;

    void swap(ST_MSSSUP_SYSTEM_COMPONENT_STOCK& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulSystemComponentID_;
    int32_t m_lStock_;

};

inline void swap(ST_MSSSUP_SYSTEM_COMPONENT_STOCK& a, ST_MSSSUP_SYSTEM_COMPONENT_STOCK& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SYSTEM_COMPONENT_STOCK& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST();

    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST (USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& operator=(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& a, USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SYSTEM_COMPONENT_STOCK >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SYSTEM_COMPONENT_STOCK >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT {
  public:
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT();

    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK, 100L >& seqSystemComponentStocks);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT (MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& operator=(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& operator=(const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT(const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT&) = default;
    #else
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& operator=(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK, 100L >& seqSystemComponentStocks() OMG_NOEXCEPT {
        return m_seqSystemComponentStocks_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK, 100L >& seqSystemComponentStocks() const OMG_NOEXCEPT {
        return m_seqSystemComponentStocks_;
    }

    void seqSystemComponentStocks(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK, 100L >& value) {
        m_seqSystemComponentStocks_ = value;
    }

    void seqSystemComponentStocks(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK, 100L >&& value) {
        m_seqSystemComponentStocks_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& other_) const;

    void swap(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK, 100L > m_seqSystemComponentStocks_;

};

inline void swap(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& a, MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& sample);

class NDDSUSERDllExport ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY {
  public:
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY();

    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY(uint32_t ulID,uint32_t ulSystemComponentID,uint32_t ulDate,uint32_t ulSupplyQuantity,uint32_t ulIssueQuantity,const std::wstring& strManager,const std::wstring& strInspector);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY (ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& operator=(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& operator=(const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY(const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&) = default;
    #else
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& operator=(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    uint32_t& ulDate() OMG_NOEXCEPT {
        return m_ulDate_;
    }

    const uint32_t& ulDate() const OMG_NOEXCEPT {
        return m_ulDate_;
    }

    void ulDate(uint32_t value) {
        m_ulDate_ = value;
    }

    uint32_t& ulSupplyQuantity() OMG_NOEXCEPT {
        return m_ulSupplyQuantity_;
    }

    const uint32_t& ulSupplyQuantity() const OMG_NOEXCEPT {
        return m_ulSupplyQuantity_;
    }

    void ulSupplyQuantity(uint32_t value) {
        m_ulSupplyQuantity_ = value;
    }

    uint32_t& ulIssueQuantity() OMG_NOEXCEPT {
        return m_ulIssueQuantity_;
    }

    const uint32_t& ulIssueQuantity() const OMG_NOEXCEPT {
        return m_ulIssueQuantity_;
    }

    void ulIssueQuantity(uint32_t value) {
        m_ulIssueQuantity_ = value;
    }

    std::wstring& strManager() OMG_NOEXCEPT {
        return m_strManager_;
    }

    const std::wstring& strManager() const OMG_NOEXCEPT {
        return m_strManager_;
    }

    void strManager(const std::wstring& value) {
        m_strManager_ = value;
    }

    void strManager(std::wstring&& value) {
        m_strManager_ = std::move(value);
    }
    std::wstring& strInspector() OMG_NOEXCEPT {
        return m_strInspector_;
    }

    const std::wstring& strInspector() const OMG_NOEXCEPT {
        return m_strInspector_;
    }

    void strInspector(const std::wstring& value) {
        m_strInspector_ = value;
    }

    void strInspector(std::wstring&& value) {
        m_strInspector_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& other_) const;
    bool operator != (const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& other_) const;

    void swap(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint32_t m_ulSystemComponentID_;
    uint32_t m_ulDate_;
    uint32_t m_ulSupplyQuantity_;
    uint32_t m_ulIssueQuantity_;
    std::wstring m_strManager_;
    std::wstring m_strInspector_;

};

inline void swap(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& a, ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST();

    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulSystemComponentID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST (USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& operator=(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulSystemComponentID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& a, USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT {
  public:
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT();

    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulSystemComponentID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY, 100L >& seqSystemComponentStockHistories);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT (MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& operator=(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& operator=(const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT(const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT&) = default;
    #else
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& operator=(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY, 100L >& seqSystemComponentStockHistories() OMG_NOEXCEPT {
        return m_seqSystemComponentStockHistories_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY, 100L >& seqSystemComponentStockHistories() const OMG_NOEXCEPT {
        return m_seqSystemComponentStockHistories_;
    }

    void seqSystemComponentStockHistories(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY, 100L >& value) {
        m_seqSystemComponentStockHistories_ = value;
    }

    void seqSystemComponentStockHistories(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY, 100L >&& value) {
        m_seqSystemComponentStockHistories_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& other_) const;

    void swap(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulSystemComponentID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY, 100L > m_seqSystemComponentStockHistories_;

};

inline void swap(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& a, MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE();

    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& stComponentStockHistory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE (USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& operator=(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& stComponentStockHistory() OMG_NOEXCEPT {
        return m_stComponentStockHistory_;
    }

    const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& stComponentStockHistory() const OMG_NOEXCEPT {
        return m_stComponentStockHistory_;
    }

    void stComponentStockHistory(const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& value) {
        m_stComponentStockHistory_ = value;
    }

    void stComponentStockHistory(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&& value) {
        m_stComponentStockHistory_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY m_stComponentStockHistory_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& a, USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE();

    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& stComponentStockHistory);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE (USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& operator=(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& stComponentStockHistory() OMG_NOEXCEPT {
        return m_stComponentStockHistory_;
    }

    const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& stComponentStockHistory() const OMG_NOEXCEPT {
        return m_stComponentStockHistory_;
    }

    void stComponentStockHistory(const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& value) {
        m_stComponentStockHistory_ = value;
    }

    void stComponentStockHistory(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY&& value) {
        m_stComponentStockHistory_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY m_stComponentStockHistory_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& a, USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE();

    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE (USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& operator=(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE(const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& operator=(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulID_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& a, USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& sample);

class NDDSUSERDllExport ST_MSSSUP_SYSTEM_COMPONENT_IETM {
  public:
    ST_MSSSUP_SYSTEM_COMPONENT_IETM();

    ST_MSSSUP_SYSTEM_COMPONENT_IETM(uint32_t ulID,uint32_t ulSystemComponentID,const std::wstring& strComponentName,const std::wstring& strName,const std::wstring& strNumber,const std::wstring& strUrl);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SYSTEM_COMPONENT_IETM (ST_MSSSUP_SYSTEM_COMPONENT_IETM&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_IETM& operator=(ST_MSSSUP_SYSTEM_COMPONENT_IETM&&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_IETM& operator=(const ST_MSSSUP_SYSTEM_COMPONENT_IETM&) = default;
    ST_MSSSUP_SYSTEM_COMPONENT_IETM(const ST_MSSSUP_SYSTEM_COMPONENT_IETM&) = default;
    #else
    ST_MSSSUP_SYSTEM_COMPONENT_IETM(ST_MSSSUP_SYSTEM_COMPONENT_IETM&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SYSTEM_COMPONENT_IETM& operator=(ST_MSSSUP_SYSTEM_COMPONENT_IETM&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    std::wstring& strComponentName() OMG_NOEXCEPT {
        return m_strComponentName_;
    }

    const std::wstring& strComponentName() const OMG_NOEXCEPT {
        return m_strComponentName_;
    }

    void strComponentName(const std::wstring& value) {
        m_strComponentName_ = value;
    }

    void strComponentName(std::wstring&& value) {
        m_strComponentName_ = std::move(value);
    }
    std::wstring& strName() OMG_NOEXCEPT {
        return m_strName_;
    }

    const std::wstring& strName() const OMG_NOEXCEPT {
        return m_strName_;
    }

    void strName(const std::wstring& value) {
        m_strName_ = value;
    }

    void strName(std::wstring&& value) {
        m_strName_ = std::move(value);
    }
    std::wstring& strNumber() OMG_NOEXCEPT {
        return m_strNumber_;
    }

    const std::wstring& strNumber() const OMG_NOEXCEPT {
        return m_strNumber_;
    }

    void strNumber(const std::wstring& value) {
        m_strNumber_ = value;
    }

    void strNumber(std::wstring&& value) {
        m_strNumber_ = std::move(value);
    }
    std::wstring& strUrl() OMG_NOEXCEPT {
        return m_strUrl_;
    }

    const std::wstring& strUrl() const OMG_NOEXCEPT {
        return m_strUrl_;
    }

    void strUrl(const std::wstring& value) {
        m_strUrl_ = value;
    }

    void strUrl(std::wstring&& value) {
        m_strUrl_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_SYSTEM_COMPONENT_IETM& other_) const;
    bool operator != (const ST_MSSSUP_SYSTEM_COMPONENT_IETM& other_) const;

    void swap(ST_MSSSUP_SYSTEM_COMPONENT_IETM& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint32_t m_ulSystemComponentID_;
    std::wstring m_strComponentName_;
    std::wstring m_strName_;
    std::wstring m_strNumber_;
    std::wstring m_strUrl_;

};

inline void swap(ST_MSSSUP_SYSTEM_COMPONENT_IETM& a, ST_MSSSUP_SYSTEM_COMPONENT_IETM& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SYSTEM_COMPONENT_IETM& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST {
  public:
    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST();

    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST (USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& operator=(const USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST&) = default;
    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST(const USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST&) = default;
    #else
    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& operator=(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& other_) const;

    void swap(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& a, USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SYSTEM_COMPONENT_IETM >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SYSTEM_COMPONENT_IETM >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT {
  public:
    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT();

    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_IETM, 100L >& seqSystemComponentIETMs);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT (MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& operator=(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& operator=(const MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT&) = default;
    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT(const MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT&) = default;
    #else
    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& operator=(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_IETM, 100L >& seqSystemComponentIETMs() OMG_NOEXCEPT {
        return m_seqSystemComponentIETMs_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_IETM, 100L >& seqSystemComponentIETMs() const OMG_NOEXCEPT {
        return m_seqSystemComponentIETMs_;
    }

    void seqSystemComponentIETMs(const ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_IETM, 100L >& value) {
        m_seqSystemComponentIETMs_ = value;
    }

    void seqSystemComponentIETMs(::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_IETM, 100L >&& value) {
        m_seqSystemComponentIETMs_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& other_) const;

    void swap(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SYSTEM_COMPONENT_IETM, 100L > m_seqSystemComponentIETMs_;

};

inline void swap(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& a, MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& sample);

class NDDSUSERDllExport ST_MSSSUP_EXTERNAL_STORAGE_INFO {
  public:
    ST_MSSSUP_EXTERNAL_STORAGE_INFO();

    ST_MSSSUP_EXTERNAL_STORAGE_INFO(const std::wstring& strSWID,const std::wstring& strExeName,const std::wstring& strPath,const std::wstring& strVersion,uint64_t ullSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_EXTERNAL_STORAGE_INFO (ST_MSSSUP_EXTERNAL_STORAGE_INFO&&) = default;
    ST_MSSSUP_EXTERNAL_STORAGE_INFO& operator=(ST_MSSSUP_EXTERNAL_STORAGE_INFO&&) = default;
    ST_MSSSUP_EXTERNAL_STORAGE_INFO& operator=(const ST_MSSSUP_EXTERNAL_STORAGE_INFO&) = default;
    ST_MSSSUP_EXTERNAL_STORAGE_INFO(const ST_MSSSUP_EXTERNAL_STORAGE_INFO&) = default;
    #else
    ST_MSSSUP_EXTERNAL_STORAGE_INFO(ST_MSSSUP_EXTERNAL_STORAGE_INFO&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_EXTERNAL_STORAGE_INFO& operator=(ST_MSSSUP_EXTERNAL_STORAGE_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    std::wstring& strSWID() OMG_NOEXCEPT {
        return m_strSWID_;
    }

    const std::wstring& strSWID() const OMG_NOEXCEPT {
        return m_strSWID_;
    }

    void strSWID(const std::wstring& value) {
        m_strSWID_ = value;
    }

    void strSWID(std::wstring&& value) {
        m_strSWID_ = std::move(value);
    }
    std::wstring& strExeName() OMG_NOEXCEPT {
        return m_strExeName_;
    }

    const std::wstring& strExeName() const OMG_NOEXCEPT {
        return m_strExeName_;
    }

    void strExeName(const std::wstring& value) {
        m_strExeName_ = value;
    }

    void strExeName(std::wstring&& value) {
        m_strExeName_ = std::move(value);
    }
    std::wstring& strPath() OMG_NOEXCEPT {
        return m_strPath_;
    }

    const std::wstring& strPath() const OMG_NOEXCEPT {
        return m_strPath_;
    }

    void strPath(const std::wstring& value) {
        m_strPath_ = value;
    }

    void strPath(std::wstring&& value) {
        m_strPath_ = std::move(value);
    }
    std::wstring& strVersion() OMG_NOEXCEPT {
        return m_strVersion_;
    }

    const std::wstring& strVersion() const OMG_NOEXCEPT {
        return m_strVersion_;
    }

    void strVersion(const std::wstring& value) {
        m_strVersion_ = value;
    }

    void strVersion(std::wstring&& value) {
        m_strVersion_ = std::move(value);
    }
    uint64_t& ullSize() OMG_NOEXCEPT {
        return m_ullSize_;
    }

    const uint64_t& ullSize() const OMG_NOEXCEPT {
        return m_ullSize_;
    }

    void ullSize(uint64_t value) {
        m_ullSize_ = value;
    }

    bool operator == (const ST_MSSSUP_EXTERNAL_STORAGE_INFO& other_) const;
    bool operator != (const ST_MSSSUP_EXTERNAL_STORAGE_INFO& other_) const;

    void swap(ST_MSSSUP_EXTERNAL_STORAGE_INFO& other_) OMG_NOEXCEPT ;

  private:

    std::wstring m_strSWID_;
    std::wstring m_strExeName_;
    std::wstring m_strPath_;
    std::wstring m_strVersion_;
    uint64_t m_ullSize_;

};

inline void swap(ST_MSSSUP_EXTERNAL_STORAGE_INFO& a, ST_MSSSUP_EXTERNAL_STORAGE_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_EXTERNAL_STORAGE_INFO& sample);

class NDDSUSERDllExport USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST {
  public:
    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST();

    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST (USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& operator=(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& operator=(const USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST&) = default;
    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST(const USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST&) = default;
    #else
    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& operator=(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& other_) const;

    void swap(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& a, USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_EXTERNAL_STORAGE_INFO >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_EXTERNAL_STORAGE_INFO >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT {
  public:
    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT();

    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_EXTERNAL_STORAGE_INFO, 100L >& seqExternalStorageInfos);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT (MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& operator=(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& operator=(const MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT&) = default;
    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT(const MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT&) = default;
    #else
    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& operator=(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_EXTERNAL_STORAGE_INFO, 100L >& seqExternalStorageInfos() OMG_NOEXCEPT {
        return m_seqExternalStorageInfos_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_EXTERNAL_STORAGE_INFO, 100L >& seqExternalStorageInfos() const OMG_NOEXCEPT {
        return m_seqExternalStorageInfos_;
    }

    void seqExternalStorageInfos(const ::rti::core::bounded_sequence< ST_MSSSUP_EXTERNAL_STORAGE_INFO, 100L >& value) {
        m_seqExternalStorageInfos_ = value;
    }

    void seqExternalStorageInfos(::rti::core::bounded_sequence< ST_MSSSUP_EXTERNAL_STORAGE_INFO, 100L >&& value) {
        m_seqExternalStorageInfos_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& other_) const;

    void swap(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_EXTERNAL_STORAGE_INFO, 100L > m_seqExternalStorageInfos_;

};

inline void swap(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& a, MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& sample);

class NDDSUSERDllExport ST_MSSSUP_NAS_INFO {
  public:
    ST_MSSSUP_NAS_INFO();

    ST_MSSSUP_NAS_INFO(const std::wstring& strSWID,const std::wstring& strExeName,const std::wstring& strPath,const std::wstring& strVersion,const std::wstring& strDate,uint64_t ullSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_NAS_INFO (ST_MSSSUP_NAS_INFO&&) = default;
    ST_MSSSUP_NAS_INFO& operator=(ST_MSSSUP_NAS_INFO&&) = default;
    ST_MSSSUP_NAS_INFO& operator=(const ST_MSSSUP_NAS_INFO&) = default;
    ST_MSSSUP_NAS_INFO(const ST_MSSSUP_NAS_INFO&) = default;
    #else
    ST_MSSSUP_NAS_INFO(ST_MSSSUP_NAS_INFO&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_NAS_INFO& operator=(ST_MSSSUP_NAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    std::wstring& strSWID() OMG_NOEXCEPT {
        return m_strSWID_;
    }

    const std::wstring& strSWID() const OMG_NOEXCEPT {
        return m_strSWID_;
    }

    void strSWID(const std::wstring& value) {
        m_strSWID_ = value;
    }

    void strSWID(std::wstring&& value) {
        m_strSWID_ = std::move(value);
    }
    std::wstring& strExeName() OMG_NOEXCEPT {
        return m_strExeName_;
    }

    const std::wstring& strExeName() const OMG_NOEXCEPT {
        return m_strExeName_;
    }

    void strExeName(const std::wstring& value) {
        m_strExeName_ = value;
    }

    void strExeName(std::wstring&& value) {
        m_strExeName_ = std::move(value);
    }
    std::wstring& strPath() OMG_NOEXCEPT {
        return m_strPath_;
    }

    const std::wstring& strPath() const OMG_NOEXCEPT {
        return m_strPath_;
    }

    void strPath(const std::wstring& value) {
        m_strPath_ = value;
    }

    void strPath(std::wstring&& value) {
        m_strPath_ = std::move(value);
    }
    std::wstring& strVersion() OMG_NOEXCEPT {
        return m_strVersion_;
    }

    const std::wstring& strVersion() const OMG_NOEXCEPT {
        return m_strVersion_;
    }

    void strVersion(const std::wstring& value) {
        m_strVersion_ = value;
    }

    void strVersion(std::wstring&& value) {
        m_strVersion_ = std::move(value);
    }
    std::wstring& strDate() OMG_NOEXCEPT {
        return m_strDate_;
    }

    const std::wstring& strDate() const OMG_NOEXCEPT {
        return m_strDate_;
    }

    void strDate(const std::wstring& value) {
        m_strDate_ = value;
    }

    void strDate(std::wstring&& value) {
        m_strDate_ = std::move(value);
    }
    uint64_t& ullSize() OMG_NOEXCEPT {
        return m_ullSize_;
    }

    const uint64_t& ullSize() const OMG_NOEXCEPT {
        return m_ullSize_;
    }

    void ullSize(uint64_t value) {
        m_ullSize_ = value;
    }

    bool operator == (const ST_MSSSUP_NAS_INFO& other_) const;
    bool operator != (const ST_MSSSUP_NAS_INFO& other_) const;

    void swap(ST_MSSSUP_NAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    std::wstring m_strSWID_;
    std::wstring m_strExeName_;
    std::wstring m_strPath_;
    std::wstring m_strVersion_;
    std::wstring m_strDate_;
    uint64_t m_ullSize_;

};

inline void swap(ST_MSSSUP_NAS_INFO& a, ST_MSSSUP_NAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_NAS_INFO& sample);

class NDDSUSERDllExport USERIF_MSS_SOFTWARE_NAS_REQUEST {
  public:
    USERIF_MSS_SOFTWARE_NAS_REQUEST();

    USERIF_MSS_SOFTWARE_NAS_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SOFTWARE_NAS_REQUEST (USERIF_MSS_SOFTWARE_NAS_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_NAS_REQUEST& operator=(USERIF_MSS_SOFTWARE_NAS_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_NAS_REQUEST& operator=(const USERIF_MSS_SOFTWARE_NAS_REQUEST&) = default;
    USERIF_MSS_SOFTWARE_NAS_REQUEST(const USERIF_MSS_SOFTWARE_NAS_REQUEST&) = default;
    #else
    USERIF_MSS_SOFTWARE_NAS_REQUEST(USERIF_MSS_SOFTWARE_NAS_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SOFTWARE_NAS_REQUEST& operator=(USERIF_MSS_SOFTWARE_NAS_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SOFTWARE_NAS_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SOFTWARE_NAS_REQUEST& other_) const;

    void swap(USERIF_MSS_SOFTWARE_NAS_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SOFTWARE_NAS_REQUEST& a, USERIF_MSS_SOFTWARE_NAS_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SOFTWARE_NAS_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_NAS_INFO >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_NAS_INFO >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SOFTWARE_NAS_RESULT {
  public:
    MSSSUP_USE_SOFTWARE_NAS_RESULT();

    MSSSUP_USE_SOFTWARE_NAS_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_NAS_INFO, 200L >& seqNasInfos);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SOFTWARE_NAS_RESULT (MSSSUP_USE_SOFTWARE_NAS_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_NAS_RESULT& operator=(MSSSUP_USE_SOFTWARE_NAS_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_NAS_RESULT& operator=(const MSSSUP_USE_SOFTWARE_NAS_RESULT&) = default;
    MSSSUP_USE_SOFTWARE_NAS_RESULT(const MSSSUP_USE_SOFTWARE_NAS_RESULT&) = default;
    #else
    MSSSUP_USE_SOFTWARE_NAS_RESULT(MSSSUP_USE_SOFTWARE_NAS_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SOFTWARE_NAS_RESULT& operator=(MSSSUP_USE_SOFTWARE_NAS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_NAS_INFO, 200L >& seqNasInfos() OMG_NOEXCEPT {
        return m_seqNasInfos_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_NAS_INFO, 200L >& seqNasInfos() const OMG_NOEXCEPT {
        return m_seqNasInfos_;
    }

    void seqNasInfos(const ::rti::core::bounded_sequence< ST_MSSSUP_NAS_INFO, 200L >& value) {
        m_seqNasInfos_ = value;
    }

    void seqNasInfos(::rti::core::bounded_sequence< ST_MSSSUP_NAS_INFO, 200L >&& value) {
        m_seqNasInfos_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SOFTWARE_NAS_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SOFTWARE_NAS_RESULT& other_) const;

    void swap(MSSSUP_USE_SOFTWARE_NAS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_NAS_INFO, 200L > m_seqNasInfos_;

};

inline void swap(MSSSUP_USE_SOFTWARE_NAS_RESULT& a, MSSSUP_USE_SOFTWARE_NAS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SOFTWARE_NAS_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST {
  public:
    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST();

    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST (USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& operator=(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& operator=(const USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST&) = default;
    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST(const USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST&) = default;
    #else
    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& operator=(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    bool operator == (const USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& other_) const;

    void swap(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;

};

inline void swap(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& a, USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& sample);

class NDDSUSERDllExport MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT {
  public:
    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT();

    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint64_t ullExternalTotalSize,uint64_t ullExternalFreeSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT (MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& operator=(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& operator=(const MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT&) = default;
    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT(const MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT&) = default;
    #else
    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& operator=(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint64_t& ullExternalTotalSize() OMG_NOEXCEPT {
        return m_ullExternalTotalSize_;
    }

    const uint64_t& ullExternalTotalSize() const OMG_NOEXCEPT {
        return m_ullExternalTotalSize_;
    }

    void ullExternalTotalSize(uint64_t value) {
        m_ullExternalTotalSize_ = value;
    }

    uint64_t& ullExternalFreeSize() OMG_NOEXCEPT {
        return m_ullExternalFreeSize_;
    }

    const uint64_t& ullExternalFreeSize() const OMG_NOEXCEPT {
        return m_ullExternalFreeSize_;
    }

    void ullExternalFreeSize(uint64_t value) {
        m_ullExternalFreeSize_ = value;
    }

    bool operator == (const MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& other_) const;

    void swap(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint64_t m_ullExternalTotalSize_;
    uint64_t m_ullExternalFreeSize_;

};

inline void swap(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& a, MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST {
  public:
    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST();

    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST (USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& operator=(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& operator=(const USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST&) = default;
    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST(const USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST&) = default;
    #else
    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& operator=(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    bool operator == (const USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& other_) const;

    void swap(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;

};

inline void swap(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& a, USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& sample);

class NDDSUSERDllExport MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT {
  public:
    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT();

    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint64_t ullNASTotalSize,uint64_t ullNASFreeSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT (MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& operator=(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& operator=(const MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT&) = default;
    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT(const MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT&) = default;
    #else
    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& operator=(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint64_t& ullNASTotalSize() OMG_NOEXCEPT {
        return m_ullNASTotalSize_;
    }

    const uint64_t& ullNASTotalSize() const OMG_NOEXCEPT {
        return m_ullNASTotalSize_;
    }

    void ullNASTotalSize(uint64_t value) {
        m_ullNASTotalSize_ = value;
    }

    uint64_t& ullNASFreeSize() OMG_NOEXCEPT {
        return m_ullNASFreeSize_;
    }

    const uint64_t& ullNASFreeSize() const OMG_NOEXCEPT {
        return m_ullNASFreeSize_;
    }

    void ullNASFreeSize(uint64_t value) {
        m_ullNASFreeSize_ = value;
    }

    bool operator == (const MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& other_) const;

    void swap(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint64_t m_ullNASTotalSize_;
    uint64_t m_ullNASFreeSize_;

};

inline void swap(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& a, MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_DISK_TO_NAS_REQUEST {
  public:
    USERIF_MSS_DISK_TO_NAS_REQUEST();

    USERIF_MSS_DISK_TO_NAS_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const std::wstring& strPath,const std::wstring& strSWID,const std::wstring& strExeName,const std::wstring& strVersion,uint64_t ullSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_DISK_TO_NAS_REQUEST (USERIF_MSS_DISK_TO_NAS_REQUEST&&) = default;
    USERIF_MSS_DISK_TO_NAS_REQUEST& operator=(USERIF_MSS_DISK_TO_NAS_REQUEST&&) = default;
    USERIF_MSS_DISK_TO_NAS_REQUEST& operator=(const USERIF_MSS_DISK_TO_NAS_REQUEST&) = default;
    USERIF_MSS_DISK_TO_NAS_REQUEST(const USERIF_MSS_DISK_TO_NAS_REQUEST&) = default;
    #else
    USERIF_MSS_DISK_TO_NAS_REQUEST(USERIF_MSS_DISK_TO_NAS_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_DISK_TO_NAS_REQUEST& operator=(USERIF_MSS_DISK_TO_NAS_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    std::wstring& strPath() OMG_NOEXCEPT {
        return m_strPath_;
    }

    const std::wstring& strPath() const OMG_NOEXCEPT {
        return m_strPath_;
    }

    void strPath(const std::wstring& value) {
        m_strPath_ = value;
    }

    void strPath(std::wstring&& value) {
        m_strPath_ = std::move(value);
    }
    std::wstring& strSWID() OMG_NOEXCEPT {
        return m_strSWID_;
    }

    const std::wstring& strSWID() const OMG_NOEXCEPT {
        return m_strSWID_;
    }

    void strSWID(const std::wstring& value) {
        m_strSWID_ = value;
    }

    void strSWID(std::wstring&& value) {
        m_strSWID_ = std::move(value);
    }
    std::wstring& strExeName() OMG_NOEXCEPT {
        return m_strExeName_;
    }

    const std::wstring& strExeName() const OMG_NOEXCEPT {
        return m_strExeName_;
    }

    void strExeName(const std::wstring& value) {
        m_strExeName_ = value;
    }

    void strExeName(std::wstring&& value) {
        m_strExeName_ = std::move(value);
    }
    std::wstring& strVersion() OMG_NOEXCEPT {
        return m_strVersion_;
    }

    const std::wstring& strVersion() const OMG_NOEXCEPT {
        return m_strVersion_;
    }

    void strVersion(const std::wstring& value) {
        m_strVersion_ = value;
    }

    void strVersion(std::wstring&& value) {
        m_strVersion_ = std::move(value);
    }
    uint64_t& ullSize() OMG_NOEXCEPT {
        return m_ullSize_;
    }

    const uint64_t& ullSize() const OMG_NOEXCEPT {
        return m_ullSize_;
    }

    void ullSize(uint64_t value) {
        m_ullSize_ = value;
    }

    bool operator == (const USERIF_MSS_DISK_TO_NAS_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_DISK_TO_NAS_REQUEST& other_) const;

    void swap(USERIF_MSS_DISK_TO_NAS_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    std::wstring m_strPath_;
    std::wstring m_strSWID_;
    std::wstring m_strExeName_;
    std::wstring m_strVersion_;
    uint64_t m_ullSize_;

};

inline void swap(USERIF_MSS_DISK_TO_NAS_REQUEST& a, USERIF_MSS_DISK_TO_NAS_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_DISK_TO_NAS_REQUEST& sample);

class NDDSUSERDllExport MSSSUP_USE_DISK_TO_NAS_RESULT {
  public:
    MSSSUP_USE_DISK_TO_NAS_RESULT();

    MSSSUP_USE_DISK_TO_NAS_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const std::wstring& strPath,uint16_t unCode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_DISK_TO_NAS_RESULT (MSSSUP_USE_DISK_TO_NAS_RESULT&&) = default;
    MSSSUP_USE_DISK_TO_NAS_RESULT& operator=(MSSSUP_USE_DISK_TO_NAS_RESULT&&) = default;
    MSSSUP_USE_DISK_TO_NAS_RESULT& operator=(const MSSSUP_USE_DISK_TO_NAS_RESULT&) = default;
    MSSSUP_USE_DISK_TO_NAS_RESULT(const MSSSUP_USE_DISK_TO_NAS_RESULT&) = default;
    #else
    MSSSUP_USE_DISK_TO_NAS_RESULT(MSSSUP_USE_DISK_TO_NAS_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_DISK_TO_NAS_RESULT& operator=(MSSSUP_USE_DISK_TO_NAS_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    std::wstring& strPath() OMG_NOEXCEPT {
        return m_strPath_;
    }

    const std::wstring& strPath() const OMG_NOEXCEPT {
        return m_strPath_;
    }

    void strPath(const std::wstring& value) {
        m_strPath_ = value;
    }

    void strPath(std::wstring&& value) {
        m_strPath_ = std::move(value);
    }
    uint16_t& unCode() OMG_NOEXCEPT {
        return m_unCode_;
    }

    const uint16_t& unCode() const OMG_NOEXCEPT {
        return m_unCode_;
    }

    void unCode(uint16_t value) {
        m_unCode_ = value;
    }

    bool operator == (const MSSSUP_USE_DISK_TO_NAS_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_DISK_TO_NAS_RESULT& other_) const;

    void swap(MSSSUP_USE_DISK_TO_NAS_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    std::wstring m_strPath_;
    uint16_t m_unCode_;

};

inline void swap(MSSSUP_USE_DISK_TO_NAS_RESULT& a, MSSSUP_USE_DISK_TO_NAS_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_DISK_TO_NAS_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_NAS_DELETE_REQUEST {
  public:
    USERIF_MSS_NAS_DELETE_REQUEST();

    USERIF_MSS_NAS_DELETE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const std::wstring& strPath,const std::wstring& strSWID,const std::wstring& strExeName,const std::wstring& strVersion,uint64_t ullSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_NAS_DELETE_REQUEST (USERIF_MSS_NAS_DELETE_REQUEST&&) = default;
    USERIF_MSS_NAS_DELETE_REQUEST& operator=(USERIF_MSS_NAS_DELETE_REQUEST&&) = default;
    USERIF_MSS_NAS_DELETE_REQUEST& operator=(const USERIF_MSS_NAS_DELETE_REQUEST&) = default;
    USERIF_MSS_NAS_DELETE_REQUEST(const USERIF_MSS_NAS_DELETE_REQUEST&) = default;
    #else
    USERIF_MSS_NAS_DELETE_REQUEST(USERIF_MSS_NAS_DELETE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_NAS_DELETE_REQUEST& operator=(USERIF_MSS_NAS_DELETE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    std::wstring& strPath() OMG_NOEXCEPT {
        return m_strPath_;
    }

    const std::wstring& strPath() const OMG_NOEXCEPT {
        return m_strPath_;
    }

    void strPath(const std::wstring& value) {
        m_strPath_ = value;
    }

    void strPath(std::wstring&& value) {
        m_strPath_ = std::move(value);
    }
    std::wstring& strSWID() OMG_NOEXCEPT {
        return m_strSWID_;
    }

    const std::wstring& strSWID() const OMG_NOEXCEPT {
        return m_strSWID_;
    }

    void strSWID(const std::wstring& value) {
        m_strSWID_ = value;
    }

    void strSWID(std::wstring&& value) {
        m_strSWID_ = std::move(value);
    }
    std::wstring& strExeName() OMG_NOEXCEPT {
        return m_strExeName_;
    }

    const std::wstring& strExeName() const OMG_NOEXCEPT {
        return m_strExeName_;
    }

    void strExeName(const std::wstring& value) {
        m_strExeName_ = value;
    }

    void strExeName(std::wstring&& value) {
        m_strExeName_ = std::move(value);
    }
    std::wstring& strVersion() OMG_NOEXCEPT {
        return m_strVersion_;
    }

    const std::wstring& strVersion() const OMG_NOEXCEPT {
        return m_strVersion_;
    }

    void strVersion(const std::wstring& value) {
        m_strVersion_ = value;
    }

    void strVersion(std::wstring&& value) {
        m_strVersion_ = std::move(value);
    }
    uint64_t& ullSize() OMG_NOEXCEPT {
        return m_ullSize_;
    }

    const uint64_t& ullSize() const OMG_NOEXCEPT {
        return m_ullSize_;
    }

    void ullSize(uint64_t value) {
        m_ullSize_ = value;
    }

    bool operator == (const USERIF_MSS_NAS_DELETE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_NAS_DELETE_REQUEST& other_) const;

    void swap(USERIF_MSS_NAS_DELETE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    std::wstring m_strPath_;
    std::wstring m_strSWID_;
    std::wstring m_strExeName_;
    std::wstring m_strVersion_;
    uint64_t m_ullSize_;

};

inline void swap(USERIF_MSS_NAS_DELETE_REQUEST& a, USERIF_MSS_NAS_DELETE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_NAS_DELETE_REQUEST& sample);

class NDDSUSERDllExport MSSSUP_USE_NAS_DELETE_RESULT {
  public:
    MSSSUP_USE_NAS_DELETE_RESULT();

    MSSSUP_USE_NAS_DELETE_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const std::wstring& strPath,uint16_t unCode);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_NAS_DELETE_RESULT (MSSSUP_USE_NAS_DELETE_RESULT&&) = default;
    MSSSUP_USE_NAS_DELETE_RESULT& operator=(MSSSUP_USE_NAS_DELETE_RESULT&&) = default;
    MSSSUP_USE_NAS_DELETE_RESULT& operator=(const MSSSUP_USE_NAS_DELETE_RESULT&) = default;
    MSSSUP_USE_NAS_DELETE_RESULT(const MSSSUP_USE_NAS_DELETE_RESULT&) = default;
    #else
    MSSSUP_USE_NAS_DELETE_RESULT(MSSSUP_USE_NAS_DELETE_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_NAS_DELETE_RESULT& operator=(MSSSUP_USE_NAS_DELETE_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    std::wstring& strPath() OMG_NOEXCEPT {
        return m_strPath_;
    }

    const std::wstring& strPath() const OMG_NOEXCEPT {
        return m_strPath_;
    }

    void strPath(const std::wstring& value) {
        m_strPath_ = value;
    }

    void strPath(std::wstring&& value) {
        m_strPath_ = std::move(value);
    }
    uint16_t& unCode() OMG_NOEXCEPT {
        return m_unCode_;
    }

    const uint16_t& unCode() const OMG_NOEXCEPT {
        return m_unCode_;
    }

    void unCode(uint16_t value) {
        m_unCode_ = value;
    }

    bool operator == (const MSSSUP_USE_NAS_DELETE_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_NAS_DELETE_RESULT& other_) const;

    void swap(MSSSUP_USE_NAS_DELETE_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    std::wstring m_strPath_;
    uint16_t m_unCode_;

};

inline void swap(MSSSUP_USE_NAS_DELETE_RESULT& a, MSSSUP_USE_NAS_DELETE_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_NAS_DELETE_RESULT& sample);

class NDDSUSERDllExport ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY {
  public:
    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY();

    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY(uint32_t ulID,uint64_t ulDate,const std::wstring& strState,const std::wstring& strPath,const std::wstring& strSWID,const std::wstring& strExeName,const std::wstring& strVersion,uint64_t ullSize,uint16_t unExists);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY (ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY&&) = default;
    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& operator=(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY&&) = default;
    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& operator=(const ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY&) = default;
    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY(const ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY&) = default;
    #else
    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& operator=(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint64_t& ulDate() OMG_NOEXCEPT {
        return m_ulDate_;
    }

    const uint64_t& ulDate() const OMG_NOEXCEPT {
        return m_ulDate_;
    }

    void ulDate(uint64_t value) {
        m_ulDate_ = value;
    }

    std::wstring& strState() OMG_NOEXCEPT {
        return m_strState_;
    }

    const std::wstring& strState() const OMG_NOEXCEPT {
        return m_strState_;
    }

    void strState(const std::wstring& value) {
        m_strState_ = value;
    }

    void strState(std::wstring&& value) {
        m_strState_ = std::move(value);
    }
    std::wstring& strPath() OMG_NOEXCEPT {
        return m_strPath_;
    }

    const std::wstring& strPath() const OMG_NOEXCEPT {
        return m_strPath_;
    }

    void strPath(const std::wstring& value) {
        m_strPath_ = value;
    }

    void strPath(std::wstring&& value) {
        m_strPath_ = std::move(value);
    }
    std::wstring& strSWID() OMG_NOEXCEPT {
        return m_strSWID_;
    }

    const std::wstring& strSWID() const OMG_NOEXCEPT {
        return m_strSWID_;
    }

    void strSWID(const std::wstring& value) {
        m_strSWID_ = value;
    }

    void strSWID(std::wstring&& value) {
        m_strSWID_ = std::move(value);
    }
    std::wstring& strExeName() OMG_NOEXCEPT {
        return m_strExeName_;
    }

    const std::wstring& strExeName() const OMG_NOEXCEPT {
        return m_strExeName_;
    }

    void strExeName(const std::wstring& value) {
        m_strExeName_ = value;
    }

    void strExeName(std::wstring&& value) {
        m_strExeName_ = std::move(value);
    }
    std::wstring& strVersion() OMG_NOEXCEPT {
        return m_strVersion_;
    }

    const std::wstring& strVersion() const OMG_NOEXCEPT {
        return m_strVersion_;
    }

    void strVersion(const std::wstring& value) {
        m_strVersion_ = value;
    }

    void strVersion(std::wstring&& value) {
        m_strVersion_ = std::move(value);
    }
    uint64_t& ullSize() OMG_NOEXCEPT {
        return m_ullSize_;
    }

    const uint64_t& ullSize() const OMG_NOEXCEPT {
        return m_ullSize_;
    }

    void ullSize(uint64_t value) {
        m_ullSize_ = value;
    }

    uint16_t& unExists() OMG_NOEXCEPT {
        return m_unExists_;
    }

    const uint16_t& unExists() const OMG_NOEXCEPT {
        return m_unExists_;
    }

    void unExists(uint16_t value) {
        m_unExists_ = value;
    }

    bool operator == (const ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& other_) const;
    bool operator != (const ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& other_) const;

    void swap(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint64_t m_ulDate_;
    std::wstring m_strState_;
    std::wstring m_strPath_;
    std::wstring m_strSWID_;
    std::wstring m_strExeName_;
    std::wstring m_strVersion_;
    uint64_t m_ullSize_;
    uint16_t m_unExists_;

};

inline void swap(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& a, ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& sample);

class NDDSUSERDllExport ST_MSSSUP_SOFTWARE_INSTALL_HISTORY {
  public:
    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY();

    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY(uint32_t ulID,uint32_t ulDate,const std::wstring& strEquipment,const std::wstring& strExeName,const std::wstring& strVersion,const std::wstring& strSWID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY (ST_MSSSUP_SOFTWARE_INSTALL_HISTORY&&) = default;
    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& operator=(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY&&) = default;
    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& operator=(const ST_MSSSUP_SOFTWARE_INSTALL_HISTORY&) = default;
    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY(const ST_MSSSUP_SOFTWARE_INSTALL_HISTORY&) = default;
    #else
    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& operator=(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint32_t& ulDate() OMG_NOEXCEPT {
        return m_ulDate_;
    }

    const uint32_t& ulDate() const OMG_NOEXCEPT {
        return m_ulDate_;
    }

    void ulDate(uint32_t value) {
        m_ulDate_ = value;
    }

    std::wstring& strEquipment() OMG_NOEXCEPT {
        return m_strEquipment_;
    }

    const std::wstring& strEquipment() const OMG_NOEXCEPT {
        return m_strEquipment_;
    }

    void strEquipment(const std::wstring& value) {
        m_strEquipment_ = value;
    }

    void strEquipment(std::wstring&& value) {
        m_strEquipment_ = std::move(value);
    }
    std::wstring& strExeName() OMG_NOEXCEPT {
        return m_strExeName_;
    }

    const std::wstring& strExeName() const OMG_NOEXCEPT {
        return m_strExeName_;
    }

    void strExeName(const std::wstring& value) {
        m_strExeName_ = value;
    }

    void strExeName(std::wstring&& value) {
        m_strExeName_ = std::move(value);
    }
    std::wstring& strVersion() OMG_NOEXCEPT {
        return m_strVersion_;
    }

    const std::wstring& strVersion() const OMG_NOEXCEPT {
        return m_strVersion_;
    }

    void strVersion(const std::wstring& value) {
        m_strVersion_ = value;
    }

    void strVersion(std::wstring&& value) {
        m_strVersion_ = std::move(value);
    }
    std::wstring& strSWID() OMG_NOEXCEPT {
        return m_strSWID_;
    }

    const std::wstring& strSWID() const OMG_NOEXCEPT {
        return m_strSWID_;
    }

    void strSWID(const std::wstring& value) {
        m_strSWID_ = value;
    }

    void strSWID(std::wstring&& value) {
        m_strSWID_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& other_) const;
    bool operator != (const ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& other_) const;

    void swap(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint32_t m_ulDate_;
    std::wstring m_strEquipment_;
    std::wstring m_strExeName_;
    std::wstring m_strVersion_;
    std::wstring m_strSWID_;

};

inline void swap(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& a, ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& sample);

class NDDSUSERDllExport USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST {
  public:
    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST();

    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST (USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& operator=(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& operator=(const USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST&) = default;
    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST(const USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST&) = default;
    #else
    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& operator=(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& other_) const;

    void swap(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& a, USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT {
  public:
    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT();

    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY, 100L >& seqSoftwareUpdateHistories);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT (MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& operator=(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& operator=(const MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT&) = default;
    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT(const MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT&) = default;
    #else
    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& operator=(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY, 100L >& seqSoftwareUpdateHistories() OMG_NOEXCEPT {
        return m_seqSoftwareUpdateHistories_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY, 100L >& seqSoftwareUpdateHistories() const OMG_NOEXCEPT {
        return m_seqSoftwareUpdateHistories_;
    }

    void seqSoftwareUpdateHistories(const ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY, 100L >& value) {
        m_seqSoftwareUpdateHistories_ = value;
    }

    void seqSoftwareUpdateHistories(::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY, 100L >&& value) {
        m_seqSoftwareUpdateHistories_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& other_) const;

    void swap(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY, 100L > m_seqSoftwareUpdateHistories_;

};

inline void swap(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& a, MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST {
  public:
    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST();

    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST (USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& operator=(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST&&) = default;
    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& operator=(const USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST&) = default;
    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST(const USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST&) = default;
    #else
    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& operator=(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& other_) const;

    void swap(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& a, USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY >;
#endif
class NDDSUSERDllExport MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT {
  public:
    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT();

    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY, 100L >& seqSoftwareInstallHistories);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT (MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& operator=(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT&&) = default;
    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& operator=(const MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT&) = default;
    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT(const MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT&) = default;
    #else
    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& operator=(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY, 100L >& seqSoftwareInstallHistories() OMG_NOEXCEPT {
        return m_seqSoftwareInstallHistories_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY, 100L >& seqSoftwareInstallHistories() const OMG_NOEXCEPT {
        return m_seqSoftwareInstallHistories_;
    }

    void seqSoftwareInstallHistories(const ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY, 100L >& value) {
        m_seqSoftwareInstallHistories_ = value;
    }

    void seqSoftwareInstallHistories(::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY, 100L >&& value) {
        m_seqSoftwareInstallHistories_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& other_) const;

    void swap(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY, 100L > m_seqSoftwareInstallHistories_;

};

inline void swap(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& a, MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST {
  public:
    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST();

    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST (USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& operator=(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST&&) = default;
    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& operator=(const USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST&) = default;
    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST(const USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST&) = default;
    #else
    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& operator=(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    bool operator == (const USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& other_) const;

    void swap(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;

};

inline void swap(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& a, USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& sample);

class NDDSUSERDllExport MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT {
  public:
    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT();

    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const std::wstring& strMessages);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT (MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& operator=(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT&&) = default;
    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& operator=(const MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT&) = default;
    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT(const MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT&) = default;
    #else
    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& operator=(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    std::wstring& strMessages() OMG_NOEXCEPT {
        return m_strMessages_;
    }

    const std::wstring& strMessages() const OMG_NOEXCEPT {
        return m_strMessages_;
    }

    void strMessages(const std::wstring& value) {
        m_strMessages_ = value;
    }

    void strMessages(std::wstring&& value) {
        m_strMessages_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& other_) const;

    void swap(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    std::wstring m_strMessages_;

};

inline void swap(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& a, MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_SERVER_DISK_STATE_REQUEST {
  public:
    USERIF_MSS_SERVER_DISK_STATE_REQUEST();

    USERIF_MSS_SERVER_DISK_STATE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_SERVER_DISK_STATE_REQUEST (USERIF_MSS_SERVER_DISK_STATE_REQUEST&&) = default;
    USERIF_MSS_SERVER_DISK_STATE_REQUEST& operator=(USERIF_MSS_SERVER_DISK_STATE_REQUEST&&) = default;
    USERIF_MSS_SERVER_DISK_STATE_REQUEST& operator=(const USERIF_MSS_SERVER_DISK_STATE_REQUEST&) = default;
    USERIF_MSS_SERVER_DISK_STATE_REQUEST(const USERIF_MSS_SERVER_DISK_STATE_REQUEST&) = default;
    #else
    USERIF_MSS_SERVER_DISK_STATE_REQUEST(USERIF_MSS_SERVER_DISK_STATE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_SERVER_DISK_STATE_REQUEST& operator=(USERIF_MSS_SERVER_DISK_STATE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    bool operator == (const USERIF_MSS_SERVER_DISK_STATE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_SERVER_DISK_STATE_REQUEST& other_) const;

    void swap(USERIF_MSS_SERVER_DISK_STATE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;

};

inline void swap(USERIF_MSS_SERVER_DISK_STATE_REQUEST& a, USERIF_MSS_SERVER_DISK_STATE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_SERVER_DISK_STATE_REQUEST& sample);

class NDDSUSERDllExport ST_MSSSUP_DATABASE_BACKUP_HISTORY {
  public:
    ST_MSSSUP_DATABASE_BACKUP_HISTORY();

    ST_MSSSUP_DATABASE_BACKUP_HISTORY(uint64_t ullDate,const std::wstring& strName,uint64_t ullSize);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_DATABASE_BACKUP_HISTORY (ST_MSSSUP_DATABASE_BACKUP_HISTORY&&) = default;
    ST_MSSSUP_DATABASE_BACKUP_HISTORY& operator=(ST_MSSSUP_DATABASE_BACKUP_HISTORY&&) = default;
    ST_MSSSUP_DATABASE_BACKUP_HISTORY& operator=(const ST_MSSSUP_DATABASE_BACKUP_HISTORY&) = default;
    ST_MSSSUP_DATABASE_BACKUP_HISTORY(const ST_MSSSUP_DATABASE_BACKUP_HISTORY&) = default;
    #else
    ST_MSSSUP_DATABASE_BACKUP_HISTORY(ST_MSSSUP_DATABASE_BACKUP_HISTORY&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_DATABASE_BACKUP_HISTORY& operator=(ST_MSSSUP_DATABASE_BACKUP_HISTORY&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint64_t& ullDate() OMG_NOEXCEPT {
        return m_ullDate_;
    }

    const uint64_t& ullDate() const OMG_NOEXCEPT {
        return m_ullDate_;
    }

    void ullDate(uint64_t value) {
        m_ullDate_ = value;
    }

    std::wstring& strName() OMG_NOEXCEPT {
        return m_strName_;
    }

    const std::wstring& strName() const OMG_NOEXCEPT {
        return m_strName_;
    }

    void strName(const std::wstring& value) {
        m_strName_ = value;
    }

    void strName(std::wstring&& value) {
        m_strName_ = std::move(value);
    }
    uint64_t& ullSize() OMG_NOEXCEPT {
        return m_ullSize_;
    }

    const uint64_t& ullSize() const OMG_NOEXCEPT {
        return m_ullSize_;
    }

    void ullSize(uint64_t value) {
        m_ullSize_ = value;
    }

    bool operator == (const ST_MSSSUP_DATABASE_BACKUP_HISTORY& other_) const;
    bool operator != (const ST_MSSSUP_DATABASE_BACKUP_HISTORY& other_) const;

    void swap(ST_MSSSUP_DATABASE_BACKUP_HISTORY& other_) OMG_NOEXCEPT ;

  private:

    uint64_t m_ullDate_;
    std::wstring m_strName_;
    uint64_t m_ullSize_;

};

inline void swap(ST_MSSSUP_DATABASE_BACKUP_HISTORY& a, ST_MSSSUP_DATABASE_BACKUP_HISTORY& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_DATABASE_BACKUP_HISTORY& sample);

class NDDSUSERDllExport USERIF_MSS_DATABASE_BACKUP_REQUEST {
  public:
    USERIF_MSS_DATABASE_BACKUP_REQUEST();

    USERIF_MSS_DATABASE_BACKUP_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_DATABASE_BACKUP_REQUEST (USERIF_MSS_DATABASE_BACKUP_REQUEST&&) = default;
    USERIF_MSS_DATABASE_BACKUP_REQUEST& operator=(USERIF_MSS_DATABASE_BACKUP_REQUEST&&) = default;
    USERIF_MSS_DATABASE_BACKUP_REQUEST& operator=(const USERIF_MSS_DATABASE_BACKUP_REQUEST&) = default;
    USERIF_MSS_DATABASE_BACKUP_REQUEST(const USERIF_MSS_DATABASE_BACKUP_REQUEST&) = default;
    #else
    USERIF_MSS_DATABASE_BACKUP_REQUEST(USERIF_MSS_DATABASE_BACKUP_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_DATABASE_BACKUP_REQUEST& operator=(USERIF_MSS_DATABASE_BACKUP_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    bool operator == (const USERIF_MSS_DATABASE_BACKUP_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_DATABASE_BACKUP_REQUEST& other_) const;

    void swap(USERIF_MSS_DATABASE_BACKUP_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;

};

inline void swap(USERIF_MSS_DATABASE_BACKUP_REQUEST& a, USERIF_MSS_DATABASE_BACKUP_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_DATABASE_BACKUP_REQUEST& sample);

class NDDSUSERDllExport USERIF_MSS_DATABASE_RESTORE_REQUEST {
  public:
    USERIF_MSS_DATABASE_RESTORE_REQUEST();

    USERIF_MSS_DATABASE_RESTORE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const std::wstring& strName);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_DATABASE_RESTORE_REQUEST (USERIF_MSS_DATABASE_RESTORE_REQUEST&&) = default;
    USERIF_MSS_DATABASE_RESTORE_REQUEST& operator=(USERIF_MSS_DATABASE_RESTORE_REQUEST&&) = default;
    USERIF_MSS_DATABASE_RESTORE_REQUEST& operator=(const USERIF_MSS_DATABASE_RESTORE_REQUEST&) = default;
    USERIF_MSS_DATABASE_RESTORE_REQUEST(const USERIF_MSS_DATABASE_RESTORE_REQUEST&) = default;
    #else
    USERIF_MSS_DATABASE_RESTORE_REQUEST(USERIF_MSS_DATABASE_RESTORE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_DATABASE_RESTORE_REQUEST& operator=(USERIF_MSS_DATABASE_RESTORE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    std::wstring& strName() OMG_NOEXCEPT {
        return m_strName_;
    }

    const std::wstring& strName() const OMG_NOEXCEPT {
        return m_strName_;
    }

    void strName(const std::wstring& value) {
        m_strName_ = value;
    }

    void strName(std::wstring&& value) {
        m_strName_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_DATABASE_RESTORE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_DATABASE_RESTORE_REQUEST& other_) const;

    void swap(USERIF_MSS_DATABASE_RESTORE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    std::wstring m_strName_;

};

inline void swap(USERIF_MSS_DATABASE_RESTORE_REQUEST& a, USERIF_MSS_DATABASE_RESTORE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_DATABASE_RESTORE_REQUEST& sample);

class NDDSUSERDllExport USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST {
  public:
    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST();

    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST (USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST&&) = default;
    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& operator=(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST&&) = default;
    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& operator=(const USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST&) = default;
    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST(const USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST&) = default;
    #else
    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& operator=(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& other_) const;

    void swap(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& a, USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_DATABASE_BACKUP_HISTORY >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_DATABASE_BACKUP_HISTORY >;
#endif
class NDDSUSERDllExport MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT {
  public:
    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT();

    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_DATABASE_BACKUP_HISTORY, 100L >& seqBackupInfos);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT (MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT&&) = default;
    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& operator=(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT&&) = default;
    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& operator=(const MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT&) = default;
    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT(const MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT&) = default;
    #else
    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& operator=(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_DATABASE_BACKUP_HISTORY, 100L >& seqBackupInfos() OMG_NOEXCEPT {
        return m_seqBackupInfos_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_DATABASE_BACKUP_HISTORY, 100L >& seqBackupInfos() const OMG_NOEXCEPT {
        return m_seqBackupInfos_;
    }

    void seqBackupInfos(const ::rti::core::bounded_sequence< ST_MSSSUP_DATABASE_BACKUP_HISTORY, 100L >& value) {
        m_seqBackupInfos_ = value;
    }

    void seqBackupInfos(::rti::core::bounded_sequence< ST_MSSSUP_DATABASE_BACKUP_HISTORY, 100L >&& value) {
        m_seqBackupInfos_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& other_) const;

    void swap(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_DATABASE_BACKUP_HISTORY, 100L > m_seqBackupInfos_;

};

inline void swap(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& a, MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& sample);

class NDDSUSERDllExport USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST {
  public:
    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST();

    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,const std::wstring& strName);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST (USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST&&) = default;
    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& operator=(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST&&) = default;
    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& operator=(const USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST&) = default;
    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST(const USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST&) = default;
    #else
    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& operator=(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    std::wstring& strName() OMG_NOEXCEPT {
        return m_strName_;
    }

    const std::wstring& strName() const OMG_NOEXCEPT {
        return m_strName_;
    }

    void strName(const std::wstring& value) {
        m_strName_ = value;
    }

    void strName(std::wstring&& value) {
        m_strName_ = std::move(value);
    }

    bool operator == (const USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& other_) const;

    void swap(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    std::wstring m_strName_;

};

inline void swap(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& a, USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& sample);

class NDDSUSERDllExport ST_MSSSUP_IETM_MAPPING_INFO {
  public:
    ST_MSSSUP_IETM_MAPPING_INFO();

    ST_MSSSUP_IETM_MAPPING_INFO(uint32_t ulID,uint32_t ulSystemComponentID,uint32_t ulHWID,const std::wstring& strErrorURL,const std::wstring& strPreventionURL,const std::wstring& strRepairURL);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_MSSSUP_IETM_MAPPING_INFO (ST_MSSSUP_IETM_MAPPING_INFO&&) = default;
    ST_MSSSUP_IETM_MAPPING_INFO& operator=(ST_MSSSUP_IETM_MAPPING_INFO&&) = default;
    ST_MSSSUP_IETM_MAPPING_INFO& operator=(const ST_MSSSUP_IETM_MAPPING_INFO&) = default;
    ST_MSSSUP_IETM_MAPPING_INFO(const ST_MSSSUP_IETM_MAPPING_INFO&) = default;
    #else
    ST_MSSSUP_IETM_MAPPING_INFO(ST_MSSSUP_IETM_MAPPING_INFO&& other_) OMG_NOEXCEPT;  
    ST_MSSSUP_IETM_MAPPING_INFO& operator=(ST_MSSSUP_IETM_MAPPING_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulID() OMG_NOEXCEPT {
        return m_ulID_;
    }

    const uint32_t& ulID() const OMG_NOEXCEPT {
        return m_ulID_;
    }

    void ulID(uint32_t value) {
        m_ulID_ = value;
    }

    uint32_t& ulSystemComponentID() OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    const uint32_t& ulSystemComponentID() const OMG_NOEXCEPT {
        return m_ulSystemComponentID_;
    }

    void ulSystemComponentID(uint32_t value) {
        m_ulSystemComponentID_ = value;
    }

    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    std::wstring& strErrorURL() OMG_NOEXCEPT {
        return m_strErrorURL_;
    }

    const std::wstring& strErrorURL() const OMG_NOEXCEPT {
        return m_strErrorURL_;
    }

    void strErrorURL(const std::wstring& value) {
        m_strErrorURL_ = value;
    }

    void strErrorURL(std::wstring&& value) {
        m_strErrorURL_ = std::move(value);
    }
    std::wstring& strPreventionURL() OMG_NOEXCEPT {
        return m_strPreventionURL_;
    }

    const std::wstring& strPreventionURL() const OMG_NOEXCEPT {
        return m_strPreventionURL_;
    }

    void strPreventionURL(const std::wstring& value) {
        m_strPreventionURL_ = value;
    }

    void strPreventionURL(std::wstring&& value) {
        m_strPreventionURL_ = std::move(value);
    }
    std::wstring& strRepairURL() OMG_NOEXCEPT {
        return m_strRepairURL_;
    }

    const std::wstring& strRepairURL() const OMG_NOEXCEPT {
        return m_strRepairURL_;
    }

    void strRepairURL(const std::wstring& value) {
        m_strRepairURL_ = value;
    }

    void strRepairURL(std::wstring&& value) {
        m_strRepairURL_ = std::move(value);
    }

    bool operator == (const ST_MSSSUP_IETM_MAPPING_INFO& other_) const;
    bool operator != (const ST_MSSSUP_IETM_MAPPING_INFO& other_) const;

    void swap(ST_MSSSUP_IETM_MAPPING_INFO& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulID_;
    uint32_t m_ulSystemComponentID_;
    uint32_t m_ulHWID_;
    std::wstring m_strErrorURL_;
    std::wstring m_strPreventionURL_;
    std::wstring m_strRepairURL_;

};

inline void swap(ST_MSSSUP_IETM_MAPPING_INFO& a, ST_MSSSUP_IETM_MAPPING_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_MSSSUP_IETM_MAPPING_INFO& sample);

class NDDSUSERDllExport USERIF_MSS_IETM_MAPPING_INFO_REQUEST {
  public:
    USERIF_MSS_IETM_MAPPING_INFO_REQUEST();

    USERIF_MSS_IETM_MAPPING_INFO_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_IETM_MAPPING_INFO_REQUEST (USERIF_MSS_IETM_MAPPING_INFO_REQUEST&&) = default;
    USERIF_MSS_IETM_MAPPING_INFO_REQUEST& operator=(USERIF_MSS_IETM_MAPPING_INFO_REQUEST&&) = default;
    USERIF_MSS_IETM_MAPPING_INFO_REQUEST& operator=(const USERIF_MSS_IETM_MAPPING_INFO_REQUEST&) = default;
    USERIF_MSS_IETM_MAPPING_INFO_REQUEST(const USERIF_MSS_IETM_MAPPING_INFO_REQUEST&) = default;
    #else
    USERIF_MSS_IETM_MAPPING_INFO_REQUEST(USERIF_MSS_IETM_MAPPING_INFO_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_IETM_MAPPING_INFO_REQUEST& operator=(USERIF_MSS_IETM_MAPPING_INFO_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_IETM_MAPPING_INFO_REQUEST& other_) const;
    bool operator != (const USERIF_MSS_IETM_MAPPING_INFO_REQUEST& other_) const;

    void swap(USERIF_MSS_IETM_MAPPING_INFO_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_IETM_MAPPING_INFO_REQUEST& a, USERIF_MSS_IETM_MAPPING_INFO_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_IETM_MAPPING_INFO_REQUEST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_MSSSUP_IETM_MAPPING_INFO >;
template class NDDSUSERDllExport std::vector< ST_MSSSUP_IETM_MAPPING_INFO >;
#endif
class NDDSUSERDllExport MSSSUP_USE_IETM_MAPPING_INFO_RESULT {
  public:
    MSSSUP_USE_IETM_MAPPING_INFO_RESULT();

    MSSSUP_USE_IETM_MAPPING_INFO_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey,const ::rti::core::bounded_sequence< ST_MSSSUP_IETM_MAPPING_INFO, 1000L >& seqIETMs);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_IETM_MAPPING_INFO_RESULT (MSSSUP_USE_IETM_MAPPING_INFO_RESULT&&) = default;
    MSSSUP_USE_IETM_MAPPING_INFO_RESULT& operator=(MSSSUP_USE_IETM_MAPPING_INFO_RESULT&&) = default;
    MSSSUP_USE_IETM_MAPPING_INFO_RESULT& operator=(const MSSSUP_USE_IETM_MAPPING_INFO_RESULT&) = default;
    MSSSUP_USE_IETM_MAPPING_INFO_RESULT(const MSSSUP_USE_IETM_MAPPING_INFO_RESULT&) = default;
    #else
    MSSSUP_USE_IETM_MAPPING_INFO_RESULT(MSSSUP_USE_IETM_MAPPING_INFO_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_IETM_MAPPING_INFO_RESULT& operator=(MSSSUP_USE_IETM_MAPPING_INFO_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    ::rti::core::bounded_sequence< ST_MSSSUP_IETM_MAPPING_INFO, 1000L >& seqIETMs() OMG_NOEXCEPT {
        return m_seqIETMs_;
    }

    const ::rti::core::bounded_sequence< ST_MSSSUP_IETM_MAPPING_INFO, 1000L >& seqIETMs() const OMG_NOEXCEPT {
        return m_seqIETMs_;
    }

    void seqIETMs(const ::rti::core::bounded_sequence< ST_MSSSUP_IETM_MAPPING_INFO, 1000L >& value) {
        m_seqIETMs_ = value;
    }

    void seqIETMs(::rti::core::bounded_sequence< ST_MSSSUP_IETM_MAPPING_INFO, 1000L >&& value) {
        m_seqIETMs_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_IETM_MAPPING_INFO_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_IETM_MAPPING_INFO_RESULT& other_) const;

    void swap(MSSSUP_USE_IETM_MAPPING_INFO_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;
    ::rti::core::bounded_sequence< ST_MSSSUP_IETM_MAPPING_INFO, 1000L > m_seqIETMs_;

};

inline void swap(MSSSUP_USE_IETM_MAPPING_INFO_RESULT& a, MSSSUP_USE_IETM_MAPPING_INFO_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_IETM_MAPPING_INFO_RESULT& sample);

class NDDSUSERDllExport MSSSUP_USE_UPDATED_SW_RESULT {
  public:
    MSSSUP_USE_UPDATED_SW_RESULT();

    MSSSUP_USE_UPDATED_SW_RESULT(const ST_MSG_HEADER& stMsgHeader,uint16_t usSWID,const std::wstring& strSWExeName,const std::wstring& strInstallSWPath);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_UPDATED_SW_RESULT (MSSSUP_USE_UPDATED_SW_RESULT&&) = default;
    MSSSUP_USE_UPDATED_SW_RESULT& operator=(MSSSUP_USE_UPDATED_SW_RESULT&&) = default;
    MSSSUP_USE_UPDATED_SW_RESULT& operator=(const MSSSUP_USE_UPDATED_SW_RESULT&) = default;
    MSSSUP_USE_UPDATED_SW_RESULT(const MSSSUP_USE_UPDATED_SW_RESULT&) = default;
    #else
    MSSSUP_USE_UPDATED_SW_RESULT(MSSSUP_USE_UPDATED_SW_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_UPDATED_SW_RESULT& operator=(MSSSUP_USE_UPDATED_SW_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& usSWID() OMG_NOEXCEPT {
        return m_usSWID_;
    }

    const uint16_t& usSWID() const OMG_NOEXCEPT {
        return m_usSWID_;
    }

    void usSWID(uint16_t value) {
        m_usSWID_ = value;
    }

    std::wstring& strSWExeName() OMG_NOEXCEPT {
        return m_strSWExeName_;
    }

    const std::wstring& strSWExeName() const OMG_NOEXCEPT {
        return m_strSWExeName_;
    }

    void strSWExeName(const std::wstring& value) {
        m_strSWExeName_ = value;
    }

    void strSWExeName(std::wstring&& value) {
        m_strSWExeName_ = std::move(value);
    }
    std::wstring& strInstallSWPath() OMG_NOEXCEPT {
        return m_strInstallSWPath_;
    }

    const std::wstring& strInstallSWPath() const OMG_NOEXCEPT {
        return m_strInstallSWPath_;
    }

    void strInstallSWPath(const std::wstring& value) {
        m_strInstallSWPath_ = value;
    }

    void strInstallSWPath(std::wstring&& value) {
        m_strInstallSWPath_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_UPDATED_SW_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_UPDATED_SW_RESULT& other_) const;

    void swap(MSSSUP_USE_UPDATED_SW_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_usSWID_;
    std::wstring m_strSWExeName_;
    std::wstring m_strInstallSWPath_;

};

inline void swap(MSSSUP_USE_UPDATED_SW_RESULT& a, MSSSUP_USE_UPDATED_SW_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_UPDATED_SW_RESULT& sample);

class NDDSUSERDllExport ST_SW_UPDATE_LIST {
  public:
    ST_SW_UPDATE_LIST();

    ST_SW_UPDATE_LIST(uint32_t ulSWID,const std::wstring& strSWPath,const ST_SW_VERSION& stSWVersion,const ST_DATE_TIME& stSWInstallTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    ST_SW_UPDATE_LIST (ST_SW_UPDATE_LIST&&) = default;
    ST_SW_UPDATE_LIST& operator=(ST_SW_UPDATE_LIST&&) = default;
    ST_SW_UPDATE_LIST& operator=(const ST_SW_UPDATE_LIST&) = default;
    ST_SW_UPDATE_LIST(const ST_SW_UPDATE_LIST&) = default;
    #else
    ST_SW_UPDATE_LIST(ST_SW_UPDATE_LIST&& other_) OMG_NOEXCEPT;  
    ST_SW_UPDATE_LIST& operator=(ST_SW_UPDATE_LIST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    uint32_t& ulSWID() OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    const uint32_t& ulSWID() const OMG_NOEXCEPT {
        return m_ulSWID_;
    }

    void ulSWID(uint32_t value) {
        m_ulSWID_ = value;
    }

    std::wstring& strSWPath() OMG_NOEXCEPT {
        return m_strSWPath_;
    }

    const std::wstring& strSWPath() const OMG_NOEXCEPT {
        return m_strSWPath_;
    }

    void strSWPath(const std::wstring& value) {
        m_strSWPath_ = value;
    }

    void strSWPath(std::wstring&& value) {
        m_strSWPath_ = std::move(value);
    }
    ST_SW_VERSION& stSWVersion() OMG_NOEXCEPT {
        return m_stSWVersion_;
    }

    const ST_SW_VERSION& stSWVersion() const OMG_NOEXCEPT {
        return m_stSWVersion_;
    }

    void stSWVersion(const ST_SW_VERSION& value) {
        m_stSWVersion_ = value;
    }

    void stSWVersion(ST_SW_VERSION&& value) {
        m_stSWVersion_ = std::move(value);
    }
    ST_DATE_TIME& stSWInstallTime() OMG_NOEXCEPT {
        return m_stSWInstallTime_;
    }

    const ST_DATE_TIME& stSWInstallTime() const OMG_NOEXCEPT {
        return m_stSWInstallTime_;
    }

    void stSWInstallTime(const ST_DATE_TIME& value) {
        m_stSWInstallTime_ = value;
    }

    void stSWInstallTime(ST_DATE_TIME&& value) {
        m_stSWInstallTime_ = std::move(value);
    }

    bool operator == (const ST_SW_UPDATE_LIST& other_) const;
    bool operator != (const ST_SW_UPDATE_LIST& other_) const;

    void swap(ST_SW_UPDATE_LIST& other_) OMG_NOEXCEPT ;

  private:

    uint32_t m_ulSWID_;
    std::wstring m_strSWPath_;
    ST_SW_VERSION m_stSWVersion_;
    ST_DATE_TIME m_stSWInstallTime_;

};

inline void swap(ST_SW_UPDATE_LIST& a, ST_SW_UPDATE_LIST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const ST_SW_UPDATE_LIST& sample);

#if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
// On Windows, dll-export template instantiations of standard types used by
// other dll-exported types
template class NDDSUSERDllExport std::allocator< ST_SW_UPDATE_LIST >;
template class NDDSUSERDllExport std::vector< ST_SW_UPDATE_LIST >;
#endif
class NDDSUSERDllExport MSSSUP_USE_UPDATE_SW_RESULT {
  public:
    MSSSUP_USE_UPDATE_SW_RESULT();

    MSSSUP_USE_UPDATE_SW_RESULT(const ST_MSG_HEADER& stMsgHeader,const ::rti::core::bounded_sequence< ST_SW_UPDATE_LIST, 1000L >& seqSWUpdateList);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_USE_UPDATE_SW_RESULT (MSSSUP_USE_UPDATE_SW_RESULT&&) = default;
    MSSSUP_USE_UPDATE_SW_RESULT& operator=(MSSSUP_USE_UPDATE_SW_RESULT&&) = default;
    MSSSUP_USE_UPDATE_SW_RESULT& operator=(const MSSSUP_USE_UPDATE_SW_RESULT&) = default;
    MSSSUP_USE_UPDATE_SW_RESULT(const MSSSUP_USE_UPDATE_SW_RESULT&) = default;
    #else
    MSSSUP_USE_UPDATE_SW_RESULT(MSSSUP_USE_UPDATE_SW_RESULT&& other_) OMG_NOEXCEPT;  
    MSSSUP_USE_UPDATE_SW_RESULT& operator=(MSSSUP_USE_UPDATE_SW_RESULT&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    ::rti::core::bounded_sequence< ST_SW_UPDATE_LIST, 1000L >& seqSWUpdateList() OMG_NOEXCEPT {
        return m_seqSWUpdateList_;
    }

    const ::rti::core::bounded_sequence< ST_SW_UPDATE_LIST, 1000L >& seqSWUpdateList() const OMG_NOEXCEPT {
        return m_seqSWUpdateList_;
    }

    void seqSWUpdateList(const ::rti::core::bounded_sequence< ST_SW_UPDATE_LIST, 1000L >& value) {
        m_seqSWUpdateList_ = value;
    }

    void seqSWUpdateList(::rti::core::bounded_sequence< ST_SW_UPDATE_LIST, 1000L >&& value) {
        m_seqSWUpdateList_ = std::move(value);
    }

    bool operator == (const MSSSUP_USE_UPDATE_SW_RESULT& other_) const;
    bool operator != (const MSSSUP_USE_UPDATE_SW_RESULT& other_) const;

    void swap(MSSSUP_USE_UPDATE_SW_RESULT& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    ::rti::core::bounded_sequence< ST_SW_UPDATE_LIST, 1000L > m_seqSWUpdateList_;

};

inline void swap(MSSSUP_USE_UPDATE_SW_RESULT& a, MSSSUP_USE_UPDATE_SW_RESULT& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_USE_UPDATE_SW_RESULT& sample);

class NDDSUSERDllExport MSSSUP_SW_UPDATE_FINISH_ALAM {
  public:
    MSSSUP_SW_UPDATE_FINISH_ALAM();

    MSSSUP_SW_UPDATE_FINISH_ALAM(const ST_MSG_HEADER& stMsgHeader,uint32_t ulUpdateSWNo);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    MSSSUP_SW_UPDATE_FINISH_ALAM (MSSSUP_SW_UPDATE_FINISH_ALAM&&) = default;
    MSSSUP_SW_UPDATE_FINISH_ALAM& operator=(MSSSUP_SW_UPDATE_FINISH_ALAM&&) = default;
    MSSSUP_SW_UPDATE_FINISH_ALAM& operator=(const MSSSUP_SW_UPDATE_FINISH_ALAM&) = default;
    MSSSUP_SW_UPDATE_FINISH_ALAM(const MSSSUP_SW_UPDATE_FINISH_ALAM&) = default;
    #else
    MSSSUP_SW_UPDATE_FINISH_ALAM(MSSSUP_SW_UPDATE_FINISH_ALAM&& other_) OMG_NOEXCEPT;  
    MSSSUP_SW_UPDATE_FINISH_ALAM& operator=(MSSSUP_SW_UPDATE_FINISH_ALAM&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint32_t& ulUpdateSWNo() OMG_NOEXCEPT {
        return m_ulUpdateSWNo_;
    }

    const uint32_t& ulUpdateSWNo() const OMG_NOEXCEPT {
        return m_ulUpdateSWNo_;
    }

    void ulUpdateSWNo(uint32_t value) {
        m_ulUpdateSWNo_ = value;
    }

    bool operator == (const MSSSUP_SW_UPDATE_FINISH_ALAM& other_) const;
    bool operator != (const MSSSUP_SW_UPDATE_FINISH_ALAM& other_) const;

    void swap(MSSSUP_SW_UPDATE_FINISH_ALAM& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint32_t m_ulUpdateSWNo_;

};

inline void swap(MSSSUP_SW_UPDATE_FINISH_ALAM& a, MSSSUP_SW_UPDATE_FINISH_ALAM& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const MSSSUP_SW_UPDATE_FINISH_ALAM& sample);

class NDDSUSERDllExport USERIF_SW_UPDATE_LIST_REUQEST {
  public:
    USERIF_SW_UPDATE_LIST_REUQEST();

    USERIF_SW_UPDATE_LIST_REUQEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oSenderID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_SW_UPDATE_LIST_REUQEST (USERIF_SW_UPDATE_LIST_REUQEST&&) = default;
    USERIF_SW_UPDATE_LIST_REUQEST& operator=(USERIF_SW_UPDATE_LIST_REUQEST&&) = default;
    USERIF_SW_UPDATE_LIST_REUQEST& operator=(const USERIF_SW_UPDATE_LIST_REUQEST&) = default;
    USERIF_SW_UPDATE_LIST_REUQEST(const USERIF_SW_UPDATE_LIST_REUQEST&) = default;
    #else
    USERIF_SW_UPDATE_LIST_REUQEST(USERIF_SW_UPDATE_LIST_REUQEST&& other_) OMG_NOEXCEPT;  
    USERIF_SW_UPDATE_LIST_REUQEST& operator=(USERIF_SW_UPDATE_LIST_REUQEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oSenderID() OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    const uint8_t& oSenderID() const OMG_NOEXCEPT {
        return m_oSenderID_;
    }

    void oSenderID(uint8_t value) {
        m_oSenderID_ = value;
    }

    bool operator == (const USERIF_SW_UPDATE_LIST_REUQEST& other_) const;
    bool operator != (const USERIF_SW_UPDATE_LIST_REUQEST& other_) const;

    void swap(USERIF_SW_UPDATE_LIST_REUQEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oSenderID_;

};

inline void swap(USERIF_SW_UPDATE_LIST_REUQEST& a, USERIF_SW_UPDATE_LIST_REUQEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_SW_UPDATE_LIST_REUQEST& sample);

class NDDSUSERDllExport USERIF_MSS_DISK_TO_NAS_INFO {
  public:
    USERIF_MSS_DISK_TO_NAS_INFO();

    USERIF_MSS_DISK_TO_NAS_INFO(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint32_t ulNextKey);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_MSS_DISK_TO_NAS_INFO (USERIF_MSS_DISK_TO_NAS_INFO&&) = default;
    USERIF_MSS_DISK_TO_NAS_INFO& operator=(USERIF_MSS_DISK_TO_NAS_INFO&&) = default;
    USERIF_MSS_DISK_TO_NAS_INFO& operator=(const USERIF_MSS_DISK_TO_NAS_INFO&) = default;
    USERIF_MSS_DISK_TO_NAS_INFO(const USERIF_MSS_DISK_TO_NAS_INFO&) = default;
    #else
    USERIF_MSS_DISK_TO_NAS_INFO(USERIF_MSS_DISK_TO_NAS_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_MSS_DISK_TO_NAS_INFO& operator=(USERIF_MSS_DISK_TO_NAS_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint32_t& ulNextKey() OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    const uint32_t& ulNextKey() const OMG_NOEXCEPT {
        return m_ulNextKey_;
    }

    void ulNextKey(uint32_t value) {
        m_ulNextKey_ = value;
    }

    bool operator == (const USERIF_MSS_DISK_TO_NAS_INFO& other_) const;
    bool operator != (const USERIF_MSS_DISK_TO_NAS_INFO& other_) const;

    void swap(USERIF_MSS_DISK_TO_NAS_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint32_t m_ulNextKey_;

};

inline void swap(USERIF_MSS_DISK_TO_NAS_INFO& a, USERIF_MSS_DISK_TO_NAS_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_MSS_DISK_TO_NAS_INFO& sample);

class NDDSUSERDllExport USERIF_INTERNAL_IETM_REQUEST {
  public:
    USERIF_INTERNAL_IETM_REQUEST();

    USERIF_INTERNAL_IETM_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint16_t unStationID,uint16_t unShellNo,uint32_t ulHWID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_INTERNAL_IETM_REQUEST (USERIF_INTERNAL_IETM_REQUEST&&) = default;
    USERIF_INTERNAL_IETM_REQUEST& operator=(USERIF_INTERNAL_IETM_REQUEST&&) = default;
    USERIF_INTERNAL_IETM_REQUEST& operator=(const USERIF_INTERNAL_IETM_REQUEST&) = default;
    USERIF_INTERNAL_IETM_REQUEST(const USERIF_INTERNAL_IETM_REQUEST&) = default;
    #else
    USERIF_INTERNAL_IETM_REQUEST(USERIF_INTERNAL_IETM_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_INTERNAL_IETM_REQUEST& operator=(USERIF_INTERNAL_IETM_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint16_t& unStationID() OMG_NOEXCEPT {
        return m_unStationID_;
    }

    const uint16_t& unStationID() const OMG_NOEXCEPT {
        return m_unStationID_;
    }

    void unStationID(uint16_t value) {
        m_unStationID_ = value;
    }

    uint16_t& unShellNo() OMG_NOEXCEPT {
        return m_unShellNo_;
    }

    const uint16_t& unShellNo() const OMG_NOEXCEPT {
        return m_unShellNo_;
    }

    void unShellNo(uint16_t value) {
        m_unShellNo_ = value;
    }

    uint32_t& ulHWID() OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    const uint32_t& ulHWID() const OMG_NOEXCEPT {
        return m_ulHWID_;
    }

    void ulHWID(uint32_t value) {
        m_ulHWID_ = value;
    }

    bool operator == (const USERIF_INTERNAL_IETM_REQUEST& other_) const;
    bool operator != (const USERIF_INTERNAL_IETM_REQUEST& other_) const;

    void swap(USERIF_INTERNAL_IETM_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint16_t m_unStationID_;
    uint16_t m_unShellNo_;
    uint32_t m_ulHWID_;

};

inline void swap(USERIF_INTERNAL_IETM_REQUEST& a, USERIF_INTERNAL_IETM_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_INTERNAL_IETM_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTS_RECORDING_REQUEST {
  public:
    USERIF_EOTS_RECORDING_REQUEST();

    USERIF_EOTS_RECORDING_REQUEST(const ST_MSG_HEADER& stMsgHeader,uint8_t oStationID,uint8_t oSensorType,uint8_t oVideoType,uint8_t oCommand,const std::wstring& strFileName);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTS_RECORDING_REQUEST (USERIF_EOTS_RECORDING_REQUEST&&) = default;
    USERIF_EOTS_RECORDING_REQUEST& operator=(USERIF_EOTS_RECORDING_REQUEST&&) = default;
    USERIF_EOTS_RECORDING_REQUEST& operator=(const USERIF_EOTS_RECORDING_REQUEST&) = default;
    USERIF_EOTS_RECORDING_REQUEST(const USERIF_EOTS_RECORDING_REQUEST&) = default;
    #else
    USERIF_EOTS_RECORDING_REQUEST(USERIF_EOTS_RECORDING_REQUEST&& other_) OMG_NOEXCEPT;  
    USERIF_EOTS_RECORDING_REQUEST& operator=(USERIF_EOTS_RECORDING_REQUEST&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    uint8_t& oSensorType() OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    const uint8_t& oSensorType() const OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    void oSensorType(uint8_t value) {
        m_oSensorType_ = value;
    }

    uint8_t& oVideoType() OMG_NOEXCEPT {
        return m_oVideoType_;
    }

    const uint8_t& oVideoType() const OMG_NOEXCEPT {
        return m_oVideoType_;
    }

    void oVideoType(uint8_t value) {
        m_oVideoType_ = value;
    }

    uint8_t& oCommand() OMG_NOEXCEPT {
        return m_oCommand_;
    }

    const uint8_t& oCommand() const OMG_NOEXCEPT {
        return m_oCommand_;
    }

    void oCommand(uint8_t value) {
        m_oCommand_ = value;
    }

    std::wstring& strFileName() OMG_NOEXCEPT {
        return m_strFileName_;
    }

    const std::wstring& strFileName() const OMG_NOEXCEPT {
        return m_strFileName_;
    }

    void strFileName(const std::wstring& value) {
        m_strFileName_ = value;
    }

    void strFileName(std::wstring&& value) {
        m_strFileName_ = std::move(value);
    }

    bool operator == (const USERIF_EOTS_RECORDING_REQUEST& other_) const;
    bool operator != (const USERIF_EOTS_RECORDING_REQUEST& other_) const;

    void swap(USERIF_EOTS_RECORDING_REQUEST& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oStationID_;
    uint8_t m_oSensorType_;
    uint8_t m_oVideoType_;
    uint8_t m_oCommand_;
    std::wstring m_strFileName_;

};

inline void swap(USERIF_EOTS_RECORDING_REQUEST& a, USERIF_EOTS_RECORDING_REQUEST& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTS_RECORDING_REQUEST& sample);

class NDDSUSERDllExport USERIF_EOTS_RECORDING_RESPONSE {
  public:
    USERIF_EOTS_RECORDING_RESPONSE();

    USERIF_EOTS_RECORDING_RESPONSE(const ST_MSG_HEADER& stMsgHeader,uint8_t oStationID,uint8_t oSensorType,uint8_t oVideoType,uint8_t oCommand,const std::wstring& strFileName,uint8_t oResponse);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTS_RECORDING_RESPONSE (USERIF_EOTS_RECORDING_RESPONSE&&) = default;
    USERIF_EOTS_RECORDING_RESPONSE& operator=(USERIF_EOTS_RECORDING_RESPONSE&&) = default;
    USERIF_EOTS_RECORDING_RESPONSE& operator=(const USERIF_EOTS_RECORDING_RESPONSE&) = default;
    USERIF_EOTS_RECORDING_RESPONSE(const USERIF_EOTS_RECORDING_RESPONSE&) = default;
    #else
    USERIF_EOTS_RECORDING_RESPONSE(USERIF_EOTS_RECORDING_RESPONSE&& other_) OMG_NOEXCEPT;  
    USERIF_EOTS_RECORDING_RESPONSE& operator=(USERIF_EOTS_RECORDING_RESPONSE&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    uint8_t& oSensorType() OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    const uint8_t& oSensorType() const OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    void oSensorType(uint8_t value) {
        m_oSensorType_ = value;
    }

    uint8_t& oVideoType() OMG_NOEXCEPT {
        return m_oVideoType_;
    }

    const uint8_t& oVideoType() const OMG_NOEXCEPT {
        return m_oVideoType_;
    }

    void oVideoType(uint8_t value) {
        m_oVideoType_ = value;
    }

    uint8_t& oCommand() OMG_NOEXCEPT {
        return m_oCommand_;
    }

    const uint8_t& oCommand() const OMG_NOEXCEPT {
        return m_oCommand_;
    }

    void oCommand(uint8_t value) {
        m_oCommand_ = value;
    }

    std::wstring& strFileName() OMG_NOEXCEPT {
        return m_strFileName_;
    }

    const std::wstring& strFileName() const OMG_NOEXCEPT {
        return m_strFileName_;
    }

    void strFileName(const std::wstring& value) {
        m_strFileName_ = value;
    }

    void strFileName(std::wstring&& value) {
        m_strFileName_ = std::move(value);
    }
    uint8_t& oResponse() OMG_NOEXCEPT {
        return m_oResponse_;
    }

    const uint8_t& oResponse() const OMG_NOEXCEPT {
        return m_oResponse_;
    }

    void oResponse(uint8_t value) {
        m_oResponse_ = value;
    }

    bool operator == (const USERIF_EOTS_RECORDING_RESPONSE& other_) const;
    bool operator != (const USERIF_EOTS_RECORDING_RESPONSE& other_) const;

    void swap(USERIF_EOTS_RECORDING_RESPONSE& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oStationID_;
    uint8_t m_oSensorType_;
    uint8_t m_oVideoType_;
    uint8_t m_oCommand_;
    std::wstring m_strFileName_;
    uint8_t m_oResponse_;

};

inline void swap(USERIF_EOTS_RECORDING_RESPONSE& a, USERIF_EOTS_RECORDING_RESPONSE& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTS_RECORDING_RESPONSE& sample);

class NDDSUSERDllExport USERIF_EOTS_RECORDING_STATUS {
  public:
    USERIF_EOTS_RECORDING_STATUS();

    USERIF_EOTS_RECORDING_STATUS(const ST_MSG_HEADER& stMsgHeader,uint8_t oStationID,uint8_t oSensorType,uint8_t oVideoType,const std::wstring& strFileName,uint32_t ulElapsedTime);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_EOTS_RECORDING_STATUS (USERIF_EOTS_RECORDING_STATUS&&) = default;
    USERIF_EOTS_RECORDING_STATUS& operator=(USERIF_EOTS_RECORDING_STATUS&&) = default;
    USERIF_EOTS_RECORDING_STATUS& operator=(const USERIF_EOTS_RECORDING_STATUS&) = default;
    USERIF_EOTS_RECORDING_STATUS(const USERIF_EOTS_RECORDING_STATUS&) = default;
    #else
    USERIF_EOTS_RECORDING_STATUS(USERIF_EOTS_RECORDING_STATUS&& other_) OMG_NOEXCEPT;  
    USERIF_EOTS_RECORDING_STATUS& operator=(USERIF_EOTS_RECORDING_STATUS&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oStationID() OMG_NOEXCEPT {
        return m_oStationID_;
    }

    const uint8_t& oStationID() const OMG_NOEXCEPT {
        return m_oStationID_;
    }

    void oStationID(uint8_t value) {
        m_oStationID_ = value;
    }

    uint8_t& oSensorType() OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    const uint8_t& oSensorType() const OMG_NOEXCEPT {
        return m_oSensorType_;
    }

    void oSensorType(uint8_t value) {
        m_oSensorType_ = value;
    }

    uint8_t& oVideoType() OMG_NOEXCEPT {
        return m_oVideoType_;
    }

    const uint8_t& oVideoType() const OMG_NOEXCEPT {
        return m_oVideoType_;
    }

    void oVideoType(uint8_t value) {
        m_oVideoType_ = value;
    }

    std::wstring& strFileName() OMG_NOEXCEPT {
        return m_strFileName_;
    }

    const std::wstring& strFileName() const OMG_NOEXCEPT {
        return m_strFileName_;
    }

    void strFileName(const std::wstring& value) {
        m_strFileName_ = value;
    }

    void strFileName(std::wstring&& value) {
        m_strFileName_ = std::move(value);
    }
    uint32_t& ulElapsedTime() OMG_NOEXCEPT {
        return m_ulElapsedTime_;
    }

    const uint32_t& ulElapsedTime() const OMG_NOEXCEPT {
        return m_ulElapsedTime_;
    }

    void ulElapsedTime(uint32_t value) {
        m_ulElapsedTime_ = value;
    }

    bool operator == (const USERIF_EOTS_RECORDING_STATUS& other_) const;
    bool operator != (const USERIF_EOTS_RECORDING_STATUS& other_) const;

    void swap(USERIF_EOTS_RECORDING_STATUS& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oStationID_;
    uint8_t m_oSensorType_;
    uint8_t m_oVideoType_;
    std::wstring m_strFileName_;
    uint32_t m_ulElapsedTime_;

};

inline void swap(USERIF_EOTS_RECORDING_STATUS& a, USERIF_EOTS_RECORDING_STATUS& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_EOTS_RECORDING_STATUS& sample);

class NDDSUSERDllExport USERIF_REQUEST_LOGIN_INFO {
  public:
    USERIF_REQUEST_LOGIN_INFO();

    explicit USERIF_REQUEST_LOGIN_INFO(const ST_MSG_HEADER& stMsgHeader);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_REQUEST_LOGIN_INFO (USERIF_REQUEST_LOGIN_INFO&&) = default;
    USERIF_REQUEST_LOGIN_INFO& operator=(USERIF_REQUEST_LOGIN_INFO&&) = default;
    USERIF_REQUEST_LOGIN_INFO& operator=(const USERIF_REQUEST_LOGIN_INFO&) = default;
    USERIF_REQUEST_LOGIN_INFO(const USERIF_REQUEST_LOGIN_INFO&) = default;
    #else
    USERIF_REQUEST_LOGIN_INFO(USERIF_REQUEST_LOGIN_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_REQUEST_LOGIN_INFO& operator=(USERIF_REQUEST_LOGIN_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }

    bool operator == (const USERIF_REQUEST_LOGIN_INFO& other_) const;
    bool operator != (const USERIF_REQUEST_LOGIN_INFO& other_) const;

    void swap(USERIF_REQUEST_LOGIN_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;

};

inline void swap(USERIF_REQUEST_LOGIN_INFO& a, USERIF_REQUEST_LOGIN_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_REQUEST_LOGIN_INFO& sample);

class NDDSUSERDllExport USERIF_RESPONSE_LOGIN_INFO {
  public:
    USERIF_RESPONSE_LOGIN_INFO();

    USERIF_RESPONSE_LOGIN_INFO(const ST_MSG_HEADER& stMsgHeader,const std::wstring& strUserID);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RESPONSE_LOGIN_INFO (USERIF_RESPONSE_LOGIN_INFO&&) = default;
    USERIF_RESPONSE_LOGIN_INFO& operator=(USERIF_RESPONSE_LOGIN_INFO&&) = default;
    USERIF_RESPONSE_LOGIN_INFO& operator=(const USERIF_RESPONSE_LOGIN_INFO&) = default;
    USERIF_RESPONSE_LOGIN_INFO(const USERIF_RESPONSE_LOGIN_INFO&) = default;
    #else
    USERIF_RESPONSE_LOGIN_INFO(USERIF_RESPONSE_LOGIN_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_RESPONSE_LOGIN_INFO& operator=(USERIF_RESPONSE_LOGIN_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    std::wstring& strUserID() OMG_NOEXCEPT {
        return m_strUserID_;
    }

    const std::wstring& strUserID() const OMG_NOEXCEPT {
        return m_strUserID_;
    }

    void strUserID(const std::wstring& value) {
        m_strUserID_ = value;
    }

    void strUserID(std::wstring&& value) {
        m_strUserID_ = std::move(value);
    }

    bool operator == (const USERIF_RESPONSE_LOGIN_INFO& other_) const;
    bool operator != (const USERIF_RESPONSE_LOGIN_INFO& other_) const;

    void swap(USERIF_RESPONSE_LOGIN_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    std::wstring m_strUserID_;

};

inline void swap(USERIF_RESPONSE_LOGIN_INFO& a, USERIF_RESPONSE_LOGIN_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RESPONSE_LOGIN_INFO& sample);

class NDDSUSERDllExport USERIF_REQUEST_DRILL_INFO {
  public:
    USERIF_REQUEST_DRILL_INFO();

    explicit USERIF_REQUEST_DRILL_INFO(const ST_MSG_HEADER& stMsgHeader);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_REQUEST_DRILL_INFO (USERIF_REQUEST_DRILL_INFO&&) = default;
    USERIF_REQUEST_DRILL_INFO& operator=(USERIF_REQUEST_DRILL_INFO&&) = default;
    USERIF_REQUEST_DRILL_INFO& operator=(const USERIF_REQUEST_DRILL_INFO&) = default;
    USERIF_REQUEST_DRILL_INFO(const USERIF_REQUEST_DRILL_INFO&) = default;
    #else
    USERIF_REQUEST_DRILL_INFO(USERIF_REQUEST_DRILL_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_REQUEST_DRILL_INFO& operator=(USERIF_REQUEST_DRILL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }

    bool operator == (const USERIF_REQUEST_DRILL_INFO& other_) const;
    bool operator != (const USERIF_REQUEST_DRILL_INFO& other_) const;

    void swap(USERIF_REQUEST_DRILL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;

};

inline void swap(USERIF_REQUEST_DRILL_INFO& a, USERIF_REQUEST_DRILL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_REQUEST_DRILL_INFO& sample);

class NDDSUSERDllExport USERIF_RESPONSE_DRILL_INFO {
  public:
    USERIF_RESPONSE_DRILL_INFO();

    USERIF_RESPONSE_DRILL_INFO(const ST_MSG_HEADER& stMsgHeader,uint8_t oActivated);

    #ifdef RTI_CXX11_RVALUE_REFERENCES
    #ifndef RTI_CXX11_NO_IMPLICIT_MOVE_OPERATIONS
    USERIF_RESPONSE_DRILL_INFO (USERIF_RESPONSE_DRILL_INFO&&) = default;
    USERIF_RESPONSE_DRILL_INFO& operator=(USERIF_RESPONSE_DRILL_INFO&&) = default;
    USERIF_RESPONSE_DRILL_INFO& operator=(const USERIF_RESPONSE_DRILL_INFO&) = default;
    USERIF_RESPONSE_DRILL_INFO(const USERIF_RESPONSE_DRILL_INFO&) = default;
    #else
    USERIF_RESPONSE_DRILL_INFO(USERIF_RESPONSE_DRILL_INFO&& other_) OMG_NOEXCEPT;  
    USERIF_RESPONSE_DRILL_INFO& operator=(USERIF_RESPONSE_DRILL_INFO&&  other_) OMG_NOEXCEPT;
    #endif
    #endif 

    ST_MSG_HEADER& stMsgHeader() OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    const ST_MSG_HEADER& stMsgHeader() const OMG_NOEXCEPT {
        return m_stMsgHeader_;
    }

    void stMsgHeader(const ST_MSG_HEADER& value) {
        m_stMsgHeader_ = value;
    }

    void stMsgHeader(ST_MSG_HEADER&& value) {
        m_stMsgHeader_ = std::move(value);
    }
    uint8_t& oActivated() OMG_NOEXCEPT {
        return m_oActivated_;
    }

    const uint8_t& oActivated() const OMG_NOEXCEPT {
        return m_oActivated_;
    }

    void oActivated(uint8_t value) {
        m_oActivated_ = value;
    }

    bool operator == (const USERIF_RESPONSE_DRILL_INFO& other_) const;
    bool operator != (const USERIF_RESPONSE_DRILL_INFO& other_) const;

    void swap(USERIF_RESPONSE_DRILL_INFO& other_) OMG_NOEXCEPT ;

  private:

    ST_MSG_HEADER m_stMsgHeader_;
    uint8_t m_oActivated_;

};

inline void swap(USERIF_RESPONSE_DRILL_INFO& a, USERIF_RESPONSE_DRILL_INFO& b)  OMG_NOEXCEPT 
{
    a.swap(b);
}

NDDSUSERDllExport std::ostream& operator<<(std::ostream& o, const USERIF_RESPONSE_DRILL_INFO& sample);

namespace rti {
    namespace flat {
        namespace topic {
        }
    }
}
namespace dds {
    namespace topic {

        template<>
        struct topic_type_name< ST_DATE_TIME > {
            NDDSUSERDllExport static std::string value() {
                return "ST_DATE_TIME";
            }
        };

        template<>
        struct is_topic_type< ST_DATE_TIME > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_DATE_TIME > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_DATE_TIME& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_DATE_TIME& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_DATE_TIME& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_DATE_TIME& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSG_HEADER > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSG_HEADER";
            }
        };

        template<>
        struct is_topic_type< ST_MSG_HEADER > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSG_HEADER > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSG_HEADER& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSG_HEADER& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSG_HEADER& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSG_HEADER& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_ACTIVE_PULSE_DB_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_ACTIVE_PULSE_DB_REQ";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_ACTIVE_PULSE_DB_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_ACTIVE_PULSE_DB_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_ACTIVE_PULSE_DB_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_ACTIVE_PULSE_DB_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_ACTIVE_PULSE_DB_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_ACTIVE_PULSE_DB_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_A_AGC_CTRL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_A_AGC_CTRL_INFO";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_A_AGC_CTRL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_A_AGC_CTRL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_A_AGC_CTRL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_A_AGC_CTRL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_A_AGC_CTRL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_A_AGC_CTRL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_A_BEAM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_A_BEAM_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_A_BEAM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_A_BEAM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_A_BEAM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_A_BEAM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_A_BEAM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_A_BEAM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_A_DETECTION_CW_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_A_DETECTION_CW_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_A_DETECTION_CW_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_A_DETECTION_CW_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_A_DETECTION_CW_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_A_DETECTION_CW_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_A_DETECTION_CW_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_A_DETECTION_CW_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_A_DETECTION_FM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_A_DETECTION_FM_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_A_DETECTION_FM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_A_DETECTION_FM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_A_DETECTION_FM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_A_DETECTION_FM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_A_DETECTION_FM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_A_DETECTION_FM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_A_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_A_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_A_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_A_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_A_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_A_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_A_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_A_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_B_AGC_CTRL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_B_AGC_CTRL_INFO";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_B_AGC_CTRL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_B_AGC_CTRL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_B_AGC_CTRL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_B_AGC_CTRL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_B_AGC_CTRL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_B_AGC_CTRL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_B_BEAM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_B_BEAM_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_B_BEAM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_B_BEAM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_B_BEAM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_B_BEAM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_B_BEAM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_B_BEAM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_B_DETECTION_CW_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_B_DETECTION_CW_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_B_DETECTION_CW_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_B_DETECTION_CW_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_B_DETECTION_CW_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_B_DETECTION_CW_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_B_DETECTION_CW_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_B_DETECTION_CW_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_B_DETECTION_FM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_B_DETECTION_FM_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_B_DETECTION_FM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_B_DETECTION_FM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_B_DETECTION_FM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_B_DETECTION_FM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_B_DETECTION_FM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_B_DETECTION_FM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_B_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_B_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_B_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_B_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_B_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_B_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_B_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_B_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_C_AGC_CTRL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_C_AGC_CTRL_INFO";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_C_AGC_CTRL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_C_AGC_CTRL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_C_AGC_CTRL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_C_AGC_CTRL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_C_AGC_CTRL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_C_AGC_CTRL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_C_BEAM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_C_BEAM_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_C_BEAM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_C_BEAM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_C_BEAM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_C_BEAM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_C_BEAM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_C_BEAM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_C_DETECTION_CW_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_C_DETECTION_CW_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_C_DETECTION_CW_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_C_DETECTION_CW_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_C_DETECTION_CW_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_C_DETECTION_CW_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_C_DETECTION_CW_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_C_DETECTION_CW_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_C_DETECTION_FM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_C_DETECTION_FM_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_C_DETECTION_FM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_C_DETECTION_FM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_C_DETECTION_FM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_C_DETECTION_FM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_C_DETECTION_FM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_C_DETECTION_FM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_C_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_C_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_C_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_C_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_C_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_C_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_C_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_C_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< BISDSP_BIS_DPD_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "BISDSP_BIS_DPD_INFO";
            }
        };

        template<>
        struct is_topic_type< BISDSP_BIS_DPD_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< BISDSP_BIS_DPD_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const BISDSP_BIS_DPD_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(BISDSP_BIS_DPD_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(BISDSP_BIS_DPD_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(BISDSP_BIS_DPD_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_A_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_A_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_A_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_A_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_A_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_B_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_B_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_B_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_B_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_B_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_C_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_C_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_C_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_C_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_C_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_IFC_POWERSUPPLY_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_IFC_POWERSUPPLY_STATUS";
            }
        };

        template<>
        struct is_topic_type< ST_IFC_POWERSUPPLY_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_IFC_POWERSUPPLY_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_IFC_POWERSUPPLY_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_IFC_POWERSUPPLY_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_IFC_POWERSUPPLY_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_IFC_POWERSUPPLY_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SENSOR_IFC_STATUS";
            }
        };

        template<>
        struct is_topic_type< ST_SENSOR_IFC_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SENSOR_IFC_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SENSOR_IFC_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SENSOR_IFC_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SENSOR_IFC_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_SENSOR_IFC_STATUS";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_SENSOR_IFC_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_SENSOR_IFC_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_SENSOR_IFC_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_SENSOR_IFC_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_SENSOR_IFC_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_SENSOR_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_SENSOR_STATUS";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_SENSOR_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_SENSOR_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_SENSOR_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_SENSOR_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_SENSOR_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_SENSOR_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_BIS_SENSOR_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_BIS_SENSOR_STATUS";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_BIS_SENSOR_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_BIS_SENSOR_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_BIS_SENSOR_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_BIS_SENSOR_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_BIS_SENSOR_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_BIS_SENSOR_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_A_FREQ_DETECTION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_A_FREQ_DETECTION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_A_FREQ_DETECTION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_A_FREQ_DETECTION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_A_FREQ_DETECTION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_A_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_A_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_A_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_A_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_A_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_A_TIME_DETECTION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_A_TIME_DETECTION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_A_TIME_DETECTION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_A_TIME_DETECTION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_A_TIME_DETECTION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_A_TIME_DETECTION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_A_TIME_DETECTION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_A_TIME_DETECTION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_B_FREQ_DETECTION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_B_FREQ_DETECTION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_B_FREQ_DETECTION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_B_FREQ_DETECTION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_B_FREQ_DETECTION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_B_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_B_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_B_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_B_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_B_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_B_TIME_DETECTION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_B_TIME_DETECTION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_B_TIME_DETECTION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_B_TIME_DETECTION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_B_TIME_DETECTION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_B_TIME_DETECTION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_B_TIME_DETECTION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_B_TIME_DETECTION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_C_FREQ_DETECTION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_C_FREQ_DETECTION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_C_FREQ_DETECTION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_C_FREQ_DETECTION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_C_FREQ_DETECTION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_C_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_C_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_C_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_C_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_C_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_C_TIME_DETECTION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_C_TIME_DETECTION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_C_TIME_DETECTION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_C_TIME_DETECTION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_C_TIME_DETECTION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_C_TIME_DETECTION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_C_TIME_DETECTION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_C_TIME_DETECTION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_TIME_DM_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_TIME_DM_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_TIME_DM_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_TIME_DM_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_TIME_DM_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_TIME_DM_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_TIME_DM_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_TIME_DM_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_FREQ_DM_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_FREQ_DM_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_FREQ_DM_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_FREQ_DM_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_FREQ_DM_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_FREQ_DM_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_FREQ_DM_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_FREQ_DM_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_SENSOR_IFC_STATUS";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_SENSOR_IFC_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_SENSOR_IFC_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_SENSOR_IFC_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_SENSOR_IFC_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_SENSOR_IFC_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_SENSOR_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_SENSOR_STATUS";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_SENSOR_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_SENSOR_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_SENSOR_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_SENSOR_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_SENSOR_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_SENSOR_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_LAS_SENSOR_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_LAS_SENSOR_STATUS";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_LAS_SENSOR_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_LAS_SENSOR_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_LAS_SENSOR_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_LAS_SENSOR_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_LAS_SENSOR_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_LAS_SENSOR_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_DETECTION_EXCLUSION_FREQ_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_DETECTION_EXCLUSION_FREQ_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_DETECTION_EXCLUSION_FREQ_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_DETECTION_EXCLUSION_FREQ_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_DETECTION_EXCLUSION_FREQ_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_DETECTION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_DETECTION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_DETECTION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_DETECTION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_DETECTION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_DETECTION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_DETECTION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_DETECTION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_SENSOR_IFC_STATUS";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_SENSOR_IFC_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_SENSOR_IFC_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_SENSOR_IFC_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_SENSOR_IFC_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_SENSOR_IFC_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_SENSOR_IFC_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_SENSOR_SIG > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_SENSOR_SIG";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_SENSOR_SIG > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_SENSOR_SIG > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_SENSOR_SIG& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_SENSOR_SIG& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_SENSOR_SIG& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_SENSOR_SIG& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_SENSOR_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_SENSOR_STATUS";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_SENSOR_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_SENSOR_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_SENSOR_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_SENSOR_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_SENSOR_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_SENSOR_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_SENSOR_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_SENSOR_STATUS";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_SENSOR_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_SENSOR_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_SENSOR_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_SENSOR_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_SENSOR_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_SENSOR_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_SIMULATOR_SIG > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_SIMULATOR_SIG";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_SIMULATOR_SIG > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_SIMULATOR_SIG > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_SIMULATOR_SIG& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_SIMULATOR_SIG& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_SIMULATOR_SIG& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_SIMULATOR_SIG& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< CTRMGR_MAS_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "CTRMGR_MAS_SIMULATION_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< CTRMGR_MAS_SIMULATION_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< CTRMGR_MAS_SIMULATION_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const CTRMGR_MAS_SIMULATION_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(CTRMGR_MAS_SIMULATION_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(CTRMGR_MAS_SIMULATION_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(CTRMGR_MAS_SIMULATION_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_TS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_TS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_AS_TS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_TS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_TS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_TS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_TS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_TS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BI_TS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BI_TS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_BI_TS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BI_TS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BI_TS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BI_TS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BI_TS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BI_TS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SOUND_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SOUND_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SOUND_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SOUND_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SOUND_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SOUND_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SOUND_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SOUND_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_PERIOD_PARAM_MNG_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_PERIOD_PARAM_MNG_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_PERIOD_PARAM_MNG_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_PERIOD_PARAM_MNG_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_PERIOD_PARAM_MNG_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_PERIOD_PARAM_MNG_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_PERIOD_PARAM_MNG_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_PERIOD_PARAM_MNG_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT";
            }
        };

        template<>
        struct is_topic_type< DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_AS_THREAT_AREA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_AS_THREAT_AREA_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_AS_THREAT_AREA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_AS_THREAT_AREA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_AS_THREAT_AREA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_AS_THREAT_AREA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_AS_THREAT_AREA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_AS_THREAT_AREA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_BIS_ACTIVE_PULSE_DB > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_BIS_ACTIVE_PULSE_DB";
            }
        };

        template<>
        struct is_topic_type< DATMGR_BIS_ACTIVE_PULSE_DB > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_BIS_ACTIVE_PULSE_DB > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_BIS_ACTIVE_PULSE_DB& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_BIS_ACTIVE_PULSE_DB& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_BIS_ACTIVE_PULSE_DB& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_BIS_ACTIVE_PULSE_DB& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_BIS_AUDIO_SIG_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_BIS_AUDIO_SIG_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_BIS_AUDIO_SIG_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_BIS_AUDIO_SIG_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_BIS_AUDIO_SIG_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_BIS_AUDIO_SIG_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_BIS_AUDIO_SIG_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_BIS_AUDIO_SIG_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_BIS_SOURCE_DB_CONTROL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_BIS_SOURCE_DB_CONTROL_RESULT";
            }
        };

        template<>
        struct is_topic_type< DATMGR_BIS_SOURCE_DB_CONTROL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_BIS_SOURCE_DB_CONTROL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_BIS_SOURCE_DB_CONTROL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_SOURCE_DB > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_SOURCE_DB";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_SOURCE_DB > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_SOURCE_DB > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_SOURCE_DB& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_SOURCE_DB& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_SOURCE_DB& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_SOURCE_DB& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_SOURCE_TYPE_MATCHING_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_SOURCE_TYPE_MATCHING_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_SOURCE_TYPE_MATCHING_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_SOURCE_TYPE_MATCHING_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_SOURCE_TYPE_MATCHING_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_SOURCE_TYPE_MATCHING_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_SOURCE_TYPE_MATCHING_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_SOURCE_TYPE_MATCHING_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_SOURCE_SHIP_MATCHING_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_SOURCE_SHIP_MATCHING_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_SOURCE_SHIP_MATCHING_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_SOURCE_SHIP_MATCHING_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_SOURCE_SHIP_MATCHING_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_SOURCE_SHIP_MATCHING_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_SOURCE_SHIP_MATCHING_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_SOURCE_SHIP_MATCHING_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_BIS_SOURCE_DB_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_BIS_SOURCE_DB_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_BIS_SOURCE_DB_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_BIS_SOURCE_DB_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_BIS_SOURCE_DB_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_BIS_SOURCE_DB_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_BIS_SOURCE_DB_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_BIS_SOURCE_DB_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HARMONIC_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HARMONIC_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_HARMONIC_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HARMONIC_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HARMONIC_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HARMONIC_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HARMONIC_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HARMONIC_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_FEATURE_FREQ_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_FEATURE_FREQ_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_FEATURE_FREQ_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_FEATURE_FREQ_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_FEATURE_FREQ_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_FEATURE_FREQ_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_FEATURE_FREQ_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_FEATURE_FREQ_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_CLA_RESULT_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_CLA_RESULT_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_CLA_RESULT_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_CLA_RESULT_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_CLA_RESULT_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_CLA_RESULT_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_CLA_RESULT_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_CLA_RESULT_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_CLASSIFICATION_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_CLASSIFICATION_RESULT";
            }
        };

        template<>
        struct is_topic_type< DATMGR_CLASSIFICATION_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_CLASSIFICATION_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_CLASSIFICATION_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_CLASSIFICATION_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_CLASSIFICATION_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_CLASSIFICATION_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_CLASSIFICATION_RESULT_LIST > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_CLASSIFICATION_RESULT_LIST";
            }
        };

        template<>
        struct is_topic_type< DATMGR_CLASSIFICATION_RESULT_LIST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_CLASSIFICATION_RESULT_LIST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_CLASSIFICATION_RESULT_LIST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_CLASSIFICATION_RESULT_LIST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_CLASSIFICATION_RESULT_LIST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_CLASSIFICATION_RESULT_LIST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_CLA_MANAGE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_CLA_MANAGE_RESULT";
            }
        };

        template<>
        struct is_topic_type< DATMGR_CLA_MANAGE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_CLA_MANAGE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_CLA_MANAGE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_CLA_MANAGE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_CLA_MANAGE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_CLA_MANAGE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_LAS_AUDIO_SIG_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_LAS_AUDIO_SIG_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_LAS_AUDIO_SIG_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_LAS_AUDIO_SIG_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_LAS_AUDIO_SIG_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_LAS_AUDIO_SIG_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_LAS_AUDIO_SIG_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_LAS_AUDIO_SIG_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EXTRACTED_GRAM > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EXTRACTED_GRAM";
            }
        };

        template<>
        struct is_topic_type< ST_EXTRACTED_GRAM > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EXTRACTED_GRAM > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EXTRACTED_GRAM& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EXTRACTED_GRAM& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EXTRACTED_GRAM& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EXTRACTED_GRAM& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_LAS_EXTRACTED_GRAM_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_LAS_EXTRACTED_GRAM_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_LAS_EXTRACTED_GRAM_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_LAS_EXTRACTED_GRAM_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_LAS_EXTRACTED_GRAM_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_LAS_EXTRACTED_GRAM_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_LAS_EXTRACTED_GRAM_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_LAS_EXTRACTED_GRAM_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_MAS_AUDIO_SIG_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_MAS_AUDIO_SIG_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_MAS_AUDIO_SIG_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_MAS_AUDIO_SIG_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_MAS_AUDIO_SIG_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_MAS_AUDIO_SIG_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_MAS_AUDIO_SIG_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_MAS_AUDIO_SIG_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_MAS_EXTRACTED_GRAM_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_MAS_EXTRACTED_GRAM_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_MAS_EXTRACTED_GRAM_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_MAS_EXTRACTED_GRAM_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_MAS_EXTRACTED_GRAM_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_MAS_EXTRACTED_GRAM_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_MAS_EXTRACTED_GRAM_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_MAS_EXTRACTED_GRAM_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OI_CLASSIFICATION_GRAM_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OI_CLASSIFICATION_GRAM_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OI_CLASSIFICATION_GRAM_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OI_CLASSIFICATION_GRAM_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OI_CLASSIFICATION_GRAM_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OI_CLASSIFICATION_GRAM_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OI_CLASSIFICATION_GRAM_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OI_CLASSIFICATION_GRAM_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OPER_BACKUP_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OPER_BACKUP_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OPER_BACKUP_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OPER_BACKUP_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OPER_BACKUP_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OPER_BACKUP_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OPER_BACKUP_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OPER_BACKUP_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OPER_DELETE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OPER_DELETE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OPER_DELETE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OPER_DELETE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OPER_DELETE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OPER_DELETE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OPER_DELETE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OPER_DELETE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OPER_EDIT_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OPER_EDIT_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OPER_EDIT_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OPER_EDIT_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OPER_EDIT_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OPER_EDIT_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OPER_EDIT_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OPER_EDIT_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_OPER_HISTORY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_OPER_HISTORY";
            }
        };

        template<>
        struct is_topic_type< ST_OPER_HISTORY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_OPER_HISTORY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_OPER_HISTORY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_OPER_HISTORY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_OPER_HISTORY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_OPER_HISTORY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OPER_HISTORY_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OPER_HISTORY_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OPER_HISTORY_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OPER_HISTORY_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OPER_HISTORY_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OPER_HISTORY_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OPER_HISTORY_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OPER_HISTORY_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_OPER_DATA_LIST > {
            NDDSUSERDllExport static std::string value() {
                return "ST_OPER_DATA_LIST";
            }
        };

        template<>
        struct is_topic_type< ST_OPER_DATA_LIST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_OPER_DATA_LIST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_OPER_DATA_LIST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_OPER_DATA_LIST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_OPER_DATA_LIST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_OPER_DATA_LIST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OPER_LIST_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OPER_LIST_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OPER_LIST_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OPER_LIST_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OPER_LIST_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OPER_LIST_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OPER_LIST_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OPER_LIST_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OPER_RESTORE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OPER_RESTORE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OPER_RESTORE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OPER_RESTORE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OPER_RESTORE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OPER_RESTORE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OPER_RESTORE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OPER_RESTORE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_OPER_SAVE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_OPER_SAVE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_OPER_SAVE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_OPER_SAVE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_OPER_SAVE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_OPER_SAVE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_OPER_SAVE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_OPER_SAVE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_RAWAUDIO_CONTROL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_RAWAUDIO_CONTROL_RESULT";
            }
        };

        template<>
        struct is_topic_type< DATMGR_RAWAUDIO_CONTROL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_RAWAUDIO_CONTROL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_RAWAUDIO_CONTROL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_RAWAUDIO_CONTROL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_RAWAUDIO_CONTROL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_RAWAUDIO_CONTROL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_RAWAUDIO_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_RAWAUDIO_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_RAWAUDIO_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_RAWAUDIO_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_RAWAUDIO_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_RAWAUDIO_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_RAWAUDIO_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_RAWAUDIO_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_RAWAUDIO_LIST_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_RAWAUDIO_LIST_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_RAWAUDIO_LIST_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_RAWAUDIO_LIST_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_RAWAUDIO_LIST_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_RAWAUDIO_LIST_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_RAWAUDIO_LIST_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_RAWAUDIO_LIST_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SCREENSHOT_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SCREENSHOT_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SCREENSHOT_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SCREENSHOT_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SCREENSHOT_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SCREENSHOT_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SCREENSHOT_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SCREENSHOT_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_SAVED_SCREENSHOT_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_SAVED_SCREENSHOT_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_SAVED_SCREENSHOT_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_SAVED_SCREENSHOT_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_SAVED_SCREENSHOT_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_SAVED_SCREENSHOT_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_SAVED_SCREENSHOT_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_SAVED_SCREENSHOT_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_SCREENSHOT_CONTROL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_SCREENSHOT_CONTROL_RESULT";
            }
        };

        template<>
        struct is_topic_type< DATMGR_SCREENSHOT_CONTROL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_SCREENSHOT_CONTROL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_SCREENSHOT_CONTROL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_SCREENSHOT_CONTROL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_SCREENSHOT_CONTROL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_SCREENSHOT_CONTROL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_SCREENSHOT_LIST_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_SCREENSHOT_LIST_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_SCREENSHOT_LIST_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_SCREENSHOT_LIST_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_SCREENSHOT_LIST_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_SCREENSHOT_LIST_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_SCREENSHOT_LIST_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_SCREENSHOT_LIST_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SENSOR_PROTECTION_AREA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SENSOR_PROTECTION_AREA_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SENSOR_PROTECTION_AREA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SENSOR_PROTECTION_AREA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SENSOR_PROTECTION_AREA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SENSOR_PROTECTION_AREA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SENSOR_PROTECTION_AREA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SENSOR_PROTECTION_AREA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_SENSOR_PROTECTION_CONTROL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_SENSOR_PROTECTION_CONTROL_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_SENSOR_PROTECTION_CONTROL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_SENSOR_PROTECTION_CONTROL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_SENSOR_PROTECTION_CONTROL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_SENSOR_PROTECTION_CONTROL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_SENSOR_PROTECTION_CONTROL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_SENSOR_PROTECTION_CONTROL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_STABILIZED_GRAM_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_STABILIZED_GRAM_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_STABILIZED_GRAM_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_STABILIZED_GRAM_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_STABILIZED_GRAM_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_STABILIZED_GRAM_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_STABILIZED_GRAM_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_STABILIZED_GRAM_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_STORAGE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_STORAGE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_STORAGE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_STORAGE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_STORAGE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_STORAGE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_STORAGE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_STORAGE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_STORAGE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_STORAGE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_STORAGE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_STORAGE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_STORAGE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_STORAGE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_STORAGE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_STORAGE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SAVE_LAS_TIME_DM_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SAVE_LAS_TIME_DM_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_SAVE_LAS_TIME_DM_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SAVE_LAS_TIME_DM_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SAVE_LAS_TIME_DM_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SAVE_LAS_TIME_DM_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SAVE_LAS_TIME_DM_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SAVE_LAS_TIME_DM_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SAVE_LAS_FREQ_DM_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SAVE_LAS_FREQ_DM_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SAVE_LAS_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SAVE_LAS_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< ST_SAVE_LAS_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SAVE_LAS_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SAVE_LAS_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SAVE_LAS_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SAVE_LAS_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SAVE_LAS_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_STRUCT_SAVE > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_STRUCT_SAVE";
            }
        };

        template<>
        struct is_topic_type< DATMGR_STRUCT_SAVE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_STRUCT_SAVE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_STRUCT_SAVE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_STRUCT_SAVE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_STRUCT_SAVE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_STRUCT_SAVE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_TACTICAL_AREA_CONTROL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_TACTICAL_AREA_CONTROL_RESULT";
            }
        };

        template<>
        struct is_topic_type< DATMGR_TACTICAL_AREA_CONTROL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_TACTICAL_AREA_CONTROL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_TACTICAL_AREA_CONTROL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_TACTICAL_AREA_CONTROL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_TACTICAL_AREA_CONTROL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_TACTICAL_AREA_CONTROL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_DRAW_OBJ > {
            NDDSUSERDllExport static std::string value() {
                return "ST_DRAW_OBJ";
            }
        };

        template<>
        struct is_topic_type< ST_DRAW_OBJ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_DRAW_OBJ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_DRAW_OBJ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_DRAW_OBJ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_DRAW_OBJ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_DRAW_OBJ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TACTICAL_AREA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TACTICAL_AREA";
            }
        };

        template<>
        struct is_topic_type< ST_TACTICAL_AREA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TACTICAL_AREA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TACTICAL_AREA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TACTICAL_AREA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TACTICAL_AREA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TACTICAL_AREA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_TACTICAL_AREA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_TACTICAL_AREA_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_TACTICAL_AREA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_TACTICAL_AREA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_TACTICAL_AREA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_TACTICAL_AREA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_TACTICAL_AREA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_TACTICAL_AREA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TARGET_DB_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TARGET_DB_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_TARGET_DB_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TARGET_DB_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TARGET_DB_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TARGET_DB_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TARGET_DB_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TARGET_DB_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TARGET_DB_AS_STRENGTH > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TARGET_DB_AS_STRENGTH";
            }
        };

        template<>
        struct is_topic_type< ST_TARGET_DB_AS_STRENGTH > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TARGET_DB_AS_STRENGTH > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TARGET_DB_AS_STRENGTH& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TARGET_DB_AS_STRENGTH& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TARGET_DB_AS_STRENGTH& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TARGET_DB_AS_STRENGTH& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TARGET_DB_BIS_STRENGTH > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TARGET_DB_BIS_STRENGTH";
            }
        };

        template<>
        struct is_topic_type< ST_TARGET_DB_BIS_STRENGTH > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TARGET_DB_BIS_STRENGTH > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TARGET_DB_BIS_STRENGTH& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TARGET_DB_BIS_STRENGTH& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TARGET_DB_BIS_STRENGTH& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TARGET_DB_BIS_STRENGTH& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TARGET_DB_BB_SOURCE_LEVEL > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TARGET_DB_BB_SOURCE_LEVEL";
            }
        };

        template<>
        struct is_topic_type< ST_TARGET_DB_BB_SOURCE_LEVEL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TARGET_DB_BB_SOURCE_LEVEL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TARGET_DB_BB_SOURCE_LEVEL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TARGET_DB_BB_SOURCE_LEVEL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TARGET_DB_BB_SOURCE_LEVEL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TARGET_DB_BB_SOURCE_LEVEL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TARGET_DB_NB_SOURCE_LEVEL > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TARGET_DB_NB_SOURCE_LEVEL";
            }
        };

        template<>
        struct is_topic_type< ST_TARGET_DB_NB_SOURCE_LEVEL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TARGET_DB_NB_SOURCE_LEVEL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TARGET_DB_NB_SOURCE_LEVEL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TARGET_DB_NB_SOURCE_LEVEL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TARGET_DB_NB_SOURCE_LEVEL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TARGET_DB_NB_SOURCE_LEVEL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_TARGET_DB_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_TARGET_DB_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_TARGET_DB_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_TARGET_DB_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_TARGET_DB_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_TARGET_DB_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_TARGET_DB_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_TARGET_DB_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_THRESH_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_THRESH_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_THRESH_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_THRESH_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_THRESH_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_THRESH_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_THRESH_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_THRESH_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_THRESH_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_THRESH_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_THRESH_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_THRESH_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_THRESH_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_THRESH_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_THRESH_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_THRESH_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_THRESH_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_THRESH_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_THRESH_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_THRESH_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_THRESH_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_THRESH_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_THRESH_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_THRESH_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_TGTTRK_PARAM_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_TGTTRK_PARAM_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_TGTTRK_PARAM_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_TGTTRK_PARAM_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_TGTTRK_PARAM_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_TGTTRK_PARAM_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_TGTTRK_PARAM_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_TGTTRK_PARAM_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_THREAT_AREA > {
            NDDSUSERDllExport static std::string value() {
                return "ST_THREAT_AREA";
            }
        };

        template<>
        struct is_topic_type< ST_THREAT_AREA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_THREAT_AREA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_THREAT_AREA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_THREAT_AREA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_THREAT_AREA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_THREAT_AREA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_THREAT_AREA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_THREAT_AREA_INFO";
            }
        };

        template<>
        struct is_topic_type< DATMGR_THREAT_AREA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_THREAT_AREA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_THREAT_AREA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_THREAT_AREA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_THREAT_AREA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_THREAT_AREA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< DATMGR_USER_LOGIN_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "DATMGR_USER_LOGIN_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< DATMGR_USER_LOGIN_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< DATMGR_USER_LOGIN_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const DATMGR_USER_LOGIN_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(DATMGR_USER_LOGIN_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(DATMGR_USER_LOGIN_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(DATMGR_USER_LOGIN_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SEN_DET_CHK > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SEN_DET_CHK";
            }
        };

        template<>
        struct is_topic_type< ST_SEN_DET_CHK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SEN_DET_CHK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SEN_DET_CHK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SEN_DET_CHK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SEN_DET_CHK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SEN_DET_CHK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SEN_DET_SEL > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SEN_DET_SEL";
            }
        };

        template<>
        struct is_topic_type< ST_SEN_DET_SEL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SEN_DET_SEL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SEN_DET_SEL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SEN_DET_SEL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SEN_DET_SEL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SEN_DET_SEL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SEN_DISTANCE > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SEN_DISTANCE";
            }
        };

        template<>
        struct is_topic_type< ST_SEN_DISTANCE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SEN_DISTANCE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SEN_DISTANCE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SEN_DISTANCE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SEN_DISTANCE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SEN_DISTANCE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SEN_BEARING > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SEN_BEARING";
            }
        };

        template<>
        struct is_topic_type< ST_SEN_BEARING > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SEN_BEARING > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SEN_BEARING& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SEN_BEARING& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SEN_BEARING& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SEN_BEARING& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_TARGET_POS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_TARGET_POS";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_TARGET_POS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_TARGET_POS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_TARGET_POS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_TARGET_POS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_TARGET_POS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_TARGET_POS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HIS_FREQ_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HIS_FREQ_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_HIS_FREQ_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HIS_FREQ_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HIS_FREQ_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HIS_FREQ_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HIS_FREQ_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HIS_FREQ_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SCENARIO_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SCENARIO_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SCENARIO_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SCENARIO_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SCENARIO_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SCENARIO_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SCENARIO_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SCENARIO_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< HUSSIS_SCENARIO_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "HUSSIS_SCENARIO_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< HUSSIS_SCENARIO_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< HUSSIS_SCENARIO_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const HUSSIS_SCENARIO_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(HUSSIS_SCENARIO_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(HUSSIS_SCENARIO_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(HUSSIS_SCENARIO_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HIS_TARGET_INFORMATION > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HIS_TARGET_INFORMATION";
            }
        };

        template<>
        struct is_topic_type< ST_HIS_TARGET_INFORMATION > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HIS_TARGET_INFORMATION > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HIS_TARGET_INFORMATION& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HIS_TARGET_INFORMATION& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HIS_TARGET_INFORMATION& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HIS_TARGET_INFORMATION& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< HUSSIS_TARGET_INFORMATION > {
            NDDSUSERDllExport static std::string value() {
                return "HUSSIS_TARGET_INFORMATION";
            }
        };

        template<>
        struct is_topic_type< HUSSIS_TARGET_INFORMATION > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< HUSSIS_TARGET_INFORMATION > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const HUSSIS_TARGET_INFORMATION& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(HUSSIS_TARGET_INFORMATION& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(HUSSIS_TARGET_INFORMATION& sample);

            NDDSUSERDllExport 
            static void allocate_sample(HUSSIS_TARGET_INFORMATION& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< HUSS_CSCI_COM_MSG > {
            NDDSUSERDllExport static std::string value() {
                return "HUSS_CSCI_COM_MSG";
            }
        };

        template<>
        struct is_topic_type< HUSS_CSCI_COM_MSG > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< HUSS_CSCI_COM_MSG > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const HUSS_CSCI_COM_MSG& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(HUSS_CSCI_COM_MSG& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(HUSS_CSCI_COM_MSG& sample);

            NDDSUSERDllExport 
            static void allocate_sample(HUSS_CSCI_COM_MSG& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_CHANNEL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_CHANNEL_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_CHANNEL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_CHANNEL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_CHANNEL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_CHANNEL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_CHANNEL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_CHANNEL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TX_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TX_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_TX_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TX_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TX_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TX_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TX_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TX_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MEAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MEAS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_MEAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MEAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MEAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MEAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MEAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MEAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_DETECT_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_DETECT_DATA";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_DETECT_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_DETECT_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_DETECT_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_DETECT_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_DETECT_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_DETECT_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TH_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TH_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_TH_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TH_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TH_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TH_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TH_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TH_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_AS_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_MODE_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_MODE_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_MODE_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_MODE_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_MODE_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_MODE_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_MODE_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_MODE_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_REV_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_REV_DATA";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_REV_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_REV_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_REV_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_REV_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_REV_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_REV_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TM_STATUS_T > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TM_STATUS_T";
            }
        };

        template<>
        struct is_topic_type< ST_TM_STATUS_T > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TM_STATUS_T > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TM_STATUS_T& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TM_STATUS_T& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TM_STATUS_T& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TM_STATUS_T& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_PS_STATUS_T > {
            NDDSUSERDllExport static std::string value() {
                return "ST_PS_STATUS_T";
            }
        };

        template<>
        struct is_topic_type< ST_PS_STATUS_T > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_PS_STATUS_T > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_PS_STATUS_T& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_PS_STATUS_T& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_PS_STATUS_T& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_PS_STATUS_T& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_PS_STATUS_F > {
            NDDSUSERDllExport static std::string value() {
                return "ST_PS_STATUS_F";
            }
        };

        template<>
        struct is_topic_type< ST_PS_STATUS_F > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_PS_STATUS_F > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_PS_STATUS_F& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_PS_STATUS_F& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_PS_STATUS_F& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_PS_STATUS_F& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_NIC_CONF > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_NIC_CONF";
            }
        };

        template<>
        struct is_topic_type< ST_AS_NIC_CONF > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_NIC_CONF > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_NIC_CONF& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_NIC_CONF& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_NIC_CONF& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_NIC_CONF& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_TILT_SENSOR > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_TILT_SENSOR";
            }
        };

        template<>
        struct is_topic_type< ST_AS_TILT_SENSOR > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_TILT_SENSOR > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_TILT_SENSOR& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_TILT_SENSOR& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_TILT_SENSOR& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_TILT_SENSOR& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_AUX_SENSOR > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_AUX_SENSOR";
            }
        };

        template<>
        struct is_topic_type< ST_AS_AUX_SENSOR > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_AUX_SENSOR > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_AUX_SENSOR& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_AUX_SENSOR& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_AUX_SENSOR& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_AUX_SENSOR& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_PSU_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_PSU_STATUS";
            }
        };

        template<>
        struct is_topic_type< ST_AS_PSU_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_PSU_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_PSU_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_PSU_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_PSU_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_PSU_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_ASE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_ASE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_ASE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_ASE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_ASE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_ASE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_ASE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_ASE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_SENSOR_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_SENSOR_STATUS";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_SENSOR_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_SENSOR_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_SENSOR_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_SENSOR_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_SENSOR_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_SENSOR_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_STEERING_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_STEERING_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_STEERING_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_STEERING_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_STEERING_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_STEERING_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_STEERING_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_STEERING_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_AIS_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_AIS_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_AIS_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_AIS_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_AIS_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_AIS_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_AIS_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_AIS_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AIS_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AIS_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_AIS_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AIS_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AIS_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AIS_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AIS_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AIS_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_AIS_TARGET_DATA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_AIS_TARGET_DATA_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_AIS_TARGET_DATA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_AIS_TARGET_DATA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_AIS_TARGET_DATA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_AIS_TARGET_DATA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_AIS_TARGET_DATA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_AIS_TARGET_DATA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_AUTH_CONTROL_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_AUTH_CONTROL_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_AUTH_CONTROL_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_AUTH_CONTROL_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_AUTH_CONTROL_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_AUTH_FAIL_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_AUTH_FAIL_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_AUTH_FAIL_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_AUTH_FAIL_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_AUTH_FAIL_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_AUTH_FAIL_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_AUTH_FAIL_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_AUTH_FAIL_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_AUTH_INFO_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_AUTH_INFO_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_AUTH_INFO_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_AUTH_INFO_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_AUTH_INFO_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_AUTH_INFO_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_AUTH_INFO_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_AUTH_INFO_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EOTE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EOTE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_EOTE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EOTE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EOTE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EOTE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EOTE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EOTE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_BIT_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_BIT_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_BIT_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_BIT_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_BIT_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_BIT_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_BIT_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_BIT_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EOTE_RESTIRCT_DISTRICT > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EOTE_RESTIRCT_DISTRICT";
            }
        };

        template<>
        struct is_topic_type< ST_EOTE_RESTIRCT_DISTRICT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EOTE_RESTIRCT_DISTRICT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EOTE_RESTIRCT_DISTRICT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EOTE_RESTIRCT_DISTRICT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EOTE_RESTIRCT_DISTRICT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EOTE_RESTIRCT_DISTRICT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_BLOCK_INFO_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_BLOCK_INFO_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_BLOCK_INFO_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_BLOCK_INFO_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_BLOCK_INFO_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_BLOCK_INFO_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_BLOCK_INFO_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_BLOCK_INFO_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_BLOCK_SET_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_BLOCK_SET_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_BLOCK_SET_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_BLOCK_SET_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_BLOCK_SET_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_BLOCK_SET_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_BLOCK_SET_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_BLOCK_SET_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_LASER_CONTROL_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_LASER_CONTROL_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_LASER_CONTROL_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_LASER_CONTROL_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_LASER_CONTROL_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_LASER_CONTROL_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_LASER_CONTROL_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_LASER_CONTROL_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_MOVE_CONTROL_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_MOVE_CONTROL_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_MOVE_CONTROL_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_MOVE_CONTROL_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_MOVE_CONTROL_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EOTE_MOVING_SEARCHING_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EOTE_MOVING_SEARCHING_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_EOTE_MOVING_SEARCHING_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EOTE_MOVING_SEARCHING_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EOTE_MOVING_SEARCHING_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EOTE_MOVING_SEARCHING_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EOTE_MOVING_SEARCHING_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EOTE_MOVING_SEARCHING_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_MOVE_INFO_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_MOVE_INFO_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_MOVE_INFO_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_MOVE_INFO_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_MOVE_INFO_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_MOVE_INFO_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_MOVE_INFO_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_MOVE_INFO_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_MOVE_SET_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_MOVE_SET_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_MOVE_SET_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_MOVE_SET_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_MOVE_SET_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_MOVE_SET_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_MOVE_SET_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_MOVE_SET_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_SENSOR_CONTROL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_SENSOR_CONTROL_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_SENSOR_CONTROL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_SENSOR_CONTROL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_SENSOR_CONTROL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_SENSOR_CONTROL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_SENSOR_CONTROL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_SENSOR_CONTROL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_EOTE_TRACK_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_EOTE_TRACK_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_EOTE_TRACK_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_EOTE_TRACK_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_EOTE_TRACK_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_EOTE_TRACK_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_EOTE_TRACK_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_EOTE_TRACK_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_KNTDS_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_KNTDS_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_KNTDS_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_KNTDS_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_KNTDS_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_KNTDS_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_KNTDS_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_KNTDS_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_KNTDS_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_KNTDS_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_KNTDS_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_KNTDS_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_KNTDS_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_KNTDS_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_KNTDS_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_KNTDS_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_KNTDS_TARGET_DATA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_KNTDS_TARGET_DATA_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_KNTDS_TARGET_DATA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_KNTDS_TARGET_DATA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_KNTDS_TARGET_DATA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_KNTDS_TARGET_DATA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_KNTDS_TARGET_DATA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_KNTDS_TARGET_DATA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_RD_IMAGE > {
            NDDSUSERDllExport static std::string value() {
                return "ST_RD_IMAGE";
            }
        };

        template<>
        struct is_topic_type< ST_RD_IMAGE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_RD_IMAGE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_RD_IMAGE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_RD_IMAGE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_RD_IMAGE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_RD_IMAGE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_RD_IMAGE_DATA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_RD_IMAGE_DATA_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_RD_IMAGE_DATA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_RD_IMAGE_DATA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_RD_IMAGE_DATA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_RD_IMAGE_DATA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_RD_IMAGE_DATA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_RD_IMAGE_DATA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_RD_OPERATION_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_RD_OPERATION_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_RD_OPERATION_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_RD_OPERATION_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_RD_OPERATION_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_RD_OPERATION_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_RD_OPERATION_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_RD_OPERATION_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_RD_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_RD_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_RD_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_RD_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_RD_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_RD_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_RD_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_RD_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_RD_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_RD_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_RD_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_RD_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_RD_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_RD_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_RD_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_RD_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_RD_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_RD_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_RD_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_RD_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_RD_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_RD_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_RD_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_RD_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_RD_TARGET_DATA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_RD_TARGET_DATA_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_RD_TARGET_DATA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_RD_TARGET_DATA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_RD_TARGET_DATA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_RD_TARGET_DATA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_RD_TARGET_DATA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_RD_TARGET_DATA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EA_INTERWORKING_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EA_INTERWORKING_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_EA_INTERWORKING_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EA_INTERWORKING_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EA_INTERWORKING_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EA_INTERWORKING_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EA_INTERWORKING_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EA_INTERWORKING_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_INTERCHANGE_DEVICE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_INTERCHANGE_DEVICE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_INTERCHANGE_DEVICE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_INTERCHANGE_DEVICE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_INTERCHANGE_DEVICE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_INTERCHANGE_DEVICE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_INTERCHANGE_DEVICE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_INTERCHANGE_DEVICE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TRANSCEIVER_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TRANSCEIVER_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_TRANSCEIVER_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TRANSCEIVER_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TRANSCEIVER_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TRANSCEIVER_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TRANSCEIVER_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TRANSCEIVER_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_RMD_TRANSCEIVER_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_RMD_TRANSCEIVER_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_RMD_TRANSCEIVER_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_RMD_TRANSCEIVER_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_RMD_TRANSCEIVER_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SIM_RD_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SIM_RD_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_SIM_RD_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SIM_RD_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SIM_RD_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SIM_RD_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SIM_RD_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SIM_RD_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_SIM_RD_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_SIM_RD_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_SIM_RD_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_SIM_RD_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_SIM_RD_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_SIM_RD_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_SIM_RD_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_SIM_RD_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SIM_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SIM_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SIM_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SIM_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SIM_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SIM_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SIM_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SIM_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< IFCCTR_SIM_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "IFCCTR_SIM_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< IFCCTR_SIM_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< IFCCTR_SIM_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const IFCCTR_SIM_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(IFCCTR_SIM_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(IFCCTR_SIM_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(IFCCTR_SIM_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_A_AGC_CTRL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_A_AGC_CTRL_INFO";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_A_AGC_CTRL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_A_AGC_CTRL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_A_AGC_CTRL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_A_AGC_CTRL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_A_AGC_CTRL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_A_AGC_CTRL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_A_BEAM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_A_BEAM_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_A_BEAM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_A_BEAM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_A_BEAM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_A_BEAM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_A_BEAM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_A_BEAM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_A_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_A_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_A_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_A_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_A_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_A_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_A_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_A_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_A_FREQ_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_A_FREQ_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_A_FREQ_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_A_FREQ_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_A_FREQ_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_A_FREQ_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_A_FREQ_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_A_FREQ_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_A_TIME_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_A_TIME_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_A_TIME_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_A_TIME_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_A_TIME_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_A_TIME_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_A_TIME_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_A_TIME_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_B_AGC_CTRL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_B_AGC_CTRL_INFO";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_B_AGC_CTRL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_B_AGC_CTRL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_B_AGC_CTRL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_B_AGC_CTRL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_B_AGC_CTRL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_B_AGC_CTRL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_B_BEAM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_B_BEAM_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_B_BEAM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_B_BEAM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_B_BEAM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_B_BEAM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_B_BEAM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_B_BEAM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_B_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_B_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_B_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_B_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_B_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_B_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_B_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_B_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_B_FREQ_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_B_FREQ_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_B_FREQ_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_B_FREQ_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_B_FREQ_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_B_FREQ_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_B_FREQ_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_B_FREQ_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_B_TIME_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_B_TIME_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_B_TIME_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_B_TIME_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_B_TIME_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_B_TIME_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_B_TIME_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_B_TIME_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_C_AGC_CTRL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_C_AGC_CTRL_INFO";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_C_AGC_CTRL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_C_AGC_CTRL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_C_AGC_CTRL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_C_AGC_CTRL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_C_AGC_CTRL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_C_AGC_CTRL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_C_BEAM_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_C_BEAM_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_C_BEAM_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_C_BEAM_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_C_BEAM_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_C_BEAM_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_C_BEAM_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_C_BEAM_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_C_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_C_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_C_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_C_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_C_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_C_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_C_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_C_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_C_FREQ_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_C_FREQ_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_C_FREQ_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_C_FREQ_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_C_FREQ_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_C_FREQ_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_C_FREQ_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_C_FREQ_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< LASDSP_LAS_C_TIME_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "LASDSP_LAS_C_TIME_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< LASDSP_LAS_C_TIME_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< LASDSP_LAS_C_TIME_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const LASDSP_LAS_C_TIME_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(LASDSP_LAS_C_TIME_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(LASDSP_LAS_C_TIME_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(LASDSP_LAS_C_TIME_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA";
            }
        };

        template<>
        struct is_topic_type< MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MASDSP_MAS_AGC_CTRL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "MASDSP_MAS_AGC_CTRL_INFO";
            }
        };

        template<>
        struct is_topic_type< MASDSP_MAS_AGC_CTRL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MASDSP_MAS_AGC_CTRL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MASDSP_MAS_AGC_CTRL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MASDSP_MAS_AGC_CTRL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MASDSP_MAS_AGC_CTRL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MASDSP_MAS_AGC_CTRL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MASDSP_MAS_DETECTION_CTRL_INFO_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "MASDSP_MAS_DETECTION_CTRL_INFO_REQ";
            }
        };

        template<>
        struct is_topic_type< MASDSP_MAS_DETECTION_CTRL_INFO_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MASDSP_MAS_DETECTION_CTRL_INFO_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MASDSP_MAS_DETECTION_CTRL_INFO_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MASDSP_MAS_DETECTION_CTRL_INFO_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MASDSP_MAS_DETECTION_CTRL_INFO_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MASDSP_MAS_DETECTION_CTRL_INFO_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MASDSP_MAS_DETECTION_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "MASDSP_MAS_DETECTION_DATA";
            }
        };

        template<>
        struct is_topic_type< MASDSP_MAS_DETECTION_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MASDSP_MAS_DETECTION_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MASDSP_MAS_DETECTION_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MASDSP_MAS_DETECTION_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MASDSP_MAS_DETECTION_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MASDSP_MAS_DETECTION_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MASDSP_MAS_ENE_DATA > {
            NDDSUSERDllExport static std::string value() {
                return "MASDSP_MAS_ENE_DATA";
            }
        };

        template<>
        struct is_topic_type< MASDSP_MAS_ENE_DATA > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MASDSP_MAS_ENE_DATA > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MASDSP_MAS_ENE_DATA& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MASDSP_MAS_ENE_DATA& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MASDSP_MAS_ENE_DATA& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MASDSP_MAS_ENE_DATA& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_ANALYSIS_PROCESS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_ANALYSIS_PROCESS_INFO";
            }
        };

        template<>
        struct is_topic_type< SPPANA_ANALYSIS_PROCESS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_ANALYSIS_PROCESS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_ANALYSIS_PROCESS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_ANALYSIS_PROCESS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_ANALYSIS_PROCESS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_ANALYSIS_PROCESS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST";
            }
        };

        template<>
        struct is_topic_type< SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_HORIZONTAL_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_HORIZONTAL_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_HORIZONTAL_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_HORIZONTAL_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_HORIZONTAL_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_HORIZONTAL_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_HORIZONTAL_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_HORIZONTAL_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_MODEL_PROCESS_STATUS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_MODEL_PROCESS_STATUS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_MODEL_PROCESS_STATUS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_MODEL_PROCESS_STATUS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_MODEL_PROCESS_STATUS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_MODEL_PROCESS_STATUS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_MODEL_PROCESS_STATUS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_MODEL_PROCESS_STATUS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_POINT_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_POINT_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_POINT_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_POINT_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_POINT_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_POINT_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_POINT_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_POINT_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SPPANA_VERTICAL_ANALYSIS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SPPANA_VERTICAL_ANALYSIS_RESULT";
            }
        };

        template<>
        struct is_topic_type< SPPANA_VERTICAL_ANALYSIS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SPPANA_VERTICAL_ANALYSIS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SPPANA_VERTICAL_ANALYSIS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SPPANA_VERTICAL_ANALYSIS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SPPANA_VERTICAL_ANALYSIS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SPPANA_VERTICAL_ANALYSIS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_NIC_ADDR > {
            NDDSUSERDllExport static std::string value() {
                return "ST_NIC_ADDR";
            }
        };

        template<>
        struct is_topic_type< ST_NIC_ADDR > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_NIC_ADDR > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_NIC_ADDR& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_NIC_ADDR& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_NIC_ADDR& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_NIC_ADDR& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EQUIP_DIAGNOSTIC_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EQUIP_DIAGNOSTIC_RESULT";
            }
        };

        template<>
        struct is_topic_type< ST_EQUIP_DIAGNOSTIC_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EQUIP_DIAGNOSTIC_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EQUIP_DIAGNOSTIC_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EQUIP_DIAGNOSTIC_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EQUIP_DIAGNOSTIC_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EQUIP_DIAGNOSTIC_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_ALERT_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_ALERT_CMD";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_ALERT_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_ALERT_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_ALERT_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_ALERT_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_ALERT_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_ALERT_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_ALERT_REPORT > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_ALERT_REPORT";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_ALERT_REPORT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_ALERT_REPORT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_ALERT_REPORT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_ALERT_REPORT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_ALERT_REPORT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_ALERT_REPORT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_NAME > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_NAME";
            }
        };

        template<>
        struct is_topic_type< ST_SW_NAME > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_NAME > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_NAME& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_NAME& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_NAME& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_NAME& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_DEV_RUN_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_DEV_RUN_CMD";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_DEV_RUN_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_DEV_RUN_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_DEV_RUN_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_DEV_RUN_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_DEV_RUN_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_DEV_RUN_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_VERSION > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_VERSION";
            }
        };

        template<>
        struct is_topic_type< ST_SW_VERSION > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_VERSION > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_VERSION& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_VERSION& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_VERSION& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_VERSION& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SW_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_ALL_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_ALL_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SW_ALL_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_ALL_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_ALL_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_ALL_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_ALL_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_ALL_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_CPU_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_CPU_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_CPU_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_CPU_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_CPU_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_CPU_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_CPU_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_CPU_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_NIC_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_NIC_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_NIC_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_NIC_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_NIC_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_NIC_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_NIC_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_NIC_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MEM_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MEM_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_MEM_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MEM_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MEM_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MEM_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MEM_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MEM_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_DRIVE_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_DRIVE_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_DRIVE_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_DRIVE_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_DRIVE_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_DRIVE_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_DRIVE_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_DRIVE_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HW_STATUS_FOR_HCI > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HW_STATUS_FOR_HCI";
            }
        };

        template<>
        struct is_topic_type< ST_HW_STATUS_FOR_HCI > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HW_STATUS_FOR_HCI > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HW_STATUS_FOR_HCI& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HW_STATUS_FOR_HCI& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HW_STATUS_FOR_HCI& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HW_STATUS_FOR_HCI& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HW_ALL_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HW_ALL_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_HW_ALL_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HW_ALL_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HW_ALL_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HW_ALL_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HW_ALL_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HW_ALL_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HW_EQUIP_BOARD_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HW_EQUIP_BOARD_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_HW_EQUIP_BOARD_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HW_EQUIP_BOARD_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HW_EQUIP_BOARD_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HW_EQUIP_BOARD_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HW_EQUIP_BOARD_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HW_EQUIP_BOARD_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_EQUIP_DIAGNOSTIC_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_EQUIP_DIAGNOSTIC_RESULT";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_EQUIP_DIAGNOSTIC_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_EQUIP_DIAGNOSTIC_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_EQUIP_DIAGNOSTIC_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_EQUIP_DIAGNOSTIC_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_EQUIP_DIAGNOSTIC_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_EQUIP_DIAGNOSTIC_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_GPS_STS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_GPS_STS_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_GPS_STS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_GPS_STS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_GPS_STS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_GPS_STS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_GPS_STS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_GPS_STS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HUSS_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HUSS_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_HUSS_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HUSS_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HUSS_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HUSS_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HUSS_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HUSS_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HUSS_EQUIP_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HUSS_EQUIP_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_HUSS_EQUIP_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HUSS_EQUIP_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HUSS_EQUIP_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HUSS_EQUIP_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HUSS_EQUIP_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HUSS_EQUIP_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_HUSS_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_HUSS_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_HUSS_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_HUSS_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_HUSS_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_HUSS_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_HUSS_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_HUSS_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HW_EQUIP_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HW_EQUIP_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_HW_EQUIP_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HW_EQUIP_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HW_EQUIP_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HW_EQUIP_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HW_EQUIP_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HW_EQUIP_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX > {
            NDDSUSERDllExport static std::string value() {
                return "ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX";
            }
        };

        template<>
        struct is_topic_type< ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_HW_ALL_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_HW_ALL_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_HW_ALL_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_HW_ALL_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_HW_ALL_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_HW_ALL_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_HW_ALL_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_HW_ALL_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_HW_STATUS_HCI_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_HW_STATUS_HCI_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_HW_STATUS_HCI_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_HW_STATUS_HCI_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_HW_STATUS_HCI_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_HW_STATUS_HCI_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_HW_STATUS_HCI_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_HW_STATUS_HCI_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_HW_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_HW_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_HW_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_HW_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_HW_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_HW_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_HW_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_HW_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_NOTIFICATION_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_NOTIFICATION_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_NOTIFICATION_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_NOTIFICATION_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_NOTIFICATION_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_NOTIFICATION_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_NOTIFICATION_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_NOTIFICATION_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_PARAMETER > {
            NDDSUSERDllExport static std::string value() {
                return "ST_PARAMETER";
            }
        };

        template<>
        struct is_topic_type< ST_PARAMETER > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_PARAMETER > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_PARAMETER& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_PARAMETER& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_PARAMETER& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_PARAMETER& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_PARAMETER_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_PARAMETER_REQ";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_PARAMETER_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_PARAMETER_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_PARAMETER_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_PARAMETER_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_PARAMETER_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_PARAMETER_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_PARAMETER_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_PARAMETER_RESULT";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_PARAMETER_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_PARAMETER_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_PARAMETER_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_PARAMETER_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_PARAMETER_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_PARAMETER_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SERVER_START_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SERVER_START_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SERVER_START_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SERVER_START_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SERVER_START_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SERVER_START_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SERVER_START_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SERVER_START_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SWUPDATE_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SWUPDATE_CMD";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SWUPDATE_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SWUPDATE_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SWUPDATE_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SWUPDATE_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SWUPDATE_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SWUPDATE_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SWUPDATE_OVERALL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SWUPDATE_OVERALL_RESULT";
            }
        };

        template<>
        struct is_topic_type< ST_SWUPDATE_OVERALL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SWUPDATE_OVERALL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SWUPDATE_OVERALL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SWUPDATE_OVERALL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SWUPDATE_OVERALL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SWUPDATE_OVERALL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SWUPDATE_OVERALL_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SWUPDATE_OVERALL_RESULT";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SWUPDATE_OVERALL_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SWUPDATE_OVERALL_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SWUPDATE_OVERALL_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SWUPDATE_OVERALL_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SWUPDATE_OVERALL_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SWUPDATE_OVERALL_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SWUPDATE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SWUPDATE_RESULT";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SWUPDATE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SWUPDATE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SWUPDATE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SWUPDATE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SWUPDATE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SWUPDATE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_GROUP_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_GROUP_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SW_GROUP_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_GROUP_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_GROUP_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_GROUP_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_GROUP_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_GROUP_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_EQUIP_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_EQUIP_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SW_EQUIP_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_EQUIP_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_EQUIP_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_EQUIP_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_EQUIP_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_EQUIP_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SW_ALL_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SW_ALL_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SW_ALL_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SW_ALL_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SW_ALL_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SW_ALL_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SW_ALL_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SW_ALL_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SW_FIRST_RUN_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SW_FIRST_RUN_REQ";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SW_FIRST_RUN_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SW_FIRST_RUN_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SW_FIRST_RUN_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SW_FIRST_RUN_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SW_FIRST_RUN_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SW_FIRST_RUN_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SW_KILL_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SW_KILL_CMD";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SW_KILL_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SW_KILL_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SW_KILL_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SW_KILL_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SW_KILL_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SW_KILL_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SW_RUN_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SW_RUN_CMD";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SW_RUN_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SW_RUN_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SW_RUN_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SW_RUN_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SW_RUN_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SW_RUN_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SW_RUN_CMD_ALL > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SW_RUN_CMD_ALL";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SW_RUN_CMD_ALL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SW_RUN_CMD_ALL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SW_RUN_CMD_ALL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SW_RUN_CMD_ALL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SW_RUN_CMD_ALL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SW_RUN_CMD_ALL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SW_STATUS_HCI_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SW_STATUS_HCI_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SW_STATUS_HCI_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SW_STATUS_HCI_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SW_STATUS_HCI_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SW_STATUS_HCI_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SW_STATUS_HCI_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SW_STATUS_HCI_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_SW_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_SW_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_SW_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_SW_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_SW_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_SW_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_SW_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_SW_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_TIMESYNC_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_TIMESYNC_CMD";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_TIMESYNC_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_TIMESYNC_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_TIMESYNC_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_TIMESYNC_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_TIMESYNC_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_TIMESYNC_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_TIMESYNC_DEV_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_TIMESYNC_DEV_CMD";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_TIMESYNC_DEV_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_TIMESYNC_DEV_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_TIMESYNC_DEV_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_TIMESYNC_DEV_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_TIMESYNC_DEV_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_TIMESYNC_DEV_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_TIMESYNC_MODE_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_TIMESYNC_MODE_INFO";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_TIMESYNC_MODE_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_TIMESYNC_MODE_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_TIMESYNC_MODE_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_TIMESYNC_MODE_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_TIMESYNC_MODE_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_TIMESYNC_MODE_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_USER_ACCOUNT_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_USER_ACCOUNT_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_USER_ACCOUNT_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_USER_ACCOUNT_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_USER_ACCOUNT_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_USER_ACCOUNT_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_USER_ACCOUNT_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_USER_ACCOUNT_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_USER_ACCOUNT_INFO_RSP > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_USER_ACCOUNT_INFO_RSP";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_USER_ACCOUNT_INFO_RSP > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_USER_ACCOUNT_INFO_RSP > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_USER_ACCOUNT_INFO_RSP& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_USER_ACCOUNT_INFO_RSP& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_USER_ACCOUNT_INFO_RSP& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_USER_ACCOUNT_INFO_RSP& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_USER_ACCOUNT_LIST_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_USER_ACCOUNT_LIST_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_USER_ACCOUNT_LIST_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_USER_ACCOUNT_LIST_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_USER_ACCOUNT_LIST_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_USER_ACCOUNT_LIST_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_USER_ACCOUNT_LIST_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_USER_ACCOUNT_LIST_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_USER_ACCOUNT_LIST_RSP > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_USER_ACCOUNT_LIST_RSP";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_USER_ACCOUNT_LIST_RSP > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_USER_ACCOUNT_LIST_RSP > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_USER_ACCOUNT_LIST_RSP& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_USER_ACCOUNT_LIST_RSP& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_USER_ACCOUNT_LIST_RSP& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_USER_ACCOUNT_LIST_RSP& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_USER_ACCOUNT_LOG_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_USER_ACCOUNT_LOG_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_USER_ACCOUNT_LOG_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_USER_ACCOUNT_LOG_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_USER_ACCOUNT_LOG_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_USER_ACCOUNT_LOG_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_USER_ACCOUNT_LOG_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_USER_ACCOUNT_LOG_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_USER_ACCOUNT_LOG_RSP > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_USER_ACCOUNT_LOG_RSP";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_USER_ACCOUNT_LOG_RSP > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_USER_ACCOUNT_LOG_RSP > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_USER_ACCOUNT_LOG_RSP& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_USER_ACCOUNT_LOG_RSP& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_USER_ACCOUNT_LOG_RSP& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_USER_ACCOUNT_LOG_RSP& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< SYSMGR_USER_REALLOCATION_RSP > {
            NDDSUSERDllExport static std::string value() {
                return "SYSMGR_USER_REALLOCATION_RSP";
            }
        };

        template<>
        struct is_topic_type< SYSMGR_USER_REALLOCATION_RSP > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< SYSMGR_USER_REALLOCATION_RSP > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const SYSMGR_USER_REALLOCATION_RSP& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(SYSMGR_USER_REALLOCATION_RSP& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(SYSMGR_USER_REALLOCATION_RSP& sample);

            NDDSUSERDllExport 
            static void allocate_sample(SYSMGR_USER_REALLOCATION_RSP& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT";
            }
        };

        template<>
        struct is_topic_type< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT";
            }
        };

        template<>
        struct is_topic_type< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT";
            }
        };

        template<>
        struct is_topic_type< TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT";
            }
        };

        template<>
        struct is_topic_type< TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTCLA_OI_CLASSIFICATION_FREQ_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTCLA_OI_CLASSIFICATION_FREQ_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTCLA_OI_CLASSIFICATION_FREQ_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTCLA_OI_CLASSIFICATION_FREQ_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTCLA_OI_CLASSIFICATION_FREQ_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTCLA_OI_CLASSIFICATION_FREQ_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTCLA_OI_CLASSIFICATION_FREQ_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTCLA_OI_CLASSIFICATION_FREQ_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTCLA_STANDARD_CLA_DB_INFO_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "TGTCLA_STANDARD_CLA_DB_INFO_RESULT";
            }
        };

        template<>
        struct is_topic_type< TGTCLA_STANDARD_CLA_DB_INFO_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTCLA_STANDARD_CLA_DB_INFO_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTCLA_STANDARD_CLA_DB_INFO_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTCLA_STANDARD_CLA_DB_INFO_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTCLA_STANDARD_CLA_DB_INFO_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTCLA_STANDARD_CLA_DB_INFO_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AIS_TARGET_ASSOICATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AIS_TARGET_ASSOICATED";
            }
        };

        template<>
        struct is_topic_type< ST_AIS_TARGET_ASSOICATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AIS_TARGET_ASSOICATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AIS_TARGET_ASSOICATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AIS_TARGET_ASSOICATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AIS_TARGET_ASSOICATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AIS_TARGET_ASSOICATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AIS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AIS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_AIS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AIS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AIS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AIS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AIS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AIS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_TARGET_ASSOCIATED";
            }
        };

        template<>
        struct is_topic_type< ST_AS_TARGET_ASSOCIATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_TARGET_ASSOCIATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_TARGET_ASSOCIATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_TARGET_ASSOCIATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_TARGET_ASSOCIATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_AS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_TARGET_ASSOCIATED";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_TARGET_ASSOCIATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_TARGET_ASSOCIATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_TARGET_ASSOCIATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_TARGET_ASSOCIATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_TARGET_ASSOCIATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_BIS_SOURCE_MANUEVER_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_BIS_SOURCE_MANUEVER_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_BIS_SOURCE_MANUEVER_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_BIS_SOURCE_MANUEVER_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_BIS_SOURCE_MANUEVER_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_BIS_SOURCE_MANUEVER_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_BIS_SOURCE_MANUEVER_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_BIS_SOURCE_MANUEVER_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_BIS_TRACK_DELETE_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_BIS_TRACK_DELETE_CONTROL";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_BIS_TRACK_DELETE_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_BIS_TRACK_DELETE_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_BIS_TRACK_DELETE_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_BIS_TRACK_DELETE_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_BIS_TRACK_DELETE_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_BIS_TRACK_DELETE_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_TARGET_TRACK_HISTORY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_TARGET_TRACK_HISTORY";
            }
        };

        template<>
        struct is_topic_type< ST_TARGET_TRACK_HISTORY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_TARGET_TRACK_HISTORY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_TARGET_TRACK_HISTORY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_TARGET_TRACK_HISTORY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_TARGET_TRACK_HISTORY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_TARGET_TRACK_HISTORY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_FOC_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_FOC_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_FOC_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_FOC_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_FOC_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_FOC_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_FOC_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_FOC_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_DR_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_DR_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_DR_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_DR_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_DR_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_DR_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_DR_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_DR_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_CCRN_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_CCRN_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_CCRN_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_CCRN_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_CCRN_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_CCRN_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_CCRN_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_CCRN_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_CONCERNED_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_CONCERNED_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_CONCERNED_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_CONCERNED_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_CONCERNED_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_CONCERNED_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_CONCERNED_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_CONCERNED_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EO_TARGET_ASSOCIATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EO_TARGET_ASSOCIATED";
            }
        };

        template<>
        struct is_topic_type< ST_EO_TARGET_ASSOCIATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EO_TARGET_ASSOCIATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EO_TARGET_ASSOCIATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EO_TARGET_ASSOCIATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EO_TARGET_ASSOCIATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EO_TARGET_ASSOCIATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EOS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EOS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_EOS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EOS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EOS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EOS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EOS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EOS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_LOCAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_LOCAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_AS_LOCAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_LOCAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_LOCAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_LOCAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_LOCAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_LOCAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_LOCAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_LOCAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_LOCAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_LOCAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_LOCAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_LOCAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_LOCAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_LOCAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_EO_LOCAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_EO_LOCAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_EO_LOCAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_EO_LOCAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_EO_LOCAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_EO_LOCAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_EO_LOCAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_EO_LOCAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_KNTDS_NETWORK_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_KNTDS_NETWORK_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_KNTDS_NETWORK_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_KNTDS_NETWORK_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_KNTDS_NETWORK_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_KNTDS_NETWORK_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_KNTDS_NETWORK_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_KNTDS_NETWORK_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_FREQ_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_FREQ_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_FREQ_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_FREQ_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_FREQ_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_FREQ_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_FREQ_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_FREQ_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_LOCAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_LOCAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_LOCAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_LOCAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_LOCAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_LOCAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_LOCAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_LOCAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_LOCAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_LOCAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_LOCAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_LOCAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_LOCAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_LOCAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_LOCAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_LOCAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_RADAR_LOCAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_RADAR_LOCAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_RADAR_LOCAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_RADAR_LOCAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_RADAR_LOCAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_RADAR_LOCAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_RADAR_LOCAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_RADAR_LOCAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_SOURCE_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_SOURCE_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_SOURCE_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_SOURCE_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_SOURCE_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_SOURCE_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_SOURCE_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_SOURCE_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_RD_TARGET_ASSOCIATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_RD_TARGET_ASSOCIATED";
            }
        };

        template<>
        struct is_topic_type< ST_RD_TARGET_ASSOCIATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_RD_TARGET_ASSOCIATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_RD_TARGET_ASSOCIATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_RD_TARGET_ASSOCIATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_RD_TARGET_ASSOCIATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_RD_TARGET_ASSOCIATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_TARGET_ASSOICATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_TARGET_ASSOICATED";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_TARGET_ASSOICATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_TARGET_ASSOICATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_TARGET_ASSOICATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_TARGET_ASSOICATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_TARGET_ASSOICATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_TARGET_ASSOICATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_TARGET_ASSOCIATED";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_TARGET_ASSOCIATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_TARGET_ASSOCIATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_TARGET_ASSOCIATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_TARGET_ASSOCIATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_TARGET_ASSOCIATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_KNTDS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport static std::string value() {
                return "ST_KNTDS_TARGET_ASSOCIATED";
            }
        };

        template<>
        struct is_topic_type< ST_KNTDS_TARGET_ASSOCIATED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_KNTDS_TARGET_ASSOCIATED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_KNTDS_TARGET_ASSOCIATED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_KNTDS_TARGET_ASSOCIATED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_KNTDS_TARGET_ASSOCIATED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_KNTDS_TARGET_ASSOCIATED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_CPA_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_CPA_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_CPA_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_CPA_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_CPA_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_CPA_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_CPA_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_CPA_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_PREDICT_PATH_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_PREDICT_PATH_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_PREDICT_PATH_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_PREDICT_PATH_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_PREDICT_PATH_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_PREDICT_PATH_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_PREDICT_PATH_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_PREDICT_PATH_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_GLOBAL_TARGET_FOR_REMOTE > {
            NDDSUSERDllExport static std::string value() {
                return "ST_GLOBAL_TARGET_FOR_REMOTE";
            }
        };

        template<>
        struct is_topic_type< ST_GLOBAL_TARGET_FOR_REMOTE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_GLOBAL_TARGET_FOR_REMOTE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_GLOBAL_TARGET_FOR_REMOTE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_GLOBAL_TARGET_FOR_REMOTE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_GLOBAL_TARGET_FOR_REMOTE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_GLOBAL_TARGET_FOR_REMOTE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_GLOBAL_TARGET_RMT_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_GLOBAL_TARGET_RMT_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_GLOBAL_TARGET_RMT_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_GLOBAL_TARGET_RMT_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_GLOBAL_TARGET_RMT_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_GLOBAL_TARGET_RMT_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_GLOBAL_TARGET_RMT_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_GLOBAL_TARGET_RMT_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_KNTDS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_KNTDS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_KNTDS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_KNTDS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_KNTDS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_KNTDS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_KNTDS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_KNTDS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LAS_TRACK_DELETE_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LAS_TRACK_DELETE_CONTROL";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LAS_TRACK_DELETE_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LAS_TRACK_DELETE_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LAS_TRACK_DELETE_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LAS_TRACK_DELETE_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LAS_TRACK_DELETE_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LAS_TRACK_DELETE_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AIS_NETWORK_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AIS_NETWORK_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_AIS_NETWORK_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AIS_NETWORK_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AIS_NETWORK_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AIS_NETWORK_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AIS_NETWORK_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AIS_NETWORK_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_AIS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_AIS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_AIS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_AIS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_AIS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_AIS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_AIS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_AIS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_AS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_AS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_AS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_AS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_AS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_AS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_AS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_AS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_BIS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_BIS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_BIS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_BIS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_BIS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_BIS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_BIS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_BIS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_EO_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_EO_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_EO_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_EO_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_EO_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_EO_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_EO_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_EO_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_KNTDS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_KNTDS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_KNTDS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_KNTDS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_KNTDS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_KNTDS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_KNTDS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_KNTDS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_LAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_LAS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_LAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_LAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_LAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_LAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_LAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_LAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_MAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_MAS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_MAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_MAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_MAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_MAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_MAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_MAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_LOCAL_TARGET_RD_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_LOCAL_TARGET_RD_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_LOCAL_TARGET_RD_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_LOCAL_TARGET_RD_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_LOCAL_TARGET_RD_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_LOCAL_TARGET_RD_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_LOCAL_TARGET_RD_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_LOCAL_TARGET_RD_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_OUM_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_OUM_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_OUM_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_OUM_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_OUM_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_OUM_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_OUM_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_OUM_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_OUM_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_OUM_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_OUM_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_OUM_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_OUM_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_OUM_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_OUM_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_OUM_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_RDS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_RDS_FUSED_GLOBAL_TARGET";
            }
        };

        template<>
        struct is_topic_type< ST_RDS_FUSED_GLOBAL_TARGET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_RDS_FUSED_GLOBAL_TARGET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_RDS_FUSED_GLOBAL_TARGET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_RDS_FUSED_GLOBAL_TARGET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_RDS_FUSED_GLOBAL_TARGET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_RDS_FUSED_GLOBAL_TARGET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_SENSOR_CONFIG_PARAM_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_SENSOR_CONFIG_PARAM_REQ";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_SENSOR_CONFIG_PARAM_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_SENSOR_CONFIG_PARAM_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_SENSOR_CONFIG_PARAM_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_SENSOR_CONFIG_PARAM_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_SENSOR_CONFIG_PARAM_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_SENSOR_CONFIG_PARAM_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_TGT_CLASSIFICATION_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_TGT_CLASSIFICATION_CONTROL";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_TGT_CLASSIFICATION_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_TGT_CLASSIFICATION_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_TGT_CLASSIFICATION_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_TGT_CLASSIFICATION_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_TGT_CLASSIFICATION_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_TGT_CLASSIFICATION_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_THREAT_TARGET_FOR_KNTDS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_THREAT_TARGET_FOR_KNTDS";
            }
        };

        template<>
        struct is_topic_type< ST_THREAT_TARGET_FOR_KNTDS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_THREAT_TARGET_FOR_KNTDS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_THREAT_TARGET_FOR_KNTDS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_THREAT_TARGET_FOR_KNTDS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_THREAT_TARGET_FOR_KNTDS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_THREAT_TARGET_FOR_KNTDS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTMGR_THREAT_TARGET_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTMGR_THREAT_TARGET_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTMGR_THREAT_TARGET_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTMGR_THREAT_TARGET_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTMGR_THREAT_TARGET_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTMGR_THREAT_TARGET_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTMGR_THREAT_TARGET_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTMGR_THREAT_TARGET_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_MEAS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_MEAS";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_MEAS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_MEAS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_MEAS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_MEAS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_MEAS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_MEAS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_MEAS_INFO_A > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_MEAS_INFO_A";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_MEAS_INFO_A > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_MEAS_INFO_A > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_MEAS_INFO_A& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_MEAS_INFO_A& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_MEAS_INFO_A& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_MEAS_INFO_A& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_MEAS_INFO_B > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_MEAS_INFO_B";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_MEAS_INFO_B > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_MEAS_INFO_B > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_MEAS_INFO_B& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_MEAS_INFO_B& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_MEAS_INFO_B& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_MEAS_INFO_B& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_MEAS_INFO_C > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_MEAS_INFO_C";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_MEAS_INFO_C > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_MEAS_INFO_C > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_MEAS_INFO_C& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_MEAS_INFO_C& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_MEAS_INFO_C& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_MEAS_INFO_C& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BIS_TARGET_LOCAL > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BIS_TARGET_LOCAL";
            }
        };

        template<>
        struct is_topic_type< ST_BIS_TARGET_LOCAL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BIS_TARGET_LOCAL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BIS_TARGET_LOCAL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BIS_TARGET_LOCAL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BIS_TARGET_LOCAL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BIS_TARGET_LOCAL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_TARGET_TRACKING_INFO_A > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_TARGET_TRACKING_INFO_A";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_TARGET_TRACKING_INFO_A > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_TARGET_TRACKING_INFO_A > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_TARGET_TRACKING_INFO_A& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_TARGET_TRACKING_INFO_B > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_TARGET_TRACKING_INFO_B";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_TARGET_TRACKING_INFO_B > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_TARGET_TRACKING_INFO_B > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_TARGET_TRACKING_INFO_B& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_TARGET_TRACKING_INFO_C > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_TARGET_TRACKING_INFO_C";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_TARGET_TRACKING_INFO_C > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_TARGET_TRACKING_INFO_C > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_TARGET_TRACKING_INFO_C& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_LOFAR_MEAS > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_LOFAR_MEAS";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_LOFAR_MEAS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_LOFAR_MEAS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_LOFAR_MEAS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_LOFAR_MEAS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_LOFAR_MEAS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_LOFAR_MEAS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_LASTRK_LOFAR_MEAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_LASTRK_LOFAR_MEAS_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_LASTRK_LOFAR_MEAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_LASTRK_LOFAR_MEAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_LASTRK_LOFAR_MEAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_LASTRK_LOFAR_MEAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_LASTRK_LOFAR_MEAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_LASTRK_LOFAR_MEAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_TARGET_LOCAL > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_TARGET_LOCAL";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_TARGET_LOCAL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_TARGET_LOCAL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_TARGET_LOCAL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_TARGET_LOCAL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_TARGET_LOCAL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_TARGET_LOCAL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_LASTRK_TARGET_TRACKING_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_LASTRK_TARGET_TRACKING_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_LASTRK_TARGET_TRACKING_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_LASTRK_TARGET_TRACKING_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_LASTRK_TARGET_TRACKING_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_LASTRK_TARGET_TRACKING_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_LASTRK_TARGET_TRACKING_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_LASTRK_TARGET_TRACKING_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_LASTRK_THRESHOLD_INFO_ACK > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_LASTRK_THRESHOLD_INFO_ACK";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_LASTRK_THRESHOLD_INFO_ACK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_LASTRK_THRESHOLD_INFO_ACK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_LASTRK_THRESHOLD_INFO_ACK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_LASTRK_THRESHOLD_INFO_ACK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_LASTRK_THRESHOLD_INFO_ACK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_LASTRK_THRESHOLD_INFO_ACK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MAS_TARGET_LOCAL > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MAS_TARGET_LOCAL";
            }
        };

        template<>
        struct is_topic_type< ST_MAS_TARGET_LOCAL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MAS_TARGET_LOCAL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MAS_TARGET_LOCAL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MAS_TARGET_LOCAL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MAS_TARGET_LOCAL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MAS_TARGET_LOCAL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_MASTRK_TARGET_TRACKING_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_MASTRK_TARGET_TRACKING_INFO";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_MASTRK_TARGET_TRACKING_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_MASTRK_TARGET_TRACKING_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_MASTRK_TARGET_TRACKING_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_MASTRK_TARGET_TRACKING_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_MASTRK_TARGET_TRACKING_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_MASTRK_TARGET_TRACKING_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_MASTRK_THRESHOLD_INFO_ACK > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_MASTRK_THRESHOLD_INFO_ACK";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_MASTRK_THRESHOLD_INFO_ACK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_MASTRK_THRESHOLD_INFO_ACK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_MASTRK_THRESHOLD_INFO_ACK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_MASTRK_THRESHOLD_INFO_ACK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_MASTRK_THRESHOLD_INFO_ACK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_MASTRK_THRESHOLD_INFO_ACK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< TGTTRK_PARAM_INFO_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "TGTTRK_PARAM_INFO_REQ";
            }
        };

        template<>
        struct is_topic_type< TGTTRK_PARAM_INFO_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< TGTTRK_PARAM_INFO_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const TGTTRK_PARAM_INFO_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(TGTTRK_PARAM_INFO_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(TGTTRK_PARAM_INFO_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(TGTTRK_PARAM_INFO_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_PERIOD_PROC_PARAM_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_PERIOD_PROC_PARAM_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_PERIOD_PROC_PARAM_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_PERIOD_PROC_PARAM_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_PERIOD_PROC_PARAM_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_PERIOD_PROC_PARAM_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_PERIOD_PROC_PARAM_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_PERIOD_PROC_PARAM_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_DETECT_TH_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_DETECT_TH_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_DETECT_TH_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_DETECT_TH_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_DETECT_TH_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_DETECT_TH_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_DETECT_TH_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_DETECT_TH_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_FISH_SUP_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_FISH_SUP_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_FISH_SUP_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_FISH_SUP_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_FISH_SUP_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_FISH_SUP_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_FISH_SUP_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_FISH_SUP_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_FLOW_SUP_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_FLOW_SUP_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_FLOW_SUP_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_FLOW_SUP_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_FLOW_SUP_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_FLOW_SUP_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_FLOW_SUP_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_FLOW_SUP_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_MANUAL_AGC_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_MANUAL_AGC_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_MANUAL_AGC_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_MANUAL_AGC_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_MANUAL_AGC_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_MANUAL_AGC_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_MANUAL_AGC_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_MANUAL_AGC_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_MAX_RANGE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_MAX_RANGE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_MAX_RANGE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_MAX_RANGE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_MAX_RANGE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_MAX_RANGE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_MAX_RANGE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_MAX_RANGE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_MAX_SPEED_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_MAX_SPEED_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_MAX_SPEED_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_MAX_SPEED_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_MAX_SPEED_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_MAX_SPEED_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_MAX_SPEED_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_MAX_SPEED_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_MODE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_MODE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_MODE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_MODE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_MODE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_MODE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_MODE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_MODE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_OIT_GEN_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_OIT_GEN_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_OIT_GEN_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_OIT_GEN_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_OIT_GEN_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_OIT_GEN_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_OIT_GEN_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_OIT_GEN_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_POWER_CTRL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_POWER_CTRL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_POWER_CTRL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_POWER_CTRL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_POWER_CTRL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_POWER_CTRL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_POWER_CTRL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_POWER_CTRL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_SENSOR_FAIL_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_SENSOR_FAIL_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_SENSOR_FAIL_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_SENSOR_FAIL_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_SENSOR_FAIL_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_SENSOR_FAIL_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_SENSOR_FAIL_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_SENSOR_FAIL_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_SONARSPEED_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_SONARSPEED_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_SONARSPEED_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_SONARSPEED_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_SONARSPEED_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_SONARSPEED_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_SONARSPEED_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_SONARSPEED_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_STAY_TARGET_MODE_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_STAY_TARGET_MODE_REQ";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_STAY_TARGET_MODE_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_STAY_TARGET_MODE_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_STAY_TARGET_MODE_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_STAY_TARGET_MODE_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_STAY_TARGET_MODE_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_STAY_TARGET_MODE_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_STEERING_CTRL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_STEERING_CTRL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_STEERING_CTRL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_STEERING_CTRL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_STEERING_CTRL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_STEERING_CTRL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_STEERING_CTRL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_STEERING_CTRL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_TRANSMIT_OPTION_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_TRANSMIT_OPTION_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_TRANSMIT_OPTION_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_TRANSMIT_OPTION_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_TRANSMIT_OPTION_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_TRANSMIT_OPTION_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_TRANSMIT_OPTION_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_TRANSMIT_OPTION_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_TRK_SENSITIVE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_TRK_SENSITIVE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_TRK_SENSITIVE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_TRK_SENSITIVE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_TRK_SENSITIVE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_TRK_SENSITIVE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_TRK_SENSITIVE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_TRK_SENSITIVE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ASE_WAKE_SUP_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ASE_WAKE_SUP_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ASE_WAKE_SUP_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ASE_WAKE_SUP_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ASE_WAKE_SUP_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ASE_WAKE_SUP_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ASE_WAKE_SUP_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ASE_WAKE_SUP_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_DEPTH_TEMP > {
            NDDSUSERDllExport static std::string value() {
                return "ST_DEPTH_TEMP";
            }
        };

        template<>
        struct is_topic_type< ST_DEPTH_TEMP > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_DEPTH_TEMP > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_DEPTH_TEMP& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_DEPTH_TEMP& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_DEPTH_TEMP& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_DEPTH_TEMP& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_USER_TEMP_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_USER_TEMP_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_USER_TEMP_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_USER_TEMP_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_USER_TEMP_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_USER_TEMP_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_USER_TEMP_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_USER_TEMP_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_SENSOR_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_SENSOR_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_AS_SENSOR_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_SENSOR_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_SENSOR_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_SENSOR_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_SENSOR_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_SENSOR_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_AS_MODEL_INPUT_SET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_AS_MODEL_INPUT_SET";
            }
        };

        template<>
        struct is_topic_type< ST_AS_MODEL_INPUT_SET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_AS_MODEL_INPUT_SET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_AS_MODEL_INPUT_SET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_AS_MODEL_INPUT_SET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_AS_MODEL_INPUT_SET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_AS_MODEL_INPUT_SET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_AS_DETECTION_PROBABILITY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_AS_DETECTION_PROBABILITY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_AS_DETECTION_PROBABILITY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_AS_DETECTION_PROBABILITY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_AS_DETECTION_PROBABILITY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_AS_DETECTION_PROBABILITY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_AS_DETECTION_PROBABILITY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_AS_DETECTION_PROBABILITY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_AS_THREAT_AREA_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_AS_THREAT_AREA_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_AS_THREAT_AREA_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_AS_THREAT_AREA_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_AS_THREAT_AREA_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_AS_THREAT_AREA_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_AS_THREAT_AREA_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_AS_THREAT_AREA_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_AS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_AS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_AS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_AS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_AS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_AS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_AS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_AS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_AUDIO_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_AUDIO_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_AUDIO_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_AUDIO_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_AUDIO_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_AUDIO_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_AUDIO_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_AUDIO_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BISTRK_CONC_TGT_REG_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BISTRK_CONC_TGT_REG_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_BISTRK_CONC_TGT_REG_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BISTRK_CONC_TGT_REG_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BISTRK_CONC_TGT_REG_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BISTRK_CONC_TGT_REG_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BISTRK_CONC_TGT_REG_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BISTRK_CONC_TGT_REG_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BISTRK_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BISTRK_OIT_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_BISTRK_OIT_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BISTRK_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BISTRK_OIT_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BISTRK_OIT_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BISTRK_OIT_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BISTRK_OIT_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BISTRK_THRESHOLD_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BISTRK_THRESHOLD_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_BISTRK_THRESHOLD_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BISTRK_THRESHOLD_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BISTRK_THRESHOLD_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BISTRK_THRESHOLD_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BISTRK_THRESHOLD_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BISTRK_THRESHOLD_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_ACTIVE_PULSE_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_ACTIVE_PULSE_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_ACTIVE_PULSE_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_ACTIVE_PULSE_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_ACTIVE_PULSE_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_ACTIVE_PULSE_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_ACTIVE_PULSE_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_ACTIVE_PULSE_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_DETECT_USERCONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_DETECT_USERCONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_DETECT_USERCONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_DETECT_USERCONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_DETECT_USERCONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_DETECT_USERCONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_DETECT_USERCONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_DETECT_USERCONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_MOVINFO_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_MOVINFO_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_MOVINFO_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_MOVINFO_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_MOVINFO_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_MOVINFO_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_MOVINFO_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_MOVINFO_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_SENSOR_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_SENSOR_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_SENSOR_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_SENSOR_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_SENSOR_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_SENSOR_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_SENSOR_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_SENSOR_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BI_SOURCE_CONFIRM_SET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BI_SOURCE_CONFIRM_SET";
            }
        };

        template<>
        struct is_topic_type< ST_BI_SOURCE_CONFIRM_SET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BI_SOURCE_CONFIRM_SET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BI_SOURCE_CONFIRM_SET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BI_SOURCE_CONFIRM_SET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BI_SOURCE_CONFIRM_SET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BI_SOURCE_CONFIRM_SET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_POSITION_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_POSITION_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_POSITION_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_POSITION_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_POSITION_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_POSITION_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_POSITION_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_POSITION_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_QROUTE_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_QROUTE_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_QROUTE_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_QROUTE_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_QROUTE_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_QROUTE_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_QROUTE_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_QROUTE_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BI_SOURCE_FIND_SET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BI_SOURCE_FIND_SET";
            }
        };

        template<>
        struct is_topic_type< ST_BI_SOURCE_FIND_SET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BI_SOURCE_FIND_SET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BI_SOURCE_FIND_SET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BI_SOURCE_FIND_SET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BI_SOURCE_FIND_SET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BI_SOURCE_FIND_SET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BI_SOURCE_SEARCH_SET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BI_SOURCE_SEARCH_SET";
            }
        };

        template<>
        struct is_topic_type< ST_BI_SOURCE_SEARCH_SET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BI_SOURCE_SEARCH_SET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BI_SOURCE_SEARCH_SET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BI_SOURCE_SEARCH_SET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BI_SOURCE_SEARCH_SET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BI_SOURCE_SEARCH_SET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_SOURCE_DB_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_SOURCE_DB_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_SOURCE_DB_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_SOURCE_DB_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_SOURCE_DB_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_BI_MODEL_INPUT_SET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_BI_MODEL_INPUT_SET";
            }
        };

        template<>
        struct is_topic_type< ST_BI_MODEL_INPUT_SET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_BI_MODEL_INPUT_SET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_BI_MODEL_INPUT_SET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_BI_MODEL_INPUT_SET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_BI_MODEL_INPUT_SET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_BI_MODEL_INPUT_SET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_BI_DETECTION_PROBABILITY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_BI_DETECTION_PROBABILITY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_BI_DETECTION_PROBABILITY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_BI_DETECTION_PROBABILITY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_BI_DETECTION_PROBABILITY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_BI_DETECTION_PROBABILITY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_BI_DETECTION_PROBABILITY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_BI_DETECTION_PROBABILITY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_CPACALCULATE_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_CPACALCULATE_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_CPACALCULATE_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_CPACALCULATE_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_CPACALCULATE_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_CPACALCULATE_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_CPACALCULATE_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_CPACALCULATE_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_DATA_BACKUP_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_DATA_BACKUP_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_DATA_BACKUP_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_DATA_BACKUP_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_DATA_BACKUP_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_DATA_BACKUP_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_DATA_BACKUP_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_DATA_BACKUP_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_DATA_DELETE_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_DATA_DELETE_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_DATA_DELETE_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_DATA_DELETE_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_DATA_DELETE_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_DATA_DELETE_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_DATA_DELETE_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_DATA_DELETE_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_DATA_LIST_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_DATA_LIST_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_DATA_LIST_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_DATA_LIST_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_DATA_LIST_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_DATA_LIST_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_DATA_LIST_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_DATA_LIST_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_DATA_MODIFY_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_DATA_MODIFY_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_DATA_MODIFY_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_DATA_MODIFY_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_DATA_MODIFY_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_DATA_MODIFY_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_DATA_MODIFY_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_DATA_MODIFY_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_DATA_RECORD_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_DATA_RECORD_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_DATA_RECORD_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_DATA_RECORD_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_DATA_RECORD_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_DATA_RECORD_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_DATA_RECORD_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_DATA_RECORD_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_DATA_RESTORE_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_DATA_RESTORE_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_DATA_RESTORE_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_DATA_RESTORE_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_DATA_RESTORE_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_DATA_RESTORE_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_DATA_RESTORE_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_DATA_RESTORE_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_ADDITIONAL_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_ADDITIONAL_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_ADDITIONAL_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_ADDITIONAL_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_ADDITIONAL_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_ADDITIONAL_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_ADDITIONAL_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_ADDITIONAL_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_ADDITIONAL_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_ADDITIONAL_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_ADDITIONAL_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_ADDITIONAL_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_ADDITIONAL_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_ADDITIONAL_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_ADDITIONAL_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_ADDITIONAL_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_AUTH_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_AUTH_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_AUTH_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_AUTH_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_AUTH_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_AUTH_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_AUTH_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_AUTH_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_AUTH_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_AUTH_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_AUTH_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_AUTH_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_AUTH_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_AUTH_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_AUTH_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_AUTH_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_BLOCK_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_BLOCK_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_BLOCK_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_BLOCK_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_BLOCK_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_BLOCK_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_BLOCK_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_BLOCK_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_BLOCK_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_BLOCK_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_BLOCK_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_BLOCK_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_BLOCK_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_BLOCK_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_BLOCK_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_BLOCK_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_CALIBRATION_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_CALIBRATION_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_CALIBRATION_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_CALIBRATION_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_CALIBRATION_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_LASER_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_LASER_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_LASER_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_LASER_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_LASER_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_LASER_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_LASER_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_LASER_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_MOTOR_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_MOTOR_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_MOTOR_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_MOTOR_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_MOTOR_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_MOTOR_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_MOTOR_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_MOTOR_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_MOVE_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_MOVE_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_MOVE_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_MOVE_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_MOVE_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_MOVE_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_MOVE_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_MOVE_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_MOVE_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_MOVE_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_MOVE_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_MOVE_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_MOVE_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_MOVE_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_MOVE_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_MOVE_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_MOVE_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_MOVE_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_MOVE_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_MOVE_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_MOVE_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_MOVE_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_MOVE_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_MOVE_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_POWER_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_POWER_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_POWER_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_POWER_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_POWER_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_POWER_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_POWER_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_POWER_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_TRACKING_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_TRACKING_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_TRACKING_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_TRACKING_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_TRACKING_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_TRACKING_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_TRACKING_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_TRACKING_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EQUIP_DIAGNOSTIC_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EQUIP_DIAGNOSTIC_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EQUIP_DIAGNOSTIC_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EQUIP_DIAGNOSTIC_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EQUIP_DIAGNOSTIC_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EQUIP_DIAGNOSTIC_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EQUIP_DIAGNOSTIC_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EQUIP_DIAGNOSTIC_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_FOC_DR_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_FOC_DR_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_FOC_DR_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_FOC_DR_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_FOC_DR_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_FOC_DR_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_FOC_DR_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_FOC_DR_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_HISTORY_EXCUTE_VACCINE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_HISTORY_EXCUTE_VACCINE";
            }
        };

        template<>
        struct is_topic_type< USERIF_HISTORY_EXCUTE_VACCINE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_HISTORY_EXCUTE_VACCINE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_HISTORY_EXCUTE_VACCINE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_HISTORY_EXCUTE_VACCINE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_HISTORY_EXCUTE_VACCINE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_HISTORY_EXCUTE_VACCINE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_HISTORY_LIST_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_HISTORY_LIST_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_HISTORY_LIST_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_HISTORY_LIST_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_HISTORY_LIST_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_HISTORY_LIST_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_HISTORY_LIST_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_HISTORY_LIST_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_HISTORY_MANAGE_ACCOUNT > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_HISTORY_MANAGE_ACCOUNT";
            }
        };

        template<>
        struct is_topic_type< USERIF_HISTORY_MANAGE_ACCOUNT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_HISTORY_MANAGE_ACCOUNT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_HISTORY_MANAGE_ACCOUNT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_HISTORY_MANAGE_ACCOUNT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_HISTORY_MANAGE_ACCOUNT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_HISTORY_MANAGE_ACCOUNT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_HISTORY_PRINT_REPORT > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_HISTORY_PRINT_REPORT";
            }
        };

        template<>
        struct is_topic_type< USERIF_HISTORY_PRINT_REPORT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_HISTORY_PRINT_REPORT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_HISTORY_PRINT_REPORT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_HISTORY_PRINT_REPORT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_HISTORY_PRINT_REPORT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_HISTORY_PRINT_REPORT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_HISTORY_RESERVED > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_HISTORY_RESERVED";
            }
        };

        template<>
        struct is_topic_type< USERIF_HISTORY_RESERVED > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_HISTORY_RESERVED > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_HISTORY_RESERVED& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_HISTORY_RESERVED& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_HISTORY_RESERVED& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_HISTORY_RESERVED& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_HORIZONTAL_ANALYSIS_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_HORIZONTAL_ANALYSIS_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_HORIZONTAL_ANALYSIS_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_HORIZONTAL_ANALYSIS_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_HORIZONTAL_ANALYSIS_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_HORIZONTAL_ANALYSIS_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_HORIZONTAL_ANALYSIS_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_HORIZONTAL_ANALYSIS_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_IPE_DEVICE_CTRL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_IPE_DEVICE_CTRL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_IPE_DEVICE_CTRL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_IPE_DEVICE_CTRL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_IPE_DEVICE_CTRL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_IPE_DEVICE_CTRL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_IPE_DEVICE_CTRL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_IPE_DEVICE_CTRL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_CONC_TGT_REG_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_CONC_TGT_REG_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_CONC_TGT_REG_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_CONC_TGT_REG_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_CONC_TGT_REG_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_CONC_TGT_REG_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_CONC_TGT_REG_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_CONC_TGT_REG_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_ASS_TGT_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_ASS_TGT_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_ASS_TGT_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_ASS_TGT_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_ASS_TGT_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_ASS_TGT_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_ASS_TGT_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_ASS_TGT_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LASTRK_THRESHOLD_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LASTRK_THRESHOLD_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_LASTRK_THRESHOLD_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LASTRK_THRESHOLD_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LASTRK_THRESHOLD_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LASTRK_THRESHOLD_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LASTRK_THRESHOLD_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LASTRK_THRESHOLD_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_LAS_MAS_MODEL_INPUT_SET > {
            NDDSUSERDllExport static std::string value() {
                return "ST_LAS_MAS_MODEL_INPUT_SET";
            }
        };

        template<>
        struct is_topic_type< ST_LAS_MAS_MODEL_INPUT_SET > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_LAS_MAS_MODEL_INPUT_SET > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_LAS_MAS_MODEL_INPUT_SET& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_LAS_MAS_MODEL_INPUT_SET& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_LAS_MAS_MODEL_INPUT_SET& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_LAS_MAS_MODEL_INPUT_SET& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_SENSOR_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_SENSOR_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_SENSOR_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_SENSOR_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_SENSOR_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_SENSOR_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_SENSOR_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_SENSOR_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_TRACK_SFL_DELETE_CONTROL > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_TRACK_SFL_DELETE_CONTROL";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_TRACK_SFL_DELETE_CONTROL > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_TRACK_SFL_DELETE_CONTROL > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_TRACK_SFL_DELETE_CONTROL& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_TRACK_SFL_DELETE_CONTROL& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_TRACK_SFL_DELETE_CONTROL& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_TRACK_SFL_DELETE_CONTROL& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_LOST_INTEREST_TARGET_SEND_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_LOST_INTEREST_TARGET_SEND_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_LOST_INTEREST_TARGET_SEND_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_LOST_INTEREST_TARGET_SEND_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_LOST_INTEREST_TARGET_SEND_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MASTRK_CONC_TGT_REG_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MASTRK_CONC_TGT_REG_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_MASTRK_CONC_TGT_REG_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MASTRK_CONC_TGT_REG_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MASTRK_CONC_TGT_REG_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MASTRK_CONC_TGT_REG_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MASTRK_CONC_TGT_REG_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MASTRK_CONC_TGT_REG_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MASTRK_THRESHOLD_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MASTRK_THRESHOLD_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_MASTRK_THRESHOLD_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MASTRK_THRESHOLD_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MASTRK_THRESHOLD_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MASTRK_THRESHOLD_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MASTRK_THRESHOLD_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MASTRK_THRESHOLD_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MAS_SENSOR_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MAS_SENSOR_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MAS_SENSOR_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MAS_SENSOR_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MAS_SENSOR_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MAS_SENSOR_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MAS_SENSOR_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MAS_SENSOR_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MAS_TRACK_USER_CONFIRM_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_MAS_TRACK_USER_CONFIRM_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MAS_TRACK_USER_CONFIRM_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MAS_TRACK_USER_CONFIRM_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_OI_CLASSIFICATION_FREQ_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_OI_CLASSIFICATION_FREQ_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_OI_CLASSIFICATION_FREQ_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_OI_CLASSIFICATION_FREQ_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_OI_CLASSIFICATION_FREQ_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_OI_CLASSIFICATION_FREQ_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_OI_CLASSIFICATION_FREQ_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_OI_CLASSIFICATION_FREQ_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_OI_CLASSIFICATION_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_OI_CLASSIFICATION_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_OI_CLASSIFICATION_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_OI_CLASSIFICATION_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_OI_CLASSIFICATION_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_OI_CLASSIFICATION_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_OI_CLASSIFICATION_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_OI_CLASSIFICATION_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_POINT_ANALYSIS_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_POINT_ANALYSIS_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_POINT_ANALYSIS_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_POINT_ANALYSIS_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_POINT_ANALYSIS_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_POINT_ANALYSIS_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_POINT_ANALYSIS_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_POINT_ANALYSIS_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RADAR_CHANNEL_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RADAR_CHANNEL_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_RADAR_CHANNEL_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RADAR_CHANNEL_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RADAR_CHANNEL_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RADAR_CHANNEL_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RADAR_CHANNEL_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RADAR_CHANNEL_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RADAR_FILTER_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RADAR_FILTER_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_RADAR_FILTER_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RADAR_FILTER_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RADAR_FILTER_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RADAR_FILTER_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RADAR_FILTER_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RADAR_FILTER_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RADAR_TRACK_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RADAR_TRACK_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_RADAR_TRACK_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RADAR_TRACK_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RADAR_TRACK_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RADAR_TRACK_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RADAR_TRACK_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RADAR_TRACK_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RADAR_VIDEO_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RADAR_VIDEO_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_RADAR_VIDEO_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RADAR_VIDEO_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RADAR_VIDEO_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RADAR_VIDEO_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RADAR_VIDEO_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RADAR_VIDEO_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RAWAUDIO_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RAWAUDIO_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_RAWAUDIO_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RAWAUDIO_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RAWAUDIO_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RAWAUDIO_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RAWAUDIO_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RAWAUDIO_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RMT_DEVICE_CTRL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RMT_DEVICE_CTRL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_RMT_DEVICE_CTRL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RMT_DEVICE_CTRL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RMT_DEVICE_CTRL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RMT_DEVICE_CTRL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RMT_DEVICE_CTRL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RMT_DEVICE_CTRL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SCREENSHOT_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SCREENSHOT_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_SCREENSHOT_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SCREENSHOT_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SCREENSHOT_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SCREENSHOT_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SCREENSHOT_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SCREENSHOT_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SCREENSHOT_LIST_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SCREENSHOT_LIST_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_SCREENSHOT_LIST_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SCREENSHOT_LIST_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SCREENSHOT_LIST_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SCREENSHOT_LIST_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SCREENSHOT_LIST_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SCREENSHOT_LIST_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SCREENSHOT_SAVE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SCREENSHOT_SAVE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_SCREENSHOT_SAVE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SCREENSHOT_SAVE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SCREENSHOT_SAVE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SCREENSHOT_SAVE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SCREENSHOT_SAVE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SCREENSHOT_SAVE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SENSOR_PROTECTION_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SENSOR_PROTECTION_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_SENSOR_PROTECTION_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SENSOR_PROTECTION_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SENSOR_PROTECTION_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SOFTWARE_OPERATE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SOFTWARE_OPERATE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_SOFTWARE_OPERATE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SOFTWARE_OPERATE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SOFTWARE_OPERATE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SOFTWARE_OPERATE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SOFTWARE_OPERATE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SOFTWARE_OPERATE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SPE_DEVICE_CTRL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SPE_DEVICE_CTRL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_SPE_DEVICE_CTRL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SPE_DEVICE_CTRL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SPE_DEVICE_CTRL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SPE_DEVICE_CTRL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SPE_DEVICE_CTRL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SPE_DEVICE_CTRL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SYSMGR_ALL_STATE_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SYSMGR_ALL_STATE_REQ";
            }
        };

        template<>
        struct is_topic_type< USERIF_SYSMGR_ALL_STATE_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SYSMGR_ALL_STATE_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SYSMGR_ALL_STATE_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SYSMGR_ALL_STATE_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SYSMGR_ALL_STATE_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SYSMGR_ALL_STATE_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SYSMGR_REALLOCATION_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SYSMGR_REALLOCATION_CMD";
            }
        };

        template<>
        struct is_topic_type< USERIF_SYSMGR_REALLOCATION_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SYSMGR_REALLOCATION_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SYSMGR_REALLOCATION_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SYSMGR_REALLOCATION_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SYSMGR_REALLOCATION_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SYSMGR_REALLOCATION_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_UPDATE_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_UPDATE_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_SW_UPDATE_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_UPDATE_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_UPDATE_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_UPDATE_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_UPDATE_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_UPDATE_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SYSMGR_SWUPDATE_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SYSMGR_SWUPDATE_CMD";
            }
        };

        template<>
        struct is_topic_type< USERIF_SYSMGR_SWUPDATE_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SYSMGR_SWUPDATE_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SYSMGR_SWUPDATE_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SYSMGR_SWUPDATE_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SYSMGR_SWUPDATE_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SYSMGR_SWUPDATE_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SYSMGR_SWUPDATE_OVERALL_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SYSMGR_SWUPDATE_OVERALL_CMD";
            }
        };

        template<>
        struct is_topic_type< USERIF_SYSMGR_SWUPDATE_OVERALL_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SYSMGR_SWUPDATE_OVERALL_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SYSMGR_SWUPDATE_OVERALL_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_DANGER_INFO_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_DANGER_INFO_REQ";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_DANGER_INFO_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_DANGER_INFO_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_DANGER_INFO_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_DANGER_INFO_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_DANGER_INFO_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_DANGER_INFO_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_DB_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_DB_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_DB_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_DB_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_DB_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_DB_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_DB_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_DB_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_FUSION_ACTIVATION_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_FUSION_ACTIVATION_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_FUSION_ACTIVATION_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_FUSION_ACTIVATION_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_FUSION_ACTIVATION_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_FUSION_ACTIVATION_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_FUSION_ACTIVATION_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_FUSION_ACTIVATION_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_FUSION_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_FUSION_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_FUSION_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_FUSION_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_FUSION_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_FUSION_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_FUSION_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_FUSION_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_GLOBAL_DELETE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_GLOBAL_DELETE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_GLOBAL_DELETE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_GLOBAL_DELETE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_GLOBAL_DELETE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_GLOBAL_DELETE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_GLOBAL_DELETE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_GLOBAL_DELETE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_GLOBAL_REFRESH_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_GLOBAL_REFRESH_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_GLOBAL_REFRESH_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_GLOBAL_REFRESH_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_GLOBAL_REFRESH_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_GLOBAL_REFRESH_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_GLOBAL_REFRESH_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_GLOBAL_REFRESH_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_GLOBAL_REGISTER_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_GLOBAL_REGISTER_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_GLOBAL_REGISTER_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_GLOBAL_REGISTER_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_GLOBAL_REGISTER_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_GLOBAL_REGISTER_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_GLOBAL_REGISTER_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_GLOBAL_REGISTER_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_INFO_INITIATE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_INFO_INITIATE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_INFO_INITIATE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_INFO_INITIATE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_INFO_INITIATE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_INFO_INITIATE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_INFO_INITIATE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_INFO_INITIATE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_INTEREST_DELETE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_INTEREST_DELETE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_INTEREST_DELETE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_INTEREST_DELETE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_INTEREST_DELETE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_INTEREST_DELETE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_INTEREST_DELETE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_INTEREST_DELETE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_INTEREST_NEW_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_INTEREST_NEW_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_INTEREST_NEW_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_INTEREST_NEW_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_INTEREST_NEW_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_INTEREST_NEW_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_INTEREST_NEW_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_INTEREST_NEW_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_OUM_DELETE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_OUM_DELETE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_OUM_DELETE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_OUM_DELETE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_OUM_DELETE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_OUM_DELETE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_OUM_DELETE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_OUM_DELETE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_OUM_REFRESH_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_OUM_REFRESH_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_OUM_REFRESH_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_OUM_REFRESH_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_OUM_REFRESH_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_OUM_REFRESH_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_OUM_REFRESH_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_OUM_REFRESH_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_OUM_REGISTER_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_OUM_REGISTER_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_OUM_REGISTER_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_OUM_REGISTER_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_OUM_REGISTER_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_OUM_REGISTER_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_OUM_REGISTER_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_OUM_REGISTER_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND";
            }
        };

        template<>
        struct is_topic_type< USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_THREAT_AREA_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_THREAT_AREA_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_THREAT_AREA_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_THREAT_AREA_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_THREAT_AREA_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_THREAT_AREA_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_THREAT_AREA_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_THREAT_AREA_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_TIMESYNC_MODE_CMD > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_TIMESYNC_MODE_CMD";
            }
        };

        template<>
        struct is_topic_type< USERIF_TIMESYNC_MODE_CMD > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_TIMESYNC_MODE_CMD > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_TIMESYNC_MODE_CMD& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_TIMESYNC_MODE_CMD& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_TIMESYNC_MODE_CMD& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_TIMESYNC_MODE_CMD& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_USER_ACCOUNT_INFO_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_USER_ACCOUNT_INFO_REQ";
            }
        };

        template<>
        struct is_topic_type< USERIF_USER_ACCOUNT_INFO_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_USER_ACCOUNT_INFO_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_USER_ACCOUNT_INFO_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_USER_ACCOUNT_INFO_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_USER_ACCOUNT_INFO_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_USER_ACCOUNT_INFO_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_USER_ACCOUNT_LIST_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_USER_ACCOUNT_LIST_REQ";
            }
        };

        template<>
        struct is_topic_type< USERIF_USER_ACCOUNT_LIST_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_USER_ACCOUNT_LIST_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_USER_ACCOUNT_LIST_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_USER_ACCOUNT_LIST_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_USER_ACCOUNT_LIST_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_USER_ACCOUNT_LIST_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_USER_ACCOUNT_LOG_REQ > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_USER_ACCOUNT_LOG_REQ";
            }
        };

        template<>
        struct is_topic_type< USERIF_USER_ACCOUNT_LOG_REQ > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_USER_ACCOUNT_LOG_REQ > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_USER_ACCOUNT_LOG_REQ& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_USER_ACCOUNT_LOG_REQ& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_USER_ACCOUNT_LOG_REQ& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_USER_ACCOUNT_LOG_REQ& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_USER_LOGIN_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_USER_LOGIN_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_USER_LOGIN_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_USER_LOGIN_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_USER_LOGIN_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_USER_LOGIN_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_USER_LOGIN_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_USER_LOGIN_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_VERTICAL_ANALYSIS_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_VERTICAL_ANALYSIS_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_VERTICAL_ANALYSIS_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_VERTICAL_ANALYSIS_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_VERTICAL_ANALYSIS_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_VERTICAL_ANALYSIS_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_VERTICAL_ANALYSIS_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_VERTICAL_ANALYSIS_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_ZONE_CONTROL_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_ZONE_CONTROL_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_ZONE_CONTROL_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_ZONE_CONTROL_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_ZONE_CONTROL_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_ZONE_CONTROL_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_ZONE_CONTROL_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_ZONE_CONTROL_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SYSTEM_COMPONENT > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SYSTEM_COMPONENT";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SYSTEM_COMPONENT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SYSTEM_COMPONENT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SYSTEM_COMPONENT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SYSTEM_COMPONENT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SYSTEM_COMPONENT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SYSTEM_COMPONENT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_TREE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_TREE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_TREE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_TREE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_TREE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_TREE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_TREE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_TREE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SYSTEM_TREE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SYSTEM_TREE_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SYSTEM_TREE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SYSTEM_TREE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SYSTEM_TREE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SYSTEM_TREE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SYSTEM_TREE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SYSTEM_TREE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SYSTEM_COMPONENT_PART > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SYSTEM_COMPONENT_PART";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SYSTEM_COMPONENT_PART > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SYSTEM_COMPONENT_PART > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SYSTEM_COMPONENT_PART& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SYSTEM_COMPONENT_PART& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SYSTEM_COMPONENT_PART& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SYSTEM_COMPONENT_PART& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SYSTEM_COMPONENT_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SYSTEM_COMPONENT_INFO";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SYSTEM_COMPONENT_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SYSTEM_COMPONENT_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SYSTEM_COMPONENT_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SYSTEM_COMPONENT_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SYSTEM_COMPONENT_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SYSTEM_COMPONENT_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_ALERT_MSG > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_ALERT_MSG";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_ALERT_MSG > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_ALERT_MSG > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_ALERT_MSG& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_ALERT_MSG& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_ALERT_MSG& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_ALERT_MSG& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_MAINTENANCE_HISTORY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_MAINTENANCE_HISTORY";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_MAINTENANCE_HISTORY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_MAINTENANCE_HISTORY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_MAINTENANCE_HISTORY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_MAINTENANCE_HISTORY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_MAINTENANCE_HISTORY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_MAINTENANCE_HISTORY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_MAINTENANCE_HISTORY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_MAINTENANCE_HISTORY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_MAINTENANCE_HISTORY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_MAINTENANCE_HISTORY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_MAINTENANCE_HISTORY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_MAINTENANCE_HISTORY_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_MAINTENANCE_HISTORY_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_MAINTENANCE_HISTORY_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_MAINTENANCE_HISTORY_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_MAINTENANCE_HISTORY_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_MAINTENANCE_HISTORY_CREATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_MAINTENANCE_HISTORY_CREATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_MAINTENANCE_HISTORY_CREATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_MAINTENANCE_HISTORY_CREATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_MAINTENANCE_HISTORY_CREATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_MAINTENANCE_HISTORY_CREATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_MAINTENANCE_HISTORY_CREATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_MAINTENANCE_HISTORY_CREATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_MAINTENANCE_HISTORY_UPDATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_MAINTENANCE_HISTORY_UPDATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_MAINTENANCE_HISTORY_UPDATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_MAINTENANCE_HISTORY_UPDATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_MAINTENANCE_HISTORY_UPDATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_MAINTENANCE_HISTORY_DELETE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_MAINTENANCE_HISTORY_DELETE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_MAINTENANCE_HISTORY_DELETE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_MAINTENANCE_HISTORY_DELETE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_MAINTENANCE_HISTORY_DELETE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_MAINTENANCE_HISTORY_DELETE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_MAINTENANCE_HISTORY_DELETE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_MAINTENANCE_HISTORY_DELETE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SYSTEM_COMPONENT_STOCK > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SYSTEM_COMPONENT_STOCK";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SYSTEM_COMPONENT_STOCK > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SYSTEM_COMPONENT_STOCK > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SYSTEM_COMPONENT_STOCK& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SYSTEM_COMPONENT_STOCK& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SYSTEM_COMPONENT_STOCK& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SYSTEM_COMPONENT_STOCK& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SYSTEM_COMPONENT_IETM > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SYSTEM_COMPONENT_IETM";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SYSTEM_COMPONENT_IETM > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SYSTEM_COMPONENT_IETM > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SYSTEM_COMPONENT_IETM& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SYSTEM_COMPONENT_IETM& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SYSTEM_COMPONENT_IETM& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SYSTEM_COMPONENT_IETM& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_EXTERNAL_STORAGE_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_EXTERNAL_STORAGE_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_EXTERNAL_STORAGE_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_EXTERNAL_STORAGE_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_EXTERNAL_STORAGE_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_EXTERNAL_STORAGE_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_EXTERNAL_STORAGE_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_EXTERNAL_STORAGE_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_NAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_NAS_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_NAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_NAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_NAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_NAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_NAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_NAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SOFTWARE_NAS_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SOFTWARE_NAS_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SOFTWARE_NAS_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SOFTWARE_NAS_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SOFTWARE_NAS_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SOFTWARE_NAS_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SOFTWARE_NAS_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SOFTWARE_NAS_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SOFTWARE_NAS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SOFTWARE_NAS_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SOFTWARE_NAS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SOFTWARE_NAS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SOFTWARE_NAS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SOFTWARE_NAS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SOFTWARE_NAS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SOFTWARE_NAS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_DISK_TO_NAS_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_DISK_TO_NAS_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_DISK_TO_NAS_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_DISK_TO_NAS_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_DISK_TO_NAS_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_DISK_TO_NAS_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_DISK_TO_NAS_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_DISK_TO_NAS_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_DISK_TO_NAS_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_DISK_TO_NAS_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_DISK_TO_NAS_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_DISK_TO_NAS_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_DISK_TO_NAS_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_DISK_TO_NAS_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_DISK_TO_NAS_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_DISK_TO_NAS_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_NAS_DELETE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_NAS_DELETE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_NAS_DELETE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_NAS_DELETE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_NAS_DELETE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_NAS_DELETE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_NAS_DELETE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_NAS_DELETE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_NAS_DELETE_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_NAS_DELETE_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_NAS_DELETE_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_NAS_DELETE_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_NAS_DELETE_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_NAS_DELETE_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_NAS_DELETE_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_NAS_DELETE_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_SOFTWARE_INSTALL_HISTORY";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_SOFTWARE_INSTALL_HISTORY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_SERVER_DISK_STATE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_SERVER_DISK_STATE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_SERVER_DISK_STATE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_SERVER_DISK_STATE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_SERVER_DISK_STATE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_SERVER_DISK_STATE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_SERVER_DISK_STATE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_SERVER_DISK_STATE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_DATABASE_BACKUP_HISTORY > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_DATABASE_BACKUP_HISTORY";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_DATABASE_BACKUP_HISTORY > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_DATABASE_BACKUP_HISTORY > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_DATABASE_BACKUP_HISTORY& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_DATABASE_BACKUP_HISTORY& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_DATABASE_BACKUP_HISTORY& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_DATABASE_BACKUP_HISTORY& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_DATABASE_BACKUP_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_DATABASE_BACKUP_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_DATABASE_BACKUP_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_DATABASE_BACKUP_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_DATABASE_BACKUP_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_DATABASE_BACKUP_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_DATABASE_BACKUP_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_DATABASE_BACKUP_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_DATABASE_RESTORE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_DATABASE_RESTORE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_DATABASE_RESTORE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_DATABASE_RESTORE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_DATABASE_RESTORE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_DATABASE_RESTORE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_DATABASE_RESTORE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_DATABASE_RESTORE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_MSSSUP_IETM_MAPPING_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "ST_MSSSUP_IETM_MAPPING_INFO";
            }
        };

        template<>
        struct is_topic_type< ST_MSSSUP_IETM_MAPPING_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_MSSSUP_IETM_MAPPING_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_MSSSUP_IETM_MAPPING_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_MSSSUP_IETM_MAPPING_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_MSSSUP_IETM_MAPPING_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_MSSSUP_IETM_MAPPING_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_IETM_MAPPING_INFO_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_IETM_MAPPING_INFO_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_IETM_MAPPING_INFO_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_IETM_MAPPING_INFO_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_IETM_MAPPING_INFO_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_IETM_MAPPING_INFO_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_IETM_MAPPING_INFO_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_IETM_MAPPING_INFO_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_IETM_MAPPING_INFO_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_IETM_MAPPING_INFO_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_IETM_MAPPING_INFO_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_IETM_MAPPING_INFO_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_IETM_MAPPING_INFO_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_IETM_MAPPING_INFO_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_IETM_MAPPING_INFO_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_IETM_MAPPING_INFO_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_UPDATED_SW_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_UPDATED_SW_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_UPDATED_SW_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_UPDATED_SW_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_UPDATED_SW_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_UPDATED_SW_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_UPDATED_SW_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_UPDATED_SW_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< ST_SW_UPDATE_LIST > {
            NDDSUSERDllExport static std::string value() {
                return "ST_SW_UPDATE_LIST";
            }
        };

        template<>
        struct is_topic_type< ST_SW_UPDATE_LIST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< ST_SW_UPDATE_LIST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const ST_SW_UPDATE_LIST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(ST_SW_UPDATE_LIST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(ST_SW_UPDATE_LIST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(ST_SW_UPDATE_LIST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_USE_UPDATE_SW_RESULT > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_USE_UPDATE_SW_RESULT";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_USE_UPDATE_SW_RESULT > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_USE_UPDATE_SW_RESULT > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_USE_UPDATE_SW_RESULT& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_USE_UPDATE_SW_RESULT& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_USE_UPDATE_SW_RESULT& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_USE_UPDATE_SW_RESULT& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< MSSSUP_SW_UPDATE_FINISH_ALAM > {
            NDDSUSERDllExport static std::string value() {
                return "MSSSUP_SW_UPDATE_FINISH_ALAM";
            }
        };

        template<>
        struct is_topic_type< MSSSUP_SW_UPDATE_FINISH_ALAM > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< MSSSUP_SW_UPDATE_FINISH_ALAM > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const MSSSUP_SW_UPDATE_FINISH_ALAM& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(MSSSUP_SW_UPDATE_FINISH_ALAM& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(MSSSUP_SW_UPDATE_FINISH_ALAM& sample);

            NDDSUSERDllExport 
            static void allocate_sample(MSSSUP_SW_UPDATE_FINISH_ALAM& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_SW_UPDATE_LIST_REUQEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_SW_UPDATE_LIST_REUQEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_SW_UPDATE_LIST_REUQEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_SW_UPDATE_LIST_REUQEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_SW_UPDATE_LIST_REUQEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_SW_UPDATE_LIST_REUQEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_SW_UPDATE_LIST_REUQEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_SW_UPDATE_LIST_REUQEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_MSS_DISK_TO_NAS_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_MSS_DISK_TO_NAS_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_MSS_DISK_TO_NAS_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_MSS_DISK_TO_NAS_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_MSS_DISK_TO_NAS_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_MSS_DISK_TO_NAS_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_MSS_DISK_TO_NAS_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_MSS_DISK_TO_NAS_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_INTERNAL_IETM_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_INTERNAL_IETM_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_INTERNAL_IETM_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_INTERNAL_IETM_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_INTERNAL_IETM_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_INTERNAL_IETM_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_INTERNAL_IETM_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_INTERNAL_IETM_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTS_RECORDING_REQUEST > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTS_RECORDING_REQUEST";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTS_RECORDING_REQUEST > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTS_RECORDING_REQUEST > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTS_RECORDING_REQUEST& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTS_RECORDING_REQUEST& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTS_RECORDING_REQUEST& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTS_RECORDING_REQUEST& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTS_RECORDING_RESPONSE > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTS_RECORDING_RESPONSE";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTS_RECORDING_RESPONSE > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTS_RECORDING_RESPONSE > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTS_RECORDING_RESPONSE& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTS_RECORDING_RESPONSE& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTS_RECORDING_RESPONSE& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTS_RECORDING_RESPONSE& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_EOTS_RECORDING_STATUS > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_EOTS_RECORDING_STATUS";
            }
        };

        template<>
        struct is_topic_type< USERIF_EOTS_RECORDING_STATUS > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_EOTS_RECORDING_STATUS > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_EOTS_RECORDING_STATUS& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_EOTS_RECORDING_STATUS& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_EOTS_RECORDING_STATUS& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_EOTS_RECORDING_STATUS& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_REQUEST_LOGIN_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_REQUEST_LOGIN_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_REQUEST_LOGIN_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_REQUEST_LOGIN_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_REQUEST_LOGIN_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_REQUEST_LOGIN_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_REQUEST_LOGIN_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_REQUEST_LOGIN_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RESPONSE_LOGIN_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RESPONSE_LOGIN_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_RESPONSE_LOGIN_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RESPONSE_LOGIN_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RESPONSE_LOGIN_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RESPONSE_LOGIN_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RESPONSE_LOGIN_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RESPONSE_LOGIN_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_REQUEST_DRILL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_REQUEST_DRILL_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_REQUEST_DRILL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_REQUEST_DRILL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_REQUEST_DRILL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_REQUEST_DRILL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_REQUEST_DRILL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_REQUEST_DRILL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
        template<>
        struct topic_type_name< USERIF_RESPONSE_DRILL_INFO > {
            NDDSUSERDllExport static std::string value() {
                return "USERIF_RESPONSE_DRILL_INFO";
            }
        };

        template<>
        struct is_topic_type< USERIF_RESPONSE_DRILL_INFO > : public ::dds::core::true_type {};

        template<>
        struct topic_type_support< USERIF_RESPONSE_DRILL_INFO > {
            NDDSUSERDllExport 
            static void register_type(
                ::dds::domain::DomainParticipant& participant,
                const std::string & type_name);

            NDDSUSERDllExport 
            static std::vector<char>& to_cdr_buffer(
                std::vector<char>& buffer, 
                const USERIF_RESPONSE_DRILL_INFO& sample,
                ::dds::core::policy::DataRepresentationId representation 
                = ::dds::core::policy::DataRepresentation::auto_id());

            NDDSUSERDllExport 
            static void from_cdr_buffer(USERIF_RESPONSE_DRILL_INFO& sample, const std::vector<char>& buffer);
            NDDSUSERDllExport 
            static void reset_sample(USERIF_RESPONSE_DRILL_INFO& sample);

            NDDSUSERDllExport 
            static void allocate_sample(USERIF_RESPONSE_DRILL_INFO& sample, int, int);

            static const ::rti::topic::TypePluginKind::type type_plugin_kind = 
            ::rti::topic::TypePluginKind::STL;
        };
    }
}

namespace rti { 
    namespace topic {
        #ifndef NDDS_STANDALONE_TYPE
        template <>
        struct default_enumerator<E_CSCI_CSC_TYPE>
        {
            static const E_CSCI_CSC_TYPE value;
        };
        template<>
        struct dynamic_type< E_CSCI_CSC_TYPE > {
            typedef ::dds::core::xtypes::EnumType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::EnumType& get();
        };
        #endif

        template <>
        struct extensibility< E_CSCI_CSC_TYPE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template <>
        struct default_enumerator<E_EQUIPMENT_ID>
        {
            static const E_EQUIPMENT_ID value;
        };
        template<>
        struct dynamic_type< E_EQUIPMENT_ID > {
            typedef ::dds::core::xtypes::EnumType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::EnumType& get();
        };
        #endif

        template <>
        struct extensibility< E_EQUIPMENT_ID > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template <>
        struct default_enumerator<E_HW_ID>
        {
            static const E_HW_ID value;
        };
        template<>
        struct dynamic_type< E_HW_ID > {
            typedef ::dds::core::xtypes::EnumType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::EnumType& get();
        };
        #endif

        template <>
        struct extensibility< E_HW_ID > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template <>
        struct default_enumerator<E_SW_GID>
        {
            static const E_SW_GID value;
        };
        template<>
        struct dynamic_type< E_SW_GID > {
            typedef ::dds::core::xtypes::EnumType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::EnumType& get();
        };
        #endif

        template <>
        struct extensibility< E_SW_GID > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_DATE_TIME > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_DATE_TIME > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSG_HEADER > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSG_HEADER > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_ACTIVE_PULSE_DB_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_ACTIVE_PULSE_DB_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_A_ACTIVE_PULSE_DETECTION_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_A_AGC_CTRL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_A_AGC_CTRL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_A_BEAM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_A_BEAM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_A_DETECTION_CW_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_A_DETECTION_CW_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_A_DETECTION_FM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_A_DETECTION_FM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_A_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_A_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_B_ACTIVE_PULSE_DETECTION_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_B_AGC_CTRL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_B_AGC_CTRL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_B_BEAM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_B_BEAM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_B_DETECTION_CW_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_B_DETECTION_CW_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_B_DETECTION_FM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_B_DETECTION_FM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_B_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_B_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_C_ACTIVE_PULSE_DETECTION_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_C_AGC_CTRL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_C_AGC_CTRL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_C_BEAM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_C_BEAM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_C_DETECTION_CW_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_C_DETECTION_CW_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_C_DETECTION_FM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_C_DETECTION_FM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_C_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_C_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< BISDSP_BIS_DPD_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< BISDSP_BIS_DPD_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_A_MONITORSENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_A_MONITOR_SIM_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_A_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_A_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_A_SIMULATION_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_B_MONITORSENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_B_MONITOR_SIM_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_B_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_B_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_B_SIMULATION_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_C_MONITORSENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_C_MONITOR_SIM_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_C_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_C_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_C_SIMULATION_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_IFC_POWERSUPPLY_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_IFC_POWERSUPPLY_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SENSOR_IFC_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SENSOR_IFC_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_SENSOR_IFC_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_SENSOR_IFC_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_SENSOR_POWER_CTRL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_SENSOR_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_SENSOR_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_BIS_SENSOR_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_BIS_SENSOR_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_A_FREQ_DETECTION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_A_FREQ_DETECTION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_A_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_A_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_A_SIMULATION_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_A_TIME_DETECTION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_A_TIME_DETECTION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_B_FREQ_DETECTION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_B_FREQ_DETECTION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_B_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_B_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_B_SIMULATION_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_B_TIME_DETECTION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_B_TIME_DETECTION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_C_FREQ_DETECTION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_C_FREQ_DETECTION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_C_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_C_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_C_SIMULATION_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_C_TIME_DETECTION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_C_TIME_DETECTION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_TIME_DM_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_TIME_DM_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_FREQ_DM_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_FREQ_DM_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_SENSOR_IFC_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_SENSOR_IFC_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_SENSOR_POWER_CTRL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_SENSOR_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_SENSOR_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_LAS_SENSOR_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_LAS_SENSOR_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_DETECTION_EXCLUSION_FREQ_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_DETECTION_EXCLUSION_FREQ_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_DETECTION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_DETECTION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_SENSOR_IFC_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_SENSOR_IFC_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_SENSOR_POWER_CTRL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_SENSOR_SIG > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_SENSOR_SIG > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_SENSOR_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_SENSOR_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_SENSOR_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_SENSOR_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_SIMULATOR_SIG > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_SIMULATOR_SIG > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< CTRMGR_MAS_SIMULATION_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< CTRMGR_MAS_SIMULATION_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_TS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_TS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BI_TS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BI_TS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SOUND_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SOUND_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_PERIOD_PARAM_MNG_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_PERIOD_PARAM_MNG_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_ACO_MODEL_PERIOD_PARAM_CONTROL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_AS_THREAT_AREA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_AS_THREAT_AREA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_BIS_ACTIVE_PULSE_DB > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_BIS_ACTIVE_PULSE_DB > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_BIS_AUDIO_SIG_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_BIS_AUDIO_SIG_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_BIS_SOURCE_DB_CONTROL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_BIS_SOURCE_DB_CONTROL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_SOURCE_DB > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_SOURCE_DB > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_SOURCE_TYPE_MATCHING_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_SOURCE_TYPE_MATCHING_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_SOURCE_SHIP_MATCHING_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_SOURCE_SHIP_MATCHING_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_BIS_SOURCE_DB_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_BIS_SOURCE_DB_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HARMONIC_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HARMONIC_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_FEATURE_FREQ_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_FEATURE_FREQ_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_CLA_RESULT_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_CLA_RESULT_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_CLASSIFICATION_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_CLASSIFICATION_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_CLASSIFICATION_RESULT_LIST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_CLASSIFICATION_RESULT_LIST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_CLA_MANAGE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_CLA_MANAGE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_LAS_AUDIO_SIG_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_LAS_AUDIO_SIG_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EXTRACTED_GRAM > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EXTRACTED_GRAM > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_LAS_EXTRACTED_GRAM_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_LAS_EXTRACTED_GRAM_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_LAS_TARGET_CLASSIFICATION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_MAS_AUDIO_SIG_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_MAS_AUDIO_SIG_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_MAS_EXTRACTED_GRAM_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_MAS_EXTRACTED_GRAM_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OI_CLASSIFICATION_GRAM_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OI_CLASSIFICATION_GRAM_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OPER_BACKUP_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OPER_BACKUP_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OPER_DELETE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OPER_DELETE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OPER_EDIT_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OPER_EDIT_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_OPER_HISTORY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_OPER_HISTORY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OPER_HISTORY_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OPER_HISTORY_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_OPER_DATA_LIST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_OPER_DATA_LIST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OPER_LIST_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OPER_LIST_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OPER_RESTORE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OPER_RESTORE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_OPER_SAVE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_OPER_SAVE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_RAWAUDIO_CONTROL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_RAWAUDIO_CONTROL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_RAWAUDIO_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_RAWAUDIO_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_RAWAUDIO_LIST_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_RAWAUDIO_LIST_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SCREENSHOT_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SCREENSHOT_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_SAVED_SCREENSHOT_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_SAVED_SCREENSHOT_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_SCREENSHOT_CONTROL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_SCREENSHOT_CONTROL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_SCREENSHOT_LIST_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_SCREENSHOT_LIST_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SENSOR_PROTECTION_AREA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SENSOR_PROTECTION_AREA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_SENSOR_PROTECTION_CONTROL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_SENSOR_PROTECTION_CONTROL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_STABILIZED_GRAM_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_STABILIZED_GRAM_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_STORAGE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_STORAGE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_STORAGE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_STORAGE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SAVE_LAS_TIME_DM_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SAVE_LAS_TIME_DM_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SAVE_LAS_FREQ_DM_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SAVE_LAS_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SAVE_LAS_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_STRUCT_SAVE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_STRUCT_SAVE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_TACTICAL_AREA_CONTROL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_TACTICAL_AREA_CONTROL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_DRAW_OBJ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_DRAW_OBJ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TACTICAL_AREA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TACTICAL_AREA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_TACTICAL_AREA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_TACTICAL_AREA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TARGET_DB_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TARGET_DB_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TARGET_DB_AS_STRENGTH > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TARGET_DB_AS_STRENGTH > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TARGET_DB_BIS_STRENGTH > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TARGET_DB_BIS_STRENGTH > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TARGET_DB_BB_SOURCE_LEVEL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TARGET_DB_BB_SOURCE_LEVEL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TARGET_DB_NB_SOURCE_LEVEL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TARGET_DB_NB_SOURCE_LEVEL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_TARGET_DB_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_TARGET_DB_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_THRESH_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_THRESH_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_THRESH_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_THRESH_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_THRESH_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_THRESH_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_TGTTRK_PARAM_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_TGTTRK_PARAM_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_THREAT_AREA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_THREAT_AREA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_THREAT_AREA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_THREAT_AREA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< DATMGR_USER_LOGIN_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< DATMGR_USER_LOGIN_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SEN_DET_CHK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SEN_DET_CHK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SEN_DET_SEL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SEN_DET_SEL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SEN_DISTANCE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SEN_DISTANCE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SEN_BEARING > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SEN_BEARING > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_TARGET_POS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_TARGET_POS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HIS_FREQ_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HIS_FREQ_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SCENARIO_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SCENARIO_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< HUSSIS_SCENARIO_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< HUSSIS_SCENARIO_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HIS_TARGET_INFORMATION > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HIS_TARGET_INFORMATION > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< HUSSIS_TARGET_INFORMATION > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< HUSSIS_TARGET_INFORMATION > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< HUSS_CSCI_COM_MSG > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< HUSS_CSCI_COM_MSG > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_CHANNEL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_CHANNEL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_CLUTTER_MAP_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TX_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TX_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MEAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MEAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_DETECT_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_DETECT_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TH_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TH_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_DETECT_TH_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_FISH_SUP_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_FLOW_SUP_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_LOCAL_TARGET_DATA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_MANUAL_AGC_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_MAX_RANGE_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_MAX_SPEED_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_MODE_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_MODE_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_OIT_GEN_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_REV_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_REV_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_SENSOR_DEG_OFFSET_SET_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_SENSOR_FAIL_SET_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TM_STATUS_T > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TM_STATUS_T > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_PS_STATUS_T > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_PS_STATUS_T > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_PS_STATUS_F > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_PS_STATUS_F > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_NIC_CONF > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_NIC_CONF > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_TILT_SENSOR > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_TILT_SENSOR > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_AUX_SENSOR > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_AUX_SENSOR > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_PSU_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_PSU_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_ASE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_ASE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_SENSOR_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_SENSOR_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_SONARSPEED_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_STAY_TARGET_MODE_RES > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_STEERING_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_STEERING_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_TRANSMIT_ACTIVIATION_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_TRANSMIT_OPTION_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_TRK_SENSITIVE_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_ACTIVESONAR_WAKE_SUP_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_AIS_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_AIS_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AIS_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AIS_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_AIS_TARGET_DATA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_AIS_TARGET_DATA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_ADDITIONAL_INFO_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_AUTH_CONTROL_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_AUTH_CONTROL_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_AUTH_FAIL_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_AUTH_FAIL_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_AUTH_INFO_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_AUTH_INFO_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EOTE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EOTE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_BIT_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_BIT_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EOTE_RESTIRCT_DISTRICT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EOTE_RESTIRCT_DISTRICT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_BLOCK_INFO_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_BLOCK_INFO_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_BLOCK_SET_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_BLOCK_SET_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_CALIBRATION_CONTROL_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_LASER_CONTROL_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_LASER_CONTROL_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_MOVE_CONTROL_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_MOVE_CONTROL_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EOTE_MOVING_SEARCHING_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EOTE_MOVING_SEARCHING_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_MOVE_INFO_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_MOVE_INFO_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_MOVE_SET_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_MOVE_SET_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_SENSOR_CONTROL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_SENSOR_CONTROL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_TRACKING_CONTROL_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_EOTE_TRACK_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_EOTE_TRACK_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_KNTDS_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_KNTDS_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_KNTDS_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_KNTDS_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_KNTDS_TARGET_DATA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_KNTDS_TARGET_DATA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_RD_IMAGE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_RD_IMAGE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_RD_IMAGE_DATA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_RD_IMAGE_DATA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_RD_OPERATION_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_RD_OPERATION_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_RD_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_RD_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_RD_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_RD_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_RD_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_RD_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_RD_TARGET_DATA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_RD_TARGET_DATA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EA_INTERWORKING_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EA_INTERWORKING_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_RMD_EA_INTERWORKING_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_INTERCHANGE_DEVICE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_INTERCHANGE_DEVICE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_RMD_INTERCHANGE_DEVICE_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TRANSCEIVER_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TRANSCEIVER_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_RMD_TRANSCEIVER_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_RMD_TRANSCEIVER_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SIM_RD_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SIM_RD_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_SIM_RD_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_SIM_RD_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SIM_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SIM_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< IFCCTR_SIM_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< IFCCTR_SIM_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_A_AGC_CTRL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_A_AGC_CTRL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_A_BEAM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_A_BEAM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_A_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_A_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_A_FREQ_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_A_FREQ_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_A_TIME_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_A_TIME_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_B_AGC_CTRL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_B_AGC_CTRL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_B_BEAM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_B_BEAM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_B_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_B_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_B_FREQ_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_B_FREQ_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_B_TIME_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_B_TIME_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_C_AGC_CTRL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_C_AGC_CTRL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_C_BEAM_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_C_BEAM_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_C_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_C_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_C_FREQ_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_C_FREQ_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< LASDSP_LAS_C_TIME_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< LASDSP_LAS_C_TIME_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MASDSP_MAS_ACO_SENSOR_SIGNAL_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MASDSP_MAS_AGC_CTRL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MASDSP_MAS_AGC_CTRL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MASDSP_MAS_DETECTION_CTRL_INFO_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MASDSP_MAS_DETECTION_CTRL_INFO_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MASDSP_MAS_DETECTION_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MASDSP_MAS_DETECTION_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MASDSP_MAS_ENE_DATA > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MASDSP_MAS_ENE_DATA > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_ANALYSIS_PROCESS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_ANALYSIS_PROCESS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_AS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_BIS_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_BIS_SOUND_SOURCE_POSITION_CONFIRM_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_BIS_SOUND_SOURCE_POSITION_FIND_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_BIS_SOUND_SOURCE_POSITION_SEARCH_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_BI_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_HORIZONTAL_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_HORIZONTAL_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_LAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_MAS_ACOUSTIC_DETECTION_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_MODEL_PROCESS_STATUS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_MODEL_PROCESS_STATUS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_POINT_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_POINT_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SPPANA_VERTICAL_ANALYSIS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SPPANA_VERTICAL_ANALYSIS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_NIC_ADDR > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_NIC_ADDR > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EQUIP_DIAGNOSTIC_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EQUIP_DIAGNOSTIC_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_AGENT_HW_DIAGNOSTIC_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_ALERT_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_ALERT_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_ALERT_REPORT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_ALERT_REPORT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_NAME > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_NAME > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_DEV_RUN_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_DEV_RUN_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_VERSION > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_VERSION > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_ALL_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_ALL_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_CPU_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_CPU_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_NIC_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_NIC_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MEM_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MEM_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_DRIVE_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_DRIVE_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HW_STATUS_FOR_HCI > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HW_STATUS_FOR_HCI > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HW_ALL_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HW_ALL_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HW_EQUIP_BOARD_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HW_EQUIP_BOARD_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_EQUIP_DIAGNOSTIC_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_EQUIP_DIAGNOSTIC_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_GPS_STS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_GPS_STS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HUSS_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HUSS_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HUSS_EQUIP_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HUSS_EQUIP_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_HUSS_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_HUSS_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HW_EQUIP_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HW_EQUIP_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_HW_EQUIP_BOARD_ALL_STATUS_INFO_EX > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_HW_ALL_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_HW_ALL_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_HW_STATUS_HCI_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_HW_STATUS_HCI_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_HW_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_HW_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_NOTIFICATION_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_NOTIFICATION_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_PARAMETER > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_PARAMETER > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_PARAMETER_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_PARAMETER_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_PARAMETER_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_PARAMETER_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SERVER_START_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SERVER_START_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SWUPDATE_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SWUPDATE_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SWUPDATE_OVERALL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SWUPDATE_OVERALL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SWUPDATE_OVERALL_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SWUPDATE_OVERALL_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SWUPDATE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SWUPDATE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_GROUP_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_GROUP_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_EQUIP_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_EQUIP_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SW_ALL_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SW_ALL_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SW_FIRST_RUN_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SW_FIRST_RUN_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SW_KILL_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SW_KILL_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SW_RUN_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SW_RUN_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SW_RUN_CMD_ALL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SW_RUN_CMD_ALL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SW_STATUS_HCI_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SW_STATUS_HCI_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_SW_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_SW_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_TIMESYNC_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_TIMESYNC_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_TIMESYNC_DEV_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_TIMESYNC_DEV_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_TIMESYNC_MODE_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_TIMESYNC_MODE_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_USER_ACCOUNT_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_USER_ACCOUNT_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_USER_ACCOUNT_INFO_RSP > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_USER_ACCOUNT_INFO_RSP > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_USER_ACCOUNT_LIST_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_USER_ACCOUNT_LIST_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_USER_ACCOUNT_LIST_RSP > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_USER_ACCOUNT_LIST_RSP > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_USER_ACCOUNT_LOG_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_USER_ACCOUNT_LOG_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_USER_ACCOUNT_LOG_RSP > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_USER_ACCOUNT_LOG_RSP > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< SYSMGR_USER_REALLOCATION_RSP > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< SYSMGR_USER_REALLOCATION_RSP > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_DATMGR_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTCLA_CI_ACOUSTIC_TARGET_CLASSIFICATION_TO_TGTMGR_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTCLA_CLA_DB_BACKUP_RESTORE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTCLA_OI_ACOUSTIC_TARGET_CLASSIFICATION_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTCLA_OI_CLASSIFICATION_FREQ_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTCLA_OI_CLASSIFICATION_FREQ_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTCLA_STANDARD_CLA_DB_INFO_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTCLA_STANDARD_CLA_DB_INFO_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AIS_TARGET_ASSOICATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AIS_TARGET_ASSOICATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AIS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AIS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_AIS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_TARGET_ASSOCIATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_TARGET_ASSOCIATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_AS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_AS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_TARGET_ASSOCIATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_TARGET_ASSOCIATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_BIS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_BIS_SOURCE_MANUEVER_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_BIS_SOURCE_MANUEVER_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_BIS_TRACK_DELETE_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_BIS_TRACK_DELETE_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_BIS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_TARGET_TRACK_HISTORY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_TARGET_TRACK_HISTORY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_FOC_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_FOC_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_DR_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_DR_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_CCRN_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_CCRN_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_CONCERNED_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_CONCERNED_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EO_TARGET_ASSOCIATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EO_TARGET_ASSOCIATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EOS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EOS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_EOS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_LOCAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_LOCAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_AS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_LOCAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_LOCAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_BIS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_EO_LOCAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_EO_LOCAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_EO_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_KNTDS_NETWORK_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_KNTDS_NETWORK_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_KNTDS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_FREQ_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_FREQ_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_LOCAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_LOCAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_LAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_LOCAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_LOCAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_MAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_RADAR_LOCAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_RADAR_LOCAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_FUSION_PROCESSED_LOCAL_TARGET_RD_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_SOURCE_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_SOURCE_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_RD_TARGET_ASSOCIATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_RD_TARGET_ASSOCIATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_TARGET_ASSOICATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_TARGET_ASSOICATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_TARGET_ASSOCIATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_TARGET_ASSOCIATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_KNTDS_TARGET_ASSOCIATED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_KNTDS_TARGET_ASSOCIATED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_CPA_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_CPA_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_PREDICT_PATH_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_PREDICT_PATH_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_GLOBAL_TARGET_FOR_FUSION_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_GLOBAL_TARGET_FOR_REMOTE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_GLOBAL_TARGET_FOR_REMOTE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_GLOBAL_TARGET_RMT_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_GLOBAL_TARGET_RMT_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_KNTDS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_KNTDS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_KNTDS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LAS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LAS_TRACK_DELETE_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LAS_TRACK_DELETE_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LAS_TRACK_SFL_DELETE_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LAS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AIS_NETWORK_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AIS_NETWORK_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_AIS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_AIS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_AS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_AS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_BIS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_BIS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_EO_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_EO_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_KNTDS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_KNTDS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_LAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_LAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_MAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_MAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_LOCAL_TARGET_RD_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_LOCAL_TARGET_RD_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_MAS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_MAS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_OUM_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_OUM_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_OUM_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_OUM_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_RDS_FUSED_GLOBAL_TARGET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_RDS_FUSED_GLOBAL_TARGET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_RDS_FUSED_GLOBAL_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_SENSOR_CONFIG_PARAM_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_SENSOR_CONFIG_PARAM_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_TARGET_FUSION_ACTIVATION_STATUS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_TGT_CLASSIFICATION_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_TGT_CLASSIFICATION_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_THREAT_TARGET_FOR_KNTDS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_THREAT_TARGET_FOR_KNTDS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTMGR_THREAT_TARGET_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTMGR_THREAT_TARGET_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_MEAS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_MEAS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_MEAS_INFO_A > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_MEAS_INFO_A > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_MEAS_INFO_B > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_MEAS_INFO_B > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_MEAS_INFO_C > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_MEAS_INFO_C > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BIS_TARGET_LOCAL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BIS_TARGET_LOCAL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_TARGET_TRACKING_INFO_A > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_TARGET_TRACKING_INFO_A > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_TARGET_TRACKING_INFO_B > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_TARGET_TRACKING_INFO_B > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_TARGET_TRACKING_INFO_C > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_TARGET_TRACKING_INFO_C > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_A > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_B > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BISTRK_THRESHOLD_INFO_ACK_C > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BIS_OIT_CONTROL_COMMAND_ACK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_BIS_SENSOR_POSITION_DATA_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_LOFAR_MEAS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_LOFAR_MEAS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_LASTRK_LOFAR_MEAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_LASTRK_LOFAR_MEAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_TARGET_LOCAL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_TARGET_LOCAL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_LASTRK_TARGET_TRACKING_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_LASTRK_TARGET_TRACKING_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_LASTRK_THRESHOLD_INFO_ACK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_LASTRK_THRESHOLD_INFO_ACK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_LAS_BBD_OIT_CONTROL_COMMAND_ACK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_LAS_DEMON_CONTROL_COMMAND_ACK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_LAS_LOFAR_OIT_CONTROL_COMMAND_ACK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_LAS_SENSOR_POSITION_DATA_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_MASTRK_ACO_FREQ_TRACK_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MAS_TARGET_LOCAL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MAS_TARGET_LOCAL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_MASTRK_TARGET_TRACKING_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_MASTRK_TARGET_TRACKING_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_MASTRK_THRESHOLD_INFO_ACK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_MASTRK_THRESHOLD_INFO_ACK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_MAS_SENSOR_POSITION_DATA_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< TGTTRK_PARAM_INFO_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< TGTTRK_PARAM_INFO_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_PERIOD_PROC_PARAM_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_PERIOD_PROC_PARAM_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ACOUSTIC_MODEL_PERIOD_PROCESS_PARAMETER_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ACOUSTIC_MODEL_PROCESS_STATUS_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ACOUSTIC_MODEL_PROCESS_STOP_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ACO_MODEL_PERIOD_PARAM_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_DETECT_TH_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_DETECT_TH_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_FISH_SUP_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_FISH_SUP_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_FLOW_SUP_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_FLOW_SUP_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_MANUAL_AGC_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_MANUAL_AGC_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_MAX_RANGE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_MAX_RANGE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_MAX_SPEED_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_MAX_SPEED_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_MODE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_MODE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_OIT_GEN_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_OIT_GEN_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_POWER_CTRL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_POWER_CTRL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_SENSOR_DEG_OFFSET_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_SENSOR_FAIL_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_SENSOR_FAIL_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_SONARSPEED_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_SONARSPEED_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_STAY_TARGET_MODE_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_STAY_TARGET_MODE_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_STEERING_CTRL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_STEERING_CTRL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_TRANSMIT_ACTIVIATION_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_TRANSMIT_OPTION_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_TRANSMIT_OPTION_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_TRK_SENSITIVE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_TRK_SENSITIVE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ASE_WAKE_SUP_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ASE_WAKE_SUP_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_DEPTH_TEMP > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_DEPTH_TEMP > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_USER_TEMP_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_USER_TEMP_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_SENSOR_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_SENSOR_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_AS_MODEL_INPUT_SET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_AS_MODEL_INPUT_SET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_AS_DETECTION_PROBABILITY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_AS_DETECTION_PROBABILITY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_AS_THREAT_AREA_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_AS_THREAT_AREA_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_AS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_AS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_AUDIO_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_AUDIO_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BISTRK_CONC_TGT_REG_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BISTRK_CONC_TGT_REG_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BISTRK_OIT_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BISTRK_OIT_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BISTRK_THRESHOLD_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BISTRK_THRESHOLD_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_ACTIVE_PULSE_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_ACTIVE_PULSE_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_DETECT_PARAM_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_DETECT_USERCONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_DETECT_USERCONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_MOVINFO_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_MOVINFO_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_SENSOR_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_SENSOR_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BI_SOURCE_CONFIRM_SET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BI_SOURCE_CONFIRM_SET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_SOUNDSOURCEPOSITION_CONFIRM_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_POSITION_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_POSITION_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_QROUTE_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_QROUTE_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BI_SOURCE_FIND_SET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BI_SOURCE_FIND_SET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_SOUNDSOURCEPOSITION_FIND_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BI_SOURCE_SEARCH_SET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BI_SOURCE_SEARCH_SET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_SOUNDSOURCEPOSITION_SEARCH_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_SOURCE_DB_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_SOURCE_DB_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BIS_USERPOWERCONTROL_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_BI_MODEL_INPUT_SET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_BI_MODEL_INPUT_SET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_BI_DETECTION_PROBABILITY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_BI_DETECTION_PROBABILITY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_CLASSIFICATIONDATABASE_BAKUPRESTORE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_CLASSIFICATIONDATABASE_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_CLASSIFICATION_RESULT_MANAGE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_CPACALCULATE_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_CPACALCULATE_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_DATA_BACKUP_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_DATA_BACKUP_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_DATA_DELETE_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_DATA_DELETE_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_DATA_LIST_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_DATA_LIST_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_DATA_MODIFY_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_DATA_MODIFY_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_DATA_RECORD_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_DATA_RECORD_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_DATA_RESTORE_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_DATA_RESTORE_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_ADDITIONAL_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_ADDITIONAL_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_ADDITIONAL_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_ADDITIONAL_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_AUTH_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_AUTH_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_AUTH_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_AUTH_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_BLOCK_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_BLOCK_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_BLOCK_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_BLOCK_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_CALIBRATION_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_CALIBRATION_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_LASER_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_LASER_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_MOTOR_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_MOTOR_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_MOVE_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_MOVE_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_MOVE_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_MOVE_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_MOVE_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_MOVE_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_POWER_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_POWER_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_TRACKING_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_TRACKING_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTE_ZOOMFOC_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EQUIP_DIAGNOSTIC_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EQUIP_DIAGNOSTIC_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_FOC_DR_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_FOC_DR_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_HISTORY_EXCUTE_VACCINE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_HISTORY_EXCUTE_VACCINE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_HISTORY_LIST_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_HISTORY_LIST_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_HISTORY_MANAGE_ACCOUNT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_HISTORY_MANAGE_ACCOUNT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_HISTORY_PRINT_REPORT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_HISTORY_PRINT_REPORT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_HISTORY_RESERVED > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_HISTORY_RESERVED > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_HORIZONTAL_ANALYSIS_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_HORIZONTAL_ANALYSIS_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_IPE_DEVICE_CTRL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_IPE_DEVICE_CTRL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_BBD_OIT_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_CONC_TGT_REG_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_CONC_TGT_REG_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_DEMON_OIT_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_EXCLUSION_FREQ_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_LOFAR_OIT_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_ASS_TGT_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_ASS_TGT_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_SEMI_OIT_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_THREAT_FREQ_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LASTRK_THRESHOLD_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LASTRK_THRESHOLD_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_DETECTTARGET_USERCONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_LAS_MAS_MODEL_INPUT_SET > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_LAS_MAS_MODEL_INPUT_SET > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_MAS_DETECTION_PROBABILITY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_SENSOR_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_SENSOR_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_TRACK_SFL_DELETE_CONTROL > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_TRACK_SFL_DELETE_CONTROL > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LAS_USERPOWERCONTROL_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_LOST_INTEREST_TARGET_SEND_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_LOST_INTEREST_TARGET_SEND_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MANUAL_TARGET_CLASSIFICATION_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MASTRK_CONC_TGT_REG_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MASTRK_CONC_TGT_REG_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MASTRK_THRESHOLD_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MASTRK_THRESHOLD_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MAS_DETECTTARGET_USERCONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MAS_SENSORRECEIVER_USER_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MAS_SENSOR_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MAS_SENSOR_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MAS_SENSOR_STATUS_MANUAL_SET_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MAS_TRACK_USER_CONFIRM_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MAS_TRACK_USER_CONFIRM_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MAS_USERPOWERCONTROL_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_OI_CLASSIFICATION_FREQ_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_OI_CLASSIFICATION_FREQ_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_OI_CLASSIFICATION_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_OI_CLASSIFICATION_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_OI_CLASSIFICATION_RESULT_SAVE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_POINT_ANALYSIS_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_POINT_ANALYSIS_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_PRESUPPOSEDHEADING_CALCULATE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RADAR_CHANNEL_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RADAR_CHANNEL_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RADAR_FILTER_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RADAR_FILTER_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RADAR_TRACK_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RADAR_TRACK_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RADAR_VIDEO_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RADAR_VIDEO_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RAWAUDIO_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RAWAUDIO_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RMT_DEVICE_CTRL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RMT_DEVICE_CTRL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SCREENSHOT_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SCREENSHOT_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SCREENSHOT_LIST_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SCREENSHOT_LIST_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SCREENSHOT_SAVE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SCREENSHOT_SAVE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SENSOR_PROTECTION_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SENSOR_PROTECTION_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SOFTWARE_OPERATE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SOFTWARE_OPERATE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SPE_DEVICE_CTRL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SPE_DEVICE_CTRL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_STABILIZED_GRAM_TARGET_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SYSMGR_ALL_STATE_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SYSMGR_ALL_STATE_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SYSMGR_REALLOCATION_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SYSMGR_REALLOCATION_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_UPDATE_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_UPDATE_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SYSMGR_SWUPDATE_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SYSMGR_SWUPDATE_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SYSMGR_SWUPDATE_OVERALL_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SYSMGR_SWUPDATE_OVERALL_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_DANGER_INFO_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_DANGER_INFO_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_DB_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_DB_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_FUSION_ACTIVATION_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_FUSION_ACTIVATION_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_FUSION_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_FUSION_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_GLOBAL_DELETE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_GLOBAL_DELETE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_GLOBAL_REFRESH_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_GLOBAL_REFRESH_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_GLOBAL_REGISTER_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_GLOBAL_REGISTER_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_INFO_INITIATE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_INFO_INITIATE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_INTEREST_DELETE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_INTEREST_DELETE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_INTEREST_NEW_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_INTEREST_NEW_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_OUM_DELETE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_OUM_DELETE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_OUM_REFRESH_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_OUM_REFRESH_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_OUM_REGISTER_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_OUM_REGISTER_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TARGET_SEMI_OIT_CONTROL_COMMAND > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_THREAT_AREA_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_THREAT_AREA_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_TIMESYNC_MODE_CMD > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_TIMESYNC_MODE_CMD > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_USER_ACCOUNT_INFO_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_USER_ACCOUNT_INFO_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_USER_ACCOUNT_LIST_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_USER_ACCOUNT_LIST_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_USER_ACCOUNT_LOG_REQ > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_USER_ACCOUNT_LOG_REQ > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_USER_LOGIN_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_USER_LOGIN_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_VERTICAL_ANALYSIS_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_VERTICAL_ANALYSIS_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_ZONE_CONTROL_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_ZONE_CONTROL_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SYSTEM_COMPONENT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SYSTEM_COMPONENT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_TREE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_TREE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SYSTEM_TREE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SYSTEM_TREE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SYSTEM_COMPONENT_REPAIR_ITEM > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SYSTEM_COMPONENT_PART > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SYSTEM_COMPONENT_PART > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SYSTEM_COMPONENT_PART_QUANTITY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SYSTEM_COMPONENT_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SYSTEM_COMPONENT_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_PREVENTIVE_MAINTENANCE_PLAN > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_PREVENTIVE_MAINTENANCE_PLAN_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_CREATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_UPDATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_ALERT_MSG > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_ALERT_MSG > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_PLAN_DELETE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_PREVENTIVE_MAINTENANCE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_PREVENTIVE_MAINTENANCE_RESULT_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_CREATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_UPDATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_PREVENTIVE_MAINTENANCE_RESULT_DELETE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_MAINTENANCE_HISTORY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_MAINTENANCE_HISTORY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_MAINTENANCE_HISTORY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_MAINTENANCE_HISTORY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_MAINTENANCE_HISTORY_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_MAINTENANCE_HISTORY_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_MAINTENANCE_HISTORY_CREATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_MAINTENANCE_HISTORY_CREATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_MAINTENANCE_HISTORY_UPDATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_MAINTENANCE_HISTORY_UPDATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_MAINTENANCE_HISTORY_DELETE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_MAINTENANCE_HISTORY_DELETE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_STOCK_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SYSTEM_COMPONENT_STOCK > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SYSTEM_COMPONENT_STOCK > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_STOCK_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SYSTEM_COMPONENT_STOCK_HISTORY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SYSTEM_COMPONENT_STOCK_HISTORY_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_CREATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_UPDATE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_STOCK_HISTORY_DELETE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SYSTEM_COMPONENT_IETM > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SYSTEM_COMPONENT_IETM > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_COMPONENT_IETM_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SYSTEM_COMPONENT_IETM_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_EXTERNAL_STORAGE_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_EXTERNAL_STORAGE_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SOFTWARE_EXTERNAL_STORAGE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SOFTWARE_EXTERNAL_STORAGE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_NAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_NAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SOFTWARE_NAS_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SOFTWARE_NAS_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SOFTWARE_NAS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SOFTWARE_NAS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SOFTWARE_DISK_SPACE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SOFTWARE_DISK_SPACE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SOFTWARE_NAS_SPACE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SOFTWARE_NAS_SPACE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_DISK_TO_NAS_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_DISK_TO_NAS_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_DISK_TO_NAS_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_DISK_TO_NAS_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_NAS_DELETE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_NAS_DELETE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_NAS_DELETE_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_NAS_DELETE_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SOFTWARE_DISTRIBUTE_HISTORY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_SOFTWARE_INSTALL_HISTORY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SOFTWARE_DISTRIBUTE_HISTORY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SOFTWARE_DISTRIBUTE_HISTORY_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SOFTWARE_INSTALL_HISTORY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SOFTWARE_INSTALL_HISTORY_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SYSTEM_ALERT_INCOMPLETION_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_SYSTEM_ALERT_INCOMPLETION_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_SERVER_DISK_STATE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_SERVER_DISK_STATE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_DATABASE_BACKUP_HISTORY > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_DATABASE_BACKUP_HISTORY > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_DATABASE_BACKUP_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_DATABASE_BACKUP_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_DATABASE_RESTORE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_DATABASE_RESTORE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_DATABASE_BACKUP_HISTORY_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_DATABASE_BACKUP_HISTORY_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_DATABASE_BACKUP_DELETE_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_MSSSUP_IETM_MAPPING_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_MSSSUP_IETM_MAPPING_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_IETM_MAPPING_INFO_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_IETM_MAPPING_INFO_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_IETM_MAPPING_INFO_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_IETM_MAPPING_INFO_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_UPDATED_SW_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_UPDATED_SW_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< ST_SW_UPDATE_LIST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< ST_SW_UPDATE_LIST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_USE_UPDATE_SW_RESULT > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_USE_UPDATE_SW_RESULT > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< MSSSUP_SW_UPDATE_FINISH_ALAM > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< MSSSUP_SW_UPDATE_FINISH_ALAM > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_SW_UPDATE_LIST_REUQEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_SW_UPDATE_LIST_REUQEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_MSS_DISK_TO_NAS_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_MSS_DISK_TO_NAS_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_INTERNAL_IETM_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_INTERNAL_IETM_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTS_RECORDING_REQUEST > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTS_RECORDING_REQUEST > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTS_RECORDING_RESPONSE > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTS_RECORDING_RESPONSE > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_EOTS_RECORDING_STATUS > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_EOTS_RECORDING_STATUS > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_REQUEST_LOGIN_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_REQUEST_LOGIN_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RESPONSE_LOGIN_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RESPONSE_LOGIN_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_REQUEST_DRILL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_REQUEST_DRILL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

        #ifndef NDDS_STANDALONE_TYPE
        template<>
        struct dynamic_type< USERIF_RESPONSE_DRILL_INFO > {
            typedef ::dds::core::xtypes::StructType type;
            NDDSUSERDllExport static const ::dds::core::xtypes::StructType& get();
        };
        #endif

        template <>
        struct extensibility< USERIF_RESPONSE_DRILL_INFO > {
            static const ::dds::core::xtypes::ExtensibilityKind::type kind =
            ::dds::core::xtypes::ExtensibilityKind::EXTENSIBLE;    };

    }
}

#if (defined(RTI_WIN32) || defined (RTI_WINCE) || defined(RTI_INTIME)) && defined(NDDS_USER_DLL_EXPORT)
/* If the code is building on Windows, stop exporting symbols.
*/
#undef NDDSUSERDllExport
#define NDDSUSERDllExport
#endif

#endif // HUSS_PH_1779633256_hpp

